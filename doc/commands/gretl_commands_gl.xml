<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE commandref SYSTEM "gretl_commands.dtd">

<commandref language="galego">

<?PSGML NOFILL label code altforms altform menu-path equation other-access?>

  <command name="add" section="Tests" label="Engadir variables a un modelo">

	  <usage>
	    <arguments>
	      <argument>listavariables</argument>
	    </arguments>
	    <options>
	<option>
	  <flag>--lm</flag>
	  <effect>Fai unha proba de ML; só con MCO</effect>
	</option>
	<option>
	  <flag>--auto</flag>
	  <optparm>criterio</optparm>
	  <effect>Progresivo cara adiante, só MCO</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Presenta só os resultados básicos da proba</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas do modelo ampliado</effect>
	</option>
	<option>
	  <flag>--both</flag>
	  <effect>Só para estimación VI; mira abaixo</effect>
	</option>
	    </options>
	    <examples>
	      <example>add 5 7 9</example>
	      <example>add xx yy zz --quiet</example>
	      <example>add xlist --auto=BIC</example>
	    </examples>
	  </usage>

    <description>
      <para context="cli">
	Debes solicitar esta instrución despois de executar unha instrución
	de estimación. Se non se indica ningunha das opcións <opt>lm</opt>
	ou <opt>auto</opt>, esta instrución realiza unha proba conxunta
	sobre a adición das variables expresadas no argumento, ao derradeiro
	modelo estimado. Estímase unha versión ampliada do modelo orixinal,
	incluíndo as variables de <repl>listavariables</repl>, e se realiza
	unha proba de Wald sobre o modelo ampliado. Este substitúe ao
	orixinal como o <quote>último modelo</quote> co propósito, por
	exemplo, de recuperar os erros mediante o accesorio <fncref targ="$uhat"/>
	ou de facer outras probas. Os resultados da proba de Wald poden
	recuperarse utilizando os accesorios <fncref targ="$test"/> e
	<fncref targ="$pvalue"/>.
      </para>
      <para context="cli">
	A opción <opt>both</opt> aplícase só cando se estima o último
	modelo mediante Mínimos Cadrados en 2 Etapas. Indica que as
	novas variables deben engadirse tanto á lista dos instrumentos,
	como á lista dos regresores, engadíndose por defecto só á lista
	de regresores.
      </para>
      <subhead context="cli">A opción lm</subhead>
      <para context="cli">
	Se indicas a opción <opt>lm</opt> (só dispoñible para modelos estimados
	mediante MCO), faise unha proba de Multiplicadores de Lagrange. Para iso,
	execútase unha regresión auxiliar na que o erro de estimación do derradeiro
	modelo tómase como variable dependente; e as variables independentes son
	as dese derradeiro modelo máis as de <repl>listavariables</repl>. Baixo a
	hipótese nula de que as variables engadidas non teñen unha capacidade
	preditiva adicional, o estatístico formado multiplicando o tamaño da mostra
	polo R-cadrado desta regresión, ten unha distribución Khi-cadrado con
	tantos graos de liberdade como o número de regresores engadidos. Con
	esta opción, o modelo orixinal non se substitúe polo modelo da regresión auxiliar.
      </para>
      <subhead context="cli">A opción automática</subhead>
      <para context="cli">
	A opción <opt>auto</opt> (que non se pode combinar coa opción
	<opt>lm</opt>) solicita que se faga a regresión progresiva cara
	adiante, utilizando o algoritmo QR tal como se describe en
	<cite key="hastie20">Hastie et al (2020)</cite>. Neste caso, interprétase
	<repl>listavariables</repl> como unha lista de <emphasis>candidatos</emphasis>
	a engadirse ao modelo orixinal. En cada etapa, o método determina
	que candidato ofrece a maior mellora do axuste, de acordo co
	<lit>criterio</lit> (indicado como un parámetro desa opción).
	O algoritmo detense cando non é posible unha mellora adicional.
	O criterio debe ter unha destas formas:
      </para>
      <ilist context="cli">
	<li>
	  <para>
	    Un Criterio de Información: <lit>AIC</lit>, <lit>BIC</lit> ou
	    <lit>HQC</lit>. O <quote>mellor</quote> candidato en cada etapa
	    é entón o que proporciona a maior mellora (redución) do criterio
	    seleccionado.
	  </para>
	</li>
	<li>
	  <para>
	    Un valor &alpha; (fracción decimal positiva). Neste caso, o factor
	    de relevancia é a suma de erros cadrados. O algoritmo detense
	    cando ningún candidato dos que queden proporcione unha redución
	    na SCE que sexa estatisticamente significativa a un nivel &alpha;
	    nunha proba Khi-cadrado.
	  </para>
	</li>
      </ilist>
      <para context="gui">
	Aquí dispós de tres opcións:
      </para>
      <ilist context="gui">
	<li>
	  <para>
	    Proba de Wald: As variables seleccionadas engádense ao modelo
	    previo, e estímase o modelo ampliado. Preséntase un estatístico
	    de proba de Wald sobre a significación conxunta das variables
	    engadidas, xunto co seu valor p.
	  </para>
	</li>
	<li>
	  <para>
	    Proba de ML (LM): Se realiza unha proba de Multiplicadores de Lagrange
	    sobre a significación conxunta das variables engadidas, sen estimar
	    o modelo ampliado.
	  </para>
	</li>
	<li>
	  <para>
	    Adición progresiva: As variables adicionais engádense de forma
	    secuencial. En cada etapa, engádese a variable que proporciona
	    a maior mellora no axuste, deténdose o proceso cando ningunha das
	    candidatas restantes proporcione unha mellora. Neste caso, é
	    necesario que elixas un criterio: un dos Criterios de Información
	    (AIC, BIC, HQC) ou SCE. Se elixes SCE, tamén é necesario que
	    especifiques un nivel &alpha; de significación para probar se
	    cada variable merece a súa inclusión.
	  </para>
	</li>
      </ilist>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas/Engadir variables</menu-path>
    </gui-access>

  </command>

  <command name="addline" section="Graphs" label="Engadir unha liña a unha gráfica"
    context="gui">

    <description>
      <para>
	Esta caixa de diálogo te permite engadirlle a unha gráfica, unha liña
	definida mediante unha fórmula que debe de ser unha expresión
	admisible para Gnuplot. Debes de usar <lit>x</lit> para denotar o valor da
	variable do eixe de abscisas. Ten en conta que Gnuplot utiliza <lit>**</lit>
	para elevar á potencia, e que o carácter decimal debe de indicarse
	con <quote>.</quote>. Exemplos:
      </para>
      <code>
	10+0.35*x
	100+5.3*x-0.12*x**2
	sin(x)
	exp(sqrt(pi*x))
      </code>
    </description>
  </command>

  <command name="adf" section="Tests" label="Proba ampliada de Dickey-Fuller">

    <usage>
      <arguments>
        <argument>nivel</argument>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>Sen constante</effect>
	</option>
	<option>
	  <flag>--c</flag>
	  <effect>Con constante</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>Con constante máis tendencia</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>Con constante, máis tendencia linear e cadrada</effect>
	</option>
	<option>
	  <flag>--seasonals</flag>
	  <effect>Inclúe variables ficticias estacionais</effect>
	</option>
	<option>
	  <flag>--gls</flag>
	  <effect>Detrae a media ou a tendencia usando MCX</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Amosa os resultados da regresión</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>Usa as primeiras diferenzas da variable</effect>
	</option>
	<option>
	  <flag>--test-down</flag>
	  <optparm optional="true">criterio</optparm>
	  <effect>Nivel de retardos automático</effect>
	</option>
	<option>
	  <flag>--perron-qu</flag>
	  <effect>Mira abaixo</effect>
	</option>
      </options>
      <examples>
	<example>adf 0 y</example>
        <example>adf 2 y --nc --c --ct</example>
        <example>adf 12 y --c --test-down</example>
	<demos>
	  <demo>jgm-1996.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Esta instrución necesita que indiques o nivel de retardos cun número
	enteiro; se o nivel é cero, execútase a proba estándar (non ampliada)
	de Dickey&ndash;Fuller. Calcúlase unha ou máis das probas de
	Dickey&ndash;Fuller sobre a(s) variable(s) do argumento, sendo a
	hipótese nula a existencia dunha raíz unitaria. (Agora ben, cando
	escolles a opción 'difference', calcúlase a primeira diferenza da(s)
	variable(s) antes de facer a proba, e a discusión de abaixo debes de
	entendela como referida á(s) variable(s) transformada(s).)
      </para>

      <para context="cli">
	As opcións que se amosan máis abaixo e a discusión que segue,
	se corresponden principalmente co uso da instrución <lit>adf</lit>
	con datos de típicas series temporais. Para utilizar esta instrución
	con datos de panel, mira máis abaixo a sección titulada
	<quote>Datos de panel</quote>.
      </para>

      <para context="cli">
	Esta instrución calcula un conxunto de probas de Dickey&ndash;Fuller
	sobre cada unha das variables do argumento, sendo a hipótese nula a
	existencia dunha raíz unitaria. (Agora ben, cando escolles a opción
	<opt>difference</opt>, calcúlase a primeira diferenza da(s) variable(s)
	antes de facer a proba, e a discusión de abaixo debes de entendela
	como referida á(s) variable(s) transformada(s).)
      </para>

      <para context="cli">
	Por defecto, amósanse dúas variantes da proba: unha baseada nunha
	regresión que utiliza unha constante, e outra que utiliza unha
	constante máis unha tendencia linear. Podes controlar as variantes
	que se presentan especificando un ou máis dos indicadores de
	opción: <opt>nc</opt>, <opt>c</opt>, <opt>ct</opt>, ou <opt>ctt</opt>.
      </para>

      <para context="cli">
	Podes utilizar a opción <opt>gls</opt> xunto con algunha das dúas opcións
	<opt>c</opt> e <opt>ct</opt> (con constante, e con constante máis tendencia).
	O efecto desta opción é que a serie que se quere probar, detráese da media
	ou da tendencia usando o procedemento de Mínimos Cadrados Xeneralizados
	proposto por <cite key="ERS96">Elliott, Rothenberg e Stock (1996)</cite>,
	que proporciona unha proba de maior potencia que a aproximación
	estándar de Dickey&ndash;Fuller. Esta opción non é compatible con
	<opt>nc</opt>, <opt>ctt</opt> nin <opt>seasonals</opt>.
      </para>

      <para>
	En tódolos casos, a variable dependente na regresión da proba, é a
	primeira diferenza da serie indicada (<math>y</math>), e a variable
	independente chave é o primeiro retardo de <math>y</math>. A regresión
	fórmase de xeito que o coeficiente da variable <math>y</math> retardada,
	é igual á raíz en cuestión, &agr;, menos 1. Por exemplo, o modelo con
	constante pode escribirse como
	<equation status="display"
	tex="\[(1-L)y_t=\beta_0+(\alpha-1)y_{t-1}+\epsilon_t\]"
	ascii="(1 - L)y(t) = b0 + (a-1)y(t-1) + e(t)" graphic="adf1"/>
	Baixo a hipótese nula de existencia dunha raíz unitaria, o coeficiente
	da variable <math>y</math> retardada é igual a cero. Baixo a hipótese
	alternativa de que <math>y</math> é estacionaria, este coeficiente é
	negativo. Daquela a proba é propiamente dunha cola.
      </para>

      <subhead context="cli">Selección do nivel de retardos</subhead>

      <para context="cli">
	A versión máis sinxela da proba de Dickey&ndash;Fuller asume que a
	perturbación aleatoria da regresión que se utiliza na proba non ten
	autocorrelación. Na práctica, isto non é probable que aconteza polo
	que a especificación da regresión habitualmente amplíase incluíndo
	un ou máis retardos da variable dependente, orixinando unha proba
	de Dickey&ndash;Fuller ampliada (ADF). O argumento <repl>nivel</repl>
	determina o número deses retardos (<math>k</math>), eventualmente
	dependendo do tamaño da mostra (<math>T</math>).
      </para>
      <ilist context="cli">
	<li>
	  <para>
	    Para usar un valor fixo de <math>k</math>, especificado polo
	    usuario: indica un valor non negativo para <repl>nivel</repl>.
	  </para>
	</li>
	<li>
	  <para>
	    Para usar un valor de <math>k</math> dependente de <math>T</math>:
	    indica <repl>nivel</repl> igual a &minus;1. Así o nivel establécese
	    segundo o consello de <cite key="schwert89">Schwert (1989)</cite>:
	    concretamente tómase a parte enteira de calcular
	    12(<math>T</math>/100)<sup>0.25</sup>.
	  </para>
	</li>
      </ilist>

      <para context="cli">
	Porén, en xeral non se sabe cantos retardos serán necesarios para
	<quote>branquear</quote> o erro da regresión de Dickey&ndash;Fuller.
	En consecuencia é habitual especificar o <emphasis>máximo</emphasis>
	valor de <math>k</math>, e deixar que os datos 'decidan' o número
	concreto de retardos que se van incluír. Isto pódese facer mediante
	a opción <opt>test-down</opt>. E tamén podes establecer o criterio
	co que se determine un valor óptimo para <math>k</math>, utilizando
	o parámetro para esta opción que deberá ser un a escoller entre
	<lit>AIC</lit> (por defecto), <lit>BIC</lit> ou
	<lit>tstat</lit>.
      </para>

      <para context="gui">
	Se o nivel de retardos (<math>k</math>) é maior ca 0, entón inclúense
	<math>k</math> retardos da variable dependente no lado dereito de cada
	unha das regresións necesarias para calcular os estatísticos das probas,
	suxeito isto ao seguinte requisito. Cando marcas o cadriño de
	<quote>Probar desde o máximo nivel de retardos cara abaixo</quote>,
	o nivel de retardos que indicas tómase como máximo, e o nivel de retardos
	concreto que se utilizará, obtense probando cara abaixo (mediante o
	criterio que elixas na lista despregable adxunta).
      </para>

      <para context="cli">
	Cando pides que se probe cara atrás mediante AIC ou BIC, o nivel
	de retardos final para a ecuación ADF é o que optimiza o criterio
	de información que escollas (de Akaike ou Baiesiano de Schwarz).
	O procedemento exacto dependerá de se indicas ou non a opción
	<opt>gls</opt>. Cando se especifica GLS (MCX), os criterios AIC
	e BIC son as versións <quote>modificadas</quote> descritas en
	<cite key="ng-perron01">Ng e Perron (2001)</cite>; se non, son
	as versións estándar. No caso de MCX, dispós dun refinamento.
	Cando indicas a opción adicional <opt>perron-qu</opt>, a selección do
	nivel de retardo realízase mediante o método revisado que recomendaron
	<cite key="perron-qu07">Perron e Qu (2007)</cite>. Neste caso, os
	datos se detraen primeiro mediante OLS (MCO) da media ou da tendencia;
	GLS (MCX) se aplica unha vez que se haxa determinado o nivel de
	retardo.
      </para>

      <para context="gui">
	Cando pides que se probe cara atrás mediante AIC ou BIC, o nivel
	de retardos final para a ecuación ADF é o que optimiza o criterio
	de información escollido (de Akaike ou Baiesiano de Schwarz).
      </para>
	
      <para>
	Cando pides que se probe cara atrás mediante o método do estatístico
	<math>t</math>, o procedemento é como se indica deseguido:
      </para>
      <nlist>
	<li><para>
	Estímase a regresión de Dickey&ndash;Fuller utilizando <math>k</math> retardos da variable dependente.
      </para>
	</li>
	<li><para>
	É significativo o último retardo? Se o é, execútase a proba cun nivel de retardos
	<math>k</math>. Se non o é, faise que <math>k</math> = <math>k</math> &minus; 1,
	e vólvese ao paso 1 cun retardo menos. O proceso repítese ata que sexa significativo
	o último retardo dunha regresión, ou ata que <math>k</math> sexa 0 (faríase a proba cun nivel de retardos igual a 0).
	    </para>
	</li>
      </nlist>
      <para>
	No contexto do paso 2 de arriba, <quote>significativo</quote> quere
	dicir que o estatístico <math>t</math> do derradeiro retardo ten un
	valor <emphasis>p</emphasis> asintótico de dúas colas igual ou menor
	a 0.10, fronte á distribución Normal.
      </para>

      <para context="cli">
	En resumo, se admitimos os diferentes argumentos de Perron, Ng, Qu
	e Schwert indicados arriba, a instrución preferible para probar unha
	serie <lit>y</lit> é probable que sexa:
      </para>
      <code context="cli">
	adf -1 y --c --gls --test-down --perron-qu
      </code>
      <para context="cli">
	(Ou substituíndo <opt>ct</opt> en troques de <opt>c</opt> se a serie
	semella presentar unha tendencia.) O nivel de retardo para a proba será
	entón determinado comprobándoo cara atrás, mediante os cambios no
	AIC a partir do máximo de Schwert, co refinamento de Perron&ndash;Qu.
      </para>

      <para>
	As Probabilidades Asociadas (valores <emphasis>P</emphasis>) para as
	probas de Dickey&ndash;Fuller están baseadas en estimacións de tipo
	superficie de resposta. Cando non se aplica MCX (GLS), se toman de
	<cite key="mackinnon96">MacKinnon (1996)</cite>. Noutro caso, tómanse
	de <cite key="cottrell15">Cottrell (2015)</cite> ou, cando se realiza
	a comprobación cara atrás, de <cite key="sephton21">Sephton (2021)</cite>.
	As Probabilidades Asociadas son específicas para o tamaño da mostra,
	agás que estean etiquetadas como asintóticas.
      </para>

      <subhead context="cli">Datos de Panel</subhead>

      <para context="cli">
	Cando se utiliza a instrución <lit>adf</lit> con datos de panel para
	facer unha proba de raíz unitaria de panel, as opcións aplicables e
	os resultados que se amosan son algo diferentes.
      </para>
      <para context="cli">
	Primeiro, mentres que podes indicar unha lista de variables para
	probar no caso de series temporais típicas, con datos de panel só
	podes probar unha variable por cada instrución. Segundo, as opcións
	que manexan a inclusión de termos determinísticos pasan a ser
	mutuamente excluíntes: debes de escoller unha entre sen constante,
	con constante, e con constante máis tendencia; por defecto é con
	constante. Ademais, a opción <opt>seasonals</opt> non está
	dispoñible. Terceiro, a opción <opt>verbose</opt> aquí ten un
	significado diferente: produce un breve informe da proba para cada
	serie temporal individual (sendo este por defecto unha presentación
	só do resultado global).
      </para>
      <para context="cli">
	Calcúlase a proba global (Hipótese nula: A serie en cuestión
	ten unha raíz unitaria para todas as unidades do panel)
	dunha ou as dúas formas seguintes: utilizando o método de
	<cite key="IPS03">Im, Pesaran e Shin (Journal of Econometrics, 2003)</cite>
	ou a de
	<cite key="choi01">Choi (Journal of International Money and Finance, 2001)</cite>
	A proba de Choi require que estean dispoñibles as probabilidades asociadas
	(valores <emphasis>P</emphasis>) para as probas individuais; se este non
	é o caso (dependendo das opcións escollidas), omítese. O estatístico
	concreto proporcionado para a proba de Im, Pesaran e Shin varía do xeito
	seguinte: se o nivel de retardo para a proba non é cero, amósase o seu
	estatístico <math>W</math>; por outra banda, se as longuras das series
	de tempo difiren dun individuo a outro, amósase o seu estatístico
	<math>Z</math>; se non, amósase o seu estatístico <math>t</math>-barra.
	Consulta tamén a instrución <cmdref targ="levinlin"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Probas de raíz unitaria/Proba ampliada de Dickey-Fuller</menu-path>
    </gui-access>

  </command>

  <command name="anova" label="ANOVA" section="Statistics">
    <usage>
      <arguments>
        <argument>resposta</argument>
        <argument>tratamento</argument>
        <argument optional="true">control</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
      </options>
    </usage>
    <description>
      <para>
	Análise da Varianza: O argumento <repl>resposta</repl> deberá de ser
	unha serie que mida algún efecto de interese, e <repl>tratamento</repl>
	deberá de ser unha variable discreta que codifique dous ou máis tipos
	de tratamento (ou non tratamento). Para un ANOVA de dous factores,
	a variable <repl>control</repl> (que tamén será discreta) deberá de
	codificar os valores dalgunha variable de control.
      </para>
      <para context="cli">
	Agás cando indicas a opción <opt>quiet</opt>, esta instrución presenta
	unha táboa amosando as sumas de cadrados e os cadrados da media xunto
	cunha proba <math>F</math>. Podes recuperar o estatístico da proba
	<math>F</math> e a súa probabilidade asociada, utilizando os accesorios
	<fncref targ="$test"/> e <fncref targ="$pvalue"/>, respectivamente.
      </para>
      <para>
	A hipótese nula da proba <math>F</math> é que a resposta media é
	invariante con respecto ao tipo de tratamento ou, noutras palabras,
	que o tratamento non ten efecto. Falando estritamente, a proba só
	é válida cando a varianza da resposta é a mesma para tódolos tipos
	de tratamento.
      </para>
      <para>
	Cae na conta de que os resultados que amosa esta instrución son de feito un
	subconxunto da información ofrecida polo seguinte procedemento, que podes
	preparar doadamente no GRETL. (1) Xera un conxunto de variables ficticias que
	codifiquen todos os tipos de tratamento agás un. Para un ANOVA de dous factores,
	xera ademais un conxunto de variables ficticias que codifiquen todos os bloques
	de <quote>control</quote> agás un. (2) Fai a regresión de <repl>resposta</repl>
	sobre unha constante e as variables ficticias utilizando <cmdref targ="ols"/>.
	Cun só factor, preséntase a táboa ANOVA mediante a opción <opt>anova</opt> nesa
	función <lit>ols</lit>. No caso de dous factores, a proba <math>F</math>
	relevante atópala utilizando a instrución <cmdref targ="omit"/> logo da regresión.
	Por exemplo, (asumindo que <repl>resposta</repl> é <lit>y</lit>, que <lit>xt</lit>
	codifica o tratamento, e que <lit>xb</lit> codifica os bloques de <quote>control</quote>):
      </para>
      <code>
	# Un factor
	list Fict_xt = dummify(xt)
	ols y 0 Fict_xt --anova
	# Dous factores
	list Fict_xb = dummify(xb)
	ols y 0 Fict_xt Fict_xb
	# Proba de significación conxunta de Fict_xt
	omit Fict_xt --quiet
      </code>
    </description>

    <gui-access>
      <menu-path>/Modelar/Outros Modelos Lineais/ANOVA</menu-path>
    </gui-access>

  </command>

  <command name="append" section="Dataset" label="Engadir datos" context="cli">

    <usage>
      <arguments>
        <argument>nomeficheiro</argument>
      </arguments>
      <options>
	<option>
	  <flag>--time-series</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--fixed-sample</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--update-overlap</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Presenta menos detalles de confirmación; mira abaixo</effect>
	</option>
	<optnote>Mira abaixo para opcións adicionais especiais</optnote>
      </options>
    </usage>

    <description>
      <para>
	Abre un ficheiro de datos e agrega o contido ao conxunto vixente
	de datos, se os novos datos son compatibles. O programa tentará
	detectar o formato do ficheiro de datos (propio, texto plano, CSV,
	Gnumeric, Excel, etc.). Por favor, ten en conta que dispós da instrución
	<cmdref targ="join"/> que ofrece un control moito maior para facer
	coincidir os datos adicionais co banco de datos vixente. Observa tamén
	que engadir datos a un conxunto de datos xa existente é potencialmente
	bastante complicado; nese senso, consulta máis abaixo a sección titulada
	<quote>Datos de panel</quote>.
      </para>
      <para>
	Os datos engadidos poden ter ben o formato de observacións adicionais
	sobre series xa presentes no conxunto de datos, e/ou ben o formato
	de novas series. No caso de engadir series, a compatibilidade require
	(a) que o número de observacións dos novos datos sexa igual ao
	número de datos actuais, ou (b) que os novos datos carrexen unha
	clara información das observacións de xeito que GRETL poda deducir
	como colocar os valores. Cae na conta de que se hai unha
	<quote>coincidencia perfecta</quote> da información das observacións
	(é dicir, cando ambas condicións (a) e (b) se satisfán), asúmese que
	se van engadir as series, máis que as observacións. E se acontece que
	non hai nomes das series no ficheiro cuxos datos se van engadir e que
	aínda non están presentes no conxunto de datos vixente, entón non se
	fai nada e amósase un aviso.
      </para>
      <para>
	Un caso que non se admite é aquel no que os novos datos comezan
	antes e rematan despois ca os datos orixinais. Para engadir series
	nesa situación, podes utilizar a opción <opt>fixed-sample</opt>;
	isto ten como efecto que se suprime o engadido de observacións,
	polo que así restrínxese a operación unicamente a engadir series
	novas.
      </para>
      <para>
	Cando se selecciona un ficheiro de datos para agregar, pode
	haber un area de solapamento co conxunto de datos existente;
	é dicir, unha ou máis series poden ter unha ou máis observacións
	en común entre as dúas orixes. Cando indicas a opción
	<opt>update-overlap</opt>, a instrución <lit>append</lit>
	substitúe calquera observación solapada cos valores do ficheiro
	de datos escollido; se non, os valores que nese momento xa
	están no seu sitio non se ven afectados.
      </para>
      <para>
	As opcións especiais adicionais <opt>sheet</opt>, <opt>coloffset</opt>,
	<opt>rowoffset</opt> e <opt>fixed-cols</opt> funcionan do mesmo xeito
	que con <cmdref targ="open"/>; consulta esa instrución para obter máis
	explicacións.
      </para>
      <para>
	Por defecto, se presenta algunha información sobre o conxunto de datos
	agregado. A opción <opt>quiet</opt> reduce esa informacióna a unha
	simple mensaxe confirmatoria que só indica a ruta ata o ficheiro.
	Se queres que a operación se complete de xeito silandeiro, indica a
	instrución <lit>set verbose off</lit> antes de agregar os datos, en
	combinación coa opción <opt>quiet</opt>.
      </para>
      <subhead>Datos de panel</subhead>
      <para>
	Cando os datos se engaden a un conxunto de datos de panel, o resultado
	tan só vai ser correcto se coinciden de xeito apropiado tanto as
	<quote>unidades</quote> ou <quote>individuos</quote>, como os períodos
	de tempo.
      </para>
      <para>
	A instrución <lit>append</lit> debería manexar correctamente dúas
	situacións relativamente simples. Sirva <math>n</math> para denotar o
	número de unidades atemporais e <math>T</math> para denotar o número
	de períodos de tempo do panel vixente; e sirva <math>m</math> para
	denotar o número de observacións dos novos datos. Se <math>m = n</math>,
	os novos datos considéranse invariantes no tempo, e cópianse
	repetidos para cada período de tempo. Por outra banda, se
	<math>m = T</math> os datos trátanse como invariantes entre
	as unidades atemporais, e cópianse repetidos para cada unidade
	atemporal. Se o panel é <quote>cadrado</quote>, e <math>T = n</math>
	aparece unha ambigüidade. Por defecto, neste caso trátanse os novos
	datos como invariantes no tempo, pero podes forzar a que GRETL os
	trate como series temporais (invariantes entre as unidades) coa a
	opción <opt>time-series</opt>.
      </para>
      <para>
	Cando se recoñece tanto ao conxunto de datos vixente como aos datos
	que se van engadir como datos de panel, entón admítese o engadido
	só se tanto a dimensión de <math>T</math> como de <math>N</math>
	coinciden; noutro caso, amósase un fallo. Para casos máis complexos,
	utiliza a instrución <cmdref targ="join"/> en troques de <lit>append</lit>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ficheiro/Engadir datos</menu-path>
    </gui-access>

  </command>

  <command name="ar" section="Estimation" label="Estimación autorregresiva">

    <usage>
      <arguments>
        <argument>retardos</argument>
	      <argument separated="true">depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta as estimacións dos parámetros</effect>
	</option>
      </options>
      <examples>
        <example>ar 1 3 4 ; y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcula as estimacións dos parámetros utilizando o procedemento iterativo
	xeneralizado de Cochrane&ndash;Orcutt; consulta a Sección 9.5 de
	<cite key="ramanathan02">Ramanathan (2002)</cite>. As iteracións rematan
	cando a sucesión de sumas de erros cadrados non difire dun termo ao
	seguinte en máis do 0.005 por cento, ou despois de 20 iteracións.
      </para>

      <para context="gui">
	Coa <quote>Lista de retardos AR</quote> especificas a estrutura
	do proceso xerador do termo de perturbación. Por exemplo, a
	indicación <quote>1 3 4</quote> correspóndese co proceso:
	<equation status="display"
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho1*u(t-1) + rho3*u(t-3) + rho4*u(t-4)"
	  graphic="arlags"/>
      </para>

      <para context="cli">
	Con <repl quote="true">retardos</repl> tes que indicar unha lista de
	retardos do termo de perturbación, rematada por un punto e coma.
	No exemplo de arriba, o termo de perturbación especifícase como
	<equation status="display"
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho(1)*u(t-1) + rho(3)*u(t-3) + rho(4)*u(t-4)"
	  graphic="arlags"/>
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelar/Series temporais univariantes/Perturbacións AR (MCX)</menu-path>
    </gui-access>

  </command>

  <command name="ar1" section="Estimation" label="Estimación AR(1)">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--hilu</flag>
	  <effect>Utiliza o procedemento de Hildreth&ndash;Lu</effect>
	</option>
	<option>
	  <flag>--pwe</flag>
	  <effect>Utiliza o estimador de Prais&ndash;Winsten</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--no-corc</flag>
	  <effect>Non afina os resultados con Cochrane-Orcutt</effect>
	</option>
	<option>
	  <flag>--loose</flag>
	  <effect>Utiliza un criterio de converxencia menos preciso</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
	</option>
      </options>
      <examples>
        <example>ar1 1 0 2 4 6 7</example>
	<example>ar1 y 0 xlista --pwe</example>
	<example>ar1 y 0 xlista --hilu --no-corc</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcula estimacións MCX que sexan viables para un modelo
	no que o termo de perturbación asúmese que sigue un proceso
	autorregresivo de primeira orde.
      </para>
      <para>
	O método utilizado por defecto é o procedemento iterativo de
	Cochrane&ndash;Orcutt; por exemplo, consulta a sección 9.4
	de <cite key="ramanathan02">Ramanathan (2002)</cite>. O
	criterio para acadar a converxencia é que as estimacións
	sucesivas do coeficiente de autocorrelación, non difiran en
	máis de 1e-6 ou, cando indicas a opción <opt>loose</opt>,
	en máis de 0.001. Se isto non se acada antes de que se
	fagan as 100 iteracións, amósase un fallo.
      </para>
      <para>
	Cando indicas a opción <opt>pwe</opt>, utilízase o estimador
	de Prais&ndash;Winsten. Isto implica unha iteración similar
	á de Cochrane&ndash;Orcutt; a diferenza está en que mentres
	que o método de Cochrane&ndash;Orcutt descarta a primeira
	observación, o método de Prais&ndash;Winsten fai uso dela.
	Para obter máis detalles consulta, por exemplo, o capítulo 13
	de <cite key="greene00">Greene (2000)</cite>.
      </para>
      <para>
	Cando indicas a opción <opt>hilu</opt>, utilízase o procedemento
	de procura de Hildreth&ndash;Lu. Nese caso afínanse os
	resultados utilizando o método de Cochrane&ndash;Orcutt,
	agás que especifiques a opción <opt>no-corc</opt>.
	Esta opción <opt>no-corc</opt> ignórase para estimadores
	diferentes ao do método de Hildreth&ndash;Lu.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Series temporais univariantes/Perturbacións AR (MCX)</menu-path>
    </gui-access>

  </command>

  <command name="arch" section="Estimation" label="Modelo ARCH">

    <usage>
      <arguments>
        <argument>nivel</argument>
        <argument>depvar</argument>
      	<argument>indepvars</argument>
      </arguments>
      <options>
      <option>
	    <flag>--quiet</flag>
	    <effect>Non presenta nada</effect>
	    </option>
      </options>
      <examples>
        <example>arch 4 y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Neste momento, esta instrución mantense por compatibilidade con
	versións anteriores, pero saes gañando se utilizas o estimador
	máximo verosímil que ofrece a instrución <cmdref targ="garch"/>.
	Se queres estimar un modelo ARCH sinxelo, podes usar o GARCH
	facendo que o seu primeiro parámetro sexa 0.
      </para>
      <para>
	Estima a especificación indicada do modelo permitindo ARCH
	(Heterocedasticidade Condicional Autorregresiva). Primeiro,
	estímase o modelo mediante MCO, e logo execútase unha regresión
	auxiliar, na que se regresa o erro cadrado da primeira sobre os
	seus propios valores retardados. O paso final é a estimación por
	mínimos cadrados ponderados, utilizando como ponderacións as
	inversas das varianzas dos erros axustados coa regresión auxiliar.
	(Se a varianza que se predí para algunha observación da regresión
	auxiliar, non é positiva, entón utilízase no seu lugar o erro cadrado
	correspondente).
      </para>
      <para>
	Os valores <lit>alpha</lit> presentados debaixo dos coeficientes
	son os parámetros estimados do proceso ARCH coa regresión
	auxiliar.
      </para>
      <para>
	Consulta tamén <cmdref targ="garch"/> e <cmdref targ="modtest"/>
	(opción <opt>arch</opt>).
      </para>
    </description>

  </command>

  <command name="arima" section="Estimation" label="Modelo ARIMA">

    <usage>
      <arguments>
	<argblock>
	  <argument>p</argument>
	  <argument>d</argument>
	  <argument>q</argument>
	</argblock>
	<argblock separated="true" optional="true">
	  <argument>P</argument>
	  <argument>D</argument>
	  <argument>Q</argument>
	</argblock>
	<argument separated="true">depvar</argument>
	<argument optional="true">indepvars</argument>
      </arguments>
      <options>
	      <option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	      </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--hessian</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--opg</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--nc</flag>
	  <effect>Sen constante</effect>
        </option>
        <option>
	  <flag>--conditional</flag>
	  <effect>Utiliza Máxima Verosimilitude condicional</effect>
        </option>
        <option>
	  <flag>--x-12-arima</flag>
	  <effect>Utiliza ARIMA X-12 ou X-13 na estimación</effect>
        </option>
	<option>
	  <flag>--lbfgs</flag>
	  <effect>Utiliza o maximizador L-BFGS-B</effect>
	</option>
	<option>
	  <flag>--y-diff-only</flag>
	  <effect>ARIMAX especial; mira abaixo</effect>
	</option>
	<option>
	  <flag>--lagselect</flag>
	  <effect>Mira abaixo</effect>
	</option>
	      </options>
      <examples>
        <example>arima 1 0 2 ; y</example>
	<example>arima 2 0 2 ; y 0 x1 x2 --verbose</example>
	<example>arima 0 1 1 ; 0 1 1 ; y --nc</example>
	<demos>
	<demo>armaloop.inp</demo>
	<demo>auto_arima.inp</demo>
	<demo>bjg.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>

      <para>
	Advertencia: <lit>arma</lit> é un alcume aceptable para esta instrución.
      </para>
      <para context="cli">
	Cando non indicas a lista <repl>indepvars</repl>, estímase
	un modelo univariante ARIMA (Autorregresivo, Integrado, de
	Medias móbiles). Os valores <repl>p</repl>, <repl>d</repl>
	e <repl>q</repl> representan o nivel autorregresivo (AR), a
	orde de diferenciación e o nivel de medias móbiles (MA),
	respectivamente. Podes indicar estes valores en formato
	numérico, ou como nomes de variables escalares xa existentes.
	Por exemplo, un valor de 1 para <repl>d</repl> significa que,
	antes de estimar os parámetros do ARMA, debe de tomarse
	a primeira diferenza da variable dependente.
      </para>
      <para context="cli">
	Se queres incluír no modelo só retardos AR ou MA específicos (en
	contraposición a todos os retardos ata un nivel indicado) podes
	substituír por <repl>p</repl> e/ou <repl>q</repl> ben (a) o nome
	dunha matriz definida previamente que contén un conxunto de valores
	enteiros, ou ben (b) unha expresión tal como <lit>{1,4}</lit>; é dicir,
	un conxunto de retardos separados con comas e contornados entre chaves.
      </para>
      <para context="cli">
	Os valores enteiros <repl>P</repl>, <repl>D</repl> e
	<repl>Q</repl> (opcionais) representan o nivel AR estacional,
	a orde de diferenciación estacional e o nivel MA estacional,
	respectivamente. Estas ordes só as podes aplicar cando os
	datos teñen unha frecuencia maior ca 1 (por exemplo, con
	datos trimestrais ou mensuais); e podes indicalas en formato
	numérico ou como variables escalares.
      </para>
      <para context="cli">
	No caso univariante, por defecto inclúese no modelo
	unha ordenada na orixe, pero podes eliminar isto por medio da
	opción <opt>nc</opt>. Cando engades <repl>indepvars</repl>,
	o modelo vólvese un ARMAX; neste caso, debes de incluír a
	constante explicitamente se queres ter a ordenada na orixe
	(como no segundo exemplo de arriba).
      </para>
      <para context="cli">
	Dispós dunha forma alternativa de sintaxe para esta instrución:
	se non queres aplicar diferenzas (nin estacionais nin non estacionais),
	podes omitir os dous campos <repl>d</repl> e <repl>D</repl> á vez,
	mellor que introducir explicitamente 0. Ademais, <lit>arma</lit>
	é un alias ou sinónimo de <lit>arima</lit> e así, por exemplo, a
	seguinte instrución é un xeito válido de especificar un modelo
	ARMA(2, 1):
      </para>
      <code context="cli">
	arma 2 1 ; y
      </code>
      <para context="gui">
	Estima un modelo ARMA, con ou sen regresores esóxenos. Se
	a orde de diferenciación é maior ca cero, o modelo vólvese
	un ARIMA. Cando os datos teñen unha frecuencia maior ca 1,
	se te presenta a posibilidade de que inclúas unha compoñente
	estacional.
      </para>
      <para context="gui">
	Se queres incluír no modelo unicamente retardos AR ou MA específicos (en
	contraposición a incluír todos os retardos ata un nivel indicado), marca
	o cadriño á dereita do botón con frechas arriba/abaixo e teclea unha lista
	de retardos no campo de anotación, separados por espazos. De forma
	alternativa, se tes definida unha matriz que contén o conxunto de retardos
	que desexas, podes teclear o seu nome no campo de anotación.
      </para>
      <para>
	Por defecto, utilízase a funcionalidade ARMA <quote>propia</quote> de
	GRETL, coa estimación Máximo Verosímil (MV) exacta; pero dispós da
	opción de facer a estimación mediante MV condicional. (Se o programa
	<program>ARIMA X-12</program> está instalado no ordenador, tes a
	posibilidade de utilizalo en vez do código propio. Ten en conta que,
	do mesmo xeito, o máis recente <program>X13</program> pode funcionar
	coma un recambio automático.) Para outros detalles relacionados con
	estas opcións, consulta o <guideref targ="chap:timeseries"/>.
      </para>
      <para context="cli">
	Cando se utiliza código propio de MV exacta, os desvíos
	padrón estimados baséanse por defecto nunha aproximación numérica á
	(inversa negativa da) matriz Hessiana, cun último recurso ao Produto
	Externo do vector Gradiente (PEG) se o cálculo da matriz Hessiana
	numérica puidera fallar. Podes utilizar dous indicadores de opción
	(mutuamente excluíntes) para forzar esta cuestión: mentres que a
	opción <opt>opg</opt> forza a utilización do método PEG, sen intentar
	calcular a matriz Hessiana, a opción <opt>hessian</opt> inhabilita
	o último recurso a PEG. Ten en conta que un fallo no cálculo da matriz
	Hessiana numérica, é xeralmente un indicador de que un modelo está
	mal especificado.
      </para>
      <para context="cli">
	A opción <opt>lbfgs</opt> é específica da estimación que utiliza
	código ARMA propio e Máxima Verosimilitude exacta; e solicita
	que se utilice o algoritmo de <quote>memoria limitada</quote>
	L-BFGS-B en vez do maximizador BFGS habitual. Isto pode ser de
	axuda nalgúns casos nos que a converxencia é difícil de acadar.
      </para>
      <para context="cli">
	A opción <opt>y-diff-only</opt> é específica da estimación de modelos
	ARIMAX (modelos con orde de integración non nula, nos que se inclúen
	regresores esóxenos) e aplícase só cando se utiliza a Máxima Verosimilitude
	exacta propia de GRETL. Para eses modelos, o comportamento por defecto
	consiste en calcular as primeiras diferenzas tanto da variable dependente
	como dos regresores; pero cando indicas esta opción, só se calcula para
	a variable dependente, quedando os regresores en niveis.
      </para>
      <para>O valor do AIC de Akaike indicado en conexión
	con modelos ARIMA, calcúlase de acordo coa definición que
	utiliza o <program>ARIMA X-12</program>, concretamente
	  <equation status="display"
	  tex="\[\mbox{AIC}=-2\ell + 2k\]"
	  ascii="AIC = -2L + 2k"
	  graphic="aic"/> onde 
	<equation status="inline"
	  tex="$\ell$" ascii="L"
	  graphic="ell"/> é o
	logaritmo da verosimilitude e <math>k</math> é o número total de
	parámetros estimados. Observa que o <program>ARIMA X-12</program>
	non produce criterios de información tales como AIC cando a estimación
	é por Máxima Verosimilitude condicional.
      </para>
      <para context="tex">
	As raíces AR e MA amosadas en conexión coa estimación
	ARMA baséanse na seguinte representación dun proceso
	ARMA($p,q$):
	  \[
	   (1-\phi_1 L - \phi_2 L^2 - \cdots - \phi_p L^p)Y =
      c + (1 + \theta_1 L + \theta_2 L^2 + \cdots +
      \theta_q L^q)\varepsilon_t
    \]
	Polo tanto, as raíces AR son as solucións a
    \[
     1 - \phi_1 z - \phi_2 z^2 - \cdots - \phi_p L^p = 0
    \]
	e a estabilidade require que estas raíces se atopen
	fóra do círculo de radio unitario.
      </para>
      <para context="tex">
	A cantidade <quote>Frecuencia</quote> presentada en
	conexión coas raíces AR e MA, é o valor $\lambda$ que
	soluciona $z=re^{i2\pi\lambda}$, onde $z$ é a raíz en
	cuestión e $r$ é o seu módulo.
      </para>
      <para context="notex">
	As raíces AR e MA amosadas en conexión coa estimación
	ARMA baséanse na seguinte representación dun proceso
	ARMA(p, q):
      </para>
      <mono context="notex">
      	(1 - a_1*L - a_2*L^2 - ... - a_p*L^p)Y =
        c + (1 + b_1*L + b_2*L^2 + ... + b_q*L^q) e_t
      </mono>
      <para context="notex">
	Polo tanto, as raíces AR son as solucións a
      </para>
      <mono context="notex">
       1 - a_1*z - a_2*z^2 - ... - a_p*L^p = 0
      </mono>
      <para context="notex">
	e a estabilidade require que estas raíces se atopen
	fóra do círculo de radio unitario.
      </para>
      <para context="notex">
	A cantidade <quote>Frecuencia</quote> presentada en conexión coas
	raíces AR e MA, é o valor &lgr; que soluciona <math>z</math> =
	<math>r</math> * exp(i*2*&pi;*&lgr;) onde <math>z</math> é a raíz
	en cuestión, e <math>r</math> é o seu módulo.
      </para>

      <subhead context="cli">Lag selection</subhead>
      <para context="cli">
	Cando se indica a opción <opt>lagselect</opt>, esta instrución non
	proporciona estimacións concretas, senón que en troques produce
	unha táboa que presenta criterios de información e o logaritmo da
	verosimilitude para certas especificacións ARMA ou ARIMA. Os niveis
	de retardo <math>p</math> e <math>q</math> considéranse como máximos;
	e cando se indica unha especificación estacional, <math>P</math> e
	<math>Q</math> tamén se consideran como máximos. En todo caso, o nivel
	mínimo considérase que é 0, e os resultados amósanse para tódalas
	especificacións desde a mínima ata a máxima. Os graos das diferenzas
	da instrución, <math>d</math> e/ou <math>D</math>, respéctanse pero non
	se tratan como obxecto de investigación. Podes obter unha matriz que
	conteña os resultados mediante o accesorio <fncref targ="$test"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Series temporais univariantes/ARIMA</menu-path>
    </gui-access>

  </command>

  <command name="arma" section="Estimation" label="Modelo ARMA">
    <description>
      <para>
	Consulta <cmdref targ="arima"/>; <lit>arma</lit> é un alcume.
      </para>
    </description>
  </command>

  <command name="ARMA-lagselect" section="Tests" context="gui"
    label="Selección do nivel de retardo dun AR(I)MA">

    <description>
      <para>
	Nesta caixa de diálogo, especifícase un modelo ARMA ou ARIMA como se adoita
	facer; mais os niveis de retardo que indiques considéranse como máximos.
      </para>
      <para>
	A saída de resultados consiste nunha táboa que amosa os valores dos
	Criterios de Información de Akaike (AIC), de Schwarz (BIC) e de
	Hannan&ndash;Quinn (HQC), así como o logaritmo da verosimilitude,
	calculados para as especificacións que van desde os mínimos ata os
	máximos. Isto está pensado para axudar na selección dos niveis óptimos
	de retardo.
      </para>
    </description>
  </command>

  <command name="bds" section="Tests" label="Proba BDS de non linearidade">
    <usage>
      <arguments>
        <argument>orde</argument>
	<argument>x</argument>
      </arguments>
      <options>
        <option>
	  <flag>--corr1</flag>
	  <optparm>rho</optparm>
	  <effect>Mira abaixo</effect>
        </option>
	<option>
	  <flag>--sdcrit</flag>
	  <optparm>multiple</optparm>
	  <effect>Mira abaixo</effect>
        </option>
	<option>
	  <flag>--boot</flag>
	  <optparm>N</optparm>
	  <effect>Mira abaixo</effect>
        </option>
	<option>
	  <flag>--matrix</flag>
	  <optparm>m</optparm>
	  <effect>Usa unha entrada matricial</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Suprime a presentación de resultados</effect>
        </option>
      </options>
      <examples>
        <example>bds 5 x</example>
	<example>bds 3 --matrix=m</example>
	<example>bds 4 --sdcrit=2.0</example>
      </examples>
    </usage>
    <description>
      <para context="cli">
	Realiza a proba BDS
	(<cite key="brock-etal96">Brock, Dechert, Scheinkman e LeBaron, 1996</cite>)
	de non linearidade para a serie <repl>x</repl>. No contexto econométrico, isto
	aplícase habitualmente para comprobar se as perturbacións dunha regresión
	incumpren a condición IID (distribución idéntica e independente). A proba
	baséase nun conxunto de integrais de correlación, amañadas para detectar a
	non linearidade de dimensión progresivamente maior; e establécese o número
	desas integrais co argumento <argname>orde</argname>. Estas deben de ser
	polo menos 2; coa primeira integral establécese unha referencia de partida, pero
	sen que permita unha proba. A proba BDS é de tipo <quote>portmanteau</quote>:
	axeitada para detectar toda clase de desvíos respecto da linearidade, pero
	non clarificadora do xeito exacto no que se incumpre a condición.
      </para>
      <para context="gui">
	A proba BDS
	(<cite key="brock-etal96">Brock, Dechert, Scheinkman e LeBaron, 1996</cite>)
	comproba a non linearidade dunha serie temporal. No contexto econométrico,
	isto aplícase habitualmente para comprobar se as perturbacións dunha regresión
	incumpren a condición IID (distribución idéntica e independente). A proba
	baséase nun conxunto de integrais de correlación, amañadas para detectar a
	non linearidade de dimensión progresivamente maior; o número desas integrais
	elíxese mediante o control <quote>Dimensión máxima</quote>. Estas deben de ser
	polo menos 2; coa primeira integral establécese unha referencia de partida, pero
	sen que permita unha proba. A proba BDS é de tipo <quote>portmanteau</quote>:
	axeitada para detectar toda clase de desvíos respecto da linearidade, pero
	non clarificadora do xeito exacto no que se incumpre a condición.
      </para>
      <para context="cli">
	En troques de indicar <repl>x</repl> como serie, podes usar a opción
	<opt>matrix</opt> para especificar unha matriz como entrada, que
	debe ter forma de vector (columna ou fila).
      </para>
      <subhead>Criterio de proximidade</subhead>
      <para context="cli">
	As integrais de correlación están baseadas nunha medida de
	<quote>proximidade</quote> entre os puntos dos datos, de xeito
	que se consideran próximos a dous deses puntos se están situados
	un do outro a menos de &egr;. Dado que a proba necesita que se
	especifique &egr;, por defecto, GRETL segue a recomendación de
	<cite key="kanzler99">Kanzler (1999)</cite>: &egr; elíxese de modo que
	a integral de correlación de primeira orde estea arredor de 0.7. Unha
	alternativa habitual (que require menos cálculos) consiste en especificar
	&egr; como un múltiplo do desvío padrón da serie de interese.
	A opción <opt>sdcrit</opt> permite este derradeiro método;
	así, no terceiro exemplo indicado máis arriba, &egr; establécese que
	sexa igual a dúas veces o desvío padrón de <repl>x</repl>.
	A opción <opt>corr1</opt> implica a utilización do método de Kanzler
	pero permite outra correlación obxectivo diferente de 0.7. Debería
	quedarche claro que estas dúas opcións exclúense mutuamente.
      </para>
      <para context="gui">
	As integrais de correlación están baseadas nunha medida de
	<quote>proximidade</quote> entre os puntos dos datos, de xeito
	que se consideran próximos a dous deses puntos se están situados
	un do outro a menos de &egr;. Dado que a proba necesita que se
	especifique &egr;, por defecto, GRETL segue a recomendación de
	<cite key="kanzler99">Kanzler (1999)</cite>: &egr; elíxese de modo que
	a integral de correlación de primeira orde estea arredor de 0.7. Unha
	alternativa habitual (que require menos cálculos) consiste en especificar
	&egr; como un múltiplo do desvío padrón da serie de interese. 
      </para>
      <subhead context="cli">Mostraxe repetida</subhead>
      <para context="cli">
	Os estatísticos da proba BDS teñen distribución asintótica de tipo
	<math>N</math>(0,1), pero a proba rexeita demasiado a hipótese nula
	de xeito moi notable con mostras de tamaño entre pequeno e moderado.
	Por ese motivo, os valores <math>P</math> obtéñense por defecto
	mediante mostraxe repetida (bootstrapping) cando <argname>x</argname>
	ten unha longura menor que 600 (e con referencia á distribución Normal,
	noutro caso). Se queres utilizar a mostraxe repetida con mostras máis
	longas, podes forzar esta cuestión indicando un valor non nulo para
	a opción <opt>boot</opt>. Pola contra, se non queres que se faga a
	mostraxe repetida coas mostras máis pequenas, indica un valor de
	cero para <opt>boot</opt>.
      </para>
      <subhead context="gui">Valores p</subhead>
      <para context="gui">
	Os estatísticos da proba BDS teñen distribución asintótica de tipo
	<math>N</math>(0,1), pero a proba rexeita demasiado a hipótese nula
	de xeito moi notable con mostras de tamaño entre pequeno e moderado.
	Por ese motivo, os valores <math>P</math> obtéñense por defecto
	mediante mostraxe repetida (bootstrapping) cando <argname>x</argname>
	ten unha longura menor que 600 (e con referencia á distribución Normal,
	noutro caso).
      </para>
      <para context="cli">
	Cando se fai a mostraxe repetida, o número de iteracións por defecto
	é de 1999; pero podes especificar un número diferente indicando un
	valor maior ca 1 coa opción <opt>boot</opt>.
      </para>
      <subhead context="cli">Matriz accesoria</subhead>
      <para context="cli">
	Cando se completa con éxito a execución desta instrución,
	<fncref targ="$result"/> proporciona os resultados da proba en forma
	dunha matriz con dúas filas e <argname>orde</argname> &minus; 1
	columnas. A primeira fila contén os estatísticos de proba e a segunda
	os valores <math>P</math>, de cada unha das probas por dimensión,
	baixo a hipótese nula de que <argname>x</argname> é linear/IID.
      </para>
    </description>
  </command>

  <command name="bfgs-config" section="Estimation" label="Opcións de BFGS"
    context="gui">
    <description>
      <para>
	Este diálogo te permite controlar algúns aspectos do funcionamento do
	maximizador BFGS. No caso de que o maximizador falle na converxencia,
	pode mellorar a cousa (nalgúns casos) ao aumentar o número de iteracións
	permitidas e/ou ao aumentar (facer máis permisiva) a tolerancia da
	converxencia. Porén, debes de sospeitar dos resultados que obteñas
	utilizando unha tolerancia elevada e considerar a posibilidade de que o
	modelo que estimas estea mal especificado.
      </para>
      <para>
	Para a maioría das aplicacións, te recomendamos que utilices o
	maximizador BFGS habitual pero, para algúns problemas, a variante
	do algoritmo con <quote>memoria limitada</quote> L-BFGS-B, pode
	producir unha converxencia máis rápida. Cando seleccionas L-BFGS-B,
	tes a posibilidade de establecer o número de correccións utilizadas na
	matriz de memoria limitada (entre 3 e 20, con 8 por defecto).
      </para>
    </description>
  </command>

  <command name="biprobit" section="Estimation" label="Modelo Probit bivariante"
    context="cli">
    <usage>
      <arguments>
        <argument>depvar1</argument>
	      <argument>depvar2</argument>
        <argument>indepvars1</argument>
	      <argument separated="true" optional="true">indepvars2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para aclaración</effect>
        </option>
	<option>
	  <flag>--opg</flag>
	  <effect>Mira abaixo</effect>
        </option>
	<option>
	  <flag>--save-xbeta</flag>
	  <effect>Mira abaixo</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta información adicional</effect>
        </option>
      </options>
      <examples>
        <example>biprobit y1 y2 0 x1 x2</example>
	<example>biprobit y1 y2 0 x11 x12 ; 0 x21 x22</example>
	<demos>
	  <demo>biprobit.inp</demo>
	</demos>
      </examples>
    </usage>
    <description>
      <para>
	Estima un modelo probit bivariante utilizando o método de
	Newton&ndash;Raphson para maximizar a verosimilitude.
      </para>
      <para>
	A lista de argumentos comeza coas dúas variables (binarias)
	dependentes, seguidas dunha lista de regresores. Cando indicas
	unha segunda lista (separada por un punto e coma) se
	entende como un grupo de regresores específicos da segunda
	ecuación, sendo <repl>indepvars1</repl> específica da primeira
	ecuación; se non, <repl>indepvars1</repl> considérase
	que representa un conxunto de regresores común.
      </para>
      <para>
	Por defecto, os desvíos padrón calcúlanse utilizando a matriz
	Hessiana analítica ao converxer. Pero se indicas a opción <opt>opg</opt>,
	a matriz de covarianzas baséase no Produto Externo do vector Gradiente
	(PEG ou OPG); ou se indicas a opción <opt>robust</opt>, calcúlanse os
	desvíos padrón case máximo verosímiles (QML), utilizando un
	<quote>emparedado</quote> entre a inversa da matriz Hessiana e o
	PEG.
      </para>
      <para>
	Cae na conta de que a estimación de rho (a correlación dos termos de
	erro entre as dúas ecuacións) inclúese no vector de coeficientes;
	é o derradeiro elemento dos accesorios <lit>coeff</lit>,
	<lit>stderr</lit> e <lit>vcv</lit>.
      </para>
      <para>
	Logo dunha estimación correcta, o accesorio <lit>$uhat</lit>
	permite recuperar unha matriz con 2 columnas que contén os
	erros xeneralizados das dúas ecuacións; é dicir, os valores
	agardados das perturbacións condicionadas aos resultados
	observados e ás variables covariantes. Por defecto, <lit>$yhat</lit>
	permite recuperar unha matriz con 4 columnas que contén as
	probabilidades estimadas dos 4 posibles resultados conxuntos para
	(<math>y</math><sub>1</sub>, <math>y</math><sub>2</sub>), na
	orde (1,1), (1,0), (0,1), (0,0). Alternativamente, cando indicas
	a opción <opt>save-xbeta</opt>, entón <lit>$yhat</lit> ten 2 columnas
	e contén os valores das funcións índice das ecuacións respectivas.
      </para>
      <para>
	O resultado inclúe unha proba da hipótese nula de que as perturbacións
	das dúas ecuacións non están correlacionadas. Esta é unha proba de Razón
	de Verosimilitudes agás que se solicite o estimador case máximo verosímil
	(QML) da varianza, en cuxo caso utilízase a proba de Wald.
      </para>
    </description>
  </command>

  <command name="bkw" section="Tests" context="cli"
	   label="Diagnósticos de Multicolinearidade">
    <usage>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
        </option>
      </options>
	<examples>
	<demos>
	  <demo>longley.inp</demo>
	</demos>
    </examples>
    </usage>

    <description>
      <para>
	Debe de ir despois da estimación dun modelo que conteña cando
	menos dúas variables explicativas. Calcula e presenta información
	de diagnóstico en relación á multicolinearidade, en concreto a
	Táboa BKW que está baseada no traballo de
	<cite key="belsley-etal80">Belsley, Kuh e Welsch (1980)</cite>.
	Esta táboa presenta unha sofisticada análise do grao e das causas da
	multicolinearidade, mediante o exame dos autovalores da inversa da
	matriz de correlacións. Para ter unha explicación polo miúdo do enfoque
	BKW en relación a GRETL, e con diversos exemplos, consulta
	<cite key="adkins15">Adkins, Waters e Hill (2015)</cite>.
      </para>
      <para>
	Despois de utilizar esta instrución, podes usar o accesorio
	<fncref targ="$result"/> para recuperar a táboa BKW en forma de
	matriz. Consulta tamén a instrución <cmdref targ="vif"/> para
	obter un enfoque máis sinxelo da diagnose da multicolinearidade.
      </para>
      <para>
	Hai tamén unha función chamada <fncref targ="bkw"/> que ofrece
	unha maior flexibilidade.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Análise/Multicolinearidade</menu-path>
    </gui-access>

  </command>

  <command name="bootstrap" section="Tests" label="Opcións de Bootstrap"
    context="gui">

    <description>

      <para>Nesta caixa de diálogo vas a elixir:</para>

      <ilist>
	<li>
	    <para>
	    A variable ou o coeficiente a examinar. (Utilizando este método,
	    só podes probar un coeficiente de cada vez .)
	    </para>
	</li>
	<li>
	    <para>
	    O tipo de análise a realizar. O intervalo de confianza por defecto
	    (do 95 por cento) baséase directamente nos cuantís das estimacións
	    dos coeficientes mediante bootstrap. A versión do intervalo
	    <quote>studentizado</quote> é consonte a Davidson e MacKinnon,
	    <cite key="davidson-mackinnon04">Economic Theory and Methods</cite>
	    (ETM, capítulo 5): en cada repetición do bootstrap fórmase
	    unha razón <math>t</math> que se calcula collendo a
	    diferenza entre a estimación dos coeficientes obtida mediante
	    bootstrap e a de partida, e dividíndoa entre o desvío
	    padrón de bootstrap. O intervalo de confianza 
	    baséase entón nos cuantís desta razón <math>t</math>
	    de bootstrap, como se explica no citado ETM. A opción valor p
	    baséase na distribución da razón <math>t</math> de bootstrap:
	    é a proporción das repeticións nas que o valor absoluto
	    deste estatístico excede o valor absoluto da razón
	    <math>t</math> de partida.
	    </para>
	</li>
	<li>
	    <para>
	    O tipo de método Bootstrap. Baixo a primeira opción, vólvese a renovar
	    a mostra dos erros da estimación orixinal, con substitución
	    (logo de volvelos a escalar como se suxire en ETM). Baixo a
	    segunda, vólvese a renovar a mostra con substitución dos
	    <quote>pares</quote> ou <quote>casos</quote>; é dicir, as
	    filas de datos (<math>y</math>, <math>X</math>). Na terceira
	    opción, os erros orixinais transfórmanse primeiro consonte a
	    <cite key="davidson-flachaire01">Davidson e Flachaire (2001)</cite>;
	    entón, en cada repetición do bootstrap, cada erro transformado
	    multiplícase por 1 ou &minus;1, con probabilidade igual
	    a 0.5 en cada caso. Na opción final, xéranse valores
	    normais pseudoaleatorios utilizando a varianza dos erros
	    orixinais.
	    </para>
	</li>
	<li>
	    <para>
	    O número de repeticións a realizar. Ten en conta que cando
	    estás construíndo un intervalo co 95 por cento de confianza,
	    é desexable que 0.05(<math>B</math> + 1)/2 sexa un enteiro
	    (onde <math>B</math> é o número de repeticións). Así, GRETL
	    pode axustar o número de repeticións que escollas para
	    garantir que este é o caso.
	    </para>
	</li>
	<li>
	    <para>
	    Produce ou non unha gráfica da distribución bootstrap. Esta
	    opción emprega o servizo de estimación da densidade do
	    kernel de GRETL.
	    </para>
	</li>
      </ilist>

    </description>
  </command>

  <command name="boxplot" section="Graphs" label="Gráficas de caixa">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--notches</flag>
	  <effect>Amosa o intervalo do 90 por cento para a mediana</effect>
	</option>
	<option>
	  <flag>--factorized</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--panel</flag>
	  <effect>Mira abaixo</effect>
	</option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nome</optparm>
	  <effect>Representa as columnas da matriz indicada</effect>
        </option>
	<option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía o resultado ao ficheiro especificado</effect>
	</option>
      </options>
    </usage>

    <description>

      <para>
	Estas gráficas amosan a distribución dunha variable. Unha
	caixa central encerra o 50 por cento central dos datos; &ie;
	está deslindada polo primeiro e terceiro cuartís. Un
	<quote>bigote</quote> esténdese desde cada límite da caixa cun
	rango igual a 1.5 veces o rango intercuartil. As observacións
	que están fóra dese rango considéranse valores atípicos e
	represéntanse mediante puntos. Debúxase unha liña ao largo
	da caixa na mediana. O signo <quote>+</quote> utilízase para
	indicar a media. Se escolles a opción de amosar un intervalo de
	confianza para a mediana, este calcúlase mediante o método
	bootstrap e amósase con formato de liñas con raias horizontais
	por arriba e/ou abaixo da mediana.
      </para>

      <para context="gui">
	A opción <quote>factorized</quote> te permite examinar a distribución
	da variable elixida condicionada ao valor de algún factor discreto.
	Por exemplo, se un conxunto de datos contén unha variable cos salarios
	e unha variable ficticia co xénero, podes escoller a dos salarios como
	obxectivo e a do xénero como o factor, para ver así as gráficas de
	caixas de salarios de homes e mulleres, unha a carón da outra.
      </para>

      <para context="cli">
	A opción <opt>factorized</opt> te permite examinar a distribución
	da variable elixida condicionada ao valor de algún factor discreto.
	Por exemplo, se un conxunto de datos contén unha variable cos salarios
	e unha variable ficticia co xénero, podes escoller a dos salarios como
	obxectivo e a do xénero como o factor, para ver así as gráficas de
	caixas de salarios de homes e mulleres, unha a carón da outra, como en
      </para>
      <code context="cli">
	boxplot salario xenero --factorized
      </code>
      <para context="cli">
	Ten en conta que neste caso debes de especificar exactamente só
	dúas variables, co factor indicado en segundo lugar.
      </para>

      <para context="cli">
	Cando tes un conxunto vixente de datos de panel e especificas só unha
	variable, a opción <opt>panel</opt> produce unha serie de gráficas
	de caixas (unha a carón da outra) na que cada unha se corresponde
	cun grupo ou <quote>unidade</quote> do panel.
      </para>

      <para context="cli">
	Xeralmente requírese o argumento <repl>listavariables</repl> que se refire
	a unha ou máis series do conxunto vixente de datos (indicadas ben
	polo nome ou ben polo número ID). Pero se, mediante a opción
	<opt>matrix</opt>, indicas unha matriz xa definida, este argumento convértese
	en opcional pois, por defecto, debúxase unha gráfica para cada columna
	da matriz especificada.
      </para>

      <para context="cli">
	As gráficas de caixas en GRETL xéranse utilizando a instrución
	<program>gnuplot</program>, e resulta posible especificar con
	maior detalle a gráfica engadindo instrucións adicionais de Gnuplot,
	contornadas entre chaves. Para obter máis detalles, consulta a axuda
	para a instrución <cmdref targ="gnuplot"/>.
      </para>

      <para context="cli">
	En modo interactivo, o resultado amósase inmediatamente. En modo de
	procesamento por lotes, o proceder por defecto consiste en escribir un
	ficheiro de instrucións de Gnuplot no cartafol de traballo do usuario,
	cun nome co padrón <filename>gpttmpN.plt</filename>, comezando con
	N = <lit>01</lit>. Podes xerar as gráficas máis tarde utilizando o
	<program>gnuplot</program> (ou ben <program>wgnuplot</program>
	baixo MS Windows). Podes modificar este comportamento mediante
	o uso da opción <opt>output=</opt><repl>nomeficheiro</repl>. Se
	queres obter máis detalles, consulta a instrución
	<cmdref targ="gnuplot"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Ver/Gráfica de variables indicadas/Gráficas de caixa</menu-path>
    </gui-access>

  </command>

  <command name="break" section="Programming"
    label="Fuxir dun bucle" context="cli">
    <description>
      <para>
	Fuxida dun bucle. Podes utilizar esta instrución só dentro dun bucle; iso
	provoca que a execución de instrucións fuxa do bucle actual (do máis interior,
	se hai varios aniñados). Consulta tamén <cmdref targ="loop"/>, <cmdref targ="continue"/>.
      </para>
    </description>
  </command>

  <command name="bwfilter" section="Transformations" context="gui"
    label="O filtro de Butterworth">

    <description>
      <para>
	O filtro de Butterworth é unha aproximación a un filtro ideal de ondas
	cadradas, que permite pasar con total potencia ás frecuencias que
	superan un certo rango, mentres detén todas as outras.
      </para>
      <para>
	En principio, os valores máis elevados do parámetro de orde
	(<math>n</math>) producen unha aproximación máis precisa ao
	filtro ideal, pero co posible custo de ter inestabilidade
	numérica. O valor <quote>de corte</quote> establece o
	límite entre a banda de paso e a banda de parada; exprésase
	en graos, e debe de ser maior ca 0 e menor ca 180&deg;
	(ou &pi; radiáns, correspondéndose este coa maior frecuencia
	dos datos). Os valores máis pequenos do valor de corte
	producen unha tendencia máis suave.
      </para>
      <para>
	Cando queiras aplicar este filtro, resulta un limiar moi útil que
	revises antes o periodograma da serie que te interesa. Consulta
	o <guideref targ="chap:genr"/> para obter máis detalles.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Filtro/Butterworth</menu-path>
    </gui-access>

  </command>

  <command name="catch" section="Programming"
    label="Capturar fallos" context="cli">
    <usage>
      <syntax><lit>catch </lit><repl>command</repl></syntax>
    </usage>
    <description>
      <para>
	Esta non é unha instrución por si mesma, pero podes utilizala como prefixo na
	maioría das instrucións habituais: o seu efecto é o de previr que remate dun
	guión de instrucións se ocorre un fallo ao executar unha delas. Se aparece un
	fallo, isto rexístrase cun código de fallo interno ao que podes acceder con
	<fncref targ="$error"/> (un valor de 0 indica éxito). Inmediatamente despois
	de utilizar <lit>catch</lit> deberías verificar sempre cal é o valor de
	<lit>$error</lit>, e realizar unha acción axeitada se fallou unha das instrucións.
      </para>
      <para>
	Non podes utilizar a palabra chave <lit>catch</lit> antes de <lit>if</lit>,
	<lit>elif</lit> ou <lit>endif</lit>. Ademais, non debe utilizarse en peticións
	a funcións definidas polo usuario, pois preténdese utilizala só coas
	instrucións de GRETL e coas peticións aos operadores ou funcións
	<quote>internos</quote>. Máis aínda, non podes usar <lit>catch</lit>
	combinada coa asignación mediante <quote>frecha atrás</quote> de modelos
	ou gráficas, a iconas de sesión (consulta o <guideref targ="chap:modes"/>).
      </para>
    </description>
  </command>

  <command name="chow" section="Tests" label="Proba de Chow">

    <usage>
      <altforms>
        <altform><lit>chow</lit> <repl>obs</repl></altform>
        <altform><lit>chow</lit> <repl>dummyvar</repl> <lit>--dummy</lit></altform>
      </altforms>
      <options>
	<option>
	  <flag>--dummy</flag>
	  <effect>Utiliza unha variable ficticia xa existente</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta as estimacións do modelo ampliado</effect>
	</option>
	<option>
	  <flag>--limit-to</flag>
	  <optparm>lista</optparm>
	  <effect>Limita a proba a un subconxunto de regresores</effect>
	</option>
      </options>
      <examples>
        <example>chow 25</example>
        <example>chow 1988:1</example>
	<example>chow muller --dummy</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Esta instrución necesita ben un número de observación (ou unha data,
	se usas datos que as teñan), ou ben o nome dunha variable ficticia.
      </para>

      <para>
	Debe de ir a continuación dunha regresión MCO (OLS). Se indicas un número
	de observación ou unha data, proporciona unha proba respecto á hipótese nula
	de que non existe cambio estrutural no punto de corte indicado. O procedemento
	consiste en crear unha variable ficticia que toma o valor 1 desde o punto
	de corte especificado por <repl>obs</repl> ata o final da mostra, e 0 noutro
	caso, así como xerar termos de interacción entre esa ficticia e os regresores
	orixinais. Se indicas unha ficticia, próbase esa hipótese nula de homoxeneidade
	estrutural respecto desa variable ficticia, e tamén engádense termos de interacción.
	En cada caso execútase unha regresión ampliada incluíndo os termos adicionais.
      </para>
      <para>
	Por defecto, calcúlase un estatístico <math>F</math>, considerando a
	regresión ampliada como o modelo sen restricións e o modelo orixinal
	como o restrinxido. Pero se o modelo orixinal utilizou un estimador
	robusto para a matriz de covarianzas, o estatístico de proba é un de
	Wald con distribución khi-cadrado; co seu valor baseado nun estimador
	robusto da matriz de covarianzas da regresión ampliada.
      </para>
      <para context="cli">
	Podes utilizar a opción <opt>limit-to</opt> para limitar o conxunto de
	termos de interacción coa variable ficticia de corte, a un subconxunto
	dos regresores orixinais. O argumento para esta opción debe de ser
	unha lista xa definida na que todos os seus elementos estean entre os
	regresores orixinais, e non debe de incluír a constante.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas/Proba de Chow</menu-path>
    </gui-access>
  </command>

  <command name="clear" section="Programming" context="cli">
    <usage>
      <options>
	<option>
	  <flag>--dataset</flag>
	  <effect>Elimina só o conxunto de datos</effect>
	</option>
	<option>
	  <flag>--functions</flag>
	  <effect>Elimina as funcións (unicamente)</effect>
	</option>
	<option>
	  <flag>--all</flag>
	  <effect>Elimina todo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Por defecto, esta instrución quita da memoria o conxunto de datos
	vixente (se hai algún), amais de todas as variables gardadas (escalares,
	matrices, etc.). Ten en conta que tamén tes este efecto ao abrir un novo
	conxunto de datos, ou ao utilizar a instrución <cmd>nulldata</cmd>
	para crear un conxunto de datos baleiro; por iso normalmente non
	necesitas facer uso explícito de <cmd>clear</cmd>.
      </para>
      <para>
	Cando indicas a opción <opt>dataset</opt>, entón só se elimina
	o conxunto de datos (máis calquera lista de series definida); outros
	obxectos gardados como matrices, escalares ou feixes, vanse
	conservar.
      </para>
      <para>
	Cando indicas a opción <opt>functions</opt>, entón se elimina da
	memoria calquera función definida polo usuario e calquera función
	definida nos paquetes que teñas cargados. O conxunto de datos e
	outras variables non se ven afectados.
      </para>
      <para>
	Cando indicas a opción <opt>all</opt>, entón a eliminación é completa:
	o conxunto de datos, as variables gardadas de todo tipo, ademais das
	funcións definidas polo usuario e en paquetes.
      </para>
    </description>
  </command>

  <command name="cluster" section="Estimation"
	   label="Estimación con varianza robusta" context="gui">
    <description>
      <para>
	Se escolles a segunda opción, debes de ofrecer o nome dunha
	variable de agrupación. Esta variable debería de ter ao menos
	dous valores diferentes, pero xeralmente deberá de ter un número
	de valores diferentes considerablemente menor que o número de
	observacións que haxa no rango da mostra.
      </para>
      <para>
	O estimador con varianza <quote>robusta por agrupación</quote> divide
	a mostra nun número de subconxuntos ou grupos de acordo co valor
	que tome a variable seleccionada. En lugar do suposto clásico de que
	o termo de perturbación está independente e identicamente distribuído,
	este estimador permite que as varianzas das perturbacións difiran por
	grupos, e tamén permite un grao de dependencia da perturbación dentro
	de cada grupo.
      </para>
    </description>
  </command>

  <command name="coeffsum" section="Tests" label="Suma de coeficientes">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
	</option>
      </options>
      <examples>
        <example>coeffsum xt xt_1 xr_2</example>
	<demos>
	  <demo>restrict.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Esta instrución necesita unha lista de variables, seleccionadas dun conxunto de variables independentes dun modelo dado.
	    </para>
      <para context="gui">
	Calcula a suma dos coeficientes das variables da lista especificada.
	Presenta esta suma xunto co seu desvío padrón e a probabilidade
	asociada ao estatístico para probar a hipótese nula de que a suma é cero.
      </para>
      <para context="cli">
	Debe de ir despois dunha regresión. Calcula a suma dos coeficientes
	das variables do argumento <repl>listavariables</repl>. Presenta esta suma
	xunto co seu desvío padrón e a probabilidade asociada ao
	estatístico para probar a hipótese nula de que a suma é cero.
      </para>
      <para>
	Ten en conta a diferenza entre isto e a instrución <cmdref targ="omit"/>,
	pois esta última te permite probar a hipótese nula de que os
	coeficientes dun subconxunto especificado de variables independentes
	son <emphasis>todos</emphasis> nulos.
	    </para>
      <para context="cli">
	A opción <opt>quiet</opt> pódeche ser útil se o único que
	queres é acceder aos valores de <fncref targ="$test"/> e de
	<fncref targ="$pvalue"/> que se rexistran logo de terminar
	a estimación con éxito.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas/Suma dos coeficientes</menu-path>
    </gui-access>

  </command>

  <command name="coint" section="Tests"
    label="Proba de cointegración de Engle-Granger">

    <usage>
      <arguments>
        <argument>nivel</argument>
        <argument>depvar</argument>
	      <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>Sen constante</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>Con constante e tendencia</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>Con constante máis tendencia linear e cadrada</effect>
	</option>
	<option>
	  <flag>--seasonals</flag>
	  <effect>Con variables ficticias estacionais</effect>
	</option>
	<option>
	  <flag>--skip-df</flag>
	  <effect>Sen probas DF sobre as variables individuais</effect>
	</option>
	<option>
	  <flag>--test-down</flag>
	  <optparm optional="true">criterio</optparm>
	  <effect>Nivel de retardos automático</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta detalles adicionais das regresións</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
	</option>
      </options>
      <examples>
	<example>coint 4 y x1 x2</example>
	<example>coint 0 y x1 x2 --ct --skip-df</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Proba de cointegración de
	<cite key="engle-granger87">Engle&ndash;Granger (1987)</cite>. O proceso
	por defecto consiste en: (1) realizar as probas de Dickey&ndash;Fuller
	respecto á hipótese nula de que cada unha das variables enumeradas ten
	unha raíz unitaria; (2) estimar a regresión de cointegración; e (3) facer
	unha proba DF respecto aos erros que comete a regresión de cointegración.
	Cando se indica a opción <opt>skip-df</opt>, omítese o paso (1).
      </para>
      <para context="cli">
	Se o nivel especificado de retardos é positivo, todas as probas de
	Dickey&ndash;Fuller usan ese nivel pero con este requisito: cando se
	indica a opción <opt>test-down</opt>, o valor indicado tómase como
	un máximo, e o nivel concreto de retardos que se utilizará en cada caso
	obtense probando cara abaixo. Consulta a instrución <cmdref targ="adf"/>
	para obter máis detalles sobre este procedemento.
      </para>
      <para context="cli">
	Por defecto, a regresión de cointegración contén unha constante pero,
	se queres eliminar a constante, engade a opción <opt>nc</opt>.
	Se queres ampliar a lista de termos determinísticos na regresión de
	cointegración con tendencia linear (ou linear e cadrada), engade a
	opción <opt>ct</opt> (ou <opt>ctt</opt>). Estes indicadores de
	opción son mutuamente excluíntes. Tamén tes a posibilidade de engadir
	variables ficticias estacionais (no caso de utilizar datos trimestrais
	ou mensuais).
      </para>

      <para context="gui">
	Proba de cointegración de Engle&ndash;Granger. O proceso por defecto
	consiste en: (1) realizar as probas de Dickey&ndash;Fuller respecto
	á hipótese nula de que cada unha das variables enumeradas ten unha
	raíz unitaria; (2) estimar a regresión de cointegración; e (3) facer
	unha proba DF respecto aos erros que comete a regresión de cointegración.
	Porén, se marcas o cadriño de <quote>Omitir as probas DF iniciais</quote>,
	o primeiro destes pasos omítese.
      </para>
      <para context="gui">
	Se o nivel de retardos (<math>k</math>) é maior ca 0, entón inclúense
	<math>k</math> retardos da variable dependente no lado dereito da
	regresión que se fai para cada proba, agás que marques o cadriño titulado
	<quote>Probar desde o máximo nivel de retardos cara abaixo</quote>. Nese
	caso o nivel de retardos que indicas tómase como máximo, e o nivel concreto
	de retardos que se utilizará, obtense probando cara abaixo. Consulta a
	instrución <cmdref targ="adf"/> para ter máis detalles sobre este procedemento.
      </para>
      <para context="gui">
	Por defecto, a regresión de cointegración contén unha constante. Se
	queres eliminar a constante ou engadir unha tendencia linear (ou
	linear e cadrada) e/ou variables ficticias estacionais, escolle a
	opción adecuada do conxunto que te ofrece o botón de selección na
	caixa de diálogo Cointegración.
      </para>

      <para>
	Os valores <emphasis>P</emphasis> (probabilidades asociadas) desta
	proba baséanse en <cite key="mackinnon96">MacKinnon (1996)</cite>.
	O código relevante inclúese co amable permiso do propio autor.
      </para>
      <para>
	Para obter as probas de cointegración de Søren Johansen,
	consulta <cmdref targ="johansen"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Series temporais multivariantes</menu-path>
    </gui-access>

  </command>

  <command name="compact" section="Dataset" context="gui"
    label="Compactar datos">

    <description>
      <para>
	Cando engades unha serie a un conxunto de datos que é de menor
	frecuencia, é necesario <quote>compactar</quote> a nova serie.
	Por exemplo, terás que compactar unha serie mensual para adaptala
	a un conxunto de datos trimestrais.
      </para>
      <para>
	Ademais, ás veces podes querer compactar un conxunto enteiro de
	datos para que teñan unha frecuencia menor (quizais antes de engadir unha
	variable de baixa frecuencia ao conxunto de datos).
      </para>
      <para>GRETL ofrece 5 opcións para compactar:</para>
      <ilist>
	<li><para>Coa media: O valor que se escribe no conxunto de datos vai ser a
	    media aritmética dos valores das series relevantes. Por exemplo, o valor
	    que se escribe para o primeiro trimestre de 1990 vai ser a media aritmética
	    dos valores para os meses de xaneiro, febreiro e marzo de 1990.
	    </para>
	</li>
	<li><para>Sumando: O valor que se escribe no conxunto de datos vai ser a
	    suma dos valores pertinentes de maior frecuencia. Por exemplo, o valor do
	    primeiro trimestre vai ser a suma dos valores de xaneiro, febreiro e marzo.
	    </para>
	</li>
	<li><para>Valores final-de-período: O valor que se escribe no conxunto de
	    datos é o último valor pertinente dos datos de frecuencia maior. Por
	    exemplo, o primeiro trimestre de 1990 vai ter o valor de marzo de 1990.
	    </para>
	</li>
	<li><para>Valores principio-de-período: O valor que se escribe no conxunto
	    de datos é o primeiro valor pertinente dos datos de frecuencia maior. Por
	    exemplo, o primeiro trimestre de 1990 vai ter o valor de xaneiro de 1990.
	    </para>
	</li>
	<li>
	    <para>
	    <quote>Espallando</quote>: Neste caso, non se perde
	    ningunha información da frecuencia maior; máis ben,
	    espállase nun conxunto de <math>m</math> series, onde
	    <math>m</math> é a razón entre a frecuencia maior e a menor.
	    Cada serie dese conxunto contén os valores dun determinado
	    subperíodo, que se identifica cun sufixo específico.
	    Por exemplo, cando se compacta unha serie <lit>x</lit> de
	    mensual a trimestral, os nomes das series xeradas van ser
	    <lit>x_m01</lit>, <lit>x_m02</lit> e <lit>x_m03</lit>
	    para os tres meses de cada trimestre.
	    </para>
	</li>
      </ilist>

      <para>
	No caso de querer compactar un conxunto de datos enteiro, a elección
	que fas nesta caixa de diálogo determina o método por defecto. Pero se
	estableciches un método para compactar unha variable individual (no
	menú <quote>Variable/Editar atributos</quote>), vaise usar ese método
	en troques do establecido por defecto. Se xa estableciches o método
	para compactar en todas e cada unha das variables, non se te presenta
	a posibilidade de elixir un método por defecto para compactar.
      </para>

    </description>
  </command>

  <command name="continue" section="Programming"
    label="Saltar cara adiante nun bucle" context="cli">
    <description>
      <para>
	Podes usar esta instrución só dentro dun bucle; o seu efecto consiste
	en saltarse os enunciados posteriores que haxa dentro da iteración
	vixente do bucle (máis interno) vixente. Consulta tamén
	<cmdref targ="loop"/>, <cmdref targ="break"/>.
      </para>
    </description>
  </command>

  <command name="controlled" section="Graphs" context="gui"
    label="Gráficas de dispersión con control">

    <description>
      <para>
	Esta instrución require a selección de 3 variables: unha para
	o eixe X, outra para o eixe Y e outra para o que queres controlar
	(chamémoslle Z). A gráfica amosa o Y axustado fronte ao X axustado,
	onde a versión axustada da variable é o erro dunha regresión
	MCO sobre Z.
      </para>
      <para>
	Exemplo: Tes datos de salarios, experiencia laboral e nivel de educación para
	unha mostra de persoas. Queres debuxar os salarios fronte ao nivel de
	educación, controlados pola experiencia. Nese caso, seleccionarías
	salarios para o eixe Y, nivel de educación para o eixe X e experiencia
	como control. A gráfica amosa os salarios fronte ao nivel de educación,
	coas dúas variables <quote>depuradas</quote> do efecto da experiencia.
      </para>
    </description>

  </command>

  <command name="corr" section="Statistics"
    label="Coeficientes de correlación">

    <usage>
      <altforms>
	<altform><lit>corr [</lit> <repl>listavariables</repl> ]</altform>
	<altform><lit>corr --matrix=</lit><repl>nomematriz</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--uniform</flag>
	  <effect>Garante unha mostra uniforme</effect>
	</option>
	<option>
	  <flag>--spearman</flag>
	  <effect>Rho de Spearman</effect>
	</option>
	<option>
	  <flag>--kendall</flag>
	  <effect>Tau de Kendall</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta xerarquías</effect>
	</option>
	<option>
	  <flag>--plot</flag>
	  <optparm>modo-ou-nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	
	<option>
	  <flag>--triangle</flag>
	  <effect>Representa só a metade inferior, mira abaixo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
	</option>
	
      </options>
      <examples>
        <example>corr y x1 x2 x3</example>
	<example>corr ylista --uniform</example>
	<example>corr x y --spearman</example>
	<example>corr --matrix=X --plot=display</example>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Presenta os coeficientes de correlación (correlación produto-momento
	de Pearson) por pares das variables escollidas. O comportamento por
	defecto desta instrución consiste en utilizar tódalas observacións
	dispoñibles para calcular cada coeficiente por parellas de variables,
	pero se marcas o cadriño de opcións, a mostra limítase (se é necesario)
	de xeito que se utiliza o mesmo conxunto de observacións para todos
	os coeficientes. Esta opción é adecuada só cando hai diferentes
	padróns de valores ausentes nas variables utilizadas.
      </para>
    </description>

    <description context="cli">
      <para>
	Por defecto, presenta os coeficientes de correlación (correlación
	produto-momento de Pearson) por pares das variables de 
	<repl>listavariables</repl>, ou de tódalas variables do conxunto de datos
	se non indicas <repl>listavariables</repl>. O comportamento típico desta
	instrución consiste en utilizar tódalas observacións dispoñibles
	para calcular cada coeficiente por parellas de variables, pero cando
	indicas a opción <flag>--uniform</flag>, a mostra limítase (se é
	necesario) de xeito que se utiliza o mesmo conxunto de observacións
	para todos os coeficientes. Esta opción é adecuada só cando hai un
	número diferente de valores ausentes nas variables utilizadas.
      </para>
      <para>
	As opcións <opt>spearman</opt> e <opt>kendall</opt> (que son
	mutuamente excluíntes) permiten calcular, respectivamente, o
	coeficiente rho de correlación por rangos de Spearman e o
	coeficiente tau de correlación por rangos de Kendall en troques
	do coeficiente de Pearson (por defecto). Cando indicas algunha
	destas opcións, <repl>listavariables</repl> debe de conter só dúas variables.
      </para>
      <para>
	Cando se calcula unha correlación por rangos, podes utilizar a
	opción <opt>verbose</opt> para presentar os datos orixinais e
	a súa xerarquía (se non, esta alternativa ignórase).
      </para>
      <para>
	Se <repl>listavariables</repl> contén máis de dúas series e GRETL non
	está en modo de procesamento por lotes, amósase unha gráfica de
	<quote>mapa de calor</quote> da matriz de correlacións. Podes axustar
	isto mediante a opción <opt>plot</opt>, na que os parámetros que se
	admiten son: <lit>none</lit> (para non amosar a gráfica), <lit>display</lit>
	(para presentar a gráfica mesmo cando se estea en modo de procesamento
	por lotes), ou un nome de ficheiro. O efecto de indicar un nome de
	ficheiro é como o descrito para a opción <opt>output</opt> da instrución
	<cmdref targ="gnuplot"/>. Cando activas a representación da gráfica,
	podes utilizar a opción <opt>triangle</opt> para amosar só o mapa de
	calor do triángulo inferior da matriz.
      </para>
      <para>
	Cando indicas unha forma alternativa, utilizando unha matriz xa
	definida en lugar dunha lista de series, as opcións <opt>spearman</opt>
	e <opt>kendall</opt> non están dispoñibles (pero consulta a función
	<fncref targ="npcorr"/>).
      </para>
      <para>
	Podes usar o accesorio <fncref targ="$result"/> para obter as
	correlacións en forma de matriz. Cae na conta de que cando esta
	é a <emphasis>matriz</emphasis> que te interese (e non só os
	coeficientes das parellas), entón no caso de que haxa valores
	ausentes aconséllase utilizar a opción <opt>uniform</opt>. Agás que
	utilices unha mostra común única, non se garante que a matriz de
	correlacións sexa semidefinida positiva, como debera ser por
	construción.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Matriz de correlacións</menu-path>
      <other-access>Xanela principal: Menú emerxente (tras selección múltiple)</other-access>
    </gui-access>

  </command>

  <command name="corrgm" section="Statistics" label="Correlograma">

    <usage>
      <arguments>
        <argument>y</argument>
        <argument optional="true">nivel</argument>
      </arguments>
      <options>
	<option>
	  <flag>--plot</flag>
	  <optparm>modo-ou-nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
	</option>
	<option>
	  <flag>--acf-only</flag>
	  <effect>Omite as autocorrelacións parciais</effect>
	</option>
	<option>
	  <flag>--bartlett</flag>
	  <effect>Utiliza os erros padrón de Bartlett</effect>
	</option>
      </options>
      <examples>
        <example>corrgm x 12</example>
        <example>corrgm GDP 12 --acf-only</example>
      </examples>
    </usage>

    <description>
      <para context="notex">
	Amosa e/ou representa os valores da función de autocorrelación (FAC)
	da serie <repl>y</repl>, que pode especificarse polo seu nome
	ou o seu número. Os valores defínense como
	&rgr;(<math>u</math><sub>t</sub>, <math>u</math><sub>t-s</sub>) onde
	<math>u</math><sub>t</sub> é a <math>t</math>-ésima observación
	da variable <math>u</math>, e <math>s</math> denota o número de
	retardos.
      </para>
      <para context="tex">
	Amosa e/ou representa os valores da función de autocorrelación (FAC)
	da serie <repl>y</repl>, que pode especificarse polo seu nome
	ou seu número. Os valores defínense como
	$\hat{\rho}(u_t, u_{t-s})$, onde $u_t$ é a $t$-ésima observación
	da variable $u$ e $s$ denota o número de
	retardos.
      </para>
      <para context="cli">
	Agás que indiques a opción <opt>acf-only</opt>, tamén se amosan os
	coeficientes da función de autocorrelación parcial (FACP, calculados
	utilizando o algoritmo de Durbin&ndash;Levinson), e que están libres
	dos efectos dos retardos intermedios.
      </para>
      <para context="gui">
	Por defecto, tamén se amosan os coeficientes da función de autocorrelación
	parcial (FACP, calculados usando o algoritmo de Durbin&ndash;Levinson),
	e que están libres dos efectos dos retardos intermedios. Se o desexas,
	podes desactivar isto.
      </para>
      <para context="cli">
	Utilízanse asteriscos para indicar a significación estatística das
	autocorrelacións individuais. Por defecto, isto avalíase utilizando un
	desvío padrón igual ao cociente entre 1 e a raíz cadrada do tamaño da
	mostra; pero cando indicas a opción <opt>bartlett</opt>, entón utilízanse
	os erros padrón de Bartlett para a FAC; mira abaixo para máis detalles.
	Se resulta aplicable, esta opción tamén determina a banda de confianza
	que se debuxa na gráfica da FAC. Ademais, preséntase o estatístico
	<math>Q</math> de Ljung&ndash;Box, que proba a hipótese nula de que a
	serie é <quote>ruído branco</quote> ata o nivel de retardo indicado.
      </para>
      <para context="gui">
	Utilízanse asteriscos para indicar a significación estatística das
	autocorrelacións individuais. Por defecto, isto avalíase utilizando un
	desvío padrón igual ao cociente entre 1 e a raíz cadrada do tamaño da
	mostra; pero tes a opción de utilizar os erros padrón de Bartlett para a
	FAC; mira abaixo para máis detalles. Esta opción tamén determina a
	banda de confianza que se debuxa na gráfica da FAC. Ademais, preséntase
	o estatístico <math>Q</math> de Ljung&ndash;Box, que proba a hipótese
	nula de que a serie é <quote>ruído branco</quote> ata o nivel de
	retardo indicado.
      </para>
      <para context="cli">
	Se especificas un valor para <repl>nivel</repl>, a lonxitude
	do correlograma limítase ata ese número de retardos como
	máximo; se non, a longura determínase automaticamente
	como unha función da frecuencia dos datos e do número de
	observacións.
      </para>
      <subhead>Erros padrón de Bartlett</subhead>
      <para>
	Por favor, cae na conta de que neste contexto os erros padrón de Bartlett
	non son exactamente unha variante robusta dos predeterminados. Os erros
	padrón predeterminados refírense á hipótese nula de que a serie en
	cuestión provén dun proceso de tipo ruído branco; en liñas xerais, isto
	non se rexeitará cun nivel do 5 por cento, cando non haxa máis dun 5 por
	cento dos valores da FAC que excedan os límites establecidos en 1.96
	veces o erro padrón. Porén, os valores de Bartlett están asociados á
	hipótese de que a serie provén dun proceso de medias móbiles. En concreto,
	se os valores da FAC caen dentro dos límites de Bartlett para retardos
	maiores que <math>k</math>, nos equivocamos ao rexeitar a hipótese
	nula de que <math>y</math> é MA(<math>k</math>). Consulta o capítulo 7
	de <cite key="brockwell-davis87">Brockwell e Davis (1987)</cite> para
	obter máis detalles sobre este punto.
      </para>
      <subhead context="cli">Representación gráfica</subhead>
      <para context="cli">
	Por defecto, se GRETL non está en modo de procesamento por lotes,
	xérase unha gráfica do correlograma. Isto podes axustalo mediante a
	opción <opt>plot</opt> na que os parámetros que se admiten son:
	<lit>none</lit> (para non amosar a gráfica), <lit>display</lit> (para
	presentar unha gráfica mesmo en modo de procesamento por lotes);
	ou un nome de ficheiro. O efecto de indicar un nome de ficheiro é
	como o descrito para a opción <opt>output</opt> da instrución
	<cmdref targ="gnuplot"/>.
      </para>
      <subhead context="cli">Accesorios</subhead>
      <para context="cli">
	Cando se complete con éxito esta instrución, podes usar os accesorios
	<fncref targ="$test"/> e <fncref targ="$pvalue"/> para recuperar o
	estatístico <math>Q</math> e a súa Probabilidade Asociada (valor
	<math>P</math>), avaliados para o retardo de nivel maior. Observa
	que se unicamente queres esta proba, podes utilizar en troques a
	función <fncref targ="ljungbox"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Correlograma</menu-path>
      <other-access>Xanela principal: Menú emerxente (selección única)</other-access>
    </gui-access>

  </command>

  <command name="count-model" section="Estimation" context="gui"
    label="Modelos para datos de reconto">

    <description>
      <para>
	Tómase a variable dependente para representar un reconto do número de
	veces que ocorre un suceso dalgún tipo, e debe de ter só valores enteiros
	non negativos. Por defecto, utilízase a distribución de Poisson, pero o
	botón da lista despregable dáche a opción de utilizar a distribución
	Binomial Negativa. (A variante NegBin 2 utilízase habitualmente en
	Econometría, pero tamén está dispoñible a menos utilizada NegBin 1.)
      </para>
      <para>
	Opcionalmente, podes engadir unha variable de <quote>exposición</quote>
	á especificación. Esta é unha variable de escala, cuxo logaritmo se engade
	á función de regresión linear (implicitamente, cun coeficiente de 1). Isto
	é lóxico se agardas que o número de veces que ocorra o suceso en cuestión
	sexa proporcional a algún factor coñecido (supoñendo o demais constante).
	Por exemplo, se asumes que o número de accidentes de tráfico é proporcional
	ao volume de tráfico (co demais constante), nese caso podes especificar
	o volume de tráfico como unha variable de <quote>exposición</quote> nun
	modelo para o cociente dos accidentes. A variable de exposición debe de ser
	estritamente positiva.
      </para>
      <para>
	Por defecto, os desvíos padrón calcúlanse utilizando unha aproximación
	numérica á matriz Hessiana na converxencia. Pero se marcas o cadriño de
	'Desvíos padrón robustos', entón calcúlanse os Desvíos Padrón Case
	Máximo Verosímiles (CMV ou QML), utilizando un <quote>emparedado</quote>
	entre a inversa da matriz Hessiana e o produto externo do vector gradiente.
      </para>
    </description>
  </command>

  <command name="curve" section="Graphs" label="Debuxar unha curva"
    context="gui">

    <description>
      <para>
	Esta caixa de diálogo te permite xerar unha gráfica de Gnuplot
	especificando unha fórmula, que deberá ser unha expresión que
	admita Gnuplot. Utiliza <lit>x</lit> para denotar a variable no
	eixe 'x'. Ten en conta que Gnuplot utiliza <lit>**</lit> para
	preceder a un expoñente (elevar á potencia) e que o carácter
	decimal debe de indicarse con <quote>.</quote>. Exemplos:
      </para>
      <code>
	10+0.35*x
	100+5.3*x-0.12*x**2
	sin(x)
	exp(sqrt(pi*x))
      </code>
      <para>
	Para poñer unha liña adicional nunha gráfica xerada deste xeito, preme
	co botón dereito do rato na gráfica e escolle <quote>Editar</quote>,
	selecciona a lapela <quote>Liñas</quote> no cadro de diálogo de
	edición de gráficas, e utiliza o botón <quote>Engadir liña</quote>.
      </para>
    </description>
  </command>

  <command name="cusum" section="Tests" label="Proba CUSUM">

    <usage>
      <options>
	<option>
	  <flag>--squares</flag>
	  <effect>Realiza a proba CUSUMSQ</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Só presenta a proba de Harvey&ndash;Collier</effect>
	</option>
	<option>
	  <flag>--plot</flag>
	  <optparm>Modo-ou-nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Debe de ir despois da estimación dun modelo mediante MCO. Te
	permite levar adiante a proba CUSUM de estabilidade dos parámetros
	(ou a proba CUSUMSQ se indicas a opción <opt>squares</opt>).
	Vas obter unha serie cos erros de predición adiantados un
	paso, executando unha serie de regresións. Na primeira
	regresión se utilizan as primeiras <math>k</math> observacións
	e permíteche xerar a predición da variable dependente na
	observación <math>k</math> + 1; na segunda se utilizan as
	primeiras <math>k</math> + 1 observacións e xérase unha
	predición para a observación <math>k</math> + 2, e así
	sucesivamente (onde <math>k</math> é o número de parámetros
	do modelo orixinal).
      </para>
      <para>
	Preséntase a suma acumulada dos erros de predición escalados
	(ou os cadrados destes erros). A hipótese nula de estabilidade
	dos parámetros rexéitase cun nivel de significación do 5 por
	cento cando a suma acumulada se afasta da banda de confianza
	do 95 por cento.
      </para>
      <para>
	No caso da proba CUSUM, tamén se presenta o estatístico
	<math>t</math> de Harvey&ndash;Collier para probar a
	hipótese nula de estabilidade dos parámetros. Consulta o
	libro <book>Econometric Analysis</book> de Greene para
	obter máis detalles. Para a proba CUSUMSQ, calcúlase a banda
	de confianza do 95 por cento utilizando o algoritmo indicado
	en <cite key="edgerton94">Edgerton e Wells (1994)</cite>.
      </para>
      <para>
	Por defecto, cando GRETL non está en modo de procesamento por lotes,
	amósase unha gráfica coa serie acumulada e o intervalo de confianza.
	Podes axustar isto mediante a opción <opt>plot</opt>. Os parámetros
	admisibles para esta opción son <lit>none</lit> (para omitir a gráfica);
	<lit>display</lit> (para visualizar unha gráfica mesmo estando en modo
	de procesamento por lotes); ou o nome dun ficheiro. O efecto de
	proporcionar o nome dun ficheiro é como o descrito para a opción
	<opt>output</opt> da instrución <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas/Proba CUSUM(SQ)</menu-path>
    </gui-access>

  </command>

  <command name="daily-purge" section="Dataset"
	   label="Depurar datos diarios" context="gui">
    <description>
      <para>
	Cando un conxunto de datos diarios está nominalmente nun
	calendario de 7 días, pero de feito unicamente inclúe datos de
	días laborables, recoméndase que elimines as filas en branco
	dos días do fin de semana, pasando así a un calendario de 5 días.
      </para>
      <para>
	Cando un conxunto de datos de días laborables contén un número
	relativamente pequeno de filas sen datos (presuntamente debido a
	festivos comerciais) poderías querer eliminar esas filas. Isto
	significa, de feito, tratar os valores ausentes por festividades como non
	existentes, máis ca como verdadeiramente <quote>ausentes</quote>, e
	tratar os días comerciais como se formasen unha serie temporal continua.
      </para>
      <para>
	Ten en conta que se colles calquera destas opcións, aínda así
	GRETL vai preservar a información da data, e vaiche ser posible
	reconstruír o conxunto de datos de calendario completo máis
	tarde, se o necesitas. Podes facer isto utilizando a instrución
	<cmdref targ="dataset"/> coa opción <lit>pad-daily</lit>.
      </para>
    </description>
  </command>

  <command name="data" section="Dataset"
    label="Importar dun banco de datos" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--compact</flag>
	  <optparm>método</optparm>
	  <effect>Especifica o método para compactar</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non amosa os resultados agás no caso de fallo</effect>
	</option>
	<option>
	  <flag>--name</flag>
	  <optparm>identificador</optparm>
	  <effect>Renomea series importadas</effect>
	</option>
	<option>
	  <flag>--odbc</flag>
	  <effect>Importa dun banco de datos ODBC</effect>
	</option>
	<option>
	  <flag>--no-align</flag>
	  <effect>Específico para ODBC, mira abaixo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Le as variables de <repl>listavariables</repl> dun ficheiro de banco
	de datos (propio de GRETL, RATS 4.0 ou PcGive) que debe de abrirse
	previamente utilizando a instrución <cmdref targ="open"/>. Podes usar
	a instrución <lit>data</lit> para importar series de DB.NOMICS ou dun
	banco de datos ODBC; para obter detalles sobre estas variantes
	consulta <mnu targ="gretlDBN">gretl + DB.NOMICS</mnu> ou o
	<guideref targ="chap:odbc"/>, respectivamente.
      </para>
      <para>
  Podes establecer a frecuencia dos datos e o rango da mostra mediante
  as instrucións <cmdref targ="setobs"/> e <cmdref targ="smpl"/>, antes
  de utilizar esta instrución. Este é un exemplo:
	    </para>
      <code>
	open fedstl.bin
	setobs 12 2000:01
	smpl ; 2019:12
	data unrate cpiaucsl
      </code>
      <para>
	As instrucións de arriba abren o banco de datos (que se ofrece con
	GRETL) chamado <filename>fedstl.bin</filename>, determinan que os
	datos son mensuais, que comezan en xaneiro de 2000, que a mostra
	finaliza en decembro de 2019, e que se importan as series denominadas
	<lit>unrate</lit> (taxa de desemprego) e <lit>cpiaucsl</lit> (IPC de todos).
	    </para>
      <para>
	Se non especificas <lit>setobs</lit> e <lit>smpl</lit> deste xeito,
	a frecuencia dos datos e o rango da mostra establécense utilizando
	a primeira variable que se le do banco de datos.
      </para>
      <para>
	Se as series que se van ler son de frecuencia maior que o conxunto de datos de traballo, podes especificar un método para compactar como aquí debaixo:
	    </para>
      <code>
	data LHUR PUNEW --compact=average
      </code>
      <para>
	Os cinco métodos que permiten compactar dos que dispós son
	estes: <quote>average</quote> (toma a media das observacións
	de alta frecuencia), <quote>last</quote> (utiliza a última
	observación), <quote>first</quote>, <quote>sum</quote> e
	<quote>spread</quote>, pero se non especificas ningún método,
	por defecto utilízase a media. O método <quote>spread</quote>
	é especial pois con el non se perde ningunha información, senón
	que máis ben esta espállase entre varias series, unha por cada
	subperíodo. Así con ela cando engades, por exemplo, unha serie
	mensual a un conxunto de datos trimestrais, xéranse 3 series
	(unha por cada mes do trimestre) cuxos nomes conteñen os sufixos
	<lit>m01</lit>, <lit>m02</lit> e <lit>m03</lit>.
      </para>
      <para>
	Cando as series que se len son de frecuencia <emphasis>menor</emphasis>
	que a do conxunto de datos de traballo, os valores dos datos engadidos
	sinxelamente repítense segundo se necesite; pero cae na conta de
	que podes utilizar a función <fncref targ="tdisagg"/> para solicitar
	que se faga unha distribución ou unha interpolación
	(<quote>desagregación temporal </quote>).
      </para>
      <para>
	No caso de bancos de datos propios (unicamente) de GRETL, podes
	utilizar os caracteres <quote>xenéricos</quote>, <lit>*</lit>
	e <lit>?</lit> en <repl>listavariables</repl> para importar series que
	coincidan co padrón indicado. Por exemplo, a seguinte expresión
	vai importar todas as series do banco de datos cuxos nomes
	comecen por <lit>cpi</lit>:
      </para>
      <code>
	data cpi*
      </code>
      <para>
	Podes usar a opción <opt>name</opt> para determinar un nome
	distinto do nome orixinal no banco de datos, para a seire importada.
	O parámetro debe de ser un identificador válido de GRETL. Esta opción
	restrínxese ao caso no que especificas unha única serie a
	importar.
      </para>
      <para>
	A opción <opt>no-align</opt> aplícase só para importar series mediante
	ODBC. Por defecto, necesítase que a solicitude ODBC devolva información
	que indique a GRETL en que filas do conxunto de datos situar os datos que
	se reciben (ou que o número de valores que se reciben coincida, cando
	menos, ben coa longura do conxunto de datos ou ben coa longura do
	rango da mostra vixente). Determinando a opción <opt>no-align</opt>
	reláxase este requisito: se non se cumpren estas condicións mencionadas,
	os valores que se reciben sitúanse simplemente de xeito consecutivo,
	comezando na primeira fila do conxunto de datos. Se o número deses
	valores é menor que o de filas no conxunto de datos, as filas do final
	énchense con NAs; se o número é maior que o de filas, se descartan
	os valores extra. Para obter máis información sobre como importar con
	ODBC, consulta o <guideref targ="chap:odbc"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ficheiro/Bancos de datos</menu-path>
    </gui-access>

  </command>

  <command name="data-files" section="Programming"
	   label="Ficheiros de datos" context="gui">
    <description>
      <para>
	Este diálogo te permite especificar ficheiros adicionais para
	incluír cun paquete de funcións. Se inclúes ese material, iso
	implica que o paquete vai tomar a forma dun ficheiro zip. Cando
	GRETL vaia a crear o ficheiro zip para ti, todos os ficheiros
	aos que se fai referencia aquí deben de estar presentes no mesmo
	cartafol ca o ficheiro gfn. Os subcartafoles poden indicarse
	igual que ficheiros normais e, nese caso, iso implica que todo
	o seu contido deberá de incluírse no paquete zip.
      </para>
      <para>
	Hai dúas intencións principais para usar este servizo. En primeiro
	lugar, podes incluír un ficheiro de datos para utilizar co guión de
	mostra do paquete, se non é adecuado ningún dos ficheiros de datos
	ofrecidos coa distribución de GRETL. Neste caso, os datos deben de
	estar no formato propio de GRETL (<lit>gdt</lit> ou <lit>gdtb</lit>
	binario). Segundo, se o teu paquete require unha matriz grande (por
	exemplo, que conteña todos os puntos críticos dun estatístico de
	proba especial), poderá ser más conveniente incluíla como un ficheiro
	matricial de GRETL (<lit>mat</lit>) que integrar a matriz mediante
	múltiples expresións da linguaxe HANSL do GRETL.
      </para>
      <para>
	Para acceder a un ficheiro empaquetado <lit>gdt</lit> ou
	<lit>gdtb</lit> desde un guión de mostra, utiliza a opción
	<opt>frompkg</opt> coa instrución <lit>open</lit>, indicando
	o nome do paquete como se fora un parámetro, como en
      </para>
      <code>
	open almon.gdt --frompkg=almonreg
      </code>
      <para>
	Para ler un ficheiro matricial empaquetado desde dentro do teu código de
	paquete, utiliza a variable de cadea incorporada <lit>$pkgdir</lit>, como en
      </para>
      <code>
	string mname = sprintf("%s/A.mat", $pkgdir)
	matrix A = mread(mname)
      </code>
      <para>
	(Ten en conta que nas rutas de MS Windows funcionará correctamente
	<quote><lit>/</lit></quote> como separador.)
      </para>
    </description>
  </command>

  <command name="dataset" section="Dataset"
    label="Manipular o conxunto de datos" context="cli">

    <usage>
      <arguments>
        <argument>chave</argument>
	      <argument>parámetros</argument>
      </arguments>
      <options>
	<option>
	  <flag>--panel-time</flag>
	  <effect>Mira abaixo 'addobs'</effect>
	</option>
      </options>
      <examples>
        <example>dataset addobs 24</example>
	<example>dataset addobs 2 --panel-time</example>
	<example>dataset insobs 10</example>
        <example>dataset compact 1</example>
        <example>dataset compact 4 last</example>
        <example>dataset expand</example>
        <example>dataset transpose</example>
	<example>dataset sortby x1</example>
	<example>dataset resample 500</example>
	<example>dataset renumber x 4</example>
	<example>dataset pad-daily 7</example>
        <example>dataset unpad-daily</example>
	<example>dataset clear</example>
      </examples>
    </usage>

    <description>
      <para>
	Realiza diversas operacións no conxunto de datos como un todo,
	dependendo da <repl>chave</repl> indicada, que debe de
	ser: <lit>addobs</lit>, <lit>insobs</lit>, <lit>clear</lit>,
	<lit>compact</lit>, <lit>expand</lit>, <lit>transpose</lit>,
	<lit>sortby</lit>, <lit>dsortby</lit>, <lit>resample</lit>,
	<lit>renumber</lit>, <lit>pad-daily</lit> ou <lit>unpad-daily</lit>.
	Advertencia: Coa excepción da opción <lit>clear</lit>, estas accións
	non están dispoñibles mentres teñas unha submostra do conxunto de
	datos, escollida por selección dos casos segundo algún criterio
	booleano.
      </para>
      <para>
	<lit>addobs</lit>: Debe de estar seguido dun enteiro positivo, digamos
	<math>n</math>. Engade as <math>n</math> observacións adicionais ao
	final do conxunto de datos de traballo. Isto está pensado principalmente
	co propósito de facer predicións. Os valores da maioría das variables
	ao longo do rango engadido vanse estipular como ausentes, pero certas
	variables determinísticas se recoñecen, e o seu contido esténdese ao
	rango engadido; en concreto, as variables con tendencia linear simple
	e as variables ficticias periódicas. Se o conxunto de datos ten a
	estrutura dun panel, a acción predeterminada consiste en engadir
	<math>n</math> unidades de sección cruzada ao panel; pero se indicas
	a opción <opt>panel-time</opt>, o efecto consiste en engadir
	<math>n</math> observacións ás series temporais para cada unidade.
      </para>
      <para>
	<lit>insobs</lit>: Debe de estar seguido dun enteiro positivo (non
	maior ca o número vixente de observacións) que especifica a posición
	na que se insire unha única observación. Todos os datos posteriores
	desprázanse un lugar e o conxunto de datos amplíase nunha observación.
	Agás á constante, dánselle valores ausentes a todas as variables na
	nova observación. Esta acción non está dispoñible para conxuntos de
	datos de panel.
      </para>
      <para>
	<lit>clear</lit>: Non necesita ningún parámetro. Libra todos os datos
	vixentes, devolvendo o GRETL a o seu estado <quote>baleiro</quote> inicial.
      </para>
      <para>
	<lit>compact</lit>: Esta acción só está dispoñible para datos de
	series temporais, e compacta todas as series do conxunto de datos a
	unha frecuencia menor. Require un parámetro, un enteiro positivo que
	represente a nova frecuencia dos datos. En xeral, debe de ser menor
	que a frecuencia vixente (por exemplo, indicar un valor de 4 cando
	a frecuencia vixente é 12, indica que se van compactar os datos de
	mensuais a trimestrais). A única excepción é unha nova frecuencia de
	52 (semanal) cando os datos vixentes sexan diarios (frecuencia 5, 6 ou 7).
	Tamén podes indicar un segundo parámetro, en concreto un de entre
	<lit>sum</lit>, <lit>first</lit>, <lit>last</lit> ou <lit>spread</lit>.
	Estes permiten especificar que se vai compactar utilizando, respectivamente:
	a suma dos valores de frecuencia maior, o valor de inicio-de-período,
	o valor de fin-de-período, ou espallando os valores de frecuencia maior
	entre varias series (unha por cada subperíodo), pois por defecto faise
	usando a media.
      </para>
      <para>
	No caso de querer compactar (unicamente) de frecuencia diaria a
	semanal, tes dispoñibles as dúas opcións especiais <opt>repday</opt>
	e <opt>weekstart</opt>. A primeira delas te permite seleccionar un
	<quote>día representativo</quote> da semana que sirva como valor
	semanal. O parámetro desta opción deberá consistir nun número enteiro
	entre 0 (Domingo) e 6 (Sábado), incluídos. Por exemplo, indicando
	<opt>--repday=3</opt> estarás elixindo o valor dos Mércores como
	representativo do valor semanal. Se non indicas a opción <opt>repday</opt>,
	necesítase saber en que día da semana pretendes comezar, para aliñar
	os datos correctamente. Con datos con frecuencia de 5 ou de 6 días,
	sempre se toma o Luns, pero con datos de 7 días tes a posibilidade
	de elixir entre as opcións <opt>weekstart=0</opt> (Domingo) e
	<opt>weekstart=1</opt> (Luns), na que se toma o Luns como a
	predeterminada.
      </para>
      <para>
	<lit>expand</lit>: Esta acción só está dispoñible para datos de
	series temporais anuais ou trimestrais, pois os datos anuais pódense
	estender a trimestrais ou mensuais, e os datos trimestrais a mensuais.
	Todas as series do conxunto de datos énchense coa nova frecuencia
	repetindo os valores existentes. Se o banco de datos orixinal é anual,
	a extensión por defecto é a trimestral, pero a función <lit>expand</lit>
	pode estar seguida de <lit>12</lit> para solicitar que sexa a mensual.
	Consulta a función <fncref targ="tdisagg"/> para obter medios máis
	sofisticados de converter os datos a unha frecuencia maior.
      </para>
      <para>
	<lit>transpose</lit>: Non necesita ningún parámetro adicional.
	Traspón o conxunto vixente de datos, é dicir, cada observación
	(fila) do conxunto vixente de datos vaise tratar como unha variable
	(columna), e cada variable como unha observación. Esta acción pode
	serte útil se os datos se leron dalgunha orixe externa na que as filas
	da táboa de datos representan variables.
      </para>
      <para>
	<lit>sortby</lit>: Requírese o nome dunha única serie ou lista.
	Cando indicas unha serie, as observacións de todas as variables do
	conxunto de datos vólvense ordenar segundo os valores ascendentes
	da serie especificada. Cando indicas unha lista, a reordenación faise
	xerarquicamente: se hai observacións empatadas ao reordenarse
	segundo a primeira variable chave, entón a segunda chave utilízase
	para rachar o empate, e así sucesivamente ata que se rache o empate
	ou se esgoten as chaves. Cae na conta de que esta acción está dispoñible
	só para datos sen data.
      </para>
      <para>
	<lit>dsortby</lit>: Funciona como <lit>sortby</lit> agás que a
	reordenación faise segundo os valores descendentes da serie chave.
      </para>
      <para>
	<lit>resample</lit>: Constrúe un novo conxunto de datos mediante
	mostraxe aleatoria (con substitución) das filas do conxunto
	vixente de datos, e require que indiques como argumento o
	número concreto de filas que queres incluír. Este pode ser
	menor, igual ou maior ca o número de observacións dos datos
	orixinais. Podes recuperar o conxunto orixinal de datos
	mediante a instrución <lit>smpl full</lit>.
      </para>
      <para>
	<lit>renumber</lit>: Require o nome dunha serie xa existente
	seguida dun número enteiro entre 1 e o número de series do
	conxunto de datos menos 1. Move a serie especificada á
	posición indicada do conxunto de datos, volvendo numerar
	as demais series conforme a isto. (A posición 0 ocúpase coa
	constante, que non pode moverse.)
      </para>
      <para>
	<lit>pad-daily</lit>: Válido só cando o conxunto vixente de datos
	contén datos con datas diarias cun calendario incompleto. Ten como
	efecto encher os datos nun calendario completo inserindo filas en
	branco (é dicir, filas que non conteñen nada agás <lit>NA</lit>s).
	Esta opción require un número enteiro como parámetro, concretamente
	o número de días por semana (5, 6 ou 7), e que debe de ser maior ou
	igual que a frecuencia vixente dos datos. Cando se completa con
	éxito, o calendario de datos vai estar <quote>completo</quote> en
	relación a este valor. Por exemplo, se días-por-semana é igual a 5,
	entón represéntanse tódolos días laborables, haxa ou non algún dato
	dispoñible para eses días.
      </para>
      <para>
	<lit>unpad-daily</lit>: Válido só cando o conxunto vixente de datos
	contén datos con datas diarias, en cuxo caso isto realiza a operación
	inversa a <lit>pad-daily</lit>. Isto é, elimínase calquera fila que
	non conteña <lit>NA</lit>s, mentres que se conserva a propiedade de
	series temporais do conxunto de datos xunto coas datas das observacións
	individuais.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos</menu-path>
    </gui-access>

  </command>

  <command name="datasort" section="Dataset" context="gui"
    label="Ordenar os datos">

    <description>
      <para>
	A variable escollida utilízase como chave de ordenación para
	todo o conxunto de datos. Vólvense ordenar as observacións
	de todas as variables segundo os valores en orde ascendente
	da variable chave, ou segundo os valores en orde decrecente
	se escolles a opción <quote>Descendente</quote>.
      </para>
    </description>
  </command>

  <command name="dbnomics" section="Utilities" label="Acceso a dbnomics" context="gui">
    <description>
      <para>
	Este diálogo te permite inspeccionar e descargar series de datos
	do servidor 'dbnomics'. Podes visitar
	<url>https://db.nomics.world/</url> para obter os
	identificadores ou códigos das series de interese. Estes teñen a
	forma de 'tripletes' (tres termos separados con barras). Por
	exemplo
      </para>
      <code>
	ECB/IRS/M.IT.L.L40.CI.0000.EUR.N.Z
      </code>
      <para>
	O primeiro termo identifica un provedor de datos, aquí <lit>ECB</lit>
	(o Banco Central Europeo). O segundo identifica un banco de datos,
	aquí <lit>IRS</lit> (de estatísticas de tipos de interese). E o terceiro
	especifica unha serie concreta do banco de datos, neste caso
	un tipo de interese italiano de 10 anos.
      </para>
      <para>
	Se introduces un identificador de serie e premes <quote>OK</quote>,
	isto vai facer emerxer unha xanela que amosará información sobre a serie.
	Entón, podes utilizar os botóns da barra de ferramentas desa xanela
	para presentar os valores da serie, debuxar a serie, ou engadila ao banco
	de datos vixente (asumindo que a serie é axeitada para o banco de
	datos).
      </para>
    </description>
  </command>

  <command name="delete" section="Dataset"
    label="Eliminar variables" context="cli">

    <usage>
      <altforms>
        <altform><lit>delete</lit> <repl>listavariables</repl></altform>
        <altform><lit>delete</lit> <repl>nomevar</repl></altform>
	      <altform><lit>delete --type=</lit><repl>tipo</repl></altform>
	      <altform><lit>delete</lit> <repl>nomepaquete</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--db</flag>
	  <effect>Elimina series do banco de datos</effect>
	</option>
	<option>
	  <flag>--force</flag>
	  <effect>Mira abaixo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Esta instrución é un destrutor. Deberías de utilizala con precaución
	pois non se pide confirmación.
      </para>
      <para>
	Na primeira variante de arriba, <repl>listavariables</repl> é unha lista de
	series, indicada polo seu nome ou número ID. Ten en conta que cando
	eliminas series, vólvese a numerar calquera serie cuxo número ID sexa
	maior que os das series da lista que se elimina. Se indicas a opción
	<opt>db</opt>, as series da lista non se eliminan con esta instrución
	do conxunto vixente de datos, pero si do banco de datos de GRETL
	(supoñendo que se abriu un deles e que o usuario ten permisos para
	escribir no ficheiro en cuestión). Consulta tamén a instrución
	<cmdref targ="open"/>.
      </para>
      <para>
	Na segunda variante, podes indicar o nome dun escalar, dunha matriz,
	dunha cadea de texto ou dun feixe, para que se elimine. A opción
	<opt>db</opt> non pode aplicarse neste caso. Ten en conta que non
	debes de mesturar series e variables de diferentes tipos nunha mesma
	chamada a <lit>delete</lit>.
      </para>
      <para>
	Na terceira variante, a opción <opt>type</opt> debes de
	acompañala con algún dos seguintes nomes de tipos: <lit>matrix</lit>,
	<lit>bundle</lit>, <lit>string</lit>, <lit>list</lit>, <lit>scalar</lit>
	ou <lit>array</lit>; e o seu efecto consiste en eliminar tódalas
	variables do tipo indicado. Neste caso non debes de indicar ningún
	argumento que non sexa a opción.
      </para>
      <para>
	Podes usar a cuarta variante para descargar un paquete de funcións.
	Neste caso, debes de proporcionar o sufixo <lit>.gfn</lit> como
	en
      </para>
      <code>
	delete somepkg.gfn
      </code>
      <para>
	Cae na conta de que isto non elimina o ficheiro de paquete; unicamente
	descarga o paquete da memoria.
      </para>

      <subhead>Eliminar variables nun bucle</subhead>
      <para>
	En xeral, non se permite eliminar variables no contexto dun bucle,
	posto que isto pode supor un risco para a integridade do código
	do propio bucle. Porén, se tes total confianza en que a eliminación
	dunha determinada variable vai ser inocua, podes anular esta
	prohibición engadindo a opción <opt>force</opt> á instrución
	<lit>delete</lit>.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela principal: Menú emerxente (selección única)</menu-path>
    </gui-access>

  </command>

  <command name="density" section="Statistics" context="gui"
    label="Estimación da densidade Kernel">

    <description>
      <para>
	A estimación da densidade Kernel realízase definindo
	un conxunto de puntos de referencia separados de xeito uniforme
	sobre un rango apropiado relacionado co rango dos datos, e atribuíndo
	unha densidade a cada punto de referencia baseada nas observacións
	presentes na súa contorna.
      </para>
      <para>
	Se te ofrece a posibilidade de utilizar un Kernel Gaussiano
	(a densidade Normal estándar) ou o Kernel de Epanechnikov.
	Por defecto, o largo de banda é o suxerido como norma xeral por
	<cite key="silverman86">Silverman (1986)</cite>.
	Podes ampliar ou reducir o largo de banda mediante o
	<quote>Factor de axuste do ancho de banda</quote>, posto que
	o largo real de banda que se vai utilizar entón, obtense
	multiplicando o valor de Silverman polo factor de axuste.
      </para>
      <para>
	Para ver unha boa discusión introdutoria da estimación da densidade
	do kernel, consulta o capítulo 15 do libro de Davidson e MacKinnon
	<book>Econometric Theory and Methods</book>.
      </para>
    </description>

  </command>

  <command name="dfgls" section="Tests" context="gui"
    label="A proba ADF-MCX">

    <description>
      <para>
	A proba ADF-MCX é unha variante da proba de raíz unitaria de
	Dickey&ndash;Fuller, para o caso no que se asume que a variable
	que se comproba ten unha media non nula ou amosa unha tendencia
	linear. A diferenza é que a detracción da media ou da tendencia
	da variable faise utilizando o procedemento MCX (GLS) suxerido
	por <cite key="ERS96">Elliott, Rothenberg e Stock (1996)</cite>.
	Isto proporciona unha proba con maior potencia que o enfoque
	estándar de Dickey&ndash;Fuller.
      </para>
      <para>
	Cando se proba cara abaixo, a partir dun nivel máximo de retardos que
	indiques, os criterios AIC e BIC <quote>modificados</quote> son como
	se describe en <cite key="ng-perron01">Ng e Perron (2001)</cite>,
	con ou sen a corrección proposta por
	<cite key="perron-qu07">Perron e Qu (2007)</cite>. Esta corrección
	implica utilizar datos coa tendencia detraída con MCO na etapa de
	determinación do nivel de retardos óptimo, e logo detraer a tendencia
	con MCX na proba final de raíz unitaria.
      </para>
      <para>
	Consulta tamén a instrución <cmdref targ="adf"/> e a opción
	<opt>gls</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Probas de raíz unitaria/Proba ADF-MCX</menu-path>
    </gui-access>

  </command>

  <command name="dialog" section="Estimation" context="gui"
    label="Caixa de diálogo do modelo">

    <description>
      <para>
	Para escoller unha variable como a dependente, salienta esa
	variable na lista da esquerda e preme o botón <quote>Elixir</quote>
	que apunta ao cadrado da variable Dependente. Se marcas o cadriño
	de <quote>Establecer por defecto</quote>, a variable que escolliches
	vaise preseleccionar como a dependente cando se volva a abrir a caixa
	de diálogo do modelo. Atallo: preme un dobre clic nunha variable da
	esquerda para escollela como a variable dependente, e tamén fixala
	por defecto.
      </para>
      <para>
	Para escoller as variables independentes, saliéntaas no lado
	esquerdo e preme o botón <quote>Engadir</quote> (ou preme un
	clic co botón dereito do rato). Podes salientar varias variables
	contiguas arrastrando co rato, e podes salientar un grupo de
	variables non contiguas premendo un clic en cada unha delas
	mentres mantés pulsada a tecla <lit>Ctrl</lit>.
      </para>
    </description>

  </command>

  <command name="diff" section="Transformations"
    label="Primeiras diferenzas" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
	<examples>
	<demos>
	  <demo>penngrow.inp</demo>
	  <demo>sw_ch12.inp</demo>
	  <demo>sw_ch14.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Con esta instrución obtés a primeira diferenza de cada variable
	de <repl>listavariables</repl>, e o resultado gárdase nunha nova variable
	co prefixo <lit>d_</lit>. Así <cmd>diff x y</cmd> xera as novas
	variables
      </para>
      <mono>
	d_x = x(t) - x(t-1)
	d_y = y(t) - y(t-1)
      </mono>
    </description>

    <gui-access>
      <menu-path>/Engadir/Primeiras diferenzas das variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="difftest" section="Tests"
    label="Probas non paramétricas de diferenzas" context="cli">

    <usage>
      <arguments>
        <argument>serie1</argument>
	      <argument>serie2</argument>
      </arguments>
      <options>
	<option>
	  <flag>--sign</flag>
	  <effect>Proba dos signos, por defecto</effect>
	</option>
	<option>
	  <flag>--rank-sum</flag>
	  <effect>Proba da suma de rangos de Wilcoxon</effect>
	</option>
	<option>
	  <flag>--signed-rank</flag>
	  <effect>Proba dos rangos con signo de Wilcoxon</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta resultados adicionais</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Suprime a presentación de resultados</effect>
	</option>
      </options>
	<examples>
	<demos>
	  <demo>ooballot.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Leva a cabo unha proba non paramétrica sobre a diferenza entre
	dúas poboacións ou grupos, na que a proba concreta depende
	da opción seleccionada.
      </para>
      <para>
	Coa opción <opt>sign</opt>, realízase a proba dos signos.
	Esta proba baséase no feito de que, cando se extraen dúas
	mostras, <math>x</math> e <math>y</math>, de forma
	aleatoria dunha mesma distribución, a probabilidade de que
	<math>x</math><sub>i</sub> &gt; <math>y</math><sub>i</sub>,
	para cada observación <math>i</math>, deberá de ser igual
	a 0.5. O estatístico de proba é <math>w</math>, é dicir,
	o número de observacións para as que se cumpre que
	<math>x</math><sub>i</sub> &gt; <math>y</math><sub>i</sub>.
	Baixo a hipótese nula, este estatístico segue unha distribución
	de probabilidade Binomial con parámetros (<math>n</math>, 0.5),
	onde <math>n</math> indica o número de
	observacións.
      </para>
      <para>
	Coa opción <opt>rank-sum</opt>, realízase a proba da suma de rangos de
	Wilcoxon. Esta proba desenvólvese determinando o rango en xerarquía das
	observacións de ambas mostras xuntas, desde a de menor valor ata a de
	maior, e logo calculando a suma dos rangos das observacións dunha calquera
	das dúas mostras. Non é necesario que as dúas mostras teñan o mesmo
	tamaño e, se son diferentes, utilízase a mostra máis pequena para calcular
	a suma dos rangos. Baixo a hipótese nula de que as mostras proceden de
	poboacións coa mesma mediana, a distribución de probabilidade da suma de
	rangos pode calcularse para calquera tamaño de mostra que se indique; e para
	mostras razoablemente longas, existe unha estreita aproximación Normal.
      </para>
      <para>
	Coa opción <opt>signed-rank</opt>, realízase a proba dos rangos con
	signo de Wilcoxon, que está ideada para pares de datos ligados
	como, por exemplo, os pares de valores dunha mesma variable nunha
	mostra de individuos, antes e despois dalgún tratamento. A proba
	desenvólvese calculando as diferenzas entre as observacións emparelladas
	<math>x</math><sub>i</sub> &minus; <math>y</math><sub>i</sub>,
	e determinando o rango destas diferenzas segundo o seu valor absoluto,
	ademais de asignándolle a cada par, un rango cun signo que coincide
	co signo da diferenza. A continuación calcúlase a suma dos rangos
	con signo positivo (<math>W</math><sub>+</sub>). De igual xeito
	que na proba da suma de rangos, baixo a hipótese nula de que a
	diferenza das medianas é cero, este estatístico segue unha distribución
	de probabilidade ben definida, que converxe á Normal para mostras
	de tamaño razoable.
      </para>
      <para>
	Para as probas de Wilcoxon, cando indicas a opción <opt>verbose</opt>,
	entón preséntase a ordenación. (Esta opción non ten efecto cando se
	selecciona a proba dos signos.)
      </para>
      <para>
	Ao completarse con éxito, vas a ter dispoñibles os accesorios
	<fncref targ="$test"/> e <fncref targ="$pvalue"/>. Se unicamente
	queres obter estes valores, podes engadir a opción <opt>quiet</opt>
	á instrución.
      </para>
    </description>

  </command>

  <command name="discrete" section="Transformations"
    label="Marcar variables como discretas" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--reverse</flag>
	  <effect>Marca as variables como continuas</effect>
	</option>
      </options>
	<examples>
	<demos>
	  <demo>ooballot.inp</demo>
	  <demo>oprobit.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Marca cada variable de <repl>listavariables</repl> como discreta pois, por
	defecto, todas as variables trátanse como continuas. Ao facer que
	unha variable sexa discreta, iso afecta ao xeito no que se manexa
	esa variable nas gráficas de frecuencia, e tamén te permite escoller
	a variable para a instrución <cmdref targ="dummify"/>.
      </para>
      <para>
	Cando especificas a opción <opt>reverse</opt>, a operación invértese;
	é dicir, as variables contidas en <repl>listavariables</repl> márcanse como
	continuas.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Editar atributos</menu-path>
    </gui-access>

  </command>

  <command name="dpanel" section="Estimation" label="Modelos de panel dinámicos">

    <usage>
      <arguments>
	      <argument>p</argument>
	     <argblock separated="true">
	      <argument>depvar</argument>
	      <argument>indepvars</argument>
	     </argblock>
	     <argblock optional="true" separated="true">
	      <argument>instrumentos</argument>
	     </argblock>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non amosa o modelo estimado</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
        <option>
	  <flag>--two-step</flag>
	  <effect>Realiza a estimación MXM (GMM) en 2 etapas</effect>
        </option>
        <option>
	  <flag>--system</flag>
	  <effect>Engade ecuacións en niveis</effect>
        </option>
        <option>
	  <flag>--collapse</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>Engade variables ficticias temporais</effect>
        </option>
        <option>
	  <flag>--dpdstyle</flag>
	  <effect>Imita o paquete DPD para Ox</effect>
        </option>
        <option>
	  <flag>--asymptotic</flag>
	  <effect>Desvíos padrón asintóticos sen corrixir</effect>
        </option>
        <option>
	  <flag>--keep-extra</flag>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
      <examples>
        <example>dpanel 2 ; y x1 x2</example>
	<example>dpanel 2 ; y x1 x2 --system</example>
        <example>dpanel {2 3} ; y x1 x2 ; x1</example>
	<example>dpanel 1 ; y x1 x2 ; x1 GMM(x2,2,3)</example>
	<demos>
	  <demo>bbond98.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Realiza a estimación de modelos dinámicos con datos de panel
	(é dicir, modelos de panel que inclúen un ou máis retardos da variable
	dependente) utilizando ben o método MXM-DIF ou ben MXM-SYS.
      </para>
      <para context="cli">
	O parámetro <repl>p</repl> representa o nivel de autorregresión
	para a variable dependente. No caso máis sinxelo, este parámetro é
	un valor escalar, pero tamén podes indicar unha matriz definida
	previamente para este argumento, para especificar con elo un
	conxunto de retardos (posiblemente non consecutivos) a utilizar.
      </para>
      <para>
	Debes de indicar a variable dependente e os regresores cos seus
	valores en niveis, pois xa se van diferenciar automaticamente
	(dado que este estimador utiliza a diferenciación para eliminar
	os efectos individuais).
      </para>
      <para context="cli">
	O último campo (opcional) da instrución é para especificar os
	instrumentos. Se non indicas ningún instrumento, asúmese que
	tódalas variables independentes son estritamente esóxenas. Se
	especificas calquera instrumento, debes de incluír na lista
	calquera variable independente estritamente esóxena. Para os
	regresores predeterminados podes utilizar a función <lit>GMM</lit>
	para incluír un rango específico de retardos co estilo diagonal
	por bloques, como se ilustra no terceiro exemplo de arriba. O
	primeiro argumento de <lit>GMM</lit> é o nome da variable en
	cuestión, o segundo é o retardo mínimo que se utiliza como
	instrumento, e o terceiro é o retardo máximo. Podes utilizar a
	mesma sintaxe coa función <lit>GMMlevel</lit> para especificar
	instrumentos de tipo MXM para as ecuacións en niveis.
      </para>
      <para context="cli">
	Podes usar a opción <opt>collapse</opt> para limitar o inzamento de
	instrumentos de <quote>estilo GMM</quote>, o que podería chegar a
	ser un problema con este estimador. O seu efecto consiste en reducir
	ese tipo de instrumentos, de un por cada retardo e por observación,
	a un por cada retardo.
      </para>
      <para context="gui">
	No referente ao manexo dos instrumentos, consulta a documentación para
	a versión de guión desta instrución. Actualmente non podes especificar
	instrumentos explicitamente na Interface Gráfica de Usuario (GUI), así
	tódalas variables independentes considéranse estritamente esóxenas.
      </para>
      <para>
	Por defecto, preséntanse os resultados da estimación en 1 etapa (cos
	desvíos padrón robustos) pero tes a opción de escoller a estimación
	en 2 etapas. En ambos casos, preséntanse as probas de autocorrelación
	de nivel 1 e 2 , así como as probas de Sargan e/ou Hansen de
	sobreidentificación, e o estatístico da proba de Wald para a significación
	conxunta dos regresores. Ten en conta que neste modelo en diferenzas,
	a autocorrelación de primeiro nivel non é unha ameaza para a validez do
	modelo, pero a autocorrelación de segundo nivel infrinxe os supostos
	estatísticos vixentes.
      </para>
      <para context="cli">
	No caso da estimación en 2 etapas, os desvíos padrón calcúlanse
	por defecto utilizando a corrección de mostra finita suxerida por
	<cite key="windmeijer05">Windmeijer (2005)</cite>. Xeralmente
	considérase que os desvíos padrón asintóticos estándar asociados
	ao estimador do método en 2 etapas, son unha guía pouco fiable para a
	inferencia, pero se por algunha razón queres velos, podes utilizar
	a opción <opt>asymptotic</opt> para desactivar a corrección de
	Windmeijer.
      </para>
      <para context="cli">
	Se indicas a opción <opt>time-dummies</opt>, engádese un conxunto
	de variables ficticias temporais aos regresores especificados.
	O número destas variables ficticias é unha menos que o número
	máximo de períodos usados na estimación, para evitar que haxa
	multicolinearidade perfecta coa constante. As variables ficticias
	introdúcense en forma de diferenzas agás que se indique a opción
	<opt>dpdstyle</opt>, en cuxo caso introdúcense en niveis.
      </para>
      <para context="cli">
	De igual xeito que con outras instrucións para facer a estimación,
	dispós dun feixe <fncref targ="$model"/> logo de facela. No caso de
	<lit>dpanel</lit>, podes usar a opción <opt>keep-extra</opt> para
	gardar información que queiras engadir nese feixe, por exemplo
	as matrices de ponderacións e de instrumentos MXM.
      </para>
      <para>
	Para obter outros detalles e exemplos, consulta o
	<guideref targ="chap:dpanel"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Panel/Modelo de Panel Dinámico</menu-path>
    </gui-access>

  </command>

  <command name="dummify" section="Transformations" context="gui"
    label="Xerar conxuntos de variables ficticias">

    <description>
      <para>
	A operación <quote>dummify</quote> está dispoñible unicamente
	para series con valores discretos. O seu efecto consiste en xerar
	un conxunto de variables ficticias que codifican os distintos
	valores presentes nas series.
      </para>
      <para>
	Por exemplo, supón que tes unha serie titulada <lit>raza</lit>, con valores
	de 1 para <quote>branco</quote>, 2 para <quote>negro</quote>, 3 para
	<quote>hispano</quote> e 4 para <quote>outros</quote>. Crear variables
	ficticias a partir desta serie significa xerar 4 variables ficticias: a
	primeira ten o valor 1 para todas as observacións nas que raza = 1 e cero
	noutro caso; a segunda ten o valor 1 para todas as observacións nas que
	raza = 2, cero noutro caso; etcétera.
      </para>
      <para>
	Na práctica, é posible que para unha serie discreta con
	<math>k</math> categorías queiras xerar unicamente
	<math>k</math> &minus; 1 variables ficticias, para evitar caer
	na denominada <quote>trampa das variables ficticias</quote>.
	De aí que teñas a posibilidade de prescindir da codificación, ben
	do valor máis baixo ou ben do valor máis alto dos considerados.
      </para>
    </description>

  </command>

  <command name="dummify" section="Transformations"
    label="Xerar conxuntos de variables ficticias" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--drop-first</flag>
	  <effect>Exclúe da codificación ao valor máis baixo</effect>
	</option>
	<option>
	  <flag>--drop-last</flag>
	  <effect>Exclúe da codificación ao valor máis alto</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Para calquera variable adecuada de <repl>listavariables</repl>, xera un
	conxunto de variables ficticias que codifican os distintos valores
	desa variable. As variables adecuadas son aquelas que se marcan
	explicitamente como discretas ou aquelas que teñen un número
	claramente pequeno de valores, dos que todos eles estean
	<quote>claramente arredondados</quote> (múltiplos de 0.25).
      </para>
      <para>
	Por defecto, engádese unha variable ficticia por cada valor diferente da
	variable en cuestión. Por exemplo, se unha variable discreta <lit>x</lit>
	ten 5 valores diferentes, engádense 5 variables ficticias ao conxunto de
	datos, cos nomes <lit>Dx_1</lit>, <lit>Dx_2</lit>, etcétera. A primeira
	variable ficticia vai ter o valor 1 nas observacións onde <lit>x</lit>
	toma o seu valor máis pequeno e 0 noutro caso; a seguinte variable
	ficticia vai ter o valor 1 nas observacións onde <lit>x</lit> toma o seu
	segundo valor máis pequeno, etcétera. Se engades un dos indicadores de
	opción <opt>drop-first</opt> ou <opt>drop-last</opt>, entón omítese do
	proceso de codificación ben o valor máis baixo ou ben o valor máis alto
	de cada variable, respectivamente (o que pode serte útil para evitar a
	<quote>trampa das variables ficticias</quote>).
      </para>
      <para>
	Tamén hai unha función que se corresponde con esta instrución,
	consulta <fncref targ="dummify"/>. Isto posibilita integrar a chamada
	directamente na especificación dunha regresión. Por exemplo, a
	seguinte liña especifica un modelo no que <lit>y</lit> se regresa
	sobre o conxunto de variables ficticias que se codifican para
	<lit>x</lit>. (Porén, os indicadores de opcións son unicamente
	para a variante da instrución, non para a variante da función de
	<cmd>dummify</cmd>.)
      </para>
      <code>
	ols y dummify(x)
      </code>
    </description>

    <gui-access>
      <other-access>Xanela principal: Menú emerxente (selección única)</other-access>
    </gui-access>

  </command>

  <command name="duration" section="Estimation" label="Modelos de duración"
    context="cli">
    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
        <argument separated="true" optional="true">censuravar</argument>
      </arguments>
      <options>
        <option>
          <flag>--exponential</flag>
          <effect>Utiliza a distribución exponencial</effect>
        </option>
        <option>
          <flag>--loglogistic</flag>
          <effect>Utiliza a distribución log-loxística</effect>
        </option>
        <option>
          <flag>--lognormal</flag>
          <effect>Utiliza a distribución log-normal</effect>
        </option>
        <option>
          <flag>--medians</flag>
          <effect>Os valores axustados son as medianas</effect>
        </option>
        <option>
          <flag>--robust</flag>
          <effect>Desvíos padrón robustos: CMV (QML)</effect>
        </option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustervar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para explicación</effect>
        </option>
        <option>
          <flag>--vcv</flag>
          <effect>Presenta a matriz de covarianzas</effect>
        </option>
        <option>
          <flag>--verbose</flag>
          <effect>Presenta os detalles das iteracións</effect>
        </option>
	      <option>
	        <flag>--quiet</flag>
	        <effect>Non presenta nada</effect>
	      </option>
      </options>
      <examples>
        <example>duration y 0 x1 x2</example>
	<example>duration y 0 x1 x2 ; cens</example>
	<demos>
	  <demo>weibull.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Estima un modelo de duración no que a variable dependente (que debe
	de ser positiva) representa a duración dalgún estado dun asunto; por
	exemplo, a duración do período de desemprego para unha sección
	cruzada de enquisados. Por defecto, utilízase a distribución de
	Weibull pero tamén están dispoñibles as distribucións exponencial,
	log-loxística e log-normal.
      </para>
      <para>
	Se algunhas das medidas de duración están censuradas pola dereita
	(&eg; o período do desemprego dun individuo aínda non rematou dentro
	do período de observación), entón debes de indicar no argumento
	posterior <repl>censuravar</repl>, unha serie na que os valores non
	nulos indiquen os casos censurados pola dereita.
      </para>
      <para>
	Por defecto, os valores axustados que obtés mediante o accesorio
	<lit>$yhat</lit> son as medias condicionadas das duracións, pero
	cando indicas a opción <opt>medians</opt> entón <lit>$yhat</lit>
	te proporciona as medianas condicionadas no seu lugar.
      </para>
      <para>
	Consulta o <guideref targ="chap:probit"/> para obter máis detalles.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Variable Dependente Limitada/Datos de Duración</menu-path>
    </gui-access>

  </command>

  <command name="elif" section="Programming" label="Control de fluxo" context="cli">
    <description>
      <para>Consulta <cmdref targ="if"/>.
      </para>
    </description>
  </command>

  <command name="else" section="Programming" label="Control de fluxo" context="cli">
    <description>
      <para>Consulta <cmdref targ="if"/>. Ten en conta que a instrución
	<cmd>else</cmd> necesita unha liña para ela mesma, antes da seguinte
	instrución condicional. Podes engadirlle un comentario, como en
      </para>
      <code>
	else # Correcto, fai algo distinto
      </code>
      <para>
	Pero non podes engadirlle unha instrución, como en
      </para>
      <code>
	else x = 5 # Incorrecto!
      </code>
    </description>
  </command>

  <command name="ema-filter" section="Transformations" context="gui"
    label="Media Móbil Exponencial">

    <description>
      <para>
	A fórmula que emprega GRETL para calcular a media móbil exponencial
	(MME ou EMA) é a de <cite key="roberts59">Roberts (1959)</cite>,
	concretamente
      </para>
      <para>
	<math>s</math><sub>t</sub> =
	&agr;<math>y</math><sub>t</sub> +
        (1&minus;&agr;)<math>s</math><sub>t&minus;1</sub>
      </para>
      <para>
	onde <math>s</math> é a MME, <math>y</math> é a serie orixinal, e
	&agr; é unha constante entre 0 e 1. Os valores máis grandes de &agr;
	cargan máis ponderación na observación vixente; e os valores máis
	pequenos producen un maior suavizado.
      </para>
      <para>
	Como <quote>primeiro valor da MME</quote>, se non se especifica,
	tómase o último valor previo á mostra, o que significa que o cálculo
	do filtro comeza coa primeira observación que hai no rango da mostra
	vixente.
      </para>
      <para>
	Para unha liña de instrución equivalente, consulta a función
	<fncref targ="movavg"/>.
      </para>
    </description>

  </command>

  <command name="end" section="Programming"
    label="Finalizar un bloque de instrucións" context="cli">
    <description>
      <para>
	Termina un bloque de instrucións dalgunha clase. Por exemplo, <cmd>end system</cmd>
	termina un sistema de ecuacións (<cmdref targ="system"/>).
      </para>
    </description>
  </command>

  <command name="endif" section="Programming" label="Control de fluxo" context="cli">
    <description><para>Consulta <cmdref targ="if"/>.</para>
    </description>
  </command>

  <command name="endloop" section="Programming"
    label="Finalizar un bucle de instrucións" context="cli">
    <description>
      <para>
	Marca a fin dun bucle de instrucións. Consulta <cmdref targ="loop"/>.
      </para>
    </description>
  </command>

  <command name="eqnprint" section="Printing"
    label="Presentar un modelo como ecuación" context="cli">

    <usage>
      <options>
        <option>
	  <flag>--complete</flag>
	  <effect>Xera un documento completo</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía o resultado ao ficheiro especificado</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Debe de ir despois da estimación dun modelo e presenta o modelo
	estimado en formato dunha ecuación &latex;. Se especificas o nome
	dun ficheiro utilizando a opción <opt>output</opt>, o resultado
	diríxese a ese ficheiro; se non, diríxese a un ficheiro cun
	nome co estilo <filename>equation_N.tex</filename>, onde <lit>N</lit>
	é o número de modelos estimados ata ese momento na sesión vixente.
	Consulta tamén <cmdref targ="tabprint"/>.
      </para>
      <para>
	O ficheiro resultante vai escribirse no cartafol de traballo
	(<cmdref targ="workdir"/>) establecido nese momento, agás que a cadea
	<repl>nomeficheiro</repl> conteña unha especificación completa da ruta.
      </para>
      <para>
	Cando especificas a opción <opt>complete</opt>, o ficheiro &latex; é
	un documento completo (listo para procesar); se non, debes de
	incluílo nun documento.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="equation" section="Estimation"
    label="Definir unha ecuación dentro dun sistema" context="cli">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <examples>
        <example>equation y x1 x2 x3 const</example>
      </examples>
    </usage>

    <description>
      <para>
	Te permite especificar unha das ecuacións dun sistema delas (consulta
	<cmdref targ="system"/>). A sintaxe para especificar unha ecuación dun
	sistema SUR é a mesma que para, &eg;, <cmdref targ="ols"/>. Pero para
	unha das ecuacións dun sistema a estimar con Mínimos Cadrados en 3 etapas,
	podes: (a) indicar unha especificación dunha ecuación como se estima con
	MCO e proporcionar unha lista normal de instrumentos utilizando a palabra
	chave <cmd>instr</cmd> (de novo, consulta <cmdref targ="system"/>), ou
	(b) utilizar a mesma sintaxe de ecuacións que para <cmdref targ="tsls"/>.
      </para>
    </description>

  </command>

  <command name="estimate" section="Estimation"
    label="Estimar sistemas de ecuacións" context="cli">

    <usage>
      <arguments>
        <argument optional="true">nomesistema</argument>
	      <argument optional="true">estimador</argument>
      </arguments>
      <options>
	<option>
	  <flag>--iterate</flag>
	  <effect>Reitera ata a converxencia</effect>
	</option>
	<option>
	  <flag>--no-df-corr</flag>
	  <effect>Sen corrección dos graos de liberdade</effect>
	</option>
	<option>
	  <flag>--geomean</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
	</option>
      </options>
      <examples>
        <example>estimate "Klein Model 1" method=fiml</example>
	<example>estimate Sys1 method=sur</example>
	<example>estimate Sys1 method=sur --iterate</example>
      </examples>
    </usage>

    <description>
      <para>
	Solicita a estimación dun sistema de ecuacións que debes de
	definir previamente usando a instrución <cmdref targ="system"/>.
	Debes de indicar primeiro o nome do sistema, contornado entre
	comiñas se o nome contén espazos. O estimador debe de ser un
	dos seguintes: <cmd>ols</cmd>, <cmd>tsls</cmd>, <cmd>sur</cmd>,
	<cmd>3sls</cmd>, <cmd>fiml</cmd> ou <cmd>liml</cmd>; e debes
	de poñerlle antes a cadea de texto <lit>method=</lit>. Estes
	argumentos son optativos se o sistema en cuestión xa se
	estimou, e ocupa o lugar do <quote>último modelo</quote>;
	nese caso, o estimador que se toma por defecto será o utilizado
	previamente.
      </para>
      <para>
	Se o sistema en cuestión tivo aplicadas un conxunto de restricións
	(consulta a instrución <cmdref targ="restrict"/>), a estimación
	estará suxeita ás restricións especificadas.
      </para>
      <para>
	Se o método de estimación é <cmd>sur</cmd> ou <cmd>3sls</cmd>, e
	especificas a opción <opt>iterate</opt>, vaise calcular o estimador
	iterativamente. No caso de SUR, se o procedemento converxe, os
	resultados son as estimacións máximo verosímiles. A iteración de
	Mínimos Cadrados en 3 Etapas (3sls), porén, en xeral non converxe aos
	resultados da máxima verosimilitude con información completa (fiml).
	A opción <opt>iterate</opt> ignórase para outros métodos de
	estimación.
      </para>
      <para>
	Se elixes os estimadores de ecuación a ecuación <cmd>ols</cmd>
	ou <cmd>tsls</cmd>, por defecto aplícase unha corrección dos
	graos de liberdade cando se calculan os desvíos padrón, mais
	podes eliminar isto utilizando a opción <opt>no-df-corr</opt>. Esta
	opción non ten efecto cos outros estimadores, e así non se aplica a
	corrección dos graos de liberdade en ningún caso.
      </para>
      <para>
	Por defecto, a fórmula utilizada para calcular os elementos
	da matriz de covarianzas das ecuacións cruzadas é
	<equation status="display"
	tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{T}\]"
	ascii="sigma(i,j) = u(i)' * u(j) / T"
	graphic="syssigma1"/>
	Cando indicas a opción <opt>geomean</opt>, aplícase unha
	corrección dos graos de liberdade co que a fórmula nese
	caso é
	<equation status="display"
	tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{\sqrt{(T-k_i)(T-k_j)}}\]"
	ascii="sigma(i,j) = u(i)' * u(j) / sqrt((T - ki) * (T - kj))"
	graphic="syssigma2"/>
	onde as <math>k</math>s denotan o número de parámetros
	independentes en cada ecuación.
      </para>
      <para>
	Cando indicas a opción <opt>verbose</opt> e especificas un
	método iterativo, preséntanse detalles das iteracións.
      </para>
    </description>

  </command>

  <command name="eval" section="Utilities" context="cli">
    <usage>
      <arguments>
        <argument>expresión</argument>
      </arguments>
      <examples>
        <example>eval x</example>
	<example>eval inv(X'X)</example>
	<example>eval sqrt($pi)</example>
      </examples>
    </usage>
    <description>
      <para>
	Esta instrución fai que GRETL funcione como unha sofisticada
	calculadora. O programa avalía <repl>expresión</repl> e
	presenta o seu valor. O argumento pode ser o nome dunha
	variable, ou algo máis complicado. En calquera caso, debe
	de ser unha expresión que podas poñer correctamente como
	o lado dereito dun enunciado de asignación (igualdade).
      </para>
      <para>
	No uso interactivo (por exemplo coa consola de GRETL), un signo
	igual funciona como unha abreviatura de <lit>eval</lit>, como en
      </para>
      <code>
	=sqrt(x)
      </code>
      <para>
	(con ou sen espazo despois de <quote>=</quote>). Pero esta variante
	non se admite no modo de edición de guións xa que podería agochar
	doadamente fallos de codificación.
      </para>
      <para>
	Na maioría dos contextos, podes usar a instrución <cmdref targ="print"/>
	no canto de <lit>eval</lit> para obter o mesmo efecto. Consulta tamén
	<cmdref targ="printf"/> para aqueles casos nos que queiras combinar
	resultados de texto e numéricos.
      </para>
    </description>
  </command>

  <command name="expand" section="Dataset" context="gui"
    label="Expandir datos">

    <description>
      <para>
	Debes considerar a <quote>expansión</quote> desde unha frecuencia
	menor a unha maior dun conxunto de datos ou dunha serie, como unha
	opción para expertos, pois necesitas saber que estás facendo. Cando
	combinas series de diferentes frecuencias orixinais dentro dun conxunto
	de datos, probablemente deberías de considerar como compactar os datos
	de frecuencia maior, máis ca expandir as series de frecuencia menor.
      </para>
      <para>
	Aclarado isto, GRETL admite a expansión mediante a simple repetición
	dos valores de baixa frecuencia. Por exemplo, ao expandir desde
	frecuencia trimestral a mensual, os valores trimestrais se repiten
	para cada mes do trimestre. As series xeradas deste xeito non é
	probable que se podan usar así para a análise econométrica, pero
	despois da expansión podes usar a función <fncref targ="tdisagg"/>
	para producir unha versión distribuída ou interpolada dos datos
	(<quote>desagregación temporal</quote>).
      </para>
      <para>
	Podes acceder a algunhas das prestacións da función <lit>tdisagg</lit>
	mediante a interface gráfica, seleccionando unha serie na xanela
	principal de GRETL, e a continuación procurar <quote>Desagregar</quote>
	baixo o menú Variable.
      </para>
    </description>
  </command>

  <command name="export" section="Dataset" context="gui"
    label="Exportar datos">

    <description>
      <para>
	Podes exportar datos no formato Valores Separados por Comas (CSV)
	que poden abrirse en follas de cálculo e moitos outros programas.
	Se escolles esta opción, vas ter algunhas opcións adicionais con
	relación ao formato específico do ficheiro CSV.
      </para>
      <para>
	Tamén tes a opción de exportar datos co formato dun ficheiro
	de datos <quote>propio</quote> de GRETL, ou de exportalos a
	un banco de datos de GRETL (se os datos son axeitados). Consulta
	<url>gretl.sourceforge.net/gretl_data.html</url> para ver un
	relatorio dos bancos de datos de GRETL.
      </para>
      <para>
	Podes tamén exportar datos nun formato de texto plano axeitado para
	usalos cos seguintes programas:
      </para>
      <ilist>
	<li>
	  <para>
	    GNU R (<url>www.r-project.org</url>): Escríbense os datos co formato
	    que utiliza espazos separados e que a función <lit>read.table</lit>
	    de R pode asimilar doadamente. Sufixo, por defecto, do nome de
	    ficheiro: <lit>.txt</lit>
	  </para>
	</li>
	<li>
	  <para>
	    GNU octave (<url>www.gnu.org/software/octave</url>): Os datos se
	    escriben como unha matriz no formato favorito de Octave. Sufixo,
	    por defecto, do nome de ficheiro: <lit>.m</lit>
	  </para>
	</li>
	<li>
	  <para>
	    JMulTi (<url>www.jmulti.de</url>): Sufixo, por defecto, do nome de
	    ficheiro: <lit>.dat</lit>
    </para>
	</li>
	<li>
	  <para>
	    PcGive (<url>www.pcgive.com</url>): Sufixo, por defecto, do nome de
	    ficheiro: <lit>.dat</lit>
    </para>
	</li>
      </ilist>
      <para>
	Se queres exportar os datos copiándoos ao portapapeis mellor que
	escribíndoos nun ficheiro do disco, selecciona na xanela principal
	as series que queres copiar, preme co botón dereito do rato na
	selección e escolle <quote>Copiar ao portapapeis</quote>.
	(Só se admite o formato CSV neste contexto.)
      </para>
    </description>
  </command>

  <command name="factorized" section="Graphs" context="gui"
    label="Gráfica con factor de separación">

    <description>
      <para>
	Esta instrución require que selecciones 3 variables e a última delas
	(a variable de factor) debe ser discreta. A variable Y se representa
	graficamente fronte á variable X, cos puntos de datos con estilos
	diferentes dependendo do valor da terceira variable.
      </para>
      <para>
	Exemplo: Supón que tes datos sobre salarios e cualificacións educativas
	para unha mostra de persoas, e tamén unha variable ficticia co valor 1
	para os homes e 0 para as mulleres (como en <filename>data7-2</filename>
	de Ramanathan). Unha <quote>gráfica con factor de separación</quote> de
	<lit>WAGE</lit> fronte a <lit>EDUC</lit>, utilizando a variable ficticia
	<lit>GENDER</lit> como factor, amosará os puntos de datos para os
	homes nunha cor e aqueles para as mulleres noutra (cunha lenda para
	identificalos).
      </para>
    </description>

  </command>

  <command name="fcast" section="Prediction"
    label="Xerar predicións">

    <usage>
      <altforms>
	<altform><lit>fcast [</lit><repl>obsinicio obsfin</repl><lit>] [</lit><repl>nomev</repl><lit>]</lit></altform>
	<altform><lit>fcast [</lit><repl>obsinicio obsfin</repl><lit>]</lit> <repl>pasosadiante</repl> <lit>[</lit><repl>nomev</repl><lit>] --recursive</lit></altform>
      </altforms>
      <options>
        <option>
	  <flag>--dynamic</flag>
	  <effect>Xera a predición dinámica</effect>
        </option>
        <option>
	  <flag>--static</flag>
	  <effect>Xera a predición estática</effect>
        </option>
        <option>
	  <flag>--out-of-sample</flag>
	  <effect>Xera a predición postmostral</effect>
        </option>
        <option>
	  <flag>--no-stats</flag>
	  <effect>Non presenta as estatísticas de predición</effect>
        </option>
        <option>
	  <flag>--stats-only</flag>
	  <effect>Presenta só as estatísticas de predición</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
        </option>
        <option>
	  <flag>--recursive</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--all-probs</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--plot</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
      <examples>
        <example>fcast 1997:1 2001:4 f1</example>
	<example>fcast fit2</example>
	<example>fcast 2004:1 2008:3 4 rfcast --recursive</example>
	<demos>
	  <demo>gdp_midas.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Debe de ir despois dunha instrución de estimación. As predicións xéranse
	para o rango especificado de observacións. Dependendo da natureza do
	modelo, tamén poden xerarse os desvíos padrón (mira abaixo).
      </para>

      <para context="cli">
	Debe de ir despois dunha instrución de estimación. As predicións
	xéranse para certo rango de observacións que será, ben o definido
	cando indicas <repl>obsinicio</repl> e <repl>obsfin</repl> (de ser
	posible), ben o definido polas observacións que van a continuación
	do rango sobre o que se estimou o modelo cando indicas a opción
	<opt>out-of-sample</opt>, ou ben, se non, o rango da mostra
	definido nese momento. Cando solicitas unha predición 'out-of-sample'
	pero non hai dispoñibles observacións relevantes, amósase un fallo.
	Dependendo da natureza do modelo, tamén poden xerarse os desvíos
	padrón (mira abaixo). Tamén mira abaixo para indagar sobre o efecto
	especial da opción <opt>recursive</opt>.
      </para>

      <para context="cli">
	Se o derradeiro modelo estimado ten unha única ecuación, entón
	o argumento <repl>nomev</repl> (opcional) ten o seguinte efecto:
	non se presentan os valores da predición, senón que se gardan no
	conxunto de datos co nome indicado. Se o último modelo é un sistema
	de ecuacións, <repl>nomev</repl> ten un efecto distinto xa que,
	concretamente, escolle unha variable endóxena en particular para facer
	a predición (pois por defecto xéranse as predicións para todas as
	variables endóxenas). No caso dun sistema ou se non indicas
	<repl>nomev</repl>, podes recuperar os valores de predición utilizando
	o accesorio <fncref targ="$fcast"/> e, se están dispoñibles, os
	desvíos padrón mediante <fncref targ="$fcse"/>.
      </para>

      <subhead>Predicións estáticas e dinámicas</subhead>
      <para>
	A elección entre unha predición estática ou dinámica aplícase
	unicamente no caso de modelos dinámicos, cunha perturbación cun
	proceso autorregresivo e/ou que inclúan un ou máis valores retardados
	da variable dependente como regresores. As predicións estáticas son
	un paso adiantadas (baseadas nos valores acadados no período previo),
	mentres que as predicións dinámicas empregan a regra da cadea de
	predición. Por exemplo, se unha predición para <math>y</math> en
	2008 require como entrada un valor de <math>y</math> en 2007, unha
	predición estática é imposible sen datos actualizados para 2007,
	pero unha predición dinámica para 2008 é posible se podes substituír
	unha predición previa para <math>y</math> en 2007.
      </para>
      <para>
	Por defecto proporciónase: (a) unha predición estática para algunha
	porción do rango de predición que cae dentro do rango da mostra sobre
	o que se estima o modelo, e (b) unha predición dinámica (se é relevante)
	fóra da mostra. A opción <opt>dynamic</opt> solicita unha predición
	dinámica a partir da data o máis temperá posible, e a opción
	<opt>static</opt> solicita unha predición estática aínda fóra da
	mostra.
      </para>

      <subhead context="cli">Predicións recursivas</subhead>
      <para context="cli">
	A opción <opt>recursive</opt> está actualmente dispoñible só
	para modelos dunha soa ecuación, estimados mediante MCO.
	Cando indicas esta opción as predicións son recursivas; é
	dicir, cada predición xérase a partir dunha estimación do
	modelo indicado, utilizando os datos a partir dun punto de
	inicio fixado (en concreto, o inicio do rango da mostra
	para a estimación orixinal) ata a data de predición menos
	<math>k</math>, o número de pasos adiantados que debes de
	indicar no argumento <repl>pasosadiante</repl>. As predicións
	sempre son dinámicas se iso é pertinente. Cae na conta de
	que debes de indicar o argumento <repl>pasosadiante</repl>
	unicamente xunto coa opción <opt>recursive</opt>.
      </para>

      <subhead>Modelos ordenados e modelo multinomial</subhead>
      <para>
	Cando a estimación é mediante logit ou probit ordenados, ou logit
	multinomial, poderías estar interesado nas probabilidades estimadas
	de cada un dos resultados discretos, mellor que unicamente no resultado
	<quote>máis probable</quote> para cada observación. Isto acádase
	mediante a opción <opt>all-probs</opt>: o efecto de <lit>fcast</lit>
	é nese caso unha matriz cunha columna por cada resultado posible.
	Podes usar o argumento <repl>vname</repl> para nomear esa matriz,
	en cuxo caso non se presenta nada. Se non indicas <repl>vname</repl>,
	entón a matriz pódese recuperar mediante <fncref targ="$fcast"/>.
	A opción <opt>plot</opt> non é compatible coa opción
	<opt>all-probs</opt>.
      </para>

      <subhead context="cli">Gráficas de predicións</subhead>
      <para context="cli">
	A opción <opt>plot</opt> solicita que se produza un ficheiro gráfico,
	que contén unha representación gráfica da predición. No caso dun
	sistema, esta opción só está dispoñible cando se usa o argumento
	<repl>nomev</repl> para seleccionar unha única variable para facer
	a predición. O sufixo do argumento <repl>nomeficheiro</repl> desta
	opción, controla o formato da gráfica: <lit>.eps</lit> para EPS,
	<lit>.pdf</lit> para PDF, <lit>.png</lit> para PNG, e <lit>.plt</lit>
	para un ficheiro de instrucións de Gnuplot. Podes utilizar o nome
	ficticio <lit>display</lit> en substitución do nome de ficheiro para
	forzar a representación da gráfica nunha xanela. Por
	exemplo,
      </para>
      <code context="cli">
	fcast --plot=fc.pdf
      </code>
      <para context="cli">
	vai xerar unha gráfica con formato PDF. Respéctanse os nomes de
	rutas que non ofrezan dúbidas; se non, os ficheiros escríbense
	no cartafol de traballo de GRETL.
      </para>

      <subhead>Desvíos padrón</subhead>
      <para>
	A natureza dos desvíos padrón das predicións (se están dispoñibles)
	depende da natureza do modelo e da predición. En modelos lineais estáticos,
	os desvíos padrón calcúlanse utilizando o método bosquexado por
	<cite key="davidson-mackinnon04">Davidson e MacKinnon (2004)</cite>;
	eles incorporan tanto a incerteza debida ao proceso da perturbación como a
	incerteza nos parámetros (resumida na matriz de covarianzas dos
	estimadores dos parámetros). En modelos dinámicos, os desvíos
	padrón das predicións calcúlanse unicamente no caso dunha predición
	dinámica, e non incorporan a incerteza nos parámetros. Para modelos
	non lineais, os desvíos padrón das predicións non están dispoñibles
	actualmente.
      </para>

    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Análise/Predicións</menu-path>
    </gui-access>

  </command>

  <command name="flush" section="Programming" context="cli">

    <description>
      <para>
	Esta sinxela instrución (sen argumentos, sen opcións) está ideada para
	usarse en guións que levan algo de tempo, e que deben de executarse coa
	Interface Gráfica de Usuario (GUI) de GRETL (o programa de liñas de
	instrución o ignora), para darlle ao usuario un indicio visual de que
	as cousas estanse movendo e GRETL non está <quote>parado</quote>.
      </para>
      <para>
	Xeralmente, se lanzas un guión na Interface Gráfica de Usuario (GUI),
	non se amosa o resultado ata que se complete a súa execución, pero
	o efecto de invocar <lit>flush</lit> é como se indica deseguido:
      </para>
      <ilist>
       <li>
	    <para>
	   Na primeira chamada, GRETL abre unha xanela, amosa os resultados
	   ata o presente e engade a mensaxe
	   <quote>Procesando...</quote>.
	    </para>
       </li>
       <li>
	    <para>
	   Tras invocacións posteriores, actualízase o texto que se amosa
	   na xanela de resultados, e engádese unha nova mensaxe
	   <quote>Procesando</quote>.
	    </para>
       </li>
     </ilist>
      <para>
	Cando se completa a execución do guión, calquera resultado que
	quede pendente descárgase automaticamente na xanela de texto.
      </para>
      <para>
	Ten en conta que non ten senso que utilices <lit>flush</lit> en
	guións que tarden menos de (digamos) 5 segundos en executarse.
	Tamén cae na conta de que non deberías de utilizar esta instrución nun
	lugar do guión onde non hai resultados posteriores que presentar,
	xa que a mensaxe <quote>Procesando</quote> será entón enganosa
	para o usuario.
      </para>
      <para>
	O seguinte código ilustra o uso que se pretende con <lit>flush</lit>:
      </para>
     <code>
       set echo off
       scalar n = 10
       loop i=1..n
           # Facer unha operación que leve algo de tempo
           loop 100 --quiet
               a = mnormal(200,200)
               b = inv(a)
           endloop
           # Presentar algúns resultados
           printf "Iteración %2d feita\n", i
           if i &lt; n
               flush
           endif
       endloop
     </code>
    </description>

  </command>

  <command name="foreign" section="Programming"
    label="Guión alleo" context="cli">

    <usage>
      <syntax><lit>foreign language=</lit><repl>ling</repl></syntax>
      <options>
	<option>
	  <flag>--send-data</flag>
	  <optparm optional="true">lista</optparm>
	  <effect>Carga previamente os datos; mira abaixo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Elimina os resultados do programa externo</effect>
	</option>
      </options>
    </usage>

    <description>
     <para>
	Esta instrución abre un modo especial no que se admiten
	instrucións que van executarse con outro programa. Podes
	saír deste modo con <lit>end foreign</lit> e, nese punto,
	execútanse as instrucións acumuladas.
      </para>
      <para>
	Actualmente os programas <quote>externos</quote> aos que se lles
	dá sostén deste xeito son GNU R (<lit>language=R</lit>), Python,
	Julia, GNU Octave (<lit>language=Octave</lit>), Ox de Jurgen
	Doornik e Stata. Os nomes das linguaxes recoñécense en termos
	que non distinguen maiúsculas e minúsculas.
      </para>
      <para>
	Xunto con R, Octave e Stata, a opción <opt>send-data</opt>
	ten como efecto o de facer accesibles os datos do espazo de
	traballo do GRETL dentro do programa sinalado. Por defecto, se
	envía o conxunto completo de datos, pero ti podes limitar os
	datos que se van enviar indicando o nome dunha lista de series
	definida previamente. Por exemplo:
      </para>
      <code>
	list Rlist = x1 x2 x3
	foreign language=R --send-data=Rlist
      </code>
      <para>
	Consulta o <guideref targ="chap:gretlR"/> para obter máis detalles e exemplos.
      </para>
    </description>

  </command>

  <command name="fractint" section="Statistics" label="Integración fraccional">

    <usage>
      <arguments>
        <argument>serie</argument>
	      <argument optional="true">nivel</argument>
      </arguments>
      <options>
        <option>
	  <flag>--gph</flag>
	  <effect>Fai a proba de Geweke e Porter-Hudak</effect>
        </option>
        <option>
	  <flag>--all</flag>
	  <effect>Fai ambas probas</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Comproba a integración fraccional (<quote>memoria longa</quote>)
	das series especificadas probando a hipótese nula de que a orde de
	integración da serie é cero. Por defecto, utilízase o Estimador Local
	Whittle <cite key="robinson95" p="true">(Robinson, 1995)</cite>,
	pero cando indicas a opción <opt>gph</opt>, realízase a proba GPH
	<cite key="GPH83" p="true">(Geweke e Porter-Hudak, 1983)</cite>
	en troques. Cando decidas indicar a opción <opt>all</opt>,
	entón vanse presentar os resultados de ámbalas dúas
	probas.
      </para>
      <para>
	Para obter máis detalles sobre esta clase de proba, consulta
	<cite key="phillips04">Phillips e Shimotsu (2004)</cite>.
      </para>
      <para>
	Cando non indicas o argumento <repl>nivel</repl> (opcional), o nivel
	para a(s) proba(s) establécese automaticamente como o número menor
	entre <math>T</math>/2 e <math>T</math><sup>0.6</sup>.
      </para>
      <para>
	As ordes estimadas de integración fraccional e os desvíos
	padrón correspondentes están dispoñibles mediante o accesorio
	<fncref targ="$result"/>. Coa opción <opt>all</opt>, atoparás a
	estimación Local Whittle na primeira fila e a estimación GPH na
	segunda.
      </para>
      <para>
	Podes recuperar os resultados da proba utilizando os accesorios
	<fncref targ="$test"/> e <fncref targ="$pvalue"/>. Estes valores
	baséanse no Estimador Local Whittle agás cando indicas a opción
	<opt>gph</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Probas de raíz unitaria/Integración fraccional</menu-path>
    </gui-access>

  </command>

  <command name="freq" section="Statistics" label="Distribución de frecuencias">

    <usage>
      <arguments>
        <argument>variable</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nbins</flag>
	  <optparm>n</optparm>
	  <effect>Especifica o número de intervalos</effect>
        </option>
        <option>
	  <flag>--min</flag>
	  <optparm>valormínimo</optparm>
	  <effect>Especifica o mínimo, mira abaixo</effect>
        </option>
        <option>
	  <flag>--binwidth</flag>
	  <optparm>ancho</optparm>
	  <effect>Especifica o ancho do intervalo, mira abaixo</effect>
        </option>
        <option>
	  <flag>--normal</flag>
	  <effect>Proba a distribución Normal</effect>
        </option>
        <option>
	  <flag>--gamma</flag>
	  <effect>Proba a distribución Gamma</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nomematriz</optparm>
	  <effect>Utiliza unha columna da matriz indicada</effect>
        </option>
        <option>
	  <flag>--plot</flag>
	  <optparm>modo-ou-nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
      <examples>
  <example>freq x</example>
	<example>freq x --normal</example>
	<example>freq x --nbins=5</example>
	<example>freq x --min=0 --binwidth=0.10</example>
      </examples>
    </usage>

    <description context="cli">
      <para>
	Se non indicas opcións, amosa a distribución de frecuencias da
	serie <repl>variable</repl> (indicada polo seu nome ou número) en
	formato tabular, co número de intervalos e os seus tamaños elixidos
	automaticamente, con ou sen unha gráfica adxunta tal como se explica
	máis abaixo. Cando se completa a instrución con éxito, podes
	recuperar a táboa de frecuencias como unha matriz utilizando
	o accesorio <fncref targ="$result"/>.
      </para>
      <para>
	Cando indicas a opción <opt>matrix</opt>, entón <repl>variable</repl>
	debe de ser un número enteiro e interprétase neste caso como un
	índice que escolle unha columna da matriz indicada. Se a matriz
	en cuestión é realmente un vector columna, podes omitir este
	argumento <repl>variable</repl>.
      </para>
      <para>
	Por defecto, a distribución de frecuencias utiliza un número de
	intervalos calculado automaticamente se os datos son continuos, ou non
	agrupa en intervalos se os datos son discretos. Para controlar este
	aspecto podes: (a) usar a instrución <cmdref targ="discrete"/> para
	establecer o status da <repl>variable</repl>, ou (b), se os datos son
	continuos, especificar <emphasis>ou</emphasis> o número de intervalos,
	ou o valor mínimo xunto co ancho dos intervalos, como se mostra nos
	dous últimos exemplos de arriba. A opción <opt>min</opt> establece
	o límite inferior do intervalo situado máis á esquerda.
      </para>
      <para>
	Cando indicas a opción <opt>normal</opt>, calcúlase o estatístico
	khi-cadrado de Doornik&ndash;Hansen para probar a Normalidade.
	Cando indicas a opción <opt>gamma</opt>, a proba de Normalidade
	substitúese pola proba non paramétrica de Locke respecto á hipótese
	nula de que unha variable segue unha distribución Gamma; consulta
	<cite key="locke76">Locke (1976)</cite>, e tamén
	<cite key="shapiro-chen01">Shapiro e Chen (2001)</cite>. Cae na
	conta de que a forma na que se indican en GRETL os parámetros da
	distribución Gamma utilizada é (forma, escala).
      </para>
      <para>
	Por defecto, se GRETL non está en modo de procesamento por
	lotes, amósase unha gráfica da distribución, pero podes axustar
	isto mediante a opción <opt>plot</opt>. Os parámetros admisibles
	para esta opción son: <lit>none</lit> (para suprimir a gráfica),
	<lit>display</lit> (para amosar unha gráfica mesmo cando esteas
	en modo de procesamento por lotes), ou un nome de ficheiro. O
	efecto de indicar un nome de ficheiro é como se describe para a
	opción <opt>output</opt> da instrución <cmdref targ="gnuplot"/>.
      </para>
      <para>
	A opción <opt>silent</opt> elimina o resultado de texto habitual.
	Podes utilizar isto xunto con unha ou outra das opcións para probas
	de distribución; entón rexístranse o estatístico de proba máis a súa
	probabilidade asociada, e podes recuperalos utilizando os accesorios
	<fncref targ="$test"/> e <fncref targ="$pvalue"/>. Tamén podes usar
	isto xunto coa opción <opt>plot</opt> se unicamente queres un
	histograma e non te interesa mirar o texto que o acompaña.
      </para>
      <para>
	Ten en conta que GRETL non ten unha función que se corresponda
	con esta instrución, pero resulta posible utilizar a función
	<fncref targ="aggregate"/> para acadar o mesmo obxectivo.
	Amais, podes obter a distribución de frecuencias que se xera coa
	instrución <lit>freq</lit>, en forma de matriz, mediante o accesorio
	<fncref targ="$result"/>.
      </para>
    </description>

    <description context="gui">
      <para>
	Na caixa de diálogo de gráfica de frecuencia podes controlar as
	características da gráfica de calquera destes dous xeitos.
      </para>
      <para>
	Primeiro, podes escoller o número de intervalos. Neste caso,
	calcúlanse automaticamente o ancho e a situación dos intervalos.
      </para>
      <para>
	Como alternativa, podes especificar o límite inferior do intervalo
	situado máis á esquerda, e o ancho dos intervalos. Neste caso, o
	número de intervalos calcúlase automaticamente.
      </para>
      <para>
	Se queres aliñar os intervalos en números arredondados, aquí tes un
	xeito de proceder: comeza especificando o número de intervalos que
	queres e bota unha ollada á gráfica que se produce. Se non é do teu
	agrado, apunta a modificación que se require (por exemplo, facer que
	o intervalo situado máis á esquerda comece en 100 e impón un ancho
	de intervalo de 200). Entón fai unha segunda proba, especificando o
	límite esquerdo e o ancho do intervalo.
      </para>
      <para>
	Este diálogo tamén permite elixir unha distribución teórica para representar
	fronte aos datos: a Normal ou a Gamma. Cando escolles a opción Normal,
	calcúlase o estatístico da proba de Normalidade de Doornik&ndash;Hansen.
	Cando seleccionas a opción Gamma, GRETL calcula o estatístico da proba non
	paramétrica de Locke respecto á hipótese nula que sostén que a variable
	segue unha distribución Gamma. Cae na conta de que a forma na que se
	indican en GRETL os parámetros da distribución Gamma é (forma, escala).
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Distribución de frecuencias</menu-path>
    </gui-access>

  </command>

  <command name="funcerr" section="Programming"
    label="Saír ao fallar" context="cli">

    <usage>
      <arguments>
        <argument optional="true">mensaxe</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Só é aplicable no contexto dunha función definida polo usuario
	(consulta <cmdref targ="function"/>). Provoca que a execución da
	function actual, remate coa sinalización dunha condición de fallo.
      </para>
      <para>
	O argumento <repl>mensaxe</repl> (opcional) pode ter
	a forma dunha cadea de texto literal, ou do nome dunha variable
	de cadea; se está presente, preséntase como parte da mensaxe
	de fallo que se lle amosa a quen invoca a función.
      </para>
      <para>
	Consulta tamén a función que está estreitamente vencellada,
	<fncref targ="errorif"/>.
      </para>
    </description>

  </command>

  <command name="function" section="Programming"
    label="Definir unha función" context="cli">

    <usage>
      <arguments>
        <argument>nomefunción</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Abre un bloque de expresións nas que se define unha función. Este
	bloque debe de estar rematado con <lit>end function</lit>. (Como
	excepción está o caso no que queiras eliminar unha función definida polo
	usuario, pois o podes conseguir mediante a sinxela liña de instrución
	<lit>function foo delete</lit> para a función chamada <quote>foo</quote>.)
	Consulta o <guideref targ="chap:functions"/> para obter máis detalles.
      </para>
    </description>

  </command>

  <command name="garch" section="Estimation" label="Modelo GARCH">

    <usage>
      <arguments>
        <argument>p</argument>
	      <argument>q</argument>
	      <argument separated="true">depvar</argument>
	      <argument optional="true">indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
	      </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--nc</flag>
	  <effect>Sen constante</effect>
        </option>
        <option>
	  <flag>--stdresid</flag>
	  <effect>Tipifica os erros</effect>
        </option>
        <option>
	  <flag>--fcp</flag>
	  <effect>Utiliza o algoritmo de Fiorentini, Calzolari e Panattoni</effect>
        </option>
        <option>
	  <flag>--arma-init</flag>
	  <effect>Parámetros iniciais da varianza partindo de ARMA</effect>
        </option>
      </options>
      <examples>
        <example>garch 1 1 ; y</example>
	<example>garch 1 1 ; y 0 x1 x2 --robust</example>
	<demos>
	  <demo>garch.inp</demo>
	  <demo>sw_ch14.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Estima un modelo GARCH (GARCH, Heterocedasticidade Condicional
	Autorregresiva Xeneralizada), ben nun modelo univariante ou
	ben incluíndo as variables esóxenas indicadas se especificas
	<repl>indepvars</repl>. Os valores enteiros <repl>p</repl> e
	<repl>q</repl> (que podes indicar en formato numérico ou con
	nomes de variables escalares xa existentes) representan os
	niveis de retardo na ecuación de varianza condicional:
	<equation status="display"
	  tex="\[h_t = \alpha_0 + \sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} +
	  \sum_{j=1}^p \beta_j h_{t-j}\]"
	  ascii="h(t) = a(0) + sum(i=1 to q) a(i)*u(t-i)^2 + sum(j=1 to p) b(j)*h(t-j)"
	  graphic="garch_h"/>
      </para>
      <para context="cli">
	Así, o parámetro <repl>p</repl> representa o nivel Xeneralizado
	(ou <quote>AR</quote>), mentres que <repl>q</repl> representa o nivel
	normal ARCH (ou <quote>MA</quote>). Cando <repl>p</repl> é non nulo,
	<repl>q</repl> tamén debe ser non nulo; se non, o modelo non está
	identificado. Con todo, podes estimar un modelo ARCH normal establecendo
	que <repl>q</repl> é un valor positivo, e que <repl>p</repl> é cero.
	A suma de <repl>p</repl> e <repl>q</repl> non debe de ser maior ca
	5. Ten en conta que se inclúe automaticamente unha constante na
	ecuación media, agás cando indiques a opción <opt>nc</opt>.
      </para>

      <para context="gui">
	Estima un modelo GARCH (GARCH, Heterocedasticidade Condicional
	Autorregresiva Xeneralizada), ben nun modelo univariante ou ben
	incluíndo as variables esóxenas indicadas (cando se escollen
	variables independentes). A ecuación da varianza condicionada
	amósase abaixo.
	<equation status="display" tex="\[h_t = \alpha_0 +
	\sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} + \sum_{j=1}^p
	\beta_i h_{t-j}\]" ascii="h(t) = a(0) + sum(i=1 to q) a(i)*u(t-i) +
	sum(j=1 to p) b(j)*h(t-j)" graphic="garch_h"/>
      </para>
      <para context="gui">
	Así, o parámetro <repl>p</repl> representa o nivel Xeneralizado
	(ou <quote>AR</quote>), mentres que <repl>q</repl> representa o nivel
	normal ARCH (ou <quote>MA</quote>). Cando <repl>p</repl> é non nulo,
	<repl>q</repl> tamén debe ser non nulo; se non, o modelo non está
	identificado. Con todo, podes estimar un modelo ARCH normal establecendo
	que <repl>q</repl> é un valor positivo, e que <repl>p</repl> é cero.
	A suma de <repl>p</repl> e <repl>q</repl> non debe de ser maior ca
	5.
      </para>

      <para>
	Por defecto, utilízase o propio código de GRETL para estimar os
	modelos GARCH, pero tamén tes a opción de usar o algoritmo de
	<cite key="fiorentini96">Fiorentini, Calzolari e Panattoni (1996)</cite>.
	O primeiro utiliza o maximizador BFGS mentres que o último usa
	a matriz de información para maximizar a verosimilitude, cunha
	posta a punto mediante a matriz Hessiana.
      </para>

      <para context="cli">
	Con esta instrución dispós de diversas variantes da matriz
	estimada das covarianzas dos estimadores. Por defecto, utilízase
	a matriz Hessiana agás que indiques a opción <opt>robust</opt>,
	en cuxo caso vaise usar a matriz de covarianzas CMV (QML de White).
	Tamén se poden especificar outras posibilidades (&eg; a matriz
	de información ou o estimador de Bollerslev&ndash;Wooldridge)
	mediante a chave <lit>garch_vcv</lit> baixo a instrución
	<cmdref targ="set"/>.
      </para>

      <para context="gui">
	Con esta instrución dispós de diversas variantes da matriz estimada
	das covarianzas dos estimadores. Por defecto, utilízase a
	matriz Hessiana agás que marques o cadriño
	<quote>Desvíos padrón robustos</quote>, en cuxo caso vaise
	usar a matriz de covarianzas CMV (QML de White). Tamén podes
	especificar outras posibilidades (&eg; a matriz de información
	ou o estimador de Bollerslev&ndash;Wooldridge) utilizando a
	instrución <cmdref targ="set"/>.
      </para>

      <para context="gui">
	Podes acceder á varianza condicionada estimada, así como aos
	erros e a varios outros estatísticos do modelo, e engadilos ao
	conxunto de datos utilizando o menú <quote>Gardar</quote> da
	xanela onde se presenta o modelo. Se marcas o cadriño titulado
	<quote>Estandarizar os erros</quote>, divídense os erros pola
	raíz cadrada da varianza condicionada.
      </para>

      <para context="cli">
	Por defecto, as estimacións dos parámetros da varianza inícianse
	usando a varianza da perturbación non condicionada dunha estimación
	inicial por MCO (para a constante) e valores positivos pequenos
	(para os coeficientes que acompañan aos valores pasados tanto das
	perturbacións cadradas como da varianza da perturbación). A opción
	<opt>arma-init</opt> solicita que, para establecer os valores
	iniciais destes parámetros, se utilice un modelo inicial ARMA,
	explotando a relación entre GARCH e ARMA exposta no capítulo 21
	do libro <book>Time Series Analysis</book> de Hamilton. Nalgúns
	casos, isto pode mellorar as posibilidades de converxencia.
      </para>

      <para context="cli">
	Podes recuperar os erros GARCH e a varianza condicionada estimada
	con <lit>$uhat</lit> e <lit>$h</lit>, respectivamente. Por exemplo,
	para obter a varianza condicional:
      </para>
      <code context="cli">
	series ht = $h
      </code>
      <para context="cli">
	Cando indicas a opción <opt>stdresid</opt>, divídense os valores de
	<lit>$uhat</lit> pola raíz cadrada de <math>h</math><sub>t</sub>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelar/Series temporais univariantes/GARCH</menu-path>
    </gui-access>

  </command>

  <command name="genr" section="Dataset"
    label="Xerar unha nova variable">

    <usage>
      <arguments>
        <argument>novavariable</argument>
        <argument>= fórmula</argument>
      </arguments>
    </usage>

    <description>

      <para>
	NOTA: Esta instrución experimentou numerosos cambios e melloras
	desde que se escribiu o seguinte texto de axuda, por iso para
	comprender e actualizar a información sobre esta instrución, deberás
	de seguir a referencia do <guideref targ="chap:genr"/>. Por outra banda,
	esta axuda non contén nada actualmente incorrecto, polo que interpreta
	o que sigue como <quote>tes isto, e máis</quote>.
      </para>

      <para context="cli">
	Para esta instrución e no contexto apropiado, as expresións
	<lit>series</lit>, <lit>scalar</lit>, <lit>matrix</lit>,
	<lit>string</lit>, <lit>bundle</lit> e <lit>array</lit> son
	sinónimos.
      </para>

      <para context="cli">
	Xera novas variables, habitualmente mediante transformacións das
	variables xa existentes. Consulta tamén <cmdref targ="diff"/>,
	<cmdref targ="logs"/>, <cmdref targ="lags"/>, <cmdref targ="ldiff"/>,
	<cmdref targ="sdiff"/> e <cmdref targ="square"/> como atallos.
	No contexto dunha fórmula <lit>genr</lit>, debes facer referencia
	ás variables xa existentes mediante o seu nome, non co seu número ID.
	A fórmula debe de ser unha combinación ben feita de nomes de
	variables, constantes, operadores e funcións (descrito máis
	abaixo). Ten en conta que podes atopar máis detalles sobre
	algúns aspectos desta instrución no <guideref targ="chap:genr"/>.
      </para>

      <para context="gui">
	Utiliza esta caixa para definir unha nova variable, co padrón
	<repl>novavariable</repl> = <repl>fórmula</repl>. A fórmula debe
	de ser unha combinación ben feita de nomes de variables, constantes,
	operadores e funcións (detalles máis abaixo). Para asegurarte
	de que obtés o tipo de variable que queres, podes preceder a
	fórmula cun tipo de nome (&eg; <lit>scalar</lit>, <lit>series</lit>
	ou <lit>matrix</lit>). Por exemplo, para xerar unha serie que
	teña un valor constante igual a 10, podes escribir
      </para>
      <code context="gui">
	series c = 10
      </code>
      <para context="gui">
	(se non, <lit>c = 10</lit> xeraría unha variable escalar).
      </para>

      <para context="cli">
	Unha instrución <lit>genr</lit> pode producir un resultado escalar ou
	unha serie. Por exemplo, a fórmula <lit>x2 = x * 2</lit> naturalmente
	produce unha serie cando a variable <lit>x</lit> é unha serie, e un
	escalar cando <lit>x</lit> é un escalar. As fórmulas <lit>x = 0</lit> e
	<lit>mx = mean(x)</lit> naturalmente devolven escalares. Baixo certas
	circunstancias, podes querer ter un resultado escalar ampliado a unha
	serie ou vector; isto podes facelo utilizando <lit>series</lit> coma
	un <quote>alcume</quote> para a instrución <lit>genr</lit>. Por
	exemplo, <lit>series x = 0</lit> produce unha serie na que todos os
	seus valores póñense a 0. Tamén podes utilizar <lit>scalar</lit> coma
	alcume de <lit>genr</lit>. Non é posible forzar a un resultado en forma
	de vector que sexa un escalar, pero a utilización desta palabra chave
	indica que o resultado <emphasis>debera ser</emphasis> un escalar:
	se non o é, xorde un fallo.
      </para>

      <para context="cli">
	Cando unha fórmula produce un resultado en forma de serie, o rango
	sobre o que se escribe ese resultado na variable obxectivo depende
	da configuración vixente da mostra. Polo tanto, podes definir unha
	serie feita a cachos utilizando a instrución <lit>smpl</lit> xunto con
	<lit>genr</lit>.
      </para>

      <para>
	Se admiten os <emphasis>operadores aritméticos</emphasis>,
	en orde de prioridade: <lit>^</lit> (elevar á potencia);
	<lit>*</lit>, <lit>/</lit> e <lit>%</lit> (módulo ou resto);
	<lit>+</lit> e <lit>-</lit>.
      </para>

      <para>
	Os <emphasis>operadores booleanos </emphasis> dispoñibles son
	(de novo, en orde de prioridade): <lit>!</lit> (negación),
	<lit>&amp;&amp;</lit> (E lóxico), <lit>||</lit> (OU lóxico),
	<lit>&gt;</lit>, <lit>&lt;</lit>, <lit>==</lit> (igual a),
	<lit>&gt;=</lit> (maior ou igual que), <lit>&lt;=</lit> (menor ou igual que)
	e <lit>!=</lit> (non igual). Tamén podes utilizar os operadores
	booleanos na construción de variables ficticias: por exemplo,
	<lit>(x &gt; 10)</lit> devolve 1 no caso de que <lit>x</lit> &gt; 10,
	e 0 noutro caso.
      </para>

      <para>
	As constantes integradas son <lit>pi</lit> e <lit>NA</lit>. A última
	é o código de valor ausente: podes iniciar unha variable co valor
	ausente mediante <lit>scalar x = NA</lit>.
      </para>

      <para>
	A instrución <lit>genr</lit> admite un amplo rango de funcións
	matemáticas e estatísticas, incluíndo todas as habituais máis
	varias que son especiais de Econometría. Ademais, ofrece acceso
	a moitas variables internas que se definen durante a execución
	das regresións, a realización de probas de hipóteses, etcétera.
	<refnote xref="false">
	  Para obter unha listaxe de funcións e accesorios, escribe
	  <quote>help functions</quote>.
	</refnote>
	<refnote xref="true">
	  Para ver unha listaxe de funcións e accesorios, consulta a
	  <gfr targ="chap:funcref"/>.
	</refnote>
      </para>

      <para>
	Ademais dos operadores e das funcións indicados arriba, hai
	algúns usos especiais de <cmd>genr</cmd>:
      </para>

      <ilist>
	<li>
	    <para>
	    <cmd>genr time</cmd> xera unha variable de tendencia temporal
	    (1,2,3,&hellip;) chamada <cmd>time</cmd>. E <cmd>genr index</cmd>
	    ten o mesmo efecto, salvo que a variable chámase <lit>index</lit>.
	    </para>
	</li>
	<li>
	    <para>
	    <cmd>genr dummy</cmd> xera tantas variables ficticias como
	    sexa a periodicidade dos datos. No caso de dispoñer datos
	    trimestrais (periodicidade 4), o programa xera <lit>dq1</lit> = 1
	    para o primeiro trimestre e 0 para os outros trimestres,
	    <lit>dq2</lit> = 1 para o segundo trimestre e 0 para os outros
	    trimestres, etcétera. Con datos mensuais, as variables ficticias
	    noméanse <lit>dm1</lit>, <lit>dm2</lit>, etcétera; con datos
	    diarios, noméanse <lit>dd1</lit>, <lit>dd2</lit>, etcétera;
	    e con outras frecuencias, os nomes son <lit>dummy_1</lit>,
	    <lit>dummy_2</lit>, etc.
	    </para>
	</li>
	<li>
	  <para>
	    <cmd>genr unitdum</cmd> e <cmd>genr timedum</cmd> xeran conxuntos
	    de variables ficticias especiais para utilizar con datos de panel,
	    codificando as unidades de sección cruzada coa primeira e o período
	    de tempo das observacións coa segunda.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Advertencia</emphasis>: Co programa en liñas de instrución,
	as instrucións <cmd>genr</cmd> que recuperan datos relacionados cun
	modelo, sempre se refiren ao modelo que se estimou máis recentemente.
	Isto tamén é certo no programa de Interface Gráfica de Usuario (GUI),
	cando utilizas <cmd>genr</cmd> na <quote>consola de GRETL</quote>ou se
	introduces unha fórmula usando a opción <quote>Definir nova variable</quote>
	baixo o menú Engadir na xanela principal. Coa GUI, porén, tes a opción
	de recuperar datos de calquera dos modelos que se amosan nese momento
	nunha xanela (sexa ou non sexa o modelo estimado máis recentemente).
	Podes facer isto baixo o menú <quote>Gardar</quote> da xanela do
	modelo correspondente.
      </para>

      <para>
	A variable especial <lit>obs</lit> serve como índice para as observacións.
	Por exemplo, <lit>series dum = (obs==15)</lit> xera unha variable
	ficticia que ten valor 1 para a observación 15, e o valor 0 noutro caso.
	Tamén podes usar esta variable para escoller observacións concretas
	por data ou nome. Por exemplo, <lit>series d = (obs&gt;1986:4)</lit>,
	<lit>series d = (obs&gt;"2008-04-01")</lit>, ou
	<lit>series d = (obs=="CA")</lit>. Cando utilizas datas diarias ou
	marcadores de observación neste contexto, debes de contornalas entre
	comiñas, pero podes usar as datas trimestrais e mensuais (cos dous
	puntos) sen comiñas. Ten en conta que, no caso de datos de series
	temporais anuais, o ano non se distingue sintacticamente dun sinxelo
	número enteiro. Polo tanto, se queres comparar observacións fronte a
	<lit>obs</lit> por ano, debes de usar a función <lit>obsnum</lit> para
	converter así o ano nun valor índice en base 1, como se fai en
	<lit>series d = (obs&gt;obsnum(1986))</lit>.
      </para>

      <para>
	Podes sacar os valores escalares dunha serie no contexto dunha
	fórmula <lit>genr</lit>, utilizando a sintaxe
	<repl>varname</repl><lit>[</lit><repl>obs</repl><lit>]</lit> na que
	podes indicar o valor <repl>obs</repl> por número ou data. Exemplos:
	<lit>x[5]</lit>, <lit>CPI[1996:01]</lit>. Para datos diarios, debes de
	usar a forma <repl>YYYY-MM-DD</repl>; &eg; <lit>ibm[1970-01-23]</lit>.
      </para>

      <para>
	Podes modificar unha observación individual dunha serie mediante
	<lit>genr</lit>. Para facer isto, debes de engadir un número válido de
	observación ou de data, entre corchetes, ao nome da variable
	no lado esquerdo da fórmula. Por exemplo, <lit>genr x[3] = 30</lit>
	ou <lit>genr x[1950:04] = 303.7</lit>.
      </para>

      <table id="tab-genr" title="Exemplos de uso da instrución genr"
	lhead="Fórmula" rhead="Comentario" lwidth="100pt" rwidth="300pt"
	style="rpara">
	<row>
	  <cell><lit>y = x1^3</lit></cell>
	  <cell><lit>x1</lit> ao cubo</cell>
	</row>
	<row>
	  <cell><lit>y = ln((x1+x2)/x3)</lit></cell>
	  <cell></cell>
	</row>
	<row>
	  <cell><lit>z = x&gt;y</lit></cell>
	  <cell><lit>z(t)</lit> = 1 se <lit>x(t) &gt; y(t)</lit>,
	    se non 0</cell>
	</row>
	<row>
	  <cell><lit>y = x(-2)</lit></cell>
	  <cell><lit>x</lit> retardada 2 períodos</cell>
	</row>
	<row>
	  <cell><lit>y = x(+2)</lit></cell>
	  <cell><lit>x</lit> adiantada 2 períodos</cell>
	</row>
	<row>
	  <cell><lit>y = diff(x)</lit></cell>
	  <cell><lit>y(t) = x(t) - x(t-1)</lit></cell>
	</row>
	<row>
	  <cell><lit>y = ldiff(x)</lit></cell>
	  <cell><lit>y(t) = log x(t) - log x(t-1)</lit>, a taxa
	    de crecemento instantáneo de <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sort(x)</lit></cell>
	  <cell>Ordena <lit>x</lit> en orde ascendente e gárdao en
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = dsort(x)</lit></cell>
	  <cell>Ordena <lit>x</lit> en orde descendente</cell>
	</row>
	<row>
	  <cell><lit>y = int(x)</lit></cell>
	  <cell>Tronza <lit>x</lit> e garda o seu valor enteiro como
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = abs(x)</lit></cell>
	  <cell>Garda os valores absolutos de <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sum(x)</lit></cell>
	  <cell>Suma os valores de <lit>x</lit> excluíndo as entradas
	  ausentes <lit>NA</lit></cell>
	</row>
	<row>
	  <cell><lit>y = cum(x)</lit></cell>
	  <cell>Acumulación:
		<equation status="inline"
		  tex="$y_t = \sum_{\tau=1}^t x_{\tau}$"
		  ascii="y(t) = suma desde s=1 ata s=t de x(s)"
		  graphic="cumulate"/>
	  </cell>
	</row>
	<row>
	  <cell><lit>aa = $ess</lit></cell>
	  <cell>Establece <lit>aa</lit> igual á Suma de Erros Cadrados
	    da derradeira regresión</cell>
	</row>
	<row>
	  <cell><lit>x = $coeff(sqft)</lit></cell>
	  <cell>Apaña o coeficiente estimado da variable
	    <lit>sqft</lit> da derradeira regresión</cell>
	</row>
	<row>
	  <cell><lit>rho4 = $rho(4)</lit></cell>
	  <cell>Apaña o coeficiente autorregresivo de orde 4 do
	    derradeiro modelo (asume un modelo <lit>ar</lit>)</cell>
	</row>
	<row>
	  <cell><lit>cvx1x2 = $vcv(x1, x2)</lit></cell>
	  <cell>Apaña a covarianza estimada dos coeficientes das
	    variables <lit>x1</lit> e <lit>x2</lit> do derradeiro modelo</cell>
	</row>
	<row>
	  <cell><lit>foo = uniform()</lit></cell>
	  <cell>Variable pseudoaleatoria Uniforme no rango
	    0&ndash;1</cell>
	</row>
	<row>
	  <cell><lit>bar = 3 * normal()</lit></cell>
	  <cell>Variable pseudoaleatoria Normal, &mu; = 0, &sigma; =
	    3</cell>
	</row>
	<row>
	  <cell><lit>samp = ok(x)</lit></cell>
	  <cell>= 1 para as observacións onde <lit>x</lit> non está
	    ausente</cell>
	</row>
      </table>

    </description>

    <gui-access>
      <menu-path>/Engadir/Definir nova variable</menu-path>
      <other-access>Xanela principal: Menú emerxente</other-access>
    </gui-access>

  </command>

  <command name="genrand" section="Programming" context="gui"
    label="Xerar variables aleatorias">

    <description>
      <para>
	Neste diálogo debes de indicar un nome para a variable que se vai
	xerar, máis algunha información adicional dependendo do tipo de
	distribución.
      </para>

      <ilist>
	<li>
	    <para>
	    Uniforme: Os límites inferior e superior da distribución.
	    </para>
	</li>
	<li>
	    <para>
	    Normal: A media e o desvío padrón (positivo).
	    </para>
	</li>
	<li>
	    <para>
	    Khi-cadrado e t de Student: Os graos de liberdade (que deben de
	    ser positivos).
	    </para>
	</li>
	<li>
	    <para>
	    F: Os graos de liberdade tanto do numerador como do denominador.
	    </para>
	</li>
	<li>
	    <para>
	    Gamma: Os parámetros de forma e de escala (ambos positivos).
	    </para>
	</li>
	<li>
	    <para>
	    Binomial: A probabilidade de <quote>éxito</quote> e un enteiro co
	    número de intentos.
	  </para>
	</li>
	<li>
	  <para>
	    Poisson: A media positiva (que tamén é igual á varianza).
	  </para>
	</li>
      </ilist>

      <para>
	Se queres xerar secuencias repetibles de números pseudoaleatorios,
	podes establecer a semente mediante o elemento
	<mnu targ="SetSeed">Semente de números aleatorios</mnu>,
	no menú Ferramentas.
      </para>

    </description>
  </command>

  <command name="genseed" section="Programming" context="gui"
    label="Establecer a semente para números aleatorios">

    <description>
      <para>
	A 'semente' controla o punto de inicio para a secuencia de números
	pseudoaleatorios xerados nunha sesión determinada de GRETL. Por defecto,
	a semente establécese cando se inicia o programa, utilizando o
	reloxo do sistema. Isto te asegura que obtés unha secuencia distinta
	de números aleatorios cada vez que executas o programa. Se queres
	obter secuencias repetibles, necesitas establecer a semente de forma
	manual (e tomar nota do valor que utilizas).
      </para>
      <para>
	Ten en conta que sempre que premes un clic 'OK' nesta caixa de
	diálogo, o xerador vólvese reiniciar utilizando a semente indicada.
	Así, por exemplo, se (a) estableces a semente en (digamos) 147;
	(b) xeras unha serie con distribución Normal estándar; (c) volves
	visitar este diálogo e premes un clic 'OK' de novo coa semente
	aínda en 147; e (d) xeras unha segunda serie con distribución
	Normal estándar, as dúas series xeradas serán idénticas.
      </para>
    </description>
  </command>

  <command name="gibbs" section="Statistics" label="Mostraxe de Gibbs">

    <usage>
      <arguments>
        <argument>queimado</argument>
        <argument>N</argument>
        <argument>saída</argument>
      </arguments>  
      <options>
	<option>
	  <flag>--cleanup</flag>
	  <effect>Mira abaixo</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
      <examples>
	<demos>
	  <demo>casella_ex1.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	   <emphasis>Esta documentación é provisoria e está suxeita a
	   trocos antes da seguinte versión de GRETL.</emphasis>
      </para>
      <para>
	Esta instrución está deseñada para facilitar a construción e execución
	dunha mostraxe de Gibbs; para unha boa explicación da mesma,
	consulta <cite key="casella92">Casella e George (1992)</cite>.
	De xeito resumido, a mostraxe de Gibbs é un xeito de aproximar a
	distribución marxinal de unha ou máis variables aleatorias que
	pertencen a unha distribución conxunta no caso de que non exista
	unha expresión analítica para as marxinais, ou de que sexa
	excesivamente complexa, se existe. Isto acádase mediante a
	simulación repetida das distribucións condicionadas asociadas.
	Dado que as marxinais existen, pódense aproximar a unha precisión
	arbitraria indicando un número suficiente de
	iteracións.
      </para>
      <para>
	A instrución ten a forma dun bloque de enunciados que definen
	obxectos de tipo escalar ou matricial, iniciado con <lit>gibbs</lit>
	e rematado con <lit>end gibbs</lit>. A estrutura ilústrase no
	sinxelo exemplo seguinte, no que <lit>x</lit> segue unha
	distribución Binomial condicionada a <lit>y</lit>, quen pola
	súa banda segue unha distribución Beta condicionada a <lit>x</lit>,
	e o que interesa é a distribución marxinal de
	<lit>x</lit>.
      </para>
      <code>
	gibbs burnin=500 N=5000 output=M
	   init y = randgen1(beta, a, n - b)
	   record x = randgen1(b, y, n)
	   y = randgen1(beta, x + a, n - x + b)
	end gibbs --verbose
      </code>
      <para>
	Na primeira liña debe indicarse un enteiro non negativo para
	o <lit>queimado</lit> e un enteiro positivo para <lit>N</lit>
	(ben como valores numéricos, ben mediante os nomes de variables
	escalares). O valor de <lit>queimado</lit> determina o número de
	iteracións preliminares que se van tentar para estabilizar o proceso
	recursivo e que non se van gravar, mentres que <lit>N</lit>indica
	o número de iteracións que se van gravar, nunha matriz nomeada
	mediante o argumento <lit>saída</lit>.
      </para>
      <para>
	As liñas interiores do bloque poden ter unha clave anteposta,
	ben <lit>init</lit> ou ben <lit>record</lit>, cos seguintes
	significados.
      </para>
      <ilist>
  <li>
      <para>
        <lit>init</lit> identifica un enunciado como o iniciador que se
        executa só unha vez previamente á iteración de Gibbs.
      </para>
  </li>
  <li>
      <para>
        <lit>record</lit> etiqueta un enunciado como aquel cuxo
        resultado debe gravarse en cada iteración.
      </para>
  </li>
      </ilist>
      <para>
	Os enunciados que non caracterizan ningunha chave se considera que
	son parte da iteración, pero os seus resultados non se gravan na matriz
	de saída. Os enunciados que se etiqueten con <lit>init</lit> deberán
	indicarse primeiro.
      </para>
      <para>
	A matriz de saída ten <lit>N</lit> filas e unha dimensión de columnas
	que depende do número e do tipo de marxinais que se graven; os
	resultados da matriz grávanse en formato vec trasposto. Se xa existe
	o nome de matriz indicado no argumento <lit>saída</lit>, sobrescríbese;
	doutro xeito, créase unha nova matriz.
      </para>
      <para>
	Admítense dúas opcións, que deben engadirse á derradeira liña do
	bloque. A opción <opt>verbose</opt> produce un breve informe de
	progreso e algúns estatísticos básicos de resumo, correspondentes
	á matriz de saída de resultados. A opción <opt>cleanup</opt> ten
	como efecto que calquera nova variable creada dentro do bloque
	<lit>gibbs</lit>, vaise eliminar unha vez que se complete a
	iteración.
      </para>
    </description>
  </command>

  <command name="gmm" section="Estimation" label="Estimación MXM (GMM)">

    <usage>
      <options>
	<option>
	  <flag>--two-step</flag>
	  <effect>Estimación en 2 etapas</effect>
	</option>
	<option>
	  <flag>--iterate</flag>
	  <effect>MXM (GMM) reiterados</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
	</option>
	<option>
	  <flag>--lbfgs</flag>
	  <effect>Utiliza L-BFGS-B en lugar do BFGS normal</effect>
	</option>
      </options>
	<examples>
     <demos>
	  <demo>hall_cbapm.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Realiza a estimación co Método Xeneralizado dos Momentos (MXM ou GMM)
	utilizando o algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno).
	Debes de especificar: (a) unha ou máis instrucións para actualizar as
	cantidades relevantes (tipicamente erros MXM), (b) un ou máis conxuntos
	de condicións de ortogonalidade, (c) unha matriz inicial de ponderacións,
	e (d) unha listaxe cos parámetros a estimar, todo contornado entre
	as etiquetas <lit>gmm</lit> e <lit>end gmm</lit>. Calquera opción
	deberá de engadirse á liña <lit>end gmm</lit>.
      </para>
      <para>
	Consulta o <guideref targ="chap:gmm"/> para obter máis detalles sobre
	esta instrución. Aquí simplemente o ilustramos cun exemplo sinxelo.
      </para>
      <code>
	gmm e = y - X*b
	  orthog e ; W
	  weights V
	  params b
	end gmm
      </code>
      <para>
	No exemplo de arriba, asumimos que tanto <lit>y</lit> como <lit>X</lit> son
	matrices de datos, <lit>b</lit> é un vector de valores dos parámetros
	coa dimensión adecuada, <lit>W</lit> é unha matriz de instrumentos, e
	<lit>V</lit> é unha matriz axeitada de ponderacións. A expresión
      </para>
      <code>
	orthog e ; W
      </code>
      <para>
	indica que o vector de erros (<lit>e</lit>) é ortogonal, en principio,
	a cada un dos instrumentos que constitúen as columnas de
	<lit>W</lit>.
      </para>
      <subhead>Nomes dos parámetros</subhead>
      <para>
	Ao estimar un modelo non linear, frecuentemente resulta conveniente
	que nomees os parámetros de xeito conciso. Ao presentar os resultados,
	porén, pode que desexes utilizar etiquetas máis informativas. Podes
	acadar isto mediante a palabra chave adicional <lit>param_names</lit>
	dentro do bloque de instrución. Para un modelo con <math>k</math>
	parámetros, o argumento que sigue a esta palabra chave debe de ser
	unha cadea de texto literal entre comiñas que conteña <math>k</math>
	nomes separados por espazos, o nome dunha variable de cadea que
	conteña <math>k</math> deses nomes, ou o nome dun arranxo con
	<math>k</math> cadeas de texto.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Variables Instrumentais/Método Xeneralizado Momentos</menu-path>
    </gui-access>

  </command>

  <command name="gnuplot" section="Graphs"
    label="Xerar unha gráfica Gnuplot" context="cli">

    <usage>
      <altforms>
        <altform><lit>gnuplot</lit> <repl>yvars</repl> <repl>xvar</repl></altform>
        <altform><lit>gnuplot</lit> <repl>yvars</repl> <lit>--time-series</lit></altform>
        <altform><lit>gnuplot</lit> <repl>yvars</repl> <repl>xvar</repl> <repl>factor</repl> <lit>--factorized</lit></altform>
        <altform><lit>gnuplot</lit> <repl>yvar</repl> <repl>xvar</repl> <repl>zvars</repl> <lit>--control</lit></altform>
      </altforms>
      <options>
        <option>
	  <flag>--with-lines</flag>
	  <optparm optional="true">varspec</optparm>
	  <effect>Utiliza liñas, puntos non</effect>
        </option>
        <option>
	  <flag>--with-lp</flag>
	  <optparm optional="true">varspec</optparm>
	  <effect>Utiliza liñas e puntos</effect>
        </option>
        <option>
	  <flag>--with-impulses</flag>
	  <optparm optional="true">varspec</optparm>
	  <effect>Utilizar barras finas verticais</effect>
        </option>
        <option>
	  <flag>--with-boxes</flag>
	  <optparm optional="true">varspec</optparm>
	  <effect>Utiliza histogramas</effect>
        </option>
        <option>
	  <flag>--with-steps</flag>
	  <optparm optional="true">varspec</optparm>
	  <effect>Utiliza segmentos de liñas perpendiculares (pasos)</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>Representa fronte ao tempo</effect>
        </option>
        <option>
	  <flag>--single-yaxis</flag>
	  <effect>Forza o uso dun único eixe de ordenadas</effect>
        </option>
        <option>
	  <flag>--y2axis</flag>
	  <optparm>yvar</optparm>
	  <effect>Coloca a variable especificada nun segundo eixe y</effect>
        </option>
        <option>
	  <flag>--ylogscale</flag>
	  <optparm optional="true">base</optparm>
	  <effect>Utiliza a escala logarítmica para o eixe vertical</effect>
        </option>
        <option>
	  <flag>--control</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--factorized</flag>
          <optparm optional="true">lista</optparm>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--fit</flag>
	  <optparm>espaxuste</optparm>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--font</flag>
	  <optparm>espfonte</optparm>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--band</flag>
	  <optparm>espfranxa</optparm>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nomematriz</optparm>
	  <effect>Representa as columnas da matriz indicada</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía o resultado ao ficheiro especificado</effect>
        </option>
        <option>
	  <flag>--outbuf</flag>
	  <optparm>nomecadea</optparm>
	  <effect>Envía o resultado á cadea de texto especificada</effect>
        </option>
        <option>
	  <flag>--input</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Colle a entrada de datos desde un ficheiro especificado</effect>
        </option>
        <option>
	  <flag>--inbuf</flag>
	  <optparm>nomecadea</optparm>
	  <effect>Colle a entrada de datos desde a cadea de texto especificada</effect>
        </option>
      </options>
      <examples>
        <example>gnuplot y1 y2 x</example>
        <example>gnuplot x --time-series --with-lines</example>
	<example>gnuplot wages educ gender --factorized</example>
	<example>gnuplot y x --fit=quadratic</example>
	<example>gnuplot y1 y2 x --with-lines=y2</example>
      </examples>
    </usage>

    <description>
      <para>
	As series da lista <repl>yvars</repl> debúxanse fronte a
	<repl>xvar</repl>. Para unha gráfica dunha serie temporal podes
	ben propoñer <lit>time</lit> en lugar de <repl>xvar</repl>, ou ben
	utilizar o indicador de opción <opt>time-series</opt>. Consulta
	tamén as instrucións<cmdref targ="plot"/> e <cmdref targ="panplot"/>.
      </para>
      <para>
	Por defecto, as posicións dos datos amósanse con puntos,
	pero podes anular isto indicando unha das seguintes opcións:
	<opt>with-lines</opt> (liñas e puntos), <opt>with-lp</opt>,
	<opt>with-impulses</opt> ou <opt>with-steps</opt>. Cando vas
	representar máis dunha variable no eixe da <math>y</math>, podes
	limitar o efecto destas opcións a un subconxunto das variables
	utilizando o parámetro <repl>varspec</repl>. Este deberá de ter o
	formato ben dunha listaxe cos nomes ou números (en ambos casos separados
	por comas) das variables que se van representar no xeito especificado,
	ou ben do nome dunha lista predefinida. Poñamos por caso, no último
	exemplo de arriba se amosa como representar <lit>y1</lit> e <lit>y2</lit>
	fronte a <lit>x</lit>, de tal xeito que <lit>y2</lit> represéntase
	cunha liña mentres <lit>y1</lit> con puntos.
      </para>
      <para>
	Cando <repl>yvars</repl> contén máis de unha variable, podería ser
	preferible utilizar dous eixes y (á esquerda e á dereita). Por defecto,
	isto se realiza automaticamente, mediante unha técnica heurística
	baseada nas escalas relativas das variables; pero podes utilizar dúas
	opcións (mutuamente excluíntes) para anular o predeterminado:
	<opt>single-yaxis</opt> evita o uso dun segundo eixe, mentres que
	<opt>y2axis=</opt><repl>yvar</repl> especifica que se represente unha
	certa variable (unicamente) en relación ao segundo eixe.
      </para>
	      <subhead>Gráficas factorizadas</subhead>
      <para>
	A opción <opt>factorized</opt> apoia á gráfica X&ndash;Y na que
	<repl>yvars</repl> se debuxan con distintos estilos (tipo de punto, cor)
	dependendo do valor dunha variable factorial discreta en cada
	observación. O factor débese especificar seguindo a variable
	<math>x</math>.
      </para>
      <para>
	O caso máis sinxelo representa unha única variable <math>y</math>
	con unha variable ficticia de tipo 0/1 como factor, como no terceiro
	exemplo de utilización indicado arriba que representa o salario (wage)
	fronte á educación, factorizado polo xénero (gender). Pero podes
	ter máis dunha variable <math>y</math>, e o factor pode ter máis
	de dous valores. Cando se van representar múltiples variables
	<math>y</math>, podes restrinxir o tratamento de factorización
	a un subconxunto engadindo un parámetro ao indicador de opcións:
	o nome dunha serie ou dunha lista de series. No seguinte exemplo
	<lit>y</lit> e <lit>yhat</lit> se representan fronte a <lit>x</lit>,
	con factorización mediante <lit>id</lit> limitada a
	<lit>y</lit>.
      </para>
      <code>
	gnuplot y yhat x id --with-lines=yhat --factorized=y
      </code>
      <subhead>Gráfica con control</subhead>
      <para>
	Cando se especifica a opción <opt>control</opt>, deben indicarse
	tres ou máis variables: unha única variable <math>y</math>, unha
	única variable <math>x</math>, e unha ou máis variables de control,
	<repl>zvars</repl>. O efecto disto é que tanto <math>y</math> como
	<math>x</math> se van regresar cada unha sobre <repl>zvars</repl>,
	e os erros de <math>y</math> se representan contra os erros de
	<math>x</math>. Esta gráfica amosa a relación entre <math>x</math>
	e <math>y</math> tendo en conta o efecto que os controis teñen
	sobre as dúas.
      </para>
      <subhead>Escala logarítmica</subhead>
      <para>
	Podes especificar que a escala do eixe <math>y</math> sexa logarítmica
	en troques de que sexa linear, utilizando a opción <opt>ylogscale</opt>,
	xunto cun parámetro de base.
	Por exemplo,
      </para>
      <code>
	gnuplot y x --ylogscale=2
      </code>
      <para>
	representa os datos de xeito que o eixe vertical se expresa con potencias
	de 2. Se non especificas a base, por defecto, establécese igual a 10.
      </para>
      <subhead>Collendo datos dunha matriz</subhead>
      <para>
	No caso básico requírense os argumentos <repl>yvars</repl> e
	<repl>xvar</repl> que se refiren a series do conxunto vixente de datos
	(indicados ben polo nome ou ben polo número ID). Pero se mediante a
	opción <opt>matrix</opt>, indicas unha matriz xa definida, estes
	argumentos convértense en opcionais: se a matriz especificada ten
	<math>k</math> columnas, por defecto trátanse as primeiras
	<math>k</math> &minus; 1 columnas como as <repl>yvars</repl>, e a
	última columna trátase como <repl>xvar</repl>. Porén, cando indicas
	a opción <opt>time-series</opt>, todas as <math>k</math> columnas
	represéntanse fronte ao tempo. Se queres representar columnas
	escollidas da matriz, debes de especificar <repl>yvars</repl>
	e <repl>xvar</repl> co formato de números de columna enteiros
	positivos. Por exemplo, se queres unha gráfica de dispersión da
	columna 2 da matriz <lit>M</lit> fronte á columna 1, podes facer:
      </para>
      <code>
	gnuplot 2 1 --matrix=M
      </code>
      <subhead>Amosar a liña do mellor axuste</subhead>
      <para>
	A opción <opt>fit</opt> é só aplicable en gráficas de dispersión de dúas
	variables e en gráficas de series temporais individuais. Por defecto, o
	procedemento nunha gráfica de dispersión consiste en amosar o axuste MCO se
	o coeficiente da pendente é significativo a un nivel do 10 por cento,
	mentres que o proceder para as series temporais é non amosar ningunha
	liña de axuste. Podes solicitar un comportamento diferente utilizando
	esta opción xunto con algún dos seguintes valores dos parámetros
	<repl>espaxuste</repl>. Ten en conta que se a gráfica é para unha serie
	temporal individual, o lugar de <math>x</math> o ocupa 'time'.
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>linear</lit>: Amosa o axuste MCO linear independentemente
	    do nivel de significación estatística.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>none</lit>: Non amosa ningunha liña de axuste.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>inverse</lit> (inversa), <lit>quadratic</lit> (cuadrática),
	    <lit>cubic</lit> (cúbica), <lit>semilog</lit> ou <lit>linlog</lit>:
	    Amosan unha liña de axuste baseada na regresión do tipo indicado.
	    Con <lit>semilog</lit> queremos dicir unha regresión do logaritmo de
	    <math>y</math> sobre <math>x</math>; entón a liña axustada representa
	    a esperanza condicionada de <math>y</math>, obtida mediante a función
	    exponencial. Con <lit>linlog</lit> quérese dicir unha regresión de
	    <math>y</math> sobre o logaritmo de <math>x</math>.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>loess</lit>: Amosa o axuste dunha regresión robusta
	    localmente ponderada (que tamén se coñece ás veces como
	    <quote>lowess</quote>).
	  </para>
	</li>
      </ilist>
      <subhead>Representando unha franxa</subhead>
      <para>
	Podes utilizar a opción <opt>band</opt> para representar unha
	<quote>franxa</quote> dalgún tipo (tipicamente representa un intervalo
	de confianza) xunto con outros datos. O xeito recomendado de especificar
	esa franxa é mediante un paquete (bundle), cuxo nome se indica como
	parámetro desa opción. Un paquete <lit>band</lit> require dous
	elementos que son necesarios: na clave <lit>center</lit>, o nome
	dunha serie para o centro da franxa; e una clave <lit>width</lit>, o
	nome dunha serie que represente o ancho da franxa (ambos indicados
	como cadeas de texto entre comiñas). Ademais, admítense outros catro
	elementos opcionais, do xeito que se indica a continuación.
      </para>
      <ilist>
	<li>
	  <para>Na clave <lit>factor</lit>: un escalar que indica o factor
	  polo que se debe multiplicar o ancho (sendo 1 o valor por
	  defecto).
	  </para>
	</li>
	<li>
	  <para>Na clave <lit>style</lit>: unha cadea de texto para
	  especificar como se representa a franxa; e que debe ser unha de entre
	  <lit>line</lit> (liña, predeterminada), <lit>fill</lit> (recheo),
	  <lit>dash</lit> (raia), <lit>bars</lit> (barra) ou <lit>step</lit> (chanzo).
	  </para>
	</li>
	<li>
	  <para>Na clave <lit>color</lit>: unha cor para a franxa, ben como
	  unha cadea de texto que conteña o nome dunha cor en Gnuplot, ou ben
	  como unha representación de RGB en hexadecimal, indicada como cadea
	  de texto ou como escalar (mira máis abaixo para obter máis detalles).
	  Por defecto, a cor selecciónase automaticamente.
	  </para>
	</li>
	<li>
	  <para>Na clave <lit>title</lit>: un título para a franxa, para que
	  apareza na clave ou lenda da gráfica. Por defecto, as franxas non
	  teñen título.
	  </para>
	</li>
      </ilist>
      <para>
	Aquí tes dous exemplos de uso, nos que se emprega a sintaxe abreviada
	<lit>_()</lit> para definir un paquete (bundle). O primeiro unicamente
	satisfai os requirimentos mínimos, mentres que no segundo se practican
	as tres opcións. Estase asumindo que todas as series <lit>y</lit>,
	<lit>x</lit> e <lit>w</lit> están no conxunto de datos vixente.
      </para>
      <code>
	bundle b1 = _(center="x", width="w")
	gnuplot y --time-series --with-lines --band=b1
	bundle b2 = _(center="x", width="w", factor=1.96, style="fill")
	b2.color=0xcccccc
	b2.title = "Intervalo do 95%"
	gnuplot y --time-series --with-lines --band=b2
      </code>
      <para>
	Se a gráfica vai conter dúas ou máis desas bandas, o indicador de
	opción débese expresar en plural, e o seu parámetro debe ser o nome
	dun <emphasis>arranxo</emphasis> de paquetes (bundles), como
	(continuando o exemplo anterior) no que segue:
      </para>
      <code>
	bundles bb = defarray(b1, b2)
	gnuplot y --time-series --with-lines --bands=bb
      </code>
      <para>
	Cando se representa graficamente unha matriz, en troques de datos de
	series, a única diferenza é que os elementos <lit>centro</lit> (center)
	e <lit>ancho</lit> (width) do paquete da franxa substitúense por un
	único elemento na clave <lit>bandmat</lit>. Este ten que indicar unha
	matriz con dúas columnas, co centro da banda na primeira columna
	e o ancho na segunda. Como alternativa, podes indicar unha cadea de
	texto baixo esta chave: o <i>nome entre comiñas</i> dunha matriz
	axeitada. Esta variante pode ser preferible se a matriz en cuestión
	vaise reutilizar con distintos valores do factor, dado que evita ter
	que duplicar a matriz na memoria.
      </para>
      <subhead>Barras de recesión</subhead>
      <para>
	Tamén podes utilizar a opción <quote>band</quote> para engadir
	<quote>barras de recesión</quote> a unha gráfica. Deste xeito estámonos
	a referir a barras verticais que ocupan todo o rango da dimensión
	<math>y</math> da gráfica, e que indican a presenza (coa barra) ou a
	ausencia (sen barra) dalgunha característica cualitativa, nunha gráfica
	de series temporais. Estas barras utilízanse habitualmente para indicar
	períodos de recesión; pero tamén podes usalas para sinalar períodos de
	guerra, ou calquera cousa que poda codificarse cunha variable ficticia 0/1.
      </para>
      <para>
	Neste contexto, o paquete (bundle) da franxa require un único elemento:
	na clave <lit>dummy</lit>, un nome entre comiñas dunha serie 0/1 (ou
	o nome entre comiñas dun vector columna axeitado, no caso dunha
	matriz de datos). As barras verticais estarán <quote>activas</quote>
	para as observacións nas que esa serie ou vector tome o valor 1 e
	<quote>inactivas</quote> cando sexa 0. As claves de <lit>centro</lit>
	(center), <lit>ancho</lit> (width), <lit>factor</lit> e <lit>estilo</lit>
	(style) non son pertinentes, pero pódese usar <lit>color</lit>. Observa
	que só pode usarse unha desas especificacións por cada gráfica. Aquí
	tes un exemplo:
      </para>
      <code>
	open AWM17 --quiet
	series dum = obs &gt;= 1990:1 &amp;&amp; obs &lt;= 1994:2
	bundle b = _(dummy="dum", color=0xcccccc)
	gnuplot YER URX --with-lines --time-series \
	  --band=b --output=display {set key top left;}
      </code>
      <subhead>Nomes das cores</subhead>
      <para>
	As cores se identifican mediante os números RGB, habitualmente
	expresados en formato hexadecimal con 6 díxitos: os dous primeiros
	díxitos indican a cantidade de vermello (de 0 a 255), os dous do medio
	indican a cantidade de verde, e os dous últimos indican a cantidade de
	azul. Así, por exemplo, <lit>0xff0080</lit> ten o máximo de vermello, non
	ten verde, e un pouco de azul (é un morado avermellado). Co gnuplot 5.2
	en diante, podes utilizar catro pares de díxitos en troques de tres:
	nese caso, os dous primeiros díxitos indican a transparencia, variando
	de 0 (opaco) a 255 (transparente). Por exemplo, <lit>0xc0ff0080</lit>
	proporcionaría á cor un valor de 192 (c0 en hexadecimal) para a
	transparencia. Podes comprobar a túa versión de gnuplot revisando
	o feixe que devolve a función <fncref targ="$sysinfo"/>.
      </para>
      <para>
	As cores hexadecimais pódense pasar ben como escalares, ou ben como
	cadeas de texto. Unha cadea para a cor pode ser un número hexadecimal
	entre comiñas (p.e. "0x191970"), pero gnuplot recoñece algunhas
	cores <quote>abreviadas</quote>. Por exemplo, <quote>violet</quote>
	equivale a <quote>0xee82ee</quote> e <quote>brown</quote> equivale
	a <quote>0xa52a2a</quote>. Podes acceder á listaxe completa cos
	nomes de cores que recoñece gnuplot formulando a instrución
	<quote><lit>show colornames</lit></quote> no propio gnuplot, ou
	executando na consola de Gretl
      </para>
      <code>
	eval readfile("@gretldir/data/gnuplot/gpcolors.txt")
      </code>
      <para>
	Para acadar un resultado esteticamente agradable, pode interesarte
	usar a función <fncref targ="rgbmix"/>.
      </para>
      <subhead>Controlando a saída de resultados</subhead>
      <para>
	En modo interactivo, a gráfica amósase inmediatamente. En modo
	de procesamento por lotes (como ao executar un guión), o xeito de
	proceder por defecto consiste en escribir un ficheiro de instrucións
	Gnuplot no cartafol de traballo do usuario, cun nome co padrón
	<filename>gpttmpN.plt</filename>, comezando con N = <lit>01</lit>.
	Podes xerar as gráficas reais máis tarde utilizando
	<program>gnuplot</program> (baixo MS Windows,
	<program>wgnuplot</program>). E podes modificar este proceder
	utilizando a opción <opt>output=</opt><repl>nomeficheiro</repl>. Esta
	opción controla o nome de ficheiro utilizado, e ao mesmo tempo te
	permite especificar un formato concreto para o resultado mediante
	a extensión do nome do ficheiro, do seguinte xeito:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>.eps</lit>: Encapsulated PostScript
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.pdf</lit>: PDF
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.png</lit>: PNG (Portable Network Graphics)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.emf</lit>: EMF (Microsoft's Enhanced MetaFile)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.html</lit>: 'canvas' de HTML
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.svg</lit>: SVG (Scalable Vector Graphics)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.fig</lit>: Xfig (*nix, programa de debuxo)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.tex</lit>: pict2e (para usar con &latex;)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.tikz</lit>: TiKZ (para usar con &latex;).
	  </para>
	</li>
      </ilist>
      <para>
	Cando se proporciona o nome ficticio <quote><lit>display</lit></quote> para
	o ficheiro, entón a gráfica amósase na pantalla en modo interactivo.
	Cando se proporciona un nome de ficheiro con calquera outra extensión
	distinta ás antes mencionadas, escríbese un ficheiro de instrucións de gnuplot.
      </para>
      <para>
	Un medio alternativo para dirixir a saída de resultados é coa opción
	<opt>outbuf=</opt><repl>nomecadea</repl>. Isto escribe as instrucións
	de Gnuplot na cadea de texto indicada ou no <quote>buffer</quote>.
	Cae na conta de que as opcións <opt>output</opt> e <opt>outbuf</opt>
	son mutuamente incompatibles.
      </para>
      <subhead>Especificando unha fonte</subhead>
      <para>
	Podes utilizar a opción <opt>font</opt> para especificar unha fonte
	concreta para a gráfica. O parámetro <repl>espfonte</repl> debe
	de ter a forma do nome dunha fonte, seguida opcionalmente por un
	número que indique o tamaño en puntos, separado do nome por unha
	coma ou espazo, todo elo contornado entre comiñas, como en
      </para>
      <code>
	--font="serif,12"
      </code>
      <para>
	Ten en conta que as fontes dispoñibles para Gnuplot varían dependendo
	da plataforma, e se estás escribindo unha instrución de gráfica que
	pretendes que sexa transportable, é mellor restrinxir o nome da fonte
	ás xenéricas <lit>sans</lit> ou <lit>serif</lit>.
      </para>
      <subhead>Engadindo instrucións Gnuplot</subhead>
      <para>
	Dispós dunha opción especial engadida desta instrución pois, a
	continuación da especificación das variables que se van debuxar e do
	indicador de opción (se hai algún), podes engadir instrucións literais
	de Gnuplot para controlar a aparencia da gráfica (por exemplo,
	establecendo o título da gráfica e/ou rangos dos eixes). Estas
	instrucións deben estar contornadas entre chaves, e debes rematar cada
	instrución Gnuplot cun punto e coma. Podes utilizar unha barra inversa
	para continuar un conxunto de instrucións Gnuplot ao longo de máis
	dunha liña. Aquí tes un exemplo da sintaxe:
      </para>
      <code>
	{ set title 'Meu Título'; set yrange [0:1000]; }
      </code>
    </description>

    <gui-access>
      <menu-path>/Ver/Gráfica de variables indicadas</menu-path>
      <other-access>Xanela principal: Menú emerxente, botón de gráficas na barra de ferramentas</other-access>
    </gui-access>

  </command>

  <command name="graphing" section="Graphs" context="gui"
    label="Representar gráficas">

    <description>
      <para>
	GRETL solicita que un programa distinto, concretamente Gnuplot,
	xere gráficas. Gnuplot é un programa de representación gráfica moi
	completo con miles de opcións. Mediante unha interface gráfica,
	GRETL dáche acceso directo a un subconxunto destas opcións e trata
	de elixir valores sensatos para ti; se queres, tamén te permite
	que teñas un control completo sobre os detalles da gráfica.
      </para>
      <para>
	Cunha gráfica xa representada, podes facer clic na xanela da gráfica
	para obter un menú emerxente con varias opcións, incluídas estas:
      </para>
      <ilist>
	<li>
	  <para>
	    Gardar como PNG: Garda en formato 'Portable Network Graphics'
	  </para>
	</li>
	<li>
	  <para>
	    Gardar como postscript (EPS): Garda a gráfica en formato 'Encapsulated
	    postscript' (EPS)
	  </para>
	</li>
	<li>
	  <para>
	    Gardar na sesión como icona: A gráfica aparecerá en forma de
	    icona cando escollas <quote>Vista de iconas</quote> no menú
	    da sesión
	  </para>
	</li>
	<li>
	  <para>
	    Zoom: Permíteche seleccionar unha área dentro da gráfica para
	    facer unha inspección máis de preto
	  </para>
	</li>
	<li>
	  <para>
	    Copiar ao portapapeis: Permíteche pegar a gráfica en aplicacións
	    tales como procesadores de texto
	  </para>
	</li>
	<li>
	  <para>
	    Editar: Abre un controlador para a gráfica que te permite axustar
	    varios aspectos do seu aspecto
	  </para>
	</li>
	<li>
	  <para>
	    Pechar: Pecha a xanela da gráfica
	  </para>
	</li>
      </ilist>

      <para>
	Se tes algún coñecemento sobre Gnuplot e queres obter un control máis
	fino sobre o aspecto dunha gráfica ca o que é accesible mediante o
	controlador gráfico (opción <quote>Editar</quote>), dispós dunha opción
	adicional:
      </para>

      <ilist>
	<li>
	  <para>
	    Unha vez que gardaches a gráfica como icona de sesión, preme o botón
	    dereito do rato sobre esa icona para ver un menú emerxente posterior.
	    Aquí, unha das opcións é <quote>Editar as ordes de gráfica</quote>:
	    isto abre unha xanela de edición coa presentación das instrucións
	    Gnuplot vixentes. Podes editar estas instrucións e, ben gardalas para
	    executalas no futuro, ou ben envialas a Gnuplot (coa icona Executar
	    da barra de ferramentas na xanela de instrucións da gráfica).
	  </para>
	</li>
      </ilist>

      <para>
	Para descubrir máis sobre Gnuplot, consulta <url>www.gnuplot.info</url>.
      </para>

    </description>

  </command>

  <command name="graphpg" section="Graphs" label="Páxina de gráficas de GRETL">

    <usage>
      <altforms>
        <altform><lit>graphpg add</lit></altform>
	<altform><lit>graphpg fontscale </lit><repl>escala</repl></altform>
	<altform><lit>graphpg show</lit></altform>
	<altform><lit>graphpg free</lit></altform>
	<altform><lit>graphpg --output=</lit><repl>nomeficheiro</repl></altform>
      </altforms>
    </usage>

    <description>

      <para>
	A sesión <quote>Páxina de gráficas</quote> vai funcionar só cando
	teñas instalado o sistema de composición tipográfica &latex;, e ademas
	podas xerar e ver un resultado PDF ou PostScript.
      </para>
      <para>
	Na xanela de iconas da sesión, podes arrastrar ata 8 gráficas sobre a
	icona de páxina de gráficas. Cando premas un dobre clic sobre a páxina
	de gráficas (ou premas o botón dereito e elixas <quote>Amosar</quote>),
	vaise compoñer unha páxina que contén as gráficas seleccionadas e vaise
	abrir cun visor adecuado. Dende aí deberías de poder imprimir a páxina.
      </para>
      <para>
	Para limpar a páxina de gráficas, preme o botón dereito do rato sobre
	a súa icona e selecciona <quote>Limpar</quote>.
      </para>
      <para>
	Ten en conta que en sistemas diferentes a MS Windows, poderías ter
	que axustar a configuración do programa utilizado para ver ficheiros
	PDF ou PostScript. Atópao baixo a lapela <quote>Programas</quote>
	na caixa de diálogo das Preferencias xerais de GRETL (baixo o menú
	Ferramentas da xanela principal).
      </para>
      <para>
	Tamén é posible traballar na páxina de gráficas mediante un guión, ou
	utilizando a consola (no programa de Interface Gráfica de Usuario,
	GUI). Dáselle apoio ás seguintes instrucións e opcións:
      </para>
      <para>
	Para engadir unha gráfica á páxina de gráficas, podes indicar a instrución
	<lit>graphpg add</lit> logo de gardar unha gráfica definida, como en
      </para>
      <code>
	grf1 &lt;- gnuplot Y X
	graphpg add
      </code>
       <para>
	Para amosar a páxina de gráficas: <lit>graphpg show</lit>.
      </para>
      <para>
	Para limpar a páxina de gráficas: <lit>graphpg free</lit>.
      </para>
      <para>
	Para axustar a escala da fonte utilizada na páxina de gráficas,
	usa <lit>graphpg fontscale</lit> <repl>escala</repl>, onde
	<repl>escala</repl> é un múltiplo (por defecto igual a 1.0).
	Deste xeito, para facer que o tamaño da fonte sexa un 50 por
	cento maior ca o tamaño por defecto, podes facer
      </para>
      <code>
	graphpg fontscale 1.5
      </code>
      <para>
	Para solicitar a impresión da páxina da gráfica nun ficheiro,
	usa a opción <opt>output=</opt> máis un nome de ficheiro; este
	nome debería de ter a extensión <quote><lit>.pdf</lit></quote>,
	<quote><lit>.ps</lit></quote> ou <quote><lit>.eps</lit></quote>.
	Por exemplo:
      </para>
      <code>
	graphpg --output="myfile.pdf"
      </code>
      <para>
	O ficheiro resultante vai escribirse no cartafol establecido nese momento
	(<cmdref targ="workdir"/>), agás que a cadea <repl>nomeficheiro</repl>
	conteña unha especificación completa da ruta.
      </para>
      <para>
	Neste contexto, para o resultado se utilizan liñas de cores por
	defecto; para utilizar padróns punto/raia en vez de cores podes
	engadir a opción <opt>monochrome</opt>.
      </para>

    </description>

  </command>

  <command name="gretl_edit" section="Utilities" context="gui"
    label="gretl_edit">

    <description>
      <para>
	gretl_edit é unha variante livián, cun propósito especial, da Interface
	Gráfica de Usuario (GUI) de GRETL. Inclúe un editor tabulado de guións,
	xunto cos medios para executar guións e ver os seus resultados. Carece
	de moitas das funcionalidades da GUI principal de GRETL, pero pode ser
	útil en base a que, ás veces, <quote>menos é máis</quote>.
      </para>
      <para>
	Este é o contexto para o que está deseñado gretl_edit.
	Estás traballando nalgún código relativamente complexo, e queres
	efectuar o seguinte ciclo:
      </para>
      <code>
	    editar un código
	    executar o código, revisar os resultados, procurar fallos
	    revisar o código
	    executar de novo...
      </code>
      <para>
	Se isto é algo que fas de cando en vez, inténtao con gretl_edit.
	Se non o fas, entón podes ignorar este programa de xeito seguro.
      </para>
      <para>
	Cae na conta de que gretl_edit <quote>non ten estado</quote>.
	A diferenza da GUI principal de GRETL, os modelos, as matrices, os
	feixes e todo o demais, non están gardados. O único estado que se
	preserva é o do guión (ou guións) que se estean editando. No contexto
	descrito antes, isto probablemente é o que queres: que cada vez que
	se execute un guión, comece cun <quote>encerado en branco</quote>.
	Isto quere dicir que, se un guión utiliza un conxunto de datos, debe
	incluír unha instrución para abrir ese conxunto de datos.
      </para>
      <para>
	Obviamente, gretl_edit admite HANSL, a linguaxe propia de GRETL para
	facer guións. De xeito menos obvio, tamén admite linguaxes que están
	cubertos polo instrumental <quote>externo</quote> a GRETL: R, Octave,
	Julia, Ox, Stata. Nestes casos externos, o editor de guións non ten unha
	funcionalidade tan completa como para HANSL: ofrece a sintaxe con resalte,
	pero non o sangrado automático nin o autorecheo.
      </para>
    </description>
  </command>

  <command name="gridplot" section="Graphs" context="cli">
    <usage>
      <arguments>
        <argument>plotspecs</argument>
      </arguments>
      <options>
	<option>
	  <flag>--fontsize</flag>
	  <optparm>fs</optparm>
	  <effect>Tamaño da fonte en puntos [10]</effect>
	</option>
	<option>
	  <flag>--width</flag>
	  <optparm>w</optparm>
	  <effect>Ancho da gráfica en pixels [800]</effect>
	</option>
	<option>
	  <flag>--height</flag>
	  <optparm>h</optparm>
	  <effect>Alto da gráfica en pixels [600]</effect>
	</option>
	<option>
	  <flag>--title</flag>
	  <optparm>cadea entre comiñas</optparm>
	  <effect>Engadir un título xeral</effect>
	</option>
	<option>
	  <flag>--rows</flag>
	  <optparm>r</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--cols</flag>
	  <optparm>c</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--layout</flag>
	  <optparm>lmat</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--output</flag>
	  <optparm>destino</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--outbuf</flag>
	  <optparm>destino alternativo</optparm>
	  <effect>Mira abaixo</effect>
	</option>
      </options>
      <examples>
        <example>gridplot myspecs --rows=3 --output=display</example>
        <example>gridplot myspecs --layout=lmat --output=composto.pdf</example>
      </examples>
    </usage>
    <description>
      <para>
	Esta instrución colle dúas ou máis especificacións individuais para
	gráficas e as ordena nunha grella para xerar unha gráfica combinada.
	O único argumento requirido, <repl>plotspecs</repl>, ten o formato dun
	arranxo de cadeas de texto, cada unha especificando unha gráfica.
	A súa instrución asociada, <cmdref targ="gpbuild"/>, ofrece un xeito
	doado de crear ese tipo de arranxo.
      </para>
      <subhead>Especificando a grella</subhead>
      <para>
	A forma da grella pódese establecer mediante calquera das tres opcións
	(que son incompatibles entre elas) <opt>rows</opt>, <opt>cols</opt> e
	<opt>layout</opt>. Cando non se indica ningunha desas opcións, o número
	de filas establécese como a raíz cadrada do número de gráficas (o tamaño
	do arranxo de entrada), arredondado cara ao enteiro superior máis próximo,
	de ser necesario. Entón, o número de columnas establécese como o número
	de gráficas dividido polo número de filas, novamente arredondado cara
	arriba, de ser necesario. As gráficas colócanse na grella por filas, na mesma
	orde que no arranxo. Cando se indica a opción <opt>rows</opt>, ese valor
	ocupa a posición de selección automática, pero o número de columnas
	establécese automaticamente como se describiu antes. En troques, cando
	se indica a opción <opt>cols</opt>, o número de filas establécese de xeito
	automático.
      </para>
      <para>
	A opción <opt>layout</opt>, que necesita unha matriz como parámetro,
	ofrece unha alternativa máis flexible. Esa matriz especifica a
	configuración da grella deste xeito: os elementos 0 piden celas
	baleiras na grella, e os elementos enteiros de 1 a <math>n</math>
	refírense ás subgráficas na orde que teñan no arranxo. Así
	por exemplo,
      </para>
      <code>
	matrix m = {1,0,0; 2,3,0; 4,5,6}
	gridplot ... --layout=m ...
      </code>
      <para>
	refírese a unha configuración triangular inferior de seis gráficas
	nunha grella <by r="3" c="3"/>. Utilizando esta opción pódense omitir
	algunhas subgráficas, ou mesmo repetir algunha.
      </para>
      <subhead>Opcións de saída</subhead>
      <para>
	A opción <opt>output</opt> pode utilizarse para indicar <lit>display</lit>
	(amosar a gráfica inmediatamente) ou o nome dun ficheiro de saída.
	Como alternativa, pódese usar a opción <opt>outbuf</opt> para facer
	unha saída directa (co formato dun buffer de instrucións de GNUPLOT)
	á cadea de texto mencionada. Na ausencia destas opcións, a saída é un
	ficheiro de instrucións de GNUPLOT nomeado de xeito automático.
	Consulta <cmdref targ="gnuplot"/> para obter máis detalles.
      </para>
    </description>
  </command>

  <command name="gpbuild" section="Graphs" context="cli">
    <usage>
      <arguments>
	<argument>plotspecs</argument>
      </arguments>
      <examples>
        <example>gpbuild MyPlots</example>
      </examples>
    </usage>
    <description>
      <para>
	Esta instrución empeza un bloque no que calquera instrución ou chamada
	a unha función que produce gráficas se trata de xeito especial, co
	obxecto de producir un arranxo de cadeas de texto de especificación de
	gráficas, para utilizalas coa instrución 	<cmdref targ="gridplot"/>: o
	argumento <repl>plotspecs</repl> proporciona o nome para ese arranxo.
	O bloque remátase coa instrución <quote><lit>end gpbuild</lit></quote>.
      </para>
      <subhead>Dúas restricións</subhead>
      <para>
	Dentro dun bloque <lit>gpbuild</lit> só teñen un tratamento especial as
	instrucións para representación gráfica; tódalas outras instrucións se
	executan normalmente. Unicamente hai dúas restricións que advertir.
      </para>
      <ilist>
   <li>
      <para>
	As instrucións de representación <emphasis>non</emphasis> deben
	incluír unha especificación de saída neste contexto, posto que iso
	estaría en conflito co cambio de dirección automático da saída,
	cara ao arranxo de <repl>plotspecs</repl>. Unha excepción a esta
	regra permítese para <lit>--output=display</lit> (que é habitual
	dabondo como opción predeterminada nos paquetes de funcións
	relacionadas con representacións gráficas); esta directiva ignórase
	silandeiramente en beneficio do tratamento automático.
      </para>
    </li>
    <li>
      <para>
  As gráficas que invoquen a directiva
  <quote><lit>multiplot</lit></quote> de GNUPLOT non son axeitadas
	para incluírse nun bloque <lit>gpbuild</lit>. Isto é porque
	<lit>gridplot</lit> utiliza internamente <lit>multiplot</lit>,
	e esas construcións non se poden
	aniñar.
      </para>
    </li>
      </ilist>
      <subhead>Alternativa manual</subhead>
      <para>
	Pódese preparar un arranxo de especificacións de gráficas para utilizar
	con <lit>gridplot</lit> sen usar un bloque <lit>gpbuild</lit>, como no
	seguinte exemplo:
      </para>
      <code>
	open data4-10
	strings MyPlots = array(3)
	gnuplot ENROLL CATHOL --outbuf=MyPlots[1]
	gnuplot ENROLL INCOME --outbuf=MyPlots[2]
	gnuplot ENROLL COLLEGE --outbuf=MyPlots[3]
      </code>
      <para>
	En esencia, o anterior é equivalente a
      </para>
      <code>
	open data4-10
	gpbuild MyPlots
	   gnuplot ENROLL CATHOL
	   gnuplot ENROLL INCOME
	   gnuplot ENROLL COLLEGE
	end gpbuild
      </code>
    </description>
  </command>

  <command name="3-D" section="Graphs" context="gui"
    label="Gráficas en 3 dimensións">

    <description>
      <para>
	Se o botón <quote>Facer a gráfica interactiva</quote> está
	dispoñible e marcado, podes manexar a gráfica 3-D co rato
	(xirala, expandir ou encoller os eixes).
      </para>
      <para>
	Ao compoñer unha gráfica 3-D, ten en conta que o eixe Z vaise
	amosar como eixe vertical. Así, se tes algunha variable dependente
	que pensas que pode estar influída por dúas variables independentes,
	debes de colocar a variable dependente no eixe Z, e as variables
	independentes nos eixes X e Y.
      </para>
      <para>
	Ao contrario que na maioría das gráficas de GRETL, unha interactiva 3-D
	contrólase mediante Gnuplot e non co propio GRETL; por iso o menú de GRETL
	para editar gráficas, non está dispoñible. Para ver o código de Gnuplot
	que xera a gráfica, quita a marca que permite facela interactiva. Entón
	podes usar o propio menú da gráfica (preme nela co botón dereito do rato)
	para gardala <quote>como icona</quote>. Na xanela do Visor de iconas da
	sesión, podes ver as instrucións premendo co botón dereito na icona da gráfica.
      </para>
    </description>
  </command>

  <command name="gui-funcs" section="Programming"
	   label="Funcións especiais" context="gui">
    <description>
      <para>
	Este diálogo permíteche especificar as funcións (se existe algunha)
	dentro dun paquete que deben de asignarse a certos roles especiais.
	Ten en conta que podes asignar unha determinada función como moito
	a un dos seguintes roles; e que unha función ten que satisfacer certos
	criterios para cualificala como candidata a un deses roles.
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>bundle-print</lit>: Presenta o resultado baseado no
	    contido dun feixe (bundle) producido polo teu paquete. Criterios:
	    Esta función debe de ter como primeiro parámetro un
	    punteiro-feixe (<quote>bundle</quote>). Cando se presenta
	    un segundo parámetro, debe de ter o formato dun conmutador
	    enteiro que teña un valor por defecto.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>bundle-plot</lit>: Xera unha ou máis gráficas utilizando
	    un feixe (bundle) producido polo teu paquete. Criterios: Igual que para
	    <lit>bundle-print</lit>.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>bundle-test</lit>: Realiza algún tipo de proba estatística
	    utilizando un feixe (bundle) producido polo teu paquete. Criterios:
	    Igual que para <lit>bundle-print</lit>.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>gui-main</lit>: A interface pública que debera de presentarse por
	    defecto aos usuarios ao utilizar a Interface Gráfica de Usuario (GUI).
	    Isto resulta útil só cando o paquete ten máis dunha interface pública.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>gui-precheck</lit>: Función gardián que devolve 0
	    se a funcionalidade do teu paquete é aplicable no contexto
	    vixente, e se non devolve non cero. Isto está pensado
	    para utilizar con paquetes que afectan a un modelo dalgún
	    xeito, para diferenciar os tipos de modelos que non se
	    manexan co paquete.
	  </para>
	</li>
      </ilist>
      <para>
	Ademais, certas funcións poden indicarse con <quote>no-print</quote>. En
	xeral, cando se chama a unha función mediante o programa de Interface
	Gráfica de Usuario (GUI), GRETL abre unha xanela para amosar o seu
	resultado en texto. Ao marcar este cadriño estás indicándolle a GRETL
	que non faga isto, de aí que non debas de agardar resultados en texto.
      </para>
      <para>
	Finalmente, podes marcar a función <lit>gui-main</lit> (se existe)
	como <quote>menu-only</quote>. Isto indícalle a GRETL que a función
	en cuestión está deseñada especificamente para que se invoque desde
	o menú da Interface Gráfica de Usuario (GUI) á que está unida, e non
	debe de presentarse aos usuarios, a non ser nese caso.
      </para>
    </description>
  </command>

  <command name="gui-htest" section="Tests" context="gui"
    label="Calculadora de estatísticos de proba">

    <description>
      <para>
	A calculadora de probas de GRETL acha os valores dos estatísticos
	de proba e das súas probabilidades asociadas (valores p) en varias
	probas habituais de hipóteses, relativas a unha ou dúas poboacións.
	As entradas que se requiren consisten en estatísticos mostrais obtidos
	dunha ou dúas mostras, en función da proba escollida; e podes escribir
	estes estatísticos con valores numéricos. Alternativamente, se tes
	aberto un ficheiro de datos, podes lograr que GRETL calcule os
	estatísticos mostrais para unha ou varias variables escollidas
	(no caso de medias e varianzas, pero non no caso de proporcións).
      </para>
      <para>
	Se queres basear a túa proba nunha variable do conxunto de
	datos, primeiro activa esta opción marcando o cadriño titulado
	<quote>Utilice unha variable do conxunto de datos</quote>.
	Entón, a lista despregable coas variables activarase e poderás
	elixir unha variable. Cando escolles unha variable da lista, os
	estatísticos destacados insírense automaticamente nas caixas
	de debaixo.
      </para>
      <para>
	Cae na conta de que no caso de dúas mostras, as probas son de
	tipo desemparellado. Se, por exemplo, queres realizar unha proba
	<emphasis>emparellada</emphasis> sobre se a diferenza entre as
	medias de dúas variables é nula, debes crear simplemente unha nova
	serie coas diferenzas entre as dúas xa existentes, e realizar unha
	sinxela proba sobre a media desa nova serie.
	    </para>
      <para>
	Amais da simple selección dunha variable, tes a opción de
	especificar unha restrición sobre a variable escollida (é
	dicir, definindo unha submostra). Por exemplo, supón que tes
	datos de salarios nunha variable chamada <lit>salario</lit>,
	e tamén tes unha variable ficticia chamada <lit>xénero</lit>
	que é igual a 1 para homes e a 0 para mulleres (ou viceversa).
	Entón, na proba da diferenza entre as dúas medias, podes
	escoller <lit>salario</lit> en ambas caixas pero engade á
	mesma caixa de arriba <lit>(xenero==0)</lit> e á de abaixo
	<lit>(xenero==1)</lit>. Así, isto ofréceche unha proba da
	diferenza entre o ingreso medio masculino e o ingreso medio
	feminino. Cae na conta de que cando tecleas unha restrición
	deste xeito, entón debes de premer a tecla Intro para obter
	os estatísticos mostrais calculados.
      </para>
      <para>
	Debes de colocar a restrición da submostra entre parénteses
	a continuación da variable escollida, e en xeral esa restrición
	ten a forma
      </para>
      <code>
	var2 op val
      </code>
      <para>
	onde <lit>var2</lit> é o nome dunha variable do conxunto
	vixente de datos, <lit>val</lit> é un valor numérico, e
	<lit>op</lit> é un dos seguintes operadores de comparación:
      </para>
      <code>
	==  !=  &lt;  &gt;  &lt;=  &gt;=
      </code>
      <para>
	(indicando respectivamente: igualdade, desigualdade, menor
	que, maior que, menor ou igual que, e maior ou igual que).
	Os espazos arredor do operador son optativos.
      </para>
    </description>
  </command>

  <command name="gui-htest-np" section="Tests" context="gui"
    label="Probas non paramétricas">

    <description>
      <para>
	Tes á túa disposición 3 tipos de probas non paramétricas mediante
	este diálogo: para a diferenza entre grupos, para a aleatoriedade,
	e para a correlación (por rangos).
      </para>

      <subhead>Probas de diferenzas</subhead>
      <para>
	Baixo a lapela <quote>Proba de diferenzas</quote> podes efectuar
	unha proba non paramétrica da diferenza entre dúas poboacións ou
	grupos dependendo, a proba concreta, da opción que selecciones.
      </para>
      <ilist>
	<li>
	  <para>
	    <emphasis>Proba de signos</emphasis>: Esta proba
	    baséase no feito de que cando se extraen dúas mostras,
	    <math>x</math> e <math>y</math>, de forma aleatoria
	    dunha mesma distribución, a probabilidade de que
	    <math>x</math><sub>i</sub> &gt; <math>y</math><sub>i</sub>,
	    para cada observación <math>i</math>, deberá de ser igual
	    a 0.5. O estatístico de proba é <math>w</math>, é dicir,
	    o número de observacións para as que se cumpre que
	    <math>x</math><sub>i</sub> &gt; <math>y</math><sub>i</sub>.
	    Baixo a hipótese nula, este estatístico segue unha distribución
	    de probabilidade Binomial con parámetros (<math>n</math>, 0.5),
	    onde <math>n</math> indica o número de
	    observacións.
	  </para>
	</li>
	<li>
	  <para>
	    <emphasis>Proba de suma de rangos</emphasis>: Realízase a proba
	    de suma de rangos de Wilcoxon, que se desenvolve determinando
	    o rango en xerarquía das observacións de ambas mostras xuntas,
	    desde a de menor valor ata a de maior, e logo calculando a suma
	    dos rangos das observacións dunha calquera das dúas mostras.
	    Non é necesario que as dúas mostras teñan o mesmo tamaño e, se
	    son diferentes, utilízase a mostra máis pequena para calcular a
	    suma dos rangos. Baixo a hipótese nula de que as mostras proceden
	    de poboacións coa mesma mediana, a distribución de probabilidade
	    da suma de rangos pode calcularse para calquera tamaño de mostra
	    que se indique; e para mostras razoablemente longas, existe unha
	    estreita aproximación Normal.
	  </para>
	</li>
	<li>
	  <para>
	    <emphasis>Proba dos rangos con signo</emphasis>: Realízase
	    a proba dos rangos con signo de Wilcoxon, que está ideada
	    para pares de datos ligados como, por exemplo, os pares
	    de valores dunha mesma variable nunha mostra de individuos,
	    antes e despois dalgún tratamento. A proba desenvólvese
	    calculando as diferenzas entre as observacións emparelladas
	    <math>x</math><sub>i</sub> &minus; <math>y</math><sub>i</sub>,
	    e determinando o rango destas diferenzas segundo o seu valor
	    absoluto, ademais de asignándolle a cada par un rango cun signo
	    que coincide co signo da diferenza. A continuación calcúlase a
	    suma dos rangos con signo positivo (<math>W</math><sub>+</sub>).
	    De igual xeito que na proba da suma de rangos, baixo a hipótese
	    nula de que a diferenza de medianas é cero, este estatístico
	    segue unha distribución de probabilidade ben definida, que
	    converxe á Normal para mostras de tamaño razoable.
	  </para>
	</li>
      </ilist>

      <subhead>Aleatoriedade</subhead>
      <para>
	Baixo a lapela <quote>Proba de ringleiras</quote>, podes levar adiante
	unha proba do carácter aleatorio dunha determinada variable, baseada no
	número de ringleiras de valores consecutivos positivos ou negativos.
	Se escolles a opción <quote>Usar a primeira diferenza</quote>, se
	calcula a primeira diferenza da variable antes da análise; e por iso
	as ringleiras interprétanse como ringleiras de valores crecentes ou
	decrecentes da variable orixinal. O estatístico de proba baséase
	nunha aproximación Normal á distribución do número de ringleiras
	baixo a hipótese nula de que a variable ten carácter aleatorio.
      </para>

      <subhead>Correlación</subhead>
      <para>
	Baixo a lapela <quote>Correlación</quote>, dispós dos coeficientes
	de correlación por rangos rho de Spearman e tau de Kendall.
      </para>

    </description>
  </command>
  
  <command name="hccme" section="Estimation" context="gui"
    label="Desvíos padrón robustos">

    <description>
      <para>
	Se te ofrecen diversas variantes de cálculo dos desvíos padrón que
	son robustas na presenza de heterocedasticidade (e de autocorrelación
	no caso do estimador HAC).
      </para>
      <para>
	HC0 produce as <quote>Desvíos padrón de White</quote> orixinais;
	HC1, HC2, HC3 e HC3a son variantes subseguintes que xeralmente
	se considera que producen resultados superiores (máis fiables).
	A variante HC3a é a tamén denominada <quote>navalla</quote>
	(jackknife) da que HC3 é unha estreita aproximación. Para obter
	máis detalles sobre os estimadores, consulta o
	<guideref targ="chap:robust_vcv"/>
	ou
	<cite key="davidson-mackinnon04">Davidson e MacKinnon, 2004)</cite>.
      </para>
      <para>
	Se utilizas o estimador HAC para MCO con datos de series temporais,
	podes afinar a longura do retardo e outros detalles utilizando a
	instrución <cmdref targ="set"/>.
      </para>
      <para>
	Ofrécense dous estimadores robustos da matriz de covarianzas para
	modelos GARCH: QML é o estimador de Case-Máxima Verosimilitude (CMV),
	e BW é o estimador de Bollerslev-Wooldridge.
      </para>
      <para>
	Cando se estiman modelos con datos de panel, o estimador robusto
	predeterminado da matriz de covarianzas é o proporcionado por
	<cite key="arellano03">Arellano (2003)</cite>. As alternativas son tanto
	os Desvíos Padrón Corrixidos de Panel (DPCP, PCSE) de
	<cite key="beck-katz95">Beck e Katz (1995)</cite> como o estimador
	Consistente de Correlación Espacial (CCE, SCC) de
	<cite key="driscoll_kraay98">Driscoll e Kraay (1998)</cite>.
	Consulta o <guideref targ="chap:robust_vcv"/> para obter máis detalles.
      </para>
      <para>
	Por defecto, GRETL usa a distribución <math>t</math>-Student ao calcular
	as probabilidades asociadas (valores p) baseadas en desvíos padrón
	robustos no contexto de estimadores de mínimos cadrados. A opción titulada
	<quote>Utilizar a distribución Normal para obter valores p robustos</quote>
	pode usarse para modificar este comportamento.
      </para>
    </description>

  </command>

  <command name="heckit" section="Estimation" context="cli"
    label="Modelo de selección de Heckman">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	      <argument separated="true">ecuaciondeseleccion</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
        <option>
	  <flag>--two-step</flag>
	  <effect>Realiza a estimación en 2 etapas</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
	<option>
	  <flag>--opg</flag>
	  <effect>Desvíos padrón PEG (OPG)</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón CMV (QML)</effect>
        </option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para máis explicacións</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta resultados adicionais</effect>
        </option>
      </options>
      <examples>
        <example>heckit y 0 x1 x2 ; ys 0 x3 x4</example>
	<demos>
	  <demo>heckit.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Modelo de selección de tipo Heckman. Ao especificar esta instrución,
	a lista antes do punto e coma representa as variables da ecuación
	resultante, e a segunda lista representa as variables da ecuación de
	selección. A variable dependente da ecuación de selección (<lit>ys</lit>
	no exemplo de arriba) debe de ser unha variable binaria.
      </para>
      <para>
	Por defecto, os parámetros estímanse polo método de máxima
	verosimilitude. A matriz de covarianzas dos estimadores dos
	parámetros calcúlase utilizando a inversa negativa da matriz
	Hessiana. Se queres facer a estimación en 2 etapas, utiliza a
	opción <opt>two-step</opt>. Neste caso, a matriz de covarianzas
	dos estimadores dos parámetros da ecuación resultante axústase de
	modo adecuado segundo <cite key="heckman79">Heckman (1979)</cite>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Variable Dependente Limitada/Heckit</menu-path>
    </gui-access>

  </command>

  <command name="help" section="Utilities"
    label="Axuda sobre as instrucións" context="cli">

    <usage>
      <altforms>
        <altform><lit>help</lit></altform>
	<altform><lit>help functions</lit></altform>
        <altform><lit>help</lit> <repl>instrución</repl></altform>
        <altform><lit>help</lit> <repl>función</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--func</flag>
	  <effect>Escolle a axuda sobre as funcións</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Se non indicas ningún argumento, presenta a lista de instrucións dispoñibles.
	Se indicas o argumento simple <lit quote="true">functions</lit>, presenta a
	lista de funcións dispoñibles (consulta <cmdref targ="genr"/>).
      </para>
      <para>
	A expresión <lit>help</lit> <repl>instrución</repl> describe cada
	instrución indicada (&eg; <lit>help smpl</lit>). A expresión
	<lit>help</lit> <repl>función</repl> describe cada función indicada
	(&eg; <lit>help ldet</lit>). Algunhas funcións teñen os mesmos nomes
	que as instrucións relacionadas (&eg; <lit>diff</lit>); nese caso,
	por defecto preséntase a axuda para a instrución, pero podes obter
	axuda para a función utilizando a opción <opt>func</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Axuda</menu-path>
    </gui-access>

  </command>

  <command name="hfplot" section="Graphs"
    label="Xerar unha gráfica MIDAS" context="cli">

    <usage>
      <arguments>
        <argument>listaaltafrec</argument>
	      <argument optional="true" separated="true">listabaixafrec</argument>
      </arguments>
      <options>
	<option>
	  <flag>--with-lines</flag>
	  <effect>Gráfica con liñas</effect>
	</option>
	<option>
	  <flag>--time-series</flag>
	  <effect>Pon o tempo no eixe de abscisas</effect>
	</option>
	<option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía o resultado ao ficheiro especificado</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Proporciona un medio de debuxar unha serie de alta frecuencia,
	tal vez xunto a unha ou máis series observadas coa frecuencia
	base do conxunto de datos. O primeiro argumento debe de ser
	unha <cmdref targ="MIDAS_list"/>; e os termos adicionais
	<repl>listabaixafrec</repl> (opcionais) deberán de ser series habituais
	(<quote>de baixa frecuencia</quote>), despois dun punto e coma.
      </para>
      <para>
	Para obter máis detalles sobre o efecto da opción <opt>output</opt>,
	consulta a instrución <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>

  <command name="hsk" section="Estimation"
    label="Estimacións coa heterocedasticidade corrixida">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--no-squares</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Esta instrución é aplicable cando existe heterocedasticidade en forma
	dunha función descoñecida dos regresores, que pode aproximarse por
	medio dunha relación cuadrática. Nese contexto, ofrece a posibilidade
	de obter desvíos padrón consistentes e estimacións máis eficientes
	dos parámetros, en comparación con MCO.
      </para>
      <para>
	O procedemento implica (a) a estimación MCO do modelo de interese,
	seguido de (b) unha regresión auxiliar para xerar unha estimación da
	varianza da perturbación, e finalmente (c) mínimos cadrados ponderados,
	utilizando como ponderación a inversa da varianza estimada.
      </para>
      <para context="cli">
	Na regresión auxiliar de (b), se regresa o logaritmo dos erros
	cadrados da primeira estimación MCO, sobre os regresores
	orixinais e os seus cadrados (por defecto), ou só sobre os
	regresores orixinais (se indicas a opción <opt>no-squares</opt>).
	A transformación logarítmica realízase para asegurar que
	as varianzas estimadas son todas non negativas. Denominando
	<math>u</math><sup>*</sup> aos valores axustados por esta
	regresión, a serie coas ponderacións para a estimación MCP (WLS)
	final fórmase entón como 1/exp(<math>u</math><sup>*</sup>).
      </para>
      <para context="gui">
	Na regresión auxiliar de (b), se regresa o logaritmo dos erros cadrados
	da primeira estimación MCO, sobre os regresores orixinais e os seus
	cadrados (por defecto), ou só sobre os regresores orixinais (se non marcas
	o cadriño <quote>A ecuación de varianza inclúe cadrados</quote>). A
	transformación logarítmica realízase para asegurar que as varianzas estimadas
	son todas non negativas. Denominando <math>u</math><sup>*</sup>
	aos valores axustados por esta regresión, a serie coas ponderacións
	para a estimación MCP (WLS) final fórmase entón como
	1/exp(<math>u</math><sup>*</sup>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Outros Modelos Lineais/Con Corrección de Heterocedasticidade</menu-path>
    </gui-access>

  </command>

  <command name="hurst" section="Statistics"
    label="Expoñente de Hurst">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--plot</flag>
	  <optparm>modo-ou-nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcula o expoñente de Hurst (unha medida de persistencia ou memoria
	longa) para unha variable de tipo serie temporal que teña polo menos
	128 observacións. Podes obter o resultado (xunto co seu desvío padrón)
	mediante o accesorio <fncref targ="$result"/>.
      </para>
      <para>
	<cite key="mandelbrot83">Mandelbrot (1983)</cite> discute
	sobre o expoñente de Hurst. En termos teóricos, este é o
	expoñente (<math>H</math>) da relación
	<equation status="display"
		  tex="\[\mathrm{RS}(x) = an^H\]"
		  ascii="RS(x) = an^H" graphic="hurst"/> onde RS expresa o
	<quote>rango que se volve a escalar</quote> da variable <math>x</math>
	en mostras de tamaño <math>n</math> e <math>a</math> é unha
	constante. O rango reescalado é o rango (valor máximo menos
	mínimo) do valor acumulado ou suma parcial de <math>x</math>
	(logo da subtracción da súa media mostral) no período da
	mostra, dividida polo desvío padrón mostral.
      </para>
      <para>
	Como punto de referencia, se <math>x</math> é unha variable ruído
	branco (con media e persistencia nulas) entón o rango do seu
	<quote>paseo</quote> (forma un paseo aleatorio) acumulado e
	escalado polo seu desvío padrón, ten un crecemento igual á
	raíz cadrada do tamaño da mostra, proporcionando un expoñente
	de Hurst agardado de 0.5. Os valores do expoñente que estean
	significativamente por encima de 0.5 indican persistencia, e os
	menores ca 0.5 indican <quote>antipersistencia</quote> (autocorrelación
	negativa). En principio, o expoñente está acoutado entre 0 e 1, aínda
	que en mostras finitas é posible obter un expoñente estimado maior ca 1.
      </para>
      <para>
	En GRETL, o expoñente estímase utilizando submostraxe binaria:
	comézase co rango completo de datos, despois coas dúas metades
	do rango, despois cos 4 cuartos, etcétera. Para tamaños da mostra
	menores que o rango de datos, o valor RS é a media entre as
	mostras dispoñibles. O expoñente estímase así como o coeficiente
	da pendente, nunha regresión do logaritmo de RS sobre o logaritmo
	do tamaño da mostra.
      </para>
      <para>
	Por defecto, se GRETL non está en modo de procesamento por
	lotes, amósase unha gráfica do rango reescalado pero podes axustar
	isto mediante a opción <opt>plot</opt>. Os parámetros que se admiten
	para esta opción son <lit>none</lit> (para suprimir a gráfica);
	<lit>display</lit> (para presentar unha gráfica mesmo en caso de
	procesar por lotes); ou un nome de ficheiro. O efecto de indicar un
	nome de ficheiro é como o descrito para a opción <opt>output</opt>
	da instrución <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Expoñente de Hurst</menu-path>
    </gui-access>

  </command>

  <command name="if" section="Programming" label="Control de fluxo" context="cli">

    <description>
      <para>Control de fluxo para a execución de instrucións. Admítense
	3 tipos de construción, como as indicadas deseguido.
      </para>
      <code>
	# Forma simple
	if (poñer a condición)
	    instrucións
	endif

	# Dúas ramas
	if (poñer a condición)
	    instrucións 1
	else
	    instrucións 2
	endif

	# Tres ou máis ramas
	if (poñer a condición 1)
	    instrucións 1
	elif (poñer a condición 2)
	    instrucións 2
	else
	    instrucións 3
	endif
      </code>

      <para>
	A condición (<repl quote="true">condition</repl>) debe de ser unha
	expresión booleana; para a súa sintaxe consulta <cmdref targ="genr"/>.
	Podes incluír máis dun bloque <cmd>elif</cmd>. Ademais, podes
	aniñar os bloques <lit>if</lit> &hellip; <lit>endif</lit>.
      </para>
    </description>

  </command>

  <command name="include" section="Programming"
    label="Incluír definicións de funcións" context="cli">

    <usage>
      <arguments>
        <argument>nomeficheiro</argument>
      </arguments>
      <options>
        <option>
	  <flag>--force</flag>
	  <effect>Forza a volver ler desde o ficheiro</effect>
        </option>
      </options>
      <examples>
        <example>include myfile.inp</example>
        <example>include sols.gfn</example>
      </examples>
    </usage>

    <description>
      <para>
	Ideado para utilizar nun guión de instrucións, principalmente
	para incluír definicións de funcións. O nome do ficheiro
	(<repl>nomeficheiro</repl>) debería de ter a extensión <lit>inp</lit>
	(un guión de texto plano) ou <lit>gfn</lit> (un paquete de funcións
	de GRETL). As instrucións de <repl>nomeficheiro</repl> execútanse
	e logo o control devólvese ao guión principal.
      </para>
      <para>
	A opción <opt>force</opt> é específica dos ficheiros <lit>gfn</lit> e
	o seu efecto consiste en forzar a GRETL a que volva ler o paquete de
	funcións desde o ficheiro, mesmo aínda que xa estea cargado na memoria.
	(Os ficheiros de texto plano <lit>inp</lit> sempre lense e procésanse
	en resposta a esta instrución.)
      </para>
      <para>
	Consulta tamén <cmdref targ="run"/>.
      </para>
    </description>

  </command>

  <command name="info" section="Dataset"
    label="Información sobre o conxunto de datos" context="cli">
    <usage>
      <altforms>
	<altform><lit>info</lit></altform>
	<altform><lit>info --to-file=</lit><repl>nomeficheiro</repl></altform>
	<altform><lit>info --from-file=</lit><repl>nomeficheiro</repl></altform>
      </altforms>
    </usage>
    <description>
      <para>
	Na súa forma básica, presenta calquera información adicional (metadatos)
	gardada co ficheiro de datos vixente. Doutro xeito, escribe esta
	información nun ficheiro (mediante a opción <opt>to-file</opt>), ou
	le os metadatos dun ficheiro especificado e os incorpora ao conxunto
	de datos vixente (mediante <opt>from-file</opt>; en cuxo caso o texto
	debe ter un formato UTF-8 correcto).
      </para>
    </description>
    <gui-access>
      <menu-path>/Datos/Información do conxunto de datos</menu-path>
    </gui-access>
  </command>

  <command name="intreg" section="Estimation" label="Modelo de regresión por intervalos">

    <usage>
      <arguments>
        <argument>minvar</argument>
        <argument>maxvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
        <option>
	  <flag>--opg</flag>
	  <effect>Mira máis abaixo</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para máis explicacións</effect>
        </option>
      </options>
      <examples>
	<example>intreg lo hi const x1 x2</example>
	<demos>
	  <demo>wtp.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Estima un modelo de regresión por intervalos. Este modelo xurde
	cando a variable dependente está imperfectamente observada para
	algunhas observacións (posiblemente todas). Noutras palabras,
	asúmese que o proceso xerador de datos é
	<equation status="display" tex="\[y^*_t = x_t \beta+\epsilon_t\]" ascii="y* = x b + u"/>
	pero só observamos
	<equation status="inline" tex="\[m_t \le y_t \le M_t\]" ascii="m &lt;= y* &lt;= M"/>
	(o intervalo pode non ter límite pola esquerda ou pola dereita).
	Cae na conta de que para algunhas observacións <math>m</math>
	pode ser igual a <math>M</math>. As variables <repl>minvar</repl>
	e <repl>maxvar</repl> deben de conter <lit>NA</lit>s para as
	observacións sen límite pola esquerda ou pola dereita,
	respectivamente.
      </para>

      <para context="gui">
	Na caixa de diálogo de especificación do modelo, identifícanse
	<repl>minvar</repl> e <repl>maxvar</repl> como a variable do
	límite Inferior e a variable do límite Superior, respectivamente.
      </para>

      <para>
	O modelo estímase mediante Máxima Verosimilitude, asumindo a
	distribución Normal do termo de perturbación aleatoria.
      </para>

      <para context="cli">
	Por defecto, os desvíos padrón calcúlanse utilizando a inversa
	negativa da matriz Hessiana. Cando especificas a opción
	<opt>robust</opt>, entón calcúlanse no seu lugar os desvíos
	padrón CMV (QML) ou de Huber&ndash;White. Neste caso, a matriz de
	covarianzas estimada é un <quote>emparedado</quote> entre a inversa da
	matriz Hessiana estimada e o produto externo do vector gradiente. Como
	alternativa podes indicar a opción<opt>opg</opt>, en cuxo caso os desvíos
	padrón baséanse unicamente no produto externo do vector gradiente.
      </para>
      <para context="gui">
	Por defecto, os desvíos padrón calcúlanse utilizando a inversa
	negativa da matriz Hessiana. Se marcas o cadriño de 'Desvíos
	padrón robustos', entón calcúlanse no seu lugar os desvíos padrón
	CMV (QML) ou Huber&ndash;White. Neste caso, a matriz de covarianzas
	estimada é un <quote>emparedado</quote> entre a inversa da matriz
	Hessiana estimada e o produto externo do vector gradiente.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelar/Variable Dependente Limitada/Regresión por intervalos</menu-path>
    </gui-access>

  </command>

  <command name="irfboot" section="Graphs" context="gui"
    label="Gráficas de resposta ao impulso">

    <description>
      <para>
	Se escolles a opción 'bootstrap' cando representas respostas ao
	impulso, GRETL calcula un intervalo de confianza para as respostas
	utilizando o método bootstrap. Vólvese a facer a mostraxe cos erros
	do VAR (ou VECM) orixinal, con substitución; constrúese un conxunto
	de datos artificial baseado nas estimacións orixinais dos parámetros
	e nos erros desa nova mostraxe; o sistema vólvese a estimar e as
	respostas ao impulso vólvense avaliar. Por defecto, isto repítese
	1999 veces, áchanse os cuantís &alpha;/2 e 1 &minus; &alpha;/2
	para as respostas, e debúxanse xunto coas estimacións por punto.
	Esta opción non está dispoñible actualmente para VECMs
	restrinxidos.
      </para>
      <para>
	Este diálogo tamén admite a reordenación das variables para facer a
	descomposición de Cholesky da matriz de covarianzas das ecuacións
	cruzadas. O proceder por defecto ven indicado pola orde na que se
	introducen as variables na especificación do modelo, pero podes usar as
	frechas de arriba e abaixo para adiantar ou retrasar a variable escollida.
      </para>
      <para>
	A respecto da escala das respostas ao impulso, a dimensión do
	<quote>impacto</quote> establécese nun desvío padrón das
	innovacións estimadas na variable de orixe, e as respostas se
	proporcionan en calquera que sexa a unidade <quote>natural</quote>
	da variable obxectivo.
      </para>
	  <para>
	  (Consulta o complemento SVAR para outras propostas de identificación
	  de 'shocks' e para máis opcións de bootstrap.)
	  </para>
    </description>

  </command>

  <command name="johansen" section="Tests" label="Proba de cointegración de Johansen">

    <usage>
      <arguments>
        <argument>nivel</argument>
        <argument>ylista</argument>
	     <argblock optional="true" separated="true">
	      <argument>xlista</argument>
	     </argblock>
	     <argblock optional="true" separated="true">
	      <argument>rxlista</argument>
	     </argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>Sen constante</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>Constante restrinxida</effect>
        </option>
        <option>
	  <flag>--uc</flag>
	  <effect>Constante non restrinxida</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>Constante e tendencia restrinxida</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>Constante e tendencia non restrinxida</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>Inclúe variables ficticias estacionais centradas</effect>
        </option>
        <option>
	  <flag>--asy</flag>
	  <effect>Garda os valores p asintóticos</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Presenta só as probas</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Presenta detalles das regresións auxiliares</effect>
        </option>
      </options>
      <examples>
        <example>johansen 2 y x</example>
	<example>johansen 4 y x1 x2 --verbose</example>
	<example>johansen 3 y x1 x2 --rc</example>
	<demos>
	  <demo>hamilton.inp</demo>
	  <demo>denmark.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Leva a cabo a proba de cointegración de Johansen entre as variables
	de <repl>ylista</repl> para o nivel de retardos seleccionado. Para obter
	máis detalles sobre esta proba, consulta o <guideref targ="chap:vecm"/>
	ou o capítulo 20 de <cite key="hamilton94">Hamilton (1994)</cite>. As
	probabilidades asociadas (valores p) calcúlanse mediante a aproximación
	Gamma de Doornik <cite key="doornik98" p="true">(Doornik, 1998)</cite>.
	Amósanse dous conxuntos de valores p para a proba da traza: valores
	asintóticos directos e valores axustados polo tamaño da mostra. Por
	defecto, o accesorio <fncref targ="$pvalue"/> xera a variante axustada,
	pero podes utilizar a opción <opt>asy</opt> para obter no seu lugar
	os valores asintóticos.
      </para>

      <para context="gui">
	Leva a cabo a proba de cointegración de Johansen entre as variables
	indicadas para o nivel de retardos seleccionado. Para obter máis detalles
	sobre esta proba consulta, por exemplo, o capítulo 20 do libro
	<book>Time Series Analysis</book> (1994) de Hamilton. As probabilidades
	asociadas (valores p) calcúlanse mediante a aproximación Gamma de Doornik
	(1998). Amósanse dous conxuntos de valores p para a proba da traza:
	valores asintóticos directos e valores axustados polo tamaño da mostra.
      </para>

      <para context="cli">
	A inclusión de termos determinísticos no modelo contrólase mediante
	os indicadores de opción. Por defecto, se non especificas ningunha
	opción, inclúese unha <quote>constante non restrinxida</quote>, que
	permite a presenza dunha ordenada na orixe non nula nas relacións
	de cointegración, así como unha tendencia nos niveis das variables
	endóxenas. Na literatura xerada a partir do traballo de Johansen
	(por exemplo, consulta o seu libro de 1995) refírese esta situación
	como o <quote>caso 3</quote>. As 4 primeiras opcións indicadas arriba,
	que son mutuamente excluíntes, producen respectivamente os casos 1,
	2, 4 e 5. Tanto o significado destes casos como o criterio para
	seleccionar un caso explícanse no <guideref targ="chap:vecm"/>.
      </para>

      <para context="gui">
	A inclusión de termos determinísticos no modelo contrólase por medio
	dunha lista despregable de opcións. Por defecto, inclúese unha
	<quote>constante non restrinxida</quote>, que permite a presenza
	dunha ordenada na orixe non nula nas relacións de cointegración, así
	como unha tendencia nos niveis das variables endóxenas. Na literatura
	xerada a partir do traballo de Johansen (por exemplo, consulta o seu
	libro de 1995) refírese esta situación como o <quote>caso 3</quote>.
	As 4 primeiras opcións indicadas arriba producen respectivamente os
	casos 1, 2, 4 e 5. Tanto o significado destes casos como o criterio
	para seleccionar un caso explícanse no <guideref targ="chap:vecm"/>.
      </para>

      <para context="cli">
	As listas <repl>xlista</repl> e <repl>rxlista</repl> (opcionais) te permiten
	controlar as variables esóxenas especificadas, e así estas entran
	no sistema ben sen restricións (<repl>xlista</repl>) ou ben restrinxidas
	ao espazo de cointegración (<repl>rxlista</repl>). Estas listas
	sepáranse de <repl>ylista</repl> e unhas das outras mediante un
	punto e coma.
      </para>

      <para context="gui">
	Podes controlar as variables esóxenas engadíndoas á caixa da lista
	inferior. Por defecto, estas entran a formar parte do modelo de forma
	non restrinxida (indicada por un <lit>U</lit> á beira do nome da
	variable). Se queres que unha determinada variable esóxena estea
	restrinxida ao espazo de cointegración, preme co botón dereito do
	rato sobre ela e escolle <quote>Restrinxido</quote> no menú emerxente;
	e o símbolo á beira da variable vaise mudar a R.
      </para>

      <para context="cli">
	A opción <opt>seasonals</opt>, que podes combinar con calquera das
	outras opcións, especifica a inclusión dun conxunto de variables
	ficticias estacionais centradas. Esta opción está dispoñible só
	para datos trimestrais ou mensuais.
      </para>

      <para context="gui">
	Se os datos son trimestrais ou mensuais, amósase un cadriño de verificación que
	te permite incluír un conxunto de variables ficticias estacionais centradas. En
	tódolos casos, un cadriño de verificación adicional (<quote>Amosar os detalles</quote>)
	permite a presentación das regresións auxiliares que forman o punto de comezo
	do procedemento de estimación máximo verosímil de Johansen.
      </para>

      <para context="notex">
	A seguinte táboa ofrécese como guía para a interpretación
	dos resultados da proba que se amosan, para o caso con
	3 variables. <lit>H0</lit> denota a hipótese nula, <lit>H1</lit>
	a hipótese alternativa, e <lit>c</lit> o número de relacións
	de cointegración.
      </para>
      <mono context="notex">
         Rango    Proba traza        Proba Lmáx
                  H0     H1          H0     H1
         ---------------------------------------
          0      c = 0  c = 3       c = 0  c = 1
          1      c = 1  c = 3       c = 1  c = 2
          2      c = 2  c = 3       c = 2  c = 3
         ---------------------------------------
      </mono>
      <para context="tex">
	A seguinte táboa ofrécese como guía para a interpretación
	dos resultados da proba que se amosan, para o caso con
	3 variables. $H_0$ denota a hipótese nula, $H_1$ a
	hipótese alternativa, e $c$ o número de relacións de
	cointegración.

	\begin{center}
	\begin{tabular}{cllll}
	&amp; \multicolumn{2}{c}{Proba traza} &amp;
	   \multicolumn{2}{c}{Proba $\lambda$-máx} \\
	Rango &amp;  \multicolumn{1}{c}{$H_0$} &amp;
	       \multicolumn{1}{c}{$H_1$} &amp;
	       \multicolumn{1}{c}{$H_0$} &amp;
	       \multicolumn{1}{c}{$H_1$} \\ [4pt]
 	0 &amp; $c$ = 0 &amp; $c$ = 3 &amp; $c$ = 0 &amp; $c$ = 1 \\
	1 &amp; $c$ = 1 &amp; $c$ = 3 &amp; $c$ = 1 &amp; $c$ = 2 \\
	2 &amp; $c$ = 2 &amp; $c$ = 3 &amp; $c$ = 2 &amp; $c$ = 3
	\end{tabular}
	\end{center}
      </para>

      <para>
	Consulta tamén a instrución <cmdref targ="vecm"/>; e a instrución
	<cmdref targ="coint"/> se queres obter a proba de cointegración de
	Engle&ndash;Granger.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelar/Series temporais multivariantes</menu-path>
    </gui-access>

  </command>

  <command name="join" section="Dataset" label="Manexar fontes de datos"
	   context="cli">

    <usage>
      <arguments>
        <argument>nomeficheiro</argument>
	      <argument>nomevar</argument>
      </arguments>
      <options>
	<option>
	  <flag>--data</flag>
	  <optparm>nomecolumna</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--filter</flag>
	  <optparm>expresión</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--ikey</flag>
	  <optparm>claveinterna</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--okey</flag>
	  <optparm>claveexterna</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--aggr</flag>
	  <optparm>método</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--tkey</flag>
	  <optparm>nomecoluma,cadeaformato</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Informe en marcha</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Esta instrución incorpora unha ou máis series desde a orixe
	<repl>nomeficheiro</repl> (que debe de ser ben un ficheiro de datos
	co texto delimitado, ou ben un ficheiro de datos <quote>propio</quote>
	de GRETL), co nome <repl>nomevar</repl>. Para obter máis detalles,
	consulta o <guideref targ="chap:join"/> pois aquí damos só un breve
	resumo das opcións dispoñibles. Consulta tamén <cmdref targ="append"/>
	para operacións de anexión máis simples.
      </para>
      <para>
	Podes utilizar a opción <opt>data</opt> para especificar o
	encabezamento dos datos do ficheiro de orixe, se difire do
	nome polo que os datos deberan de coñecerse en GRETL.
      </para>
      <para>
	Podes usar a opción <opt>filter</opt> para especificar un
	criterio para filtrar os datos de orixe (é dicir, para escoller
	un subconxunto das observacións).
      </para>
      <para>
	Podes utilizar as opcións <opt>ikey</opt> e <opt>okey</opt> para
	especificar unha equivalencia entre as observacións do conxunto
	vixente de datos e as observacións da fonte de datos (por exemplo,
	os individuos poden facerse corresponder co fogar ao que pertencen).
      </para>
      <para>
	A opción <opt>aggr</opt> utilízase cando a equivalencia entre
	as observacións do conxunto vixente de datos e as da orixe non
	é de unha a unha.
      </para>
      <para>
	A opción <opt>tkey</opt> aplícase só cando o conxunto vixente
	de datos ten unha estrutura de serie temporal. Podes usala para
	especificar, ben o nome dunha columna que conteña datas que van
	ser emparelladas co conxunto de datos, e/ou ben o formato no que
	as datas se representan nesa columna.
      </para>
      <subhead>Incorporación de máis dunha serie á vez</subhead>
      <para>
	Coa instrución <cmd>join</cmd> podes manexar a incorporación
	de varias series ao mesmo tempo. Isto acontece se o argumento
	<repl>nomevar</repl>: (a) consiste nunha lista de nomes separados
	por espazos, en troques dun único nome; ou (b) apunta a un arranxo
	de cadeas de texto, cuxos elementos deben ser os nomes das series
	que se quere incorporar.
      </para>
      <para>
	Porén, este método ten algunha limitación como o feito de que a opción
	<opt>data</opt> neste caso non está dispoñible. E cando incorporas
	múltiples series, estás obrigado a aceptar os nomes <quote>externos</quote>
	que xa teñen. As demais opcións se aplican de xeito uniforme a todas
	as series que se incorporan mediante unha instrución concreta.
      </para>
    </description>

  </command>

  <command name="join" section="Dataset" label="Engadir datos con controis"
	   context="gui">
    <description>
    <para>
	    Este diálogo dáche acceso a certa funcionalidade (pero non toda)
	    da instrución <lit>join</lit>. Para obter detalles máis completos,
	    consulta o <guideref targ="chap:join"/>.
    </para>
    <para>
	    Na esquerda deberías de ver unha listaxe das series do conxunto de datos
	    vixente. Aquí podes escoller unha serie, e utilizar os botóns coas frechas
	    para especificala como unha ou outra das <quote>chaves internas</quote>
	    (opcionais). As chaves funcionan para emparellar filas entre o conxunto
	    vixente de datos e o ficheiro do que esteas importando datos.
    </para>
    <para>
	    Na dereita deberían de listarse as series do ficheiro de datos que
	    escolliches. Podes usar os botóns coas frechas para elixir o nome das
	    series a importar desa lista, e (de ser necesario) os nomes das series
	    que se corresponden coas chaves <quote>internas</quote>. (Por defecto,
	    suponse que as chaves internas e externas teñen o mesmo nome.) Na
	    listaxe desta caixa tamén podes ver unha entrada <quote>ficticia</quote>
	    nomeada <lit>$obsmajor</lit> que, aínda que non se pode importar,
	    podes usala como chave; consulta <fncref targ="$obsmajor"/>.
    </para>
    <para>
	    No medio do cadro de diálogo podes especificar parámetros
	    adicionais para a operación <quote>join</quote>:
    </para>
    <ilist>
      <li>
	<para>
	  Un nome co que se deberá de recoñecer á serie importada. (Por
	  defecto, este é o mesmo ca o nome a <quote>importar</quote>).
	</para>
      </li>
      <li>
	<para>
	  Unha expresión como filtro. Esta vaise avaliar para cada fila do
	  conxunto de datos externo, e só vanse importar as filas nas que
	  a expresión proporcione un valor non nulo.
	</para>
      </li>
      <li>
	<para>
	  Un método de agregación. Este requírese só cando o emparellamento
	  mediante as claves selecciona máis dun valor externo para cada
	  observación interna.
	</para>
      </li>
    </ilist>
    <subhead>Datos de series de tempo</subhead>
    <para>
      Cando o banco de datos vixente é de series temporais, é moi probable
      que os datos que vaias engadir sexan tamén series de tempo. Nese
      caso, GRETL pode ser capaz de achar a unión sen a axuda das chaves
      específicas do usuario. Isto se indica mediante a cadea de texto
      <quote>detectar automaticamente</quote>, do marcador de posición
      nas caixas de entrada de chaves internas. Posto que non hai garantía
      de que isto faga exactamente o que queres, probablemente pague a
      pena que probes antes a recorrer a un enfoque máis complexo.
    </para>
    </description>
  </command>

  <command name="kalman" section="Utilities"
	   label="Modelado do espazo dos estados" context="gui">
    <description>
      <para>
	Esta interface gráfica ofrece unha pequena mostra da funcionalidade
	que está dispoñible por medio da creación de secuencias de comando
	no mecanismo sobre estado dos espazos de GRETL.
      </para>
      <para>
	Se te interesa o que estás lendo aquí, por favor, bota unha ollada ao
	<guideref targ="chap:kalman"/> (titulado <quote>State Space Modeling</quote>).
	Aí atoparás detalles sobre como manexar matrices que varían no tempo,
	perturbacións que están correlacionadas a través de observacións e
	ecuacións de transición entre estados, e moito máis. Tamén vas atopar
	varios guións de exemplo que se poden descargar. Estes exemplos ilustran,
	entre outras cousas, como conectar o filtro de Kalman de GRETL co seu
	maximizador da verosimilitude.
      </para>
    </description>
  </command>

  <command name="kdplot" section="Graphs" label="Gráfica da densidade do Kernel">
    <usage>
      <arguments>
	<argument>y</argument>
      </arguments>
      <options>
	<option>
	  <flag>--alt</flag>
	  <effect>Utiliza o kernel de Epanechnikov</effect>
        </option>
        <option>
	  <flag>--scale</flag>
	  <optparm>s</optparm>
	  <effect>Factor de axuste do ancho de banda</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía a gráfica ao ficheiro indicado</effect>
        </option>
      </options>
    </usage>
    <description>
      <para>
	Representa unha gráfica coa estimación da densidade do kernel para a
	serie <argname>y</argname>. Por defecto, o kernel é Gaussiano pero
	se indicas a opción <opt>alt</opt>, utilízase o kernel de
	Epanechnikov. Podes axustar o grao de suavizado mediante a opción
	<opt>scale</opt>, que ten un valor predeterminado de 1.0
	(os valores máis grandes de <repl>s</repl> producen un resultado
	máis suavizado).
      </para>
      <para context="cli">
	A opción <opt>output</opt> ten como efecto o envío do resultado ao
	ficheiro que se indique nela; utiliza a verba <quote>display</quote>
	para forzar que o resultado apareza na pantalla. Consulta a instrución
	<cmdref targ="gnuplot"/> para obter máis detalles sobre esta opción.
      </para>
      <para>
	Para obter medios máis flexibles para xerar estimacións da densidade
	do kernel, coa posibilidade de recuperar o resultado en forma de matriz,
	consulta a función <fncref targ="kdensity"/>.
      </para>
    </description>
    <gui-access>
      <menu-path>/Variable/Gráfica da densidade estimada</menu-path>
    </gui-access>
  </command>

  <command name="kpss" section="Tests" label="Proba de estacionariedade KPSS">

    <usage>
      <arguments>
        <argument>nivel</argument>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--trend</flag>
	  <effect>Inclúe unha tendencia</effect>
	</option>
	<option>
	  <flag>--seasonals</flag>
	  <effect>Inclúe variables ficticias estacionais</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os resultados da regresión</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>Utiliza a primeira diferenza da variable</effect>
	</option>
      </options>
      <examples>
	<example>kpss 8 y</example>
        <example>kpss 4 x1 --trend</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Calcula a proba de estacionariedade KPSS (Kwiatkowski, Phillips, Schmidt
	e Shin, Journal of Econometrics, 1992) da variable indicada (ou da súa
	primeira diferenza, se escolles a opción de usar as primeiras diferenzas).
	A hipótese nula é que a variable en cuestión é estacionaria, ben arredor
	dun nivel ou, se marcas o cadriño de <quote>Incluír unha tendencia</quote>,
	arredor dunha tendencia linear determinística.
      </para>

      <para context="cli">
	Para utilizar esta instrución con datos de panel, consulta a sección
	final destas anotacións.
      </para>

      <para context="cli">
	Calcula a proba de estacionariedade KPSS
	<cite key="KPSS92" p="true">(Kwiatkowski et al, Journal of Econometrics, 1992)</cite>
	para cada unha das variables indicadas (ou para as súas primeiras
	diferenzas, se escolles a opción <opt>difference</opt>). A hipótese
	nula é que a variable en cuestión é estacionaria, ben arredor dun
	nivel ou, se marcas a opción <opt>trend</opt>, arredor dunha tendencia
	linear determinística.
      </para>

      <para context="gui">
	O nivel de retardos seleccionado determina o tamaño da xanela
	utilizada para o suavizado de Bartlett. Se marcas o cadriño de
	<quote>Amosar os resultados da regresión</quote>, preséntanse
	os resultados da regresión auxiliar, xunto coa varianza estimada
	da compoñente de paseo aleatorio da variable.
      </para>

      <para context="cli">
	O argumento <repl>nivel</repl> determina o tamaño da xanela
	utilizada para o suavizado de Bartlett. Cando indicas un valor
	negativo, iso tómase como sinal para que se utilice unha xanela
	automática de tamaño 4(<math>T</math>/100)<sup>0.25</sup>, onde
	<math>T</math> é o tamaño da mostra.
      </para>

      <para context="cli">
	Se escolles a opción <opt>verbose</opt>, preséntanse os resultados
	da regresión auxiliar xunto coa varianza estimada da compoñente de
	paseo aleatorio da variable.
      </para>

      <para>
	Os puntos críticos amosados para o estatístico de proba baséanse
	en superficies de resposta estimadas do xeito establecido por
	<cite key="sephton95">Sephton (Economics Letters, 1995)</cite>,
	que son máis fiables para mostras pequenas ca os valores indicados
	no artigo orixinal de KPSS. Cando o estatístico de proba cae entre
	os puntos críticos do 1 e do 10 por cento, amósase unha probabilidade
	asociada (valor p) que se obtén mediante interpolación linear e
	non debe de tomarse demasiado literalmente. Consulta a función
	<fncref targ="kpsscrit"/> para ver un medio de obter eses puntos
	críticos coa axuda do programa.
      </para>

      <subhead context="cli">Datos de panel</subhead>

      <para context="cli">
	Cando se utiliza a instrución <lit>kpss</lit> con datos de panel, para
	realizar unha proba de raíz unitaria de panel, as opcións aplicables
	e os resultados amosados son algo diferentes. Mentres que no caso
	habitual de series temporais, podes indicar unha lista de variables
	para comprobar, con datos de panel só podes comprobar unha variable
	por cada instrución. E a opción <opt>verbose</opt> ten un significado
	diferente, pois xera unha breve presentación da proba para cada serie
	temporal individual (xa que, por defecto, só se amosa o resultado global).
      </para>
      <para context="cli">
	Cando é posible, calcúlase a proba global (Hipótese nula:
	O PE da serie en cuestión é estacionario para todas as unidades do
	panel) utilizando para elo o método de
	<cite key="choi01">Choi (Journal of International Money and Finance, 2001)</cite>.
	Isto non sempre é sinxelo pois a dificultade está en que, mentres
	que a proba de Choi se basea nas probabilidades asociadas das
	probas coas series individuais, non temos actualmente un
	xeito de calcular as probabilidades asociadas para o estatístico
	de proba KPSS; debemos de apoiarnos nuns poucos puntos críticos.
      </para>
      <para context="cli">
	Se o estatístico de proba con unha determinada serie, cae entre os puntos críticos
	do 1 e do 10 por cento, podemos interpolar unha probabilidade asociada.
	Pero se o valor do estatístico da proba cae por debaixo do correspondente
	ao 10 por cento ou se excede ao do 1 por cento, non se pode interpolar e como
	moito pódese establecer un límite sobre a proba de Choi global. Se o valor
	do estatístico de proba individual cae por debaixo do correspondente ao 10
	por cento para unhas unidades e excede ao do 1 por cento para outras, nin
	sequera se pode calcular un límite para a proba global.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Probas de raíz unitaria/Proba KPSS</menu-path>
    </gui-access>

  </command>

  <command name="labels" section="Dataset"
    label="Etiquetas de variables" context="cli">

    <usage>
      <altforms>
	<altform><lit>labels [</lit> <repl>listavariables</repl> <lit>]</lit></altform>
	<altform><lit>labels --to-file=</lit><repl>nomeficheiro</repl></altform>
	<altform><lit>labels --from-file=</lit><repl>nomeficheiro</repl></altform>
	<altform><lit>labels --delete</lit></altform>
      </altforms>
	<examples>
	<demos>
	  <demo>oprobit.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Coa primeira forma, se presentan as etiquetas informativas
	(se existen) das series de <repl>listavariables</repl>, ou
	de todas as series do conxunto de datos cando non especificas
	<repl>listavariables</repl>.
      </para>
      <para>
	Coa opción <opt>to-file</opt> se escriben no ficheiro indicado, as
	etiquetas de todas as series do conxunto de datos, unha etiqueta por
	cada liña. Se non hai ningunha etiqueta, amósase un fallo; e se algunhas
	series teñen etiqueta e outras non, preséntase unha liña en branco para
	as series sen etiqueta. O ficheiro resultante vaise escribir no cartafol
	<cmdref targ="workdir"/> vixente nese momento, agás que a cadea
	<repl>nomeficheiro</repl> conteña unha especificación completa da ruta.
      </para>
      <para>
	Coa opción <opt>from-file</opt>, lese o ficheiro especificado
	(que debe de ser de texto plano) e asígnanse etiquetas ás series
	do conxunto de datos, léndose unha etiqueta por liña e usando
	liñas en branco para indicar etiquetas en branco.
      </para>
      <para>
	A opción <opt>delete</opt> fai o que cabería agardar pois elimina
	todas as etiquetas das series do conxunto de datos.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos/Etiquetas de variables</menu-path>
    </gui-access>

  </command>

  <command name="lad" section="Estimation"
    label="Estimación da Mínima Desviación Absoluta">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--no-vcv</flag>
	  <effect>Non calcula a matriz de covarianzas</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
	      </option>
      </options>
    </usage>

    <description>
      <para>
	Calcula unha regresión que minimiza a suma das desviacións absolutas
	dos valores axustados respecto aos valores observados da variable
	dependente. As estimacións dos coeficientes derívanse utilizando o
	algoritmo do simplex de Barrodale&ndash;Roberts; e preséntase unha
	advertencia se a solución non é única.
      </para>
      <para>
	Os desvíos padrón dedúcense utilizando o procedemento 'bootstrap'
	con 500 extraccións. A matriz de covarianzas dos estimadores dos
	parámetros, que se presenta cando indicas <opt>vcv</opt>, baséase
	no mesmo 'bootstrap'. Dado que esta é unha operación custosa dabondo,
	a opción <opt>no-vcv</opt> proporciónase para aqueles casos nos que
	non se precisa a matriz de covarianzas; cando indicas esta opción, os
	desvíos padrón no van estar dispoñibles.
      </para>
      <para>
	Ten en conta que este método pode resultar lento cando a mostra
	é moi longa ou cando hai moitos regresores. Por iso, neses casos,
	pode ser mellor utilizar a instrución <cmdref targ="quantreg"/>.
	Dadas unha variable dependente <lit>y</lit> e unha lista <lit>X</lit>
	de regresores, as seguintes instrucións son basicamente equivalentes,
	coa excepción de que o método "quantreg" utiliza o algoritmo máis
	rápido de Frisch&ndash;Newton, e que proporciona os desvíos
	padrón analíticos en lugar dos de "bootstrapping".
      </para>
      <code>
	lad y const X
	quantreg 0.5 y const X
      </code>
    </description>

    <gui-access>
      <menu-path>/Modelar/Estimación Robusta/Mínima Desviación Absoluta</menu-path>
    </gui-access>

  </command>

  <command name="lags" section="Transformations" label="Xerar retardos"
	   context="cli">

    <usage>
      <arguments>
        <argument optional="true" separated="true">nivel</argument>
	      <argument>listaretardos</argument>
      </arguments>
      <options>
	<option>
	  <flag>--bylag</flag>
	  <effect>Ordena os termos por retardo</effect>
	</option>
      </options>
      <examples>
	<example>lags x y</example>
	<example>lags 12 ; x y</example>
	<example>lags 4 ; x1 x2 x3 --bylag</example>
	<demos>
	  <demo>sw_ch12.inp</demo>
	  <demo>sw_ch14.inp</demo>
	</demos>
	    </examples>
    </usage>

    <description>
      <para>
	Xera novas series que conteñen os valores retardados de cada
	unha das series de <repl>listavariables</repl>. Por defecto, o
	número de retardos que se crean é igual á periodicidade
	dos datos. Por exemplo, se a periodicidade é 4 (trimestral),
	a instrución <cmd>lags x</cmd> xera
      </para>
      <mono>
	x_1 = x(t-1)
	x_2 = x(t-2)
	x_3 = x(t-3)
	x_4 = x(t-4)
      </mono>
      <para>
	Podes controlar o número de retardos xerados mediante o
	primeiro parámetro opcional (que, se existe, debe de estar
	seguido dun punto e coma).
      </para>
      <para>
	A opción <opt>bylag</opt> ten sentido só cando <repl>listavariables</repl>
	contén máis dunha serie e o nivel máximo de retardos é maior ca 1.
	Por defecto, engádense os termos retardados ao conxunto de datos,
	por variable: primeiro todos os retardos da primeira serie da lista,
	despois todos os retardos da segunda serie, etcétera. Pero cando
	indicas <opt>bylag</opt>, a ordenación faise por retardos: primeiro
	o retardo 1 de todas as series da lista, despois o retardo 2 de todas
	as series da lista, etcétera.
      </para>
      <para>
  Esta prestación tamén está dispoñible como función: consulta
  <fncref targ="lags"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Engadir/Retardos das variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="lags-dialog" section="Estimation" context="gui"
    label="Cadro de selección de retardos">

    <description>
      <para>
	Neste diálogo podes elixir o nivel de retardos para as variables independentes
	do modelo de series temporais e, nalgúns casos, tamén para a variable dependente.
	(Pero ten en conta que o nivel de retardos habitual para modelos de vectores
	como VARs e VECMs manéxase por separado, mediante un botón con frechas
	arriba/abaixo de selección, na caixa de diálogo principal do modelo.)
      </para>
      <para>
	Os botóns con frechas arriba/abaixo da esquerda te permiten escoller un
	rango de retardos consecutivos para calquera variable dada. Para indicar
	retardos non consecutivos, preme un clic no cadriño a carón do campo co
	título <quote>Retardos específicos</quote>. Isto activa a caixa de anotación,
	na que podes teclear unha lista de retardos separados por espazos.
      </para>
      <para>
	A fila titulada <quote>Por defecto</quote> te ofrece un xeito rápido de
	establecer unha especificación de retardos común para todas as variables
	independentes, pois os valores colocados nesa fila cópianse a todas as
	outras (agás da variable dependente, se está presente).
      </para>
      <para>
	A variable dependente trátase de xeito especial: o retardo mínimo
	debe de ser cero, o que sitúa ao valor actual da variable no lado
	esquerdo do modelo. Calquera retardo maior aparece coas variables
	independentes no lado dereito do modelo.
      </para>
      <para>
	Os valores seleccionados neste diálogo lémbranse ao longo da duración
	da túa sesión cun conxunto determinado de datos.
      </para>

    </description>

  </command>

  <command name="ldiff" section="Transformations"
    label="Diferenzas logarítmicas" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Obtense a primeira diferenza do logaritmo natural de cada unha
	das series de <repl>listavariables</repl>, e o resultado gárdase nunha
	nova serie co prefixo <lit>ld_</lit>. Así <cmd>ldiff x y</cmd>
	xera as novas variables
      </para>
      <mono>
	ld_x = log(x) - log(x(-1))
	ld_y = log(y) - log(y(-1))
      </mono>
    </description>

    <gui-access>
      <menu-path>/Engadir/Diferenzas de logaritmos das variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="leverage" section="Tests" label="Observacións influentes">

    <usage>
      <options>
	<option>
	  <flag>--save</flag>
	  <effect>Garda as series resultantes</effect>
	</option>
	<option>
	  <flag>--overwrite</flag>
	  <effect>Conformidade para sobrescribir series xa existentes</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
	<option>
	  <flag>--plot</flag>
	  <optparm>Modo-ou-nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
	</option>
      </options>
	<examples>
	<demos>
	  <demo>leverage.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Debe de ir despois dunha instrución de MCO (<cmd>ols</cmd>). Calcula
	o pancamento (<math>h</math>, que debe de caer no rango entre 0 e 1)
	para cada punto de datos da mostra sobre a que se estimou o modelo
	previo. Amosa o erro (<math>u</math>) para cada observación xunto
	co seu pancamento e unha medida da súa influencia nas estimacións,
	<math>uh</math>/(1 &minus; <math>h</math>).
	Os <quote>puntos de Leverage</quote> para os que o valor de
	<math>h</math> supera 2<math>k</math>/<math>n</math> (onde
	<math>k</math> é o número de parámetros que se estiman e
	<math>n</math> é o tamaño da mostra) destácanse mediante
	un asterisco. Para obter máis detalles sobre os conceptos
	de pancamento e influencia, consulta o capítulo 2 do libro de
	<cite key="davidson-mackinnon93">Davidson e MacKinnon (1993)</cite>.
      </para>
      <para context="tex">
	Tamén se calculan os valores DFFITS: estes son iguais aos Erros
	tipificados (erros divididos polos seus desvíos padrón) multiplicados
	por $\sqrt{h/(1 - h)}$. Proporcionan unha medida da diferenza no
	axuste da observación <math>i</math> dependendo de se esa observación
	está incluída ou non na mostra da estimación. Para máis información
	sobre este apartado, consulta o capítulo 12 do libro de Maddala
	<cite key="maddala92">Introduction to Econometrics</cite>
	ou <cite key="belsley-etal80">Belsley, Kuh e Welsch (1980)</cite>.
	Para máis detalles sobre os Erros tipificados consulta máis abaixo,
	a sección titulada <emphasis>Matriz mediante accesorio</emphasis>.
      </para>
      <para context="notex">
	Tamén se calculan os valores DFFITS: estes son iguais aos Erros
	tipificados (erros divididos polos seus desvíos padrón) multiplicados
	pola raíz cadrada de <math>h</math>(1 &minus; <math>h</math>).
	Proporcionan unha medida da diferenza no axuste da observación
	<math>i</math> dependendo de se esa observación está incluída
	ou non na mostra da estimación. Para máis información
	sobre este apartado, consulta o capítulo 12 do libro de Maddala
	<cite key="maddala92">Introduction to Econometrics</cite>
	ou <cite key="belsley-etal80">Belsley, Kuh e Welsch (1980)</cite>.
	Para máis detalles sobre os Erros tipificados consulta máis abaixo,
	a sección titulada <emphasis>Matriz mediante accesorio</emphasis>.
      </para>
      <para context="cli">
	Cando especificas a opción <opt>save</opt> xunto con esta instrución,
	os valores de pancamento, influencia e DFFITS engádense ao
	conxunto vixente de datos; neste contexto, podes utilizar a opción
	<opt>quiet</opt> para eliminar a presentación dos resultados. Os
	nomes por defecto das series gardadas son <lit>lever</lit>,
	<lit>influ</lit> e <lit>dffits</lit>, respectivamente. Se xa existen
	series con eses nomes, o que aconteza dependerá de se indicas
	a opción <opt>overwrite</opt>, pois nese caso vanse sobrescribir
	as series xa existentes. En caso contrario, os nomes vanse axustar
	para poder garantir a unicidade, e as series novas xeradas serán
	as tres series con números ID máis grandes do conxunto de
	datos.
      </para>
      <para context="gui">
	Coa icona '+' da parte de arriba da xanela da proba de pancamento,
	podes presentar na pantalla unha caixa de diálogo que te permite gardar
	no conxunto vixente de datos, unha ou máis das variables desa proba.
      </para>
      <para context="tex">
	Logo da execución, o accesorio <fncref targ="$test"/> devolve o criterio
	de validación cruzada, que se define como
        \[
	\sum_{i=1}^n (y_i - \hat{y}_{-i})^2
        \]
	onde $\hat{y}_{-i}$ é o erro de predición para a observación
	$i$-ésima, logo de que esta sexa excluída da mostra. Por iso, o
	criterio é igual á suma dos erros cadrados de predición cando se
	utilizan todas as $n$ observacións agás a $i$-ésima para predicir
	(o denominado estimador <emphasis>deixar-un-fóra</emphasis>).
	Para unha discusión máis ampla sobre o criterio de validación
	cruzada, consulta o libro de Davidson e MacKinnon
	<book>Econometric Theory and Methods</book>, páxinas 685--686,
	e as referencias que contén.
      </para>
      <para context="notex">
	Logo da execución, o accesorio <fncref targ="$test"/> devolve o criterio
	de validación cruzada, que se define como a suma das desviacións cadradas
	da variable dependente con relación aos seus valores de predición,
	estando a predición para cada observación baseada nunha mostra da
	que se exclúe esa observación. (Este é o coñecido como estimador
	<emphasis>deixar-un-fóra</emphasis>). Para unha discusión máis ampla sobre
	o criterio de validación cruzada, consulta o libro de Davidson e MacKinnon
	<book>Econometric Theory and Methods</book>, páxinas 685&ndash;686, e
	as referencias que contén.
      </para>
      <para context="cli">
	Por defecto, se fas unha chamada interactiva a esta instrución, amósase
	unha gráfica cos valores de pancamento e influencia. Podes axustar
	isto mediante a opción <opt>plot</opt>. Os parámetros que se
	admiten para esta opción son <lit>none</lit> (para suprimir a gráfica),
	<lit>display</lit> (para amosar unha gráfica mesmo ao estar en modo
	de guións), ou un nome de ficheiro. O efecto de indicar un nome de
	ficheiro é como o descrito para a opción <opt>output</opt> da instrución
	<cmdref targ="gnuplot"/>.
      </para>
      <subhead context="cli">Matriz mediante accesorio</subhead>
      <para context="cli">
	Amais da opción <opt>save</opt> sinalada  antes, podes recuperar
	os resultados desta instrución en formato dunha matriz de tres
	columnas por medio do accesorio <fncref targ="$result"/>. As dúas
	primeiras columnas da mencionada matriz conteñen os valores de
	pancamento e de influencia (como con <opt>save</opt>), pero a
	terceira columna contén os Erros tipificados, en troques dos valores
	DFFITS. Estes son erros <quote>Tipificados externamente</quote>
	ou <quote>anavallados (jackknifed)</quote> &mdash;isto é, o desvío
	padrón que está no divisor para a observación <math>i</math> utiliza
	a media dos cadrados dos erros, omitindo esa observación. Ese tipo de erro
	pode interpretarse como un estatístico de proba <math>t</math> para
	a hipótese de que unha variable ficticia 0/1 que codifica de xeito
	especial a observación <math>i</math>, tería un coeficiente real nulo.
	Para obter máis detalles sobre a discusión adicional arredor dos
	Erros tipificados, consulta
	<cite key="chatterjee-hadi86">Chatterjee e Hadi (1986)</cite>.
      </para>
      <para>
	Os valores DFFITS tamén poden obterse a partir da matriz de
	<lit>$result</lit> do seguinte xeito:
      </para>
      <code>
	R = $result
	dffits = R[,3] .* sqrt(R[,1] ./ (1-R[,1]))
      </code>
      <para>
	Ou utilizando series:
      </para>
      <code>
	series h = $result[,1]  # Pancamento
	series sr = $result[,3] # Erro tipificado
	series dffits = sr * sqrt(h/(1-h))
      </code>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Análise/Observacións influentes</menu-path>
    </gui-access>

  </command>

  <command name="levinlin" section="Tests" label="Proba de Levin-Lin-Chu">

    <usage>
      <arguments>
        <argument>nivel</argument>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>Sen constante</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>Con constante e tendencia</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os resultados por unidade</effect>
	</option>
      </options>
      <examples>
	<example>levinlin 0 y</example>
        <example>levinlin 2 y --ct</example>
        <example>levinlin {2,2,3,3,4,4} y</example>
      </examples>
    </usage>

    <description>
      <para>
	Realiza a proba de raíz unitaria para panel descrita por
	<cite key="LLC2002">Levin, Lin e Chu (2002)</cite>. A hipótese
	nula é que todas as series temporais individuais presentan unha
	raíz unitaria, e a alternativa é que ningunha das series ten unha
	raíz unitaria. (É dicir, asúmese un mesmo coeficiente común de
	AR(1), aínda que noutros aspectos se permite que as propiedades
	estatísticas das series varíen duns individuos a outros.)
      </para>
	    <para context="cli">
	Por defecto, as regresións da proba ADF inclúen unha constante.
	Para eliminar a constante utiliza a opción <opt>nc</opt> e para
	incluíla xunto cunha tendencia linear utiliza a opción <opt>ct</opt>.
	(Consulta a instrución <cmdref targ="adf"/> para unha explicación
	das regresións do ADF.)
      </para>
      <para context="cli">
	Podes indicar o nivel de retardo con <repl>nivel</repl> (non negativo)
	para facer a proba (controlando así o número de retardos da variable
	dependente a incluír nas regresións do ADF) dunha destas dúas formas.
	Cando indicas un valor escalar, isto aplícase a tódolos individuos
	do panel. A alternativa é proporcionar unha matriz que conteña un
	nivel específico de retardos para cada individuo; esta debe de ser
	un vector con tantos elementos como individuos haxa no rango da
	mostra vixente. Podes especificar esa matriz co nome ou construíla
	utilizando chaves, como se ilustrou no último exemplo de
	arriba.
      </para>
      <para context="cli">
	Cando indicas a opción <opt>verbose</opt>, preséntanse os
	seguintes resultados para cada unidade do panel:
	<lit>delta</lit>, o coeficiente do nivel retardado en cada
	regresión ADF; <lit>s2e</lit>, a varianza estimada das
	innovacións; e <lit>s2y</lit>, a varianza estimada a longo
	prazo da serie diferenciada.
      </para>
      <para>
	Cae na conta de que as probas de raíz unitaria nun panel tamén podes realizalas
	utilizando as instrucións <cmdref targ="adf"/> e <cmdref targ="kpss"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Probas de raíz unitaria/Proba de Levin-Lin-Chu</menu-path>
    </gui-access>

  </command>

  <command name="loess" section="Estimation" label="Loess" context="gui">
    <description>
      <para>
	Realiza a regresión local (polinómica ponderada localmente) e
	xera unha serie que contén os valores preditos da variable
	dependente para cada valor non ausente da variable independente.
	O método é como se describe por
	<cite key="cleveland79">William Cleveland (1979)</cite>.
      </para>
      <para>
	Os controis te permiten que especifiques o nivel do polinomio
	da variable independente e a proporción de puntos de datos que
	se utilizan en cada regresión local (o largo da banda). Os
	valores máis grandes do largo de banda producen un resultado
	máis suave.
      </para>
      <para>
	Se marcas o cadriño de ponderacións robustas, o procedemento
	de regresión local reitérase dúas veces, coa modificación das
	ponderacións en base aos erros da iteración previa, de xeito que
	se lle dea menos influencia aos valores atípicos.
      </para>
     </description>
  </command>

  <command name="logistic" section="Estimation" label="Regresión loxística">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--ymax</flag>
	  <optparm>máximo</optparm>
	  <effect>Especifica o máximo da variable dependente</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para unha explicación</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--fixed-effects</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
	</option>
      </options>
      <examples>
        <example>logistic y const x</example>
        <example>logistic y const x --ymax=50</example>
      </examples>
    </usage>

    <description>
      <para>
	Regresión loxística: Leva a cabo unha regresión MCO utilizando
	a transformación loxística da variable dependente,
	<equation status="display"
	  tex="\[\log\left(\frac{y}{y^*-y}\right)\]"
	  ascii="log(y/(y* - y))"
	  graphic="logistic1"/>
	No caso de usar datos de panel, a especificación pode incluír os
	efectos fixos individuais.
      </para>
      <para>
	A variable dependente debe de ser estritamente positiva. Se
	todos os seus valores están entre 0 e 1, por defecto utilízase
	un valor de <math>y</math><sup>*</sup> (o máximo asintótico da
	variable dependente) igual a 1; se os seus valores están entre
	0 e 100, entón <math>y</math><sup>*</sup> é 100 por defecto.
      </para>
      <para context="cli">
	Se queres establecer un máximo diferente, utiliza a opción
	<opt>ymax</opt>. Ten en conta que o valor que indiques debe
	de ser maior ca todos os valores observados da variable
	dependente.
      </para>
      <para context="gui">
	Podes especificar un valor máximo diferente para <math>y</math>.
	Ten en conta que o valor que indiques debe de ser maior ca
	todos os valores observados da variable dependente.
      </para>
      <para>
	Os valores axustados e os erros da regresión transfórmanse
	automaticamente utilizando a inversa da transformación
	loxística:
	<equation status="display"
	  tex="\[y \approx E\left(\frac{y^*}{1+e^{-x}}\right)\]"
	  ascii="y =~ E(y* / (1 + exp(-x)))"
	  graphic="logistic2"/>
	onde <math>x</math> representa un valor axustado ou un erro,
	obtidos da regresión MCO que utiliza a variable dependente
	loxística. Deste xeito podes comparar os valores que se presentan
	cos da variable dependente orixinal. A aproximación é necesaria pois
	a transformación inversa non é linear, e polo tanto a esperanza non
	se corresponde exactamente.
      </para>
      <para>
	A opción <opt>fixed-effects</opt> só é aplicable cando o conxunto
	de datos ten forma de panel. Nese caso, réstanselle as medias de
	grupo da transformación loxística da variable dependente, e a
	estimación continúa como adoita facerse con efectos fixos.
      </para>
      <para>
	Ten en conta que se a variable dependente é binaria, debes de
	utilizar no seu lugar a instrución <cmdref targ="logit"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Variable Dependente Limitada/Loxística</menu-path>
      <menu-path>/Modelar/Panel/Loxística EF</menu-path>
    </gui-access>

  </command>

  <command name="logit" section="Estimation"
    label="Regresión Logit">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Desvíos padrón agrupados</effect>
        </option>
	<option>
	  <flag>--multinomial</flag>
	  <effect>Estima un logit multinomial</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>Amosa os valores p en vez das pendentes</effect>
	</option>
	<option>
	  <flag>--estrella</flag>
	  <effect>Escolle a variante pseudo-R-cadrado</effect>
	</option>
      </options>
	<examples>
	<demos>
	  <demo>keane.inp</demo>
	  <demo>oprobit.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Se a variable dependente é unha variable binaria (todos os seus
	valores son 0 ou 1), obtéñense estimacións máximo verosímiles
	dos coeficientes das variables de <repl>indepvars</repl> mediante
	o método de Newton&ndash;Raphson. Como o modelo é non linear,
	as pendentes están condicionadas polos valores das variables
	independentes. Por defecto, calcúlanse as pendentes con respecto a
	cada unha das variables independentes (nas medias desas variables),
	e estas pendentes substitúen os valores p habituais no resultado
	da regresión. Podes prescindir deste proceder indicando a opción
	<opt>p-values</opt>. O estatístico khi-cadrado proba a hipótese
	nula de que todos os coeficientes son cero, agás o da
	constante.
      </para>
      <para context="cli">
	Por defecto, os desvíos padrón calcúlanse utilizando a inversa
	negativa da matriz Hessiana. Se indicas a opción <opt>robust</opt>,
	entón calcúlanse no seu lugar os desvíos padrón CMV (QML) ou de
	Huber&ndash;White. Neste caso, a matriz de covarianzas estimadas é un
	<quote>emparedado</quote> entre a inversa da matriz Hessiana estimada
	e o produto externo do vector gradiente; consulta o capítulo 10 do libro de
	<cite key="davidson-mackinnon04">Davidson e MacKinnon (2004)</cite>.
	Pero cando indicas a opción <opt>cluster</opt>, entón xéranse os
	desvíos padrón <quote>robustos por agrupación</quote>;
	consulta o <guideref targ="chap:robust_vcv"/> para obter máis
	detalles.
      </para>
      <para context="cli">
	Por defecto, vaise amosar o estatístico pseudo-R-cadrado que foi
	suxerido por <cite key="mcfadden74">McFadden (1974)</cite>;
	mais no caso binario, se indicas a opción <opt>estrella</opt>
	vaise amosar en troques a variante recomendada por
	<cite key="estrella98">Estrella (1998)</cite>. Esta variante
	previsiblemente imita de xeito máis semellante as propiedades do
	<math>R</math><sup>2</sup> habitual no contexto da estimación
	de mínimos cadrados.
      </para>
      <para context="cli">
	Se a variable dependente é binaria, os coeficientes de logit representan
	os logaritmos das proporcións de probabilidades (cocientes entre a
	probabilidade de que <math>y</math> = 1 e a de que <math>y</math> = 0).
	Nese caso, o feixe (bundle) de <lit>$model</lit> dispoñible despois da
	estimación inclúe un elemento adicional nomeado <lit>oddsratios</lit>,
	unha matriz con catro columnas que conteñen o coeficiente (proporción
	de probabilidades) exponenciado, máis o erro padrón calculado mediante
	o método delta, e o intervalo co 95 por cento de confianza, para cada
	regresor. Cae na conta, porén, de que o intervalo de confianza
	calcúlase como o expoñente do intervalo para o coeficiente
	orixinal.
      </para>
      <para context="gui">
	Por defecto, os desvíos padrón calcúlanse utilizando a inversa
	negativa da matriz Hessiana. Se marcas o cadriño de
	<quote>Desvíos padrón robustos</quote>, entón calcúlanse no seu
	lugar os desvíos padrón CMV (QML) ou de Huber&ndash;White. Neste
	caso, a matriz de covarianzas estimadas é un <quote>emparedado</quote>
	entre a inversa da matriz Hessiana estimada e o produto externo do
	vector gradiente. Consulta o capítulo 10 do libro de Davidson e MacKinnon
	para obter máis detalles.
      </para>
      <para>
	Se a variable dependente non é binaria senón discreta, entón por defecto
	interprétase como unha resposta ordinal e obtéñense as estimacións cun
	Logit Ordenado. Porén, cando indicas a opción <opt>multinomial</opt>,
	a variable dependente interprétase como unha resposta sen ordenar e
	xéranse as estimacións cun Logit Multinomial. (Noutro caso, se
	a variable escollida como dependente non é de tipo discreto, amósase
	un fallo.) O accesorio <lit>$allprobs</lit> está dispoñible despois da
	estimación, para conseguir unha matriz que conteña as probabilidades
	estimadas dos posibles valores da variable dependente para cada
	observación (coas observacións por filas e os posibles valores por
	columnas).
      </para>
      <para>
	Se queres utilizar un Logit para a análise de proporcións onde, para
	cada observación, a variable dependente é a proporción de casos
	que teñen unha determinada característica (en vez dunha variable
	con 1 ou 0 para indicar se está presente ou non a característica),
	non debes de utilizar a instrución <cmd>logit</cmd>, senón máis
	ben construír a variable logit, como en
      </para>
      <code>
	series lgt_p = log(p/(1 - p))
      </code>
      <para>
	e utilizar esta como a variable dependente dunha regresión MCO. Consulta o capítulo 12 de <cite key="ramanathan02">Ramanathan (2002)</cite>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Variable Dependente Limitada/Logit</menu-path>
    </gui-access>

  </command>

  <command name="logs" section="Transformations"
    label="Xerar logaritmos" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Permite obter o logaritmo natural de cada unha das series de
	<repl>listavariables</repl> e o resultado gárdase nunha nova serie co
	prefixo <lit>l_</lit> (<quote>ele</quote> e guión baixo). Por
	exemplo, <cmd>logs x y</cmd> xera as novas variables
	<lit>l_x</lit> = ln(<lit>x</lit>) e <lit>l_y</lit> = ln(<lit>y</lit>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Engadir/Logaritmos das variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="loop" section="Programming"
    label="Comezar un bucle de instrucións" context="cli">

    <usage>
      <arguments>
        <argument>control</argument>
      </arguments>
      <options>
	<option>
	  <flag>--progressive</flag>
	  <effect>Permite formas especiais de certas instrucións</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Reflicte as instrucións e amosa mensaxes confirmatorios</effect>
	</option>
	<option>
	  <flag>--decr</flag>
	  <effect>Mira abaixo</effect>
	</option>
      </options>
      <examples>
        <example>loop 1000</example>
        <example>loop i=1..10</example>
        <example>loop while essdiff &gt; .00001</example>
        <example>loop for (r=-.99; r&lt;=.99; r+=.01)</example>
	<example>loop foreach i listaX</example>
	<demos>
	  <demo>armaloop.inp</demo>
	  <demo>keane.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Esta instrución abre un modo especial no que o programa admite que
	as instrucións se executen repetidas veces. Terminas o proceso de
	ir introducindo as instrucións do bucle con <cmd>endloop</cmd> e
	neste punto execútanse as instrucións apiñadas.
      </para>
      <para>
	O parámetro <repl quote="true">control</repl> pode ter calquera das 5
	formas seguintes, tal como se amosa nos exemplos: (a) un número
	enteiro que indica as veces a repetir as instrucións dun bucle;
	(b) un rango de valores enteiros para unha variable índice; (c) a
	palabra <quote><lit>while</lit></quote> máis unha condición booleana;
	(d) a palabra <quote><lit>for</lit></quote> máis 3 expresións dentro
	dunha paréntese, separadas con punto e comas (que imita a orde
	<lit>for</lit> na linguaxe de programación C); ou (e) a palabra
	<quote><lit>foreach</lit></quote> máis unha variable índice e unha
	lista.
      </para>
      <para>
	A opción <opt>decr</opt> é específica só para a forma de bucle do
	tipo <quote>rango de valores enteiros</quote>. Por defecto, o índice
	se incrementa en 1 en cada iteración; e se o valor de inicio é menor
	que o valor final, o bucle non vai funcionar. Pero cando se proporcione
	un valor para <opt>decr</opt>, o índice se reduce en 1 en cada
	iteración.
      </para>
      <para>
	Consulta o <guideref targ="chap:looping"/> para obter todos os detalles
	e exemplos. Aí explícase o efecto da opción <opt>progressive</opt>
	(que está deseñada para utilizarse con simulacións de tipo Monte
	Carlo). Non podes utilizar todas as instrucións de GRETL dentro dun
	bucle; por iso as instrucións dispoñibles neste contexto tamén se
	expoñen aí.
      </para>
      <para>
	Por defecto, a execución de instrucións faise de xeito máis silandeiro
	dentro de bucles ca noutros contextos. Se queres máis retroalimentación
	co que estea a pasar nun bucle, indica a opción <opt>verbose</opt>.
      </para>
    </description>

  </command>

  <command name="mahal" section="Statistics" label="Distancias de Mahalanobis">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
        </option>
	<option>
	  <flag>--save</flag>
	  <effect>Engade as distancias ao conxunto de datos</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Calcula as distancias de Mahalanobis desde cada observación ata o
	centroide, usando as series indicadas en <repl>listavariables</repl>.
	A distancia de Mahalanobis é a distancia entre dous puntos nun
	espazo de dimensión <math>k</math>, escalada pola variación
	estatística en cada dimensión do espazo. Por exemplo, se
	<math>p</math> e <math>q</math> son dúas observacións dun conxunto
	de <math>k</math> variables con matriz de covarianzas <math>C</math>,
	entón a distancia de Mahalanobis entre as observacións ven dada
	por
	<equation status="display"
        tex="\[\sqrt{(p-q)^{\prime}C^{-1}(p-q)}\]"
        ascii="sqrt((p - q)' * C-inverse * (p - q))"
          graphic="mahal"/>
	onde (<math>p</math> &minus; <math>q</math>) é un vector
	de dimensión <math>k</math>. Isto redúcese á distancia
	euclidiana en caso de que a matriz de covarianzas sexa unha
	matriz identidade.
      </para>
      <para>
	O espazo para o que se calculan as distancias está definido polas
	variables seleccionadas. Para cada observación do rango
	vixente da mostra, a distancia calcúlase entre a observación
	e o centroide das variables escollidas. Esta distancia é a
	contrapartida multidimensional dunha puntuación <math>z</math>
	estándar, e podes utilizala para xulgar se unha observación
	dada <quote>ten un sitio</quote> xunto a un grupo doutras
	observacións.
      </para>
      <para context="cli">
	Cando indicas a opción <opt>vcv</opt>, preséntanse tanto a
	matriz de covarianzas como a súa inversa. Cando indicas a
	opción <opt>save</opt>, as distancias gárdanse no conxunto
	de datos co nome <lit>mdist</lit> (ou <lit>mdist1</lit>,
	<lit>mdist2</lit> e así sucesivamente, se xa existe unha
	variable con ese nome).
      </para>
      <para context="gui">
	Cando o número de variables seleccionadas é de 4 ou menos,
	preséntanse tanto a matriz de covarianzas como a súa inversa.
	Ao premer co rato no botón '+' no alto da xanela que amosa as
	distancias, te permite a posibilidade de engadir as distancias
	ao conxunto de datos como unha nova variable.
      </para>
      <para>
        Consulta tamén a función <fncref targ="distance"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Distancias de Mahalanobis</menu-path>
    </gui-access>

  </command>

  <command name="mailer" section="Utilities" context="gui"
    label="Enviar un ficheiro por correo">

    <description>
      <para>
	Podes enviar un banco de datos (ou un guión de instrucións) como engadido
	de correo desde dentro de GRETL, usando o SMTP (Simple Mail Transfer
	Protocol). Deseguido, explícase como interpretar as dúas táboas
	(<quote>Configuración de correo</quote> e <quote>Mensaxe</quote>) da caixa
	de diálogo do correo. Tamén se comentan os requirimentos de contrasinal.
      </para>
      <subhead>Lapela de configuración de correo</subhead>
      <ilist>
	<li>
	  <para>
	    Servidor SMTP: é o servidor co que debera de enviarse o teu
	    correo. Se es usuario de gmail é de agardar que te atopes
	    con que te funciona a configuración por defecto,
	    <lit>smtps://smtp.gmail.com:465</lit>; do contrario, vas ter
	    que introducir a información pola túa conta. Fíxate que a cadea
	    de texto do servidor debe comezar ben con <lit>smtp://</lit>,
	    ou ben con <lit>smtps://</lit>. Despois do nome do servidor é
	    necesario engadir dous puntos, seguidos por o número dun porto,
	    como no <quote><lit>:465</lit></quote> indicado antes. Outros
	    valores posibles para o número do porto SMTP son 25 e 587.
	  </para>
	</li>
	<li>
	  <para>
	    Nome de usuario de correo: é o nome de usuario co que te
	    identifica o teu servidor de correo. Probablemente é o mesmo
	    nome que ten a túa dirección de correo.
	  </para>
	</li>
	<li>
	  <para>
	    Contrasinal de correo: o máis probable é que o teu servidor SMTP
	    desexe comprobar un contrasinal, pero se non, podes premer en
	    <quote>Non é necesario contrasinal</quote>.
	  </para>
	</li>
      </ilist>
      <para>
	A túa información de servidor e de usuario lémbrase dunha sesión de
	GRETL ata a seguinte, de xeito que só tes que introducila unha vez.
	De igual xeito que co contrasinal, é elección túa decidir gardala ou
	non; consulta a sección <emphasis>Contrasinal de correo</emphasis>
	de máis abaixo para obter máis detalles.
      </para>
      <para>
	Ao premer <lit>OK</lit> na ficha de configuración de correo, vaste mover
	á ficha de mensaxe (agás que se perdese a información requirida).
      </para>
      <subhead>Lapela de mensaxe</subhead>
      <ilist>
       <li>
	 <para>
	   A: é a dirección de correo do destinatario. A primeira vez vas
	   ter que introducila pola túa conta, pois GRETL non ten acceso á
	   túa axenda de direccións. Agora ben, unha vez introducida unha
	   dirección, esta lémbrase e podes seleccionala máis adiante
	   mediante unha lista despregable. Podes gardar ata dez direccións
	   deste xeito.
	 </para>
       </li>
       <li>
	 <para>
	   De: é a túa propia dirección de correo. Esta lémbrase dunha
	   sesión de GRETL ata a seguinte.
	 </para>
       </li>
       <li>
	 <para>
	   Tema: isto énchese automaticamente, pero se o desexas podes
	   editalo.
	 </para>
       </li>
       <li>
	 <para>
	   Nota: tamén énchese automaticamente, pero podes editala.
	 </para>
       </li>
      </ilist>
      <para>
	Ao premer <lit>OK</lit> na ficha de mensaxe, enviarás a mensaxe
	(agás que se perdese algunha información requirida).
      </para>
      <subhead>Contrasinal de correo</subhead>
      <para>
	Si se necesita un contrasinal para enviar o correo, podes elixir que
	GRETL o teña gardado. Nese caso, gárdase en formato arrevesado nun
	directorio que está reservado para ti, no teu ordenador (en ningún
	servidor de internet). Porén, non podemos garantir a súa
	seguridade.
      </para>
      <para>
	Se ti es usuario de gmail e utilizas a autenticación en 2-pasos,
	ten en conta que o teu contrasinal habitual de gmail non vai
	funcionar neste contexto. Vas necesitar unha
	<quote>App de contrasinal</quote> para utilizala con GRETL; consulta
	<url>https://support.google.com/accounts/answer/185833</url>.
      </para>
    </description>

  </command>

  <command name="makepkg" section="Programming" context="cli"
    label="Facer un paquete de funcións">

    <usage>
      <arguments>
        <argument>nomeficheiro</argument>
      </arguments>
      <options>
        <option>
	  <flag>--index</flag>
	  <effect>Escribe o ficheiro índice, auxiliar</effect>
        </option>
        <option>
	  <flag>--translations</flag>
	  <effect>Escribe o ficheiro de cadeas de texto, auxiliar</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Funciona silandeiramente</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Dá soporte á creación dun paquete de funcións de GRETL mediante a liña
	de instrucións. O modo de funcionamento desta instrución depende da
	extensión do <repl>nomeficheiro</repl>, que debe de ser ben
	<lit>.gfn</lit> ou ben <lit>.zip</lit>.
      </para>
      <subhead>Modo gfn</subhead>
      <para>
	Escribe un ficheiro gfn. Asúmese que pode accederse a un ficheiro
	de especificación dun paquete, que ten o mesmo nome base ca
	<repl>nomeficheiro</repl> pero coa extensión <lit>.spec</lit>, xunto
	con calquera ficheiro auxiliar ao que faga referencia. Tamén asúmese
	que todas as funcións a empaquetar léronse na memoria.
      </para>
      <subhead>Modo zip</subhead>
      <para>
	Escribe un ficheiro comprimido zip dun paquete (un gfn máis outros
	elementos). En caso de acharse un ficheiro gfn co mesmo nome base
	que <repl>nomeficheiro</repl>, GRETL comproba os ficheiros correspondentes
	<lit>inp</lit> e <lit>spec</lit>, e se os atopa a ambos, sendo polo
	menos un deles máis novo ca o ficheiro gfn, entón vólvese xerar
	o gfn; se non, utilízase o gfn existente. Cando non se atopa
	ese ficheiro, GRETL tenta primeiro xerar o gfn.
      </para>
      <subhead>Opcións de gfn</subhead>
      <para>
	Os indicadores de opcións admiten a escritura de ficheiros auxiliares,
	pensados para utilizar cos <quote>engadidos</quote> de GRETL. O
	ficheiro índice é un curto documento XML que contén información
	básica sobre o paquete, e que ten o seu mesmo nome como base
	ademáis da extensión <lit>.xml</lit>. O ficheiro de traducións contén
	as cadeas de texto do paquete (en formato C) que poderían ser
	apropiadas para a tradución; para un paquete <lit>foo</lit>
	este ficheiro chámase <lit>foo-i18n.c</lit>. Estes ficheiros
	non se xeran se a instrución opera en modo zip, e se utiliza
	un ficheiro gfn que xa existía.
      </para>
      <para>
	Para obter máis detalles sobre todo isto, consulta o
	<mnu targ="Pkgbook">Manual de paquetes de funcións</mnu> de GRETL.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ficheiro/Paquetes de funcións/Novo paquete</menu-path>
    </gui-access>

  </command>

  <command name="maps" section="Utilities" label="Debuxar mapas" context="gui">
    <description>
      <para>
	Esta instrución te permite crear un mapa, baseado en datos xeográficos
	descargados previamente (en formato dun ficheiro GeoJSON ou dun
	ficheiro ESRI de forma). As opcións son as seguintes.
      </para>
      <ilist>
	<li>
	  <para>
	    series to plot: En caso de existir, representa a serie a partir
	    da que se deberán colorear as rexións do mapa; tamén se coñece
	    como a <quote>carga</quote>. Se falta esa carga só se amosarán
	    os trazos do mapa. Se o conxunto de datos vixente contén unha
	    ou máis series que semellan posibles candidatas (en base a unha
	    heurística sinxela), estas vanse amosar nun selector
	    despregable.
	  </para>
	</li>
	<li>
	  <para>
	    palette: A paleta que permite a escolla do conxunto de cores
	    que se usan para representar a carga, e que en consecuencia
	    só resulta relevante cando se selecciona unha carga.
	  </para>
	</li>
	<li>
	  <para>
	    log scale: No caso de seleccionar unha carga, se debería
	    representar esta en escala logarítmica? Por defecto, non.
	  </para>
	</li>
	<li>
	  <para>
	    border: Debera debuxarse un borde rectangular arredor do mapa?
	    Por defecto, si; pero podes eliminar isto.
	  </para>
	</li>
	<li>
	  <para>
	    feature border width: Te proporciona o control sobre a anchura
	    do borde ou do contorno que se debuxa arredor das distintas
	    <quote>características</quote> do mapa (por exemplo: países,
	    estados, rexións, provincias,...). Se o teu gráfico xa inclúe
	    unha carga, podes reducir a anchura ata cero para eliminar eses
	    bordes.
	  </para>
	</li>
	<li>
	  <para>
	    height: Isto indica altura, e permite controlar o tamaño da imaxe
	    do mapa. Dada a altura, o ancho calcúlase en base ao rango de
	    lonxitude do mapa.
	  </para>
	</li>
      </ilist>
      <para>
	Cae na conta de que podes gañar un control <i>moito</i> maior
	sobre os detalles do mapa, por medio da invocación á función
	<fncref targ="geoplot"/>.
      </para>
    </description>
  </command>

  <command name="markers" section="Dataset" label="Marcadores de observación" context="cli">

    <usage>
      <altforms>
	<altform><lit>markers --to-file=</lit><repl>nomeficheiro</repl></altform>
	<altform><lit>markers --from-file=</lit><repl>nomeficheiro</repl></altform>
	<altform><lit>markers --to-array=</lit><repl>nome</repl></altform>
	<altform><lit>markers --from-array=</lit><repl>nome</repl></altform>
	<altform><lit>markers --from-series=</lit><repl>nome</repl></altform>
	<altform><lit>markers --delete</lit></altform>
      </altforms>
    </usage>

    <description>
      <para>
	As opcións <opt>to-file</opt> e <opt>to-array</opt> proporcionan xeitos
	de gardar as cadeas de texto que son marcadores das observacións do
	conxunto vixente de datos, ben no ficheiro ou ben no arranxo que indiques.
	Se non existe ningunha desas cadeas, amósase un fallo. No caso do
	ficheiro, as cadeas escríbense unha por cada liña nese ficheiro, e este
	gárdase no cartafol (<cmdref targ="workdir"/>) establecido nese momento,
	agás que a cadea <repl>nomeficheiro</repl> conteña unha especificación
	completa da ruta. No caso do arranxo, se <repl>nome</repl> é o
	identificador dun arraxo de cadeas de texto xa existente, ese arranxo 
	vaise sobrescribir; noutro caso, vaise crear un novo.
      </para>
      <para>
	Coa opción <opt>from-file</opt>, lese o ficheiro especificado (que
	debe de ser de texto UTF-8) e asígnanse os marcadores de observación
	contidos neste, un por cada liña, ás filas do conxunto de datos. En
	xeral, debería de haber como mínimo tantos marcadores no ficheiro
	como observacións no conxunto de datos; pero se o conxunto de datos
	é de tipo panel, tamén se acepta que o número de marcadores no
	ficheiro coincida co número de unidades de sección cruzada (en cuxo
	caso os marcadores repítense para cada período de tempo.) A opción
	<opt>from-array</opt> funciona de xeito similar, facendo a lectura a
	partir dun arranxo de cadeas de texto determinado.
      </para>
      <para>
	A opción <opt>from-series</opt> ofrece un xeito apropiado de crear
	marcadores de observación, copiándoos dunha serie con valores en
	forma de cadeas de texto. Amósase un fallo cando a serie indicada
	non ten valores de cadea de texto.
      </para>
      <para>
	A opción <opt>delete</opt> fai o que xa agardarías, é dicir, eliminar
	as cadeas de texto que marcan cada observación do conxunto de datos.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos/Marcadores das observacións</menu-path>
    </gui-access>

  </command>

  <command name="meantest" section="Tests" label="Diferenza de medias">

    <usage>
      <altforms>
        <altform><lit>meantest</lit> <repl>x</repl> <repl>y</repl> </altform>
        <altform><lit>meantest</lit> <repl>x</repl> <lit>--split-by=</lit><repl>ficticia</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--unequal-vars</flag>
	  <effect>Asume que as varianzas non son iguais</effect>
        </option>
        <option>
	  <flag>--paired</flag>
	  <effect>Realiza unha proba de emparellados</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Elimina a presentación do resultado</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Só para series temporais</effect>
        </option>
      </options>
      <examples>
        <example>meantest x y</example>
        <example>meantest x y --unequal-vars</example>
        <example>meantest x y --paired</example>
        <example>meantest x --split-by=d</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	No seu uso básico, calcula o estatístico <math>t</math> para probar
	a hipótese nula de que as medias na poboación son iguais para as
	series <repl>x</repl> e <repl>y</repl>, e amosa un resultado que
	inclúe a súa probabilidade asociada (valor p). Os resultados se
	poden recuperar utilizando os accesorios <fncref targ="$test"/> e
	<fncref targ="$pvalue"/>, en cuxo caso pódese utilizar a opción
	<opt>quiet</opt> para omitir a impresión.
      </para>
      <para context="cli">
	Na súa forma alternativa, coa opción <opt>split-by</opt>, as mostras
	para as que se proba a igualdade das súas medias son dous subconxuntos
	da serie <repl>x</repl>, para as que a serie <repl>ficticia</repl>
	toma os valores 0 e 1, respectivamente.
      </para>
      <para context="cli">
	Por defecto, o estatístico de proba calcúlase baixo o suposto
	de que as varianzas son iguais para as dúas variables. Coa
	opción <opt>unequal-vars</opt> asúmese que as varianzas
	son diferentes; e neste caso, os graos de liberdade do
	estatístico de proba aproxímanse consonte a
	<cite key="satter46">Satterthwaite (1946)</cite>.
      </para>
      <subhead context="cli">Proba de emparellados</subhead>
      <para context="cli">
	No caso básico (unicamente) pódese indicar a opción <opt>paired</opt>
	para probar a hipótese nula de que a diferenza media entre os
	valores emparellados das dúas series dos argumentos, é nula.
	Noutro caso, non se asume o emparellamento.
      </para>
      <subhead context="cli">Proba robusta</subhead>
      <para context="cli">
	Con datos de series temporais, no caso básico (unicamente) pódese
	indicar a opción <opt>robust</opt> para realizar unha proba de
	igualdade de medias entre <repl>x</repl> e <repl>y</repl> que é
	robusta a respecto da autocorrelación.
      </para>
      <para context="gui">
	Calcula o estatístico t para probar a hipótese nula de que as medias
	na poboación son iguais para dúas series seleccionadas, e amosa a
	súa probabilidade asociada (valor p). Podes invocar esta instrución
	asumindo ou non que as varianzas son iguais para as dúas variables.
	No derradeiro caso, os graos de liberdade do estatístico para a proba
	aproxímanse consonte a
	<cite key="satter46">Satterthwaite (1946)</cite>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ferramentas/Calculadora de estatísticos de proba</menu-path>
    </gui-access>

  </command>

  <command name="MIDAS_list" section="Dataset" label="Lista MIDAS"
	   context="gui">
    <description>
      <para>
	Unha lista MIDAS (MIDAS = Mixed Data Sampling) é unha lista definida
	(de series) cuxos elementos representan conxuntamente unha variable
	de tipo serie temporal que se observa nunha frecuencia maior ca do
	conxunto de datos do contexto (<quote>host</quote>). Por exemplo,
	unha lista deste tipo podería representar unha serie mensual no
	contexto dun conxunto de datos trimestrais ou anuais, ou unha serie
	diaria no contexto dun conxunto de datos mensual.
      </para>
      <para>
	Unha lista deste tipo debe de ter <math>m</math> elementos,
	onde <math>m</math> é o número de períodos de alta frecuencia
	por período do conxunto de datos, e cada serie contén os valores
	para un determinado subperíodo. No caso mensual/trimestral, isto
	quere dicir que unha lista ten 3 elementos: un elemento contén os
	valores para o terceiro mes do trimestre, outro contén os valores
	para o segundo mes, e o outro os valores para o primeiro mes.
      </para>
      <para>
	Ademais, estes membros da lista deben de estar dispostos na orde
	particular <emphasis>primeiro os máis recentes</emphasis>, en
	concreto. Continuando co exemplo mensual/trimestral, a orde debe
	de ser: mes 3, mes 2, mes 1. Aínda que isto podería semellar
	<quote>ao revés</quote> é a orde que se require para poder
	xerar as listas de retardos, que é a característica distintiva
	da modelaxe MIDAS.
      </para>
      <para>
	Para ter unha guía de como xerar un conxunto de datos que
	admita listas MIDAS, consulta
      </para>
      <para>
	<url>http://gretl.sourceforge.net/midas/midas_gretl.pdf</url>
      </para>
    </description>
  </command>
  
  <command name="MIDAS_parm" section="Estimation"
	   label="Hiperparámetros do MIDAS" context="gui">
    <description>
      <para>
	Neste diálogo se te pide que escollas o tipo de disposición de
	parámetros para un conxunto de termos de alta frecuencia, así
	como o rango de retardos destes termos. Os tipos admitidos de
	disposición de parámetros son:
      </para>
      <ilist>
	<li>
	  <para>
	    U-MIDAS ou <quote>MIDAS non restrinxido</quote>: cada
	    retardo ten o seu propio coeficiente.
	  </para>
	</li>
	<li>
	  <para>
	    Almon exponencial normalizada: require polo menos un
	    parámetro e habitualmente utiliza dous.
	  </para>
	</li>
	<li>
	  <para>
	    Beta normalizada cun derradeiro retardo nulo: require
	    exactamente dous parámetros.
	  </para>
	</li>
	<li>
	  <para>
	    Beta normalizada cun derradeiro retardo non nulo:
	    require exactamente tres parámetros.
	  </para>
	</li>
	<li>
	  <para>
	    Polinomio de Almon: require polo menos un parámetro.
	  </para>
	</li>
	<li>
	  <para>
	    Beta normalizada, 1 parámetro: esta é unha variante
	    do Beta normalizada cun derradeiro retardo nulo, no que
	    o valor do primeiro parámetro fíxase en 1.0. O segundo
	    parámetro estímase suxeito á restrición de que este é
	    cando menos 1.0.
	  </para>
	</li>
      </ilist>
    </description>
  </command>

  <command name="midasreg" section="Estimation" label="Regresión MIDAS">
    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	      <argument separated="true">termosMIDAS</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
        </option>
        <option>
	  <flag>--levenberg</flag>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
      <examples>
        <example>midasreg y 0 y(-1) ; mds(X, 1, 9, 1, theta)</example>
	<example>midasreg y 0 y(-1) ; mds(X, 1, 9, 0)</example>
	<example>midasreg y 0 y(-1) ; mdsl(XL, 2, theta)</example>
	<demos>
	  <demo>gdp_midas.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Leva a cabo a estimación por mínimos cadrados (ben MCNL ou ben
	MCO, dependendo da especificación) dun modelo MIDAS (Mixed Data
	Sampling). Este tipo de modelos inclúe unha ou máis variables
	independentes que se observan cunha frecuencia maior que a
	variable dependente; para unha boa e breve introdución consulta
	<cite key="armesto10">Armesto, Engemann e Owyang (2010)</cite>.
      </para>
      <para context="cli">
	As variables de <repl>indepvars</repl> deben de ter a mesma
	frecuencia que a variable dependente. Esta lista normalmente
	debe incluír <lit>const</lit> ou <lit>0</lit> (ordenada na orixe),
	e habitualmente inclúe un ou máis retardos da variable dependente.
	Os termos de alta frecuencia indícanse despois dun punto e coma;
	cada un ten o formato duns cuantos argumentos entre parénteses,
	separados con comas, precedidos ben por <lit>mds</lit> ou ben
	por <lit>mdsl</lit>.
      </para>
      <para context="gui">
	As variables baixo <repl>Regresores</repl> teñen a mesma frecuencia que
	a variable dependente, e escóllense da lista superior do lado esquerdo.
	Os modelos MIDAS habitualmente inclúen un ou máis retardos da variable
	dependente; isto contrólase mediante o botón con frechas arriba/abaixo
	de <quote>Orde AR</quote>, que por defecto marca 1 retardo. Para engadir
	termos MIDAS (alta frecuencia), elixe variables na lista do lado inferior
	esquerdo e usa a frecha verde inferior (ou preme o botón dereito do rato).
      </para>
      <para context="gui">
	Ao engadir un termo MIDAS, emerxe un diálogo para permitirche
	escoller: o rango de retardos, o tipo de disposición de parámetros
	e o número de hiperparámetros (para aqueles tipos que non teñen
	un número fixo de parámetros). Podes facer emerxer outra vez este
	diálogo para revisar unha especificación, premendo o botón dereito
	do rato nun termo MIDAS da dereita.
      </para>
      <para context="cli">
	<lit>mds</lit>: Esta variante xeralmente require 5 argumentos, do
	xeito seguinte: o nome dunha <cmdref targ="MIDAS_list"/>, dous
	enteiros que indican os retardos mínimo e máximo de alta frecuencia,
	un enteiro entre 0 e 4 (ou unha cadea de texto, mira baixo) que
	especifica o tipo de disposición dos parámetros que se vai usar, e o
	nome dun vector que contén os valores iniciais dos parámetros. O
	exemplo de abaixo solicita os retardos do 3 ao 11 das series de alta
	frecuencia representadas na lista <lit>X</lit>, utilizando para elo
	unha disposición dos parámetros de tipo 1 (Almon exponencial, mira
	abaixo) co vector de inicio <lit>theta</lit>.
      </para>
      <code context="cli">
	mds(X, 3, 11, 1, theta)
      </code>
      <para context="cli">
	<lit>mdsl</lit>: Xeralmente require 3 argumentos: o nome dunha lista de
	retardos MIDAS, un número enteiro (ou unha cadea de texto, mira baixo)
	para especificar o tipo de disposición dos parámetros e o nome dun vector
	de inicio. Neste caso, os retardos máximo e mínimo están implícitos no
	argumento inicial da lista. No exemplo de abaixo <lit>Xlags</lit> debe
	de ser unha lista que xa conteña todos os retardos que se necesiten;
	podes construír unha lista dese tipo utilizando a función
	<fncref targ="hflags"/>.
      </para>
      <code context="cli">
	mdsl(XLags, 1, theta)
      </code>
      <para context="cli">
	Os tipos de disposición de parámetros que se admiten amósanse
	abaixo. No contexto das especificacións <lit>mds</lit> e <lit>mdsl</lit>,
	podes indicalos en forma dos códigos numéricos, ou das cadeas de texto
	entre comiñas que se amosan despois dos números:
      </para>
      <para context="cli">
	0 ou <lit>"umidas"</lit>: MIDAS sen restricións ou U-MIDAS, no que
	cada retardo ten o seu propio coeficiente.
      </para>
      <para context="cli">
	1 ou <lit>"nealmon"</lit>: Almon exponencial normalizada, que
	require polo menos un parámetro e habitualmente utiliza dous.
      </para>
      <para context="cli">
	2 ou <lit>"beta0"</lit>: Beta normalizada cun derradeiro retardo
	nulo, que require exactamente dous parámetros.
      </para>
      <para context="cli">
	3 ou <lit>"betan"</lit>: Beta normalizada cun derradeiro retardo
	non nulo, que require exactamente tres parámetros.
      </para>
      <para context="cli">
	4 ou <lit>"almonp"</lit>: Polinomio de Almon (non normalizada),
	que require polo menos un parámetro.
      </para>
      <para context="cli">
	5 or <lit>"beta1"</lit>: Similar a <lit>beta0</lit>, mais co primeiro
	parámetro fixado en 1 (deixando un único parámetro libre).
      </para>
      <para context="cli">
	Cando a disposición de parámetros é U-MIDAS, non é necesario o
	vector de inicio do último argumento. Noutros casos, podes solicitar
	unha iniciación automática substituíndo o nome do vector de
	parámetros inicial por algunha destas dúas formas:
      </para>
      <ilist context="cli">
	<li>
	  <para>
	    A palabra chave <lit>null</lit>: isto só é admisible cando a
	    disposición dos parámetros ten un número fixo de termos (os
	    casos Beta, con 2 ou 3 parámetros). Tamén se acepta no caso
	    do Almon exponencial, o que implica que ese é o valor por
	    defecto dos dous parámetros.
	  </para>
	</li>
	<li>
	  <para>
	    Un valor enteiro que indica o número requirido de parámetros.
	  </para>
	</li>
      </ilist>
      <para context="cli">
	O método de estimación que utiliza esta instrución depende da
	especificación dos elementos de alta frecuencia. No caso de U-MIDAS,
	o método é MCO (OLS); noutro caso, é mínimos cadrados non lineais
	(MCNL ou NLS). Cando especificas as disposicións de parámetros
	Almon exponencial normalizada ou Beta normalizada, o método MCNL
	por defecto é unha combinación de BFGS restrinxido e MCO, pero
	podes indicar a opción <opt>levenberg</opt> para forzar que se
	utilice o algoritmo de Levenberg&ndash;Marquardt.
      </para>
      <para context="gui">
	O método de estimación que utiliza esta instrución depende da
	especificación dos elementos de alta frecuencia. No caso de U-MIDAS,
	o método é MCO (OLS); noutro caso, é mínimos cadrados non lineais
	(MCNL ou NLS). Cando especificas as disposicións de parámetros
	Almon exponencial normalizada ou Beta normalizada, o método MCNL
	por defecto é unha combinación de BFGS restrinxido e MCO, agás
	que marques a caixiña titulada
	<quote>Preferir MCNL mediante Levenberg-Marquardt</quote>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Series temporais univariantes/MIDAS</menu-path>
    </gui-access>
  </command>

  <command name="missing" section="Dataset" context="gui"
    label="Valores para datos ausentes">

    <description>
      <para>
	Establece un valor numérico que se interpreta como <quote>ausente</quote>
	ou <quote>non dispoñible</quote>, ben para unha serie de datos particular
	(baixo o menú Variable) ou ben globalmente para todo o conxunto de
	datos (baixo o menú Datos).
      </para>
      <para>
	GRETL ten a súa propia codificación interna para os valores ausentes,
	pero á veces os datos que se importan poden empregar outro código
	distinto. Por exemplo, se unha serie concreta está codificada de xeito
	que o valor '-1' indica <quote>non aplicable</quote>, podes escoller
	<quote>Establecer código de valor ausente</quote> baixo o menú
	Variable e teclear o valor <quote>-1</quote> (sen as comiñas). Entón
	GRETL vai ler eses (-1) como observacións ausentes.
      </para>
    </description>
  </command>

  <command name="mdhelp" section="Programming" label="Axuda para marcado Markdown"
    context="gui">

    <description>
      <para>
	Nesta xanela do editor podes inserir elementos para marcado lixeiro como
	se indica despois; pero observa que a expresión <quote>inmediatamente</quote>
	de máis abaixo, quere dicir que non teña ningún espazo intermedio.
      </para>
      <ilist>
	<li>
	  <para>
	    Grosa: Coloca dous asteriscos (<lit>**</lit>),
	    inmediatamente antes e despois dun anaco de texto.
	  </para>
	</li>
	<li>
	  <para>
	    Cursiva: Coloca un único asterisco ou guión baixo,
	    inmediatamente antes e despois dun anaco de texto.
	  </para>
	</li>
	<li>
	  <para>
	    Monoespazada: Coloca unha comiña simple esquerda (<lit>`</lit>),
	    inmediatamente antes e despois dun anaco de texto.
	  </para>
	</li>
	<li>
	  <para>
	    Cabeceira de nivel 1: Coloca un único cancelo (<lit>#</lit>)
	    antes da cabeceira, e deixa unha liña en branco despois da
	    mesma.
	  </para>
	</li>
	<li>
	  <para>
	    Cabeceira de nivel 2: Coloca dos cancelos sucesivos antes da
	    cabeceira, e deixa unha liña en branco a continuación.
	  </para>
	</li>
	<li>
	  <para>
	    Bloque de código: Deixa unha liña en branco e a continuación
	    coloca tres comiñas simples esquerdas sucesivas (<lit>```</lit>)
	    na liña xusto anterior ao código, e outras tres na liña xusto
	    despois do mesmo.
	  </para>
	</li>
	<li>
	  <para>
	    Lista non numerada: Deixa unha liña en branco antes da lista, e
	    insire un guión cun espazo (<quote><lit>- </lit></quote>) antes
	    de cada elemento, usando unha nova liña para cada un deles.
	  </para>
	</li>
	<li>
	  <para>
	    Lista numerada: Deixa unha liña en branco antes da lista, e
	    insire o número, un punto e un espazo (por exemplo,
	    <quote><lit>1. </lit></quote>) antes de cada elemento, usando
	    unha nova liña para cada un deles.
	  </para>
	</li>
      </ilist>
      <para>
	A icona dun ollo desta xanela te permite obter unha visión previa do
	texto de axuda con marcado lixeiro (markdown). Cae na conta de que
	se realmente o texto non contén anotacións de marcado lixeiro, a
	<quote>visión previa</quote> podería non ter unha boa aparencia.
      </para>
    </description>
  </command>

  <command name="menu-attach" section="Programming"
	   label="Anexo ao menú" context="gui">
    <description>
      <para>
	Este diálogo te permite especificar un anexo ao menú para un paquete
	de funcións. Para iso debes de completar os seguintes tres campos na
	caixa de diálogo.
      </para>
      <subhead>1. Etiqueta</subhead>
      <para>
	Isto require unha curta cadea de texto como etiqueta, que aparecerá como
	acceso ao paquete, no menú.
      </para>
      <subhead>2. Xanela</subhead>
      <para>
	Selecciona <quote>Xanela de modelo</quote> para un paquete de
	funcións que fai algo cun modelo de GRETL, e deba de aparecer
	na barra de menús dunha xanela de modelos de GRETL. Se non,
	selecciona <quote>Xanela principal</quote>.
      </para>
      <subhead>3. Árbore do menú</subhead>
      <para>
	Escolle a posición dentro da árbore do menú (ben da xanela
	principal ou ben da xanela de modelos, como elixiches de acordo
	co indicado arriba), onde debe de aparecer o acceso ao paquete.
      </para>
      <subhead>Elementos opcionais</subhead>
      <para>
	Ademais, podes utilizar o botón <quote>Texto de axuda</quote> da GUI
	para engadir ou editar texto de axuda específico de Interface Gráfica
	de Usuario (GUI) para que se amose cando se invoque o paquete desde
	un menú. E se o paquete está pensado para invocalo desde a xanela dun
	modelo, podes especificar un certo tipo de modelo (identificado pola
	súa palabra chave como instrución de GRETL) como requisito.
      </para>
    </description>
  </command>

  <command name="mle" section="Estimation"
    label="Estimación Máximo Verosímil">

    <usage>
      <arguments>
        <argument>función logaritmo-verosimilitude</argument>
	      <argument optional="true">derivadas</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non amosa o modelo estimado</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--hessian</flag>
	  <effect>Basea a matriz de covarianzas na Hessiana</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <optparm optional="true">hac</optparm>
	  <effect>Matriz de covarianzas CMV (QML) ou HAC</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Matriz de covarianzas robusta por agrupación</effect>
  </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
	</option>
	<option>
	  <flag>--no-gradient-check</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--auxiliary</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--lbfgs</flag>
	  <effect>Utiliza L-BFGS-B en vez do BFGS habitual</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>weibull.inp</demo>
	  <demo>biprobit_via_ghk.inp</demo>
	  <demo>frontier.inp</demo>
	  <demo>keane.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Realiza a estimación de Máxima Verosimilitude (MV ou ML) usando
	ben o algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno) ou ben
	o método de Newton. Debes de especificar a función logaritmo de
	verosimilitude; e se te recomenda que tamén proporciones as expresións
	das derivadas desta función con respecto a cada un dos parámetros,
	se é posible.
      </para>
      <para>
	Este texto de axuda asume que se utiliza o maximizador por defecto
	BFGS. Para obter información relativa ao uso do método de Newton,
	consulta o <guideref targ="chap:mle"/>.
      </para>
      <para>
	Exemplo sinxelo: Supón que temos unha serie <lit>X</lit> con
	valores 0 ou 1, e queremos obter a estimación máximo verosímil da
	probabilidade (<lit>p</lit>) de que <lit>X</lit> = 1. (Neste caso
	sinxelo, pódese adiantar que a estimación MV de <lit>p</lit> será
	simplemente equivalente á proporción de Xs iguais a 1, na mostra.)
      </para>
      <para>
	Debes primeiro engadir o parámetro <lit>p</lit> ao conxunto de datos e
	indicar o seu valor inicial. Podes facer isto usando a instrución 'genr'
	ou mediante eleccións de menú. Podes teclear as liñas <quote>genr</quote>
	axeitadas na xanela de especificación da EMV, antes de especificar a
	función logaritmo de verosimilitude.
      </para>
      <para>
	Na xanela EMV, tecleamos as seguintes liñas:
      </para>
      <code>
	loglik = X*log(p) + (1-X)*log(1-p)
	deriv p = X/p - (1-X)/(1-p)
      </code>
      <para>
	A primeira liña especifica a función logaritmo de verosimilitude,
	e a seguinte liña proporciona a derivada desa función con
	respecto ao parámetro 'p'. Se non indicas liñas 'deriv',
	calcúlase unha aproximación numérica ás derivadas.
      </para>
      <para>
	Cando non se expresa previamente o parámetro 'p', podemos
	poñer antes das liñas de arriba algo como o seguinte:
      </para>
      <code>
	scalar p = 0.5
      </code>
      <para>
	os desvíos padrón baséanse no Produto Externo do vector Gradiente, por
	defecto. Se marcas o cadriño <quote>Desvíos padrón robustos</quote>,
	utilízase un estimador CMV (QML, un <quote>emparedado</quote> entre a
	inversa negativa da matriz Hessiana e a matriz de covarianzas do vector
	gradiente, en concreto). A matriz Hessiana aproxímase numericamente.
      </para>
      <para>
	Para unha descrición moito máis en profundidade da estimación
	<cmd>mle</cmd>, consulta o <guideref targ="chap:mle"/>.
      </para>
    </description>

    <description context="cli">
      <para>
	Realiza a estimación de Máxima Verosimilitude (MV ou ML)
	utilizando ben o algoritmo BFGS (Broyden, Fletcher, Goldfarb,
	Shanno) ou ben o método de Newton. Debes de especificar a
	función logaritmo de verosimilitude. E debes de expresar os
	parámetros desta función, e asignarlles valores iniciais antes
	da estimación. Opcionalmente, o usuario pode especificar as
	derivadas da función logaritmo de verosimilitude con respecto a
	cada un dos parámetros; se non indicas as derivadas analíticas,
	calcúlase unha aproximación numérica.
      </para>
      <para>
	Este texto de axuda asume que se utiliza, por defecto, o maximizador
	BFGS. Para obter máis información sobre o uso do método de Newton,
	por favor consulta o <guideref targ="chap:mle"/>.
      </para>
      <para>
	Exemplo sinxelo: Supón que temos unha serie <lit>X</lit>
	con valores 0 ou 1, e queremos obter a estimación máximo
	verosímil da probabilidade (<lit>p</lit>) de que <lit>X</lit> = 1.
	(Neste caso sinxelo, pódese adiantar que a estimación MV
	de <lit>p</lit> será simplemente equivalente á proporción
	de Xs iguais a 1, na mostra.)
      </para>
      <para>
	Débese primeiro engadir o parámetro <lit>p</lit> ao conxunto de datos, e
	indicar o seu valor inicial. Por exemplo,
        <lit>scalar p = 0.5</lit>.
      </para>
      <para>
	A continuación, configúrase o bloque de instrucións de estimación EMV:
      </para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  deriv p = X/p - (1-X)/(1-p)
	end mle
      </code>
      <para>
	A primeira liña de arriba especifica a función logaritmo de
	verosimilitude. Comeza coa palabra chave <lit>mle</lit>, logo
	especifícase a variable dependente e indícase unha expresión
	para o logaritmo da verosimilitude (usando a mesma sintaxe que
	na instrución <cmd>genr</cmd>). A seguinte liña (que é opcional)
	comeza coa palabra chave <lit>deriv</lit> e proporciona a
	derivada da función logaritmo de verosimilitude con respecto
	ao parámetro <lit>p</lit>. Se non indicas as derivadas, debes
	de incluír unha orde utilizando a palabra chave <lit>params</lit>
	que identifique os parámetros libres: estes enuméranse nunha
	liña, separados por espazos e poden ser ben escalares, ben
	vectores, ou ben calquera combinación dos dous. Por exemplo,
	podes mudar o de arriba por:
      </para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  params p
	end mle
      </code>
      <para>
	en cuxo caso utilizaríanse derivadas numéricas.
      </para>
      <para>
	Ten en conta que calquera indicador de opción debe de engadirse á
	liña final do bloque EMV (MLE). Por exemplo:
      </para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  params p
	end mle --quiet
      </code>
      <subhead>Matriz de covarianzas e desvíos padrón</subhead>
      <para>
	Cando a función do logaritmo da verosimilitude devolve unha serie ou
	un vector que proporciona valores por observación, entón os desvíos
	padrón estimados baséanse por defecto no Produto Externo do vector
	Gradiente (PEG); mentres que se indicas a opción <opt>hessian</opt>,
	baséanse pola contra na inversa negativa da matriz Hessiana, que se
	aproxima numericamente. Cando indicas a opción <opt>robust</opt>,
	utilízase un estimador CMV (QML, un <quote>emparedado</quote> entre
	a inversa negativa da matriz Hessiana e o PEG). Se ademais engades o
	parámetro <lit>hac</lit> a esta opción, o PEG se incrementa do xeito
	de <cite key="newey-west87">Newey e West</cite> para permitir
	autocorrelación do gradente. (Isto unicamente ten sentido con datos
	de series de tempo.) Agora ben, cando a función do logaritmo da
	verosimilitude unicamente devolve un valor escalar, o PEG non está
	dispoñible (polo tanto tampouco o estimador CMV), e os desvíos
	padrón teñen que calcularse necesariamente utilizando a matriz
	Hessiana numérica.
      </para>
      <para>
	No caso de que unicamente queiras as estimacións do parámetro
	primario, podes indicar a opción <opt>auxiliary</opt>, que elimina
	o cálculo da matriz de covarianzas e dos desvíos padrón. Isto
	vai aforrar algúns ciclos de CPU e uso de memoria.
      </para>
      <subhead>Comprobando as derivadas analíticas</subhead>
      <para>
	Se proporcionas as derivadas analíticas, por defecto GRETL executa
	unha verificación numérica da súa credibilidade. Algunhas veces isto
	pode producir falsos positivos, por situacións nas que as derivadas
	correctas semellan ser incorrectas e a estimación rexéitase. Para
	ter isto en conta ou para acadar unha pouca velocidade adicional,
	podes indicar a opción <opt>no-gradient-check</opt>. Obviamente,
	debes de facer isto só cando teñas certeza de que o vector gradiente
	que especificaches é correcto.
      </para>
      <subhead>Nomes de parámetros</subhead>
      <para>
	Ao estimar un modelo non linear, con frecuencia é conveniente nomear
	os parámetros de forma sucinta. Agora ben, ao presentar os resultados,
	pode que desexes utilizar etiquetas máis informativas. Isto o podes
	lograr mediante a palabra chave adicional <lit>param_names</lit>
	dentro do bloque de instrucións. Para un modelo con <math>k</math>
	parámetros, o argumento que sigue a esta palabra chave debe de ser
	unha cadea de texto literal entre comiñas que conteña <math>k</math>
	nomes separados por espazos, o nome dunha variable de cadea que
	conteña <math>k</math> deses nomes, ou o nome dun arranxo con
	<math>k</math> cadeas de texto.
      </para>
      <para>
	Para unha descrición máis en profundidade da estimación
	<cmd>mle</cmd> consulta o <guideref targ="chap:mle"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Máxima Verosimilitude</menu-path>
    </gui-access>

  </command>

  <command name="modeltab" section="Utilities" label="A táboa de modelos">

    <usage>
      <altforms>
	<altform><lit>modeltab add</lit></altform>
	<altform><lit>modeltab show</lit></altform>
	<altform><lit>modeltab free</lit></altform>
	<altform><lit>modeltab --output=</lit><repl>nomeficheiro</repl></altform>
	<altform><lit>modeltab --options=</lit><repl>feixe (bundle)</repl></altform>
      </altforms>
    </usage>

    <description context="gui">
      <para>
	Na investigación econométrica é habitual estimar varios modelos
	cunha mesma variable dependente, diferenciándose eses modelos
	nas variables independentes que están incluídas en cada un ou,
	quizais, no tipo de estimador utilizado. Nesta situación, resulta
	conveniente presentar os resultados da regresión en forma dunha
	táboa, na que cada columna conteña os resultados (as estimacións
	dos coeficientes e dos desvíos padrón) para un modelo dado,
	e na que cada fila conteña as estimacións para unha determinada
	variable nos diferentes modelos.
      </para>
      <para>
	GRETL proporciona un medio para elaborar unha táboa deste tipo
	(e de copiala en texto plano, &latex; ou Rich Text Format).
	Aquí tes como facelo:
      </para>
      <nlist>
	<li>
	  <para>
	    Estima un modelo que queiras incluír na táboa e,
	    baixo o menú Ficheiro da xanela de modelos, selecciona
	    <quote>Gardar na sesión como icona</quote> ou
	    <quote>Gardar como icona e pechar</quote>.
    </para>
	</li>
	<li>
	  <para>
	    Repite o paso 1 para os outros modelos que se van
	    incluír na táboa (ata un total de 6 modelos).
    </para>
	</li>
	<li>
	  <para>
	    Cando xa teñas feita a estimación dos modelos, abre o visor de
	    iconas da túa sesión de GRETL (escollendo <quote>Vista de iconas</quote>
	    baixo o menú de Ver na xanela principal de GRETL, ou premendo na
	    icona titulada <quote>Ver iconas de sesión</quote> na barra de
	    ferramentas de GRETL).
    </para>
	</li>
	<li>
	  <para>
	    Na vista de iconas de sesión, hai unha icona titulada
	    <quote>Táboa de modelos</quote>. Decide o modelo que queres
	    que apareza na columna máis á esquerda da Táboa de modelos e
	    engádeo á táboa, ben arrastrando a súa icona sobre a icona da
	    Táboa de modelos, ou ben premendo o botón dereito do rato sobre a icona
	    do modelo, e escollendo <quote>Engadir á táboa de modelos</quote>
	    do menú emerxente.
    </para>
	</li>
	<li>
	  <para>
	    Repite o paso 4 para os demais modelos que queras incluír na
	    táboa; así o segundo modelo que selecciones vai aparecer
	    na segunda columna, empezando pola esquerda; etcétera.
    </para>
	</li>
	<li>
	  <para>
	    Cando remates de compoñer a táboa de modelos, amósaa
	    premendo un dobre clic sobre a súa icona. Baixo o menú
	    'Copiar' da xanela que aparece, tes a posibilidade de
	    copiar a táboa ao portapapeis en varios tipos de formato.
    </para>
	</li>
	<li>
	  <para>
	    Se a orde dos modelos na táboa non é a que querías,
	    preme o botón dereito do rato sobre a icona da táboa de
	    modelos, e escolle <quote>Librar</quote>. Entón volve ao
	    paso 4 de arriba e inténtao de novo.
    </para>
	</li>
      </nlist>
    </description>

    <description context="cli">
      <para>
	Permite manexar a <quote>Táboa de modelos</quote> de GRETL;
	consulta o <guideref targ="chap:modes"/> para obter máis
	detalles. As instrucións subordinadas teñen os seguintes efectos:
	<cmd>add</cmd> engade o derradeiro modelo estimado á táboa
	de modelos, cando sexa posible; <cmd>show</cmd> amosa a táboa
	de modelos nunha xanela; e <cmd>free</cmd> limpa a táboa.
      </para>
      <para>
	Para solicitar que se garde a táboa de modelos, usa a opción
	<opt>output=</opt> máis un nome de ficheiro. Cando o nome
	do ficheiro teña o sufixo <quote><lit>.tex</lit></quote>, o
	resultado vai estar en formato &tex;; cando o sufixo sexa
	<quote><lit>.rtf</lit></quote>, o resultado terá formato RTF; e
	se non, vai estar en texto plano. No caso dun resultado
	&tex;, por defecto xérase un <quote>anaco</quote> axeitado
	para incluír nun documento; en cambio, se queres un documento
	independente, usa a opción <opt>complete</opt>, como por exemplo
      </para>
      <code>
	modeltab --output="myfile.tex" --complete
      </code>
      <para>
	Podes utilizar o indicador <opt>options=</opt>, o que require indicar
	o nome dun feixe (bundle) de GRETL, para controlar algúns aspectos
	de formato na táboa do modelo. Se admiten as seguintes
	claves:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>colheads</lit>: Enteiro de 1 a 4, que permite escoller entre
	    os catro estilos admitidos para o encabezamento de columnas:
	    numeración Arábiga, numeración Romana, alfabética, ou a utilización
	    dos nomes baixo os que se gardaron os modelos.
	    O predeterminado é 1 (numeración Arábiga).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>tstats</lit>: Booleano, que permite substituír os desvíos padrón cos
	    estatísticos t, ou non (o predeterminado, 0).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>pvalues</lit>: Booleano, que permite incluír os valores
	    <math>P</math>, ou non (o predeterminado, 0).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>asterisks</lit>: Booleano, que permite amosar asteriscos
	    relativos ao nivel de significación, ou non (o predeterminado, 0).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>digits</lit>: Enteiro de 2 a 6, que permite elixir o número
	    de díxitos significativos que se amosan (o predeterminado, 4).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>decplaces</lit>: Enteiro de 2 a 6, que permite elixir o número
	    de posicións decimais que se amosan.
	  </para>
	</li>
      </ilist>
      <para>
	Cae na conta de que as dúas últimas claves son mutuamente excluíntes.
	Ofrecen xeitos alternativos de especificar a precisión coa que se amosan
	os valores numéricos: ben en termos de díxitos significativos, ben en
	termos de posicións decimais. Por defecto, son 4 díxitos significativos.
      </para>
      <para>
	Podes indicar un feixe de opcións mediante unha instrución independente
	(como no último dos exemplos de máis abaixo), ou pódese combinar co
	proceso <lit>show</lit>, ou coa opción <opt>output</opt>. Por exemplo,
	o seguinte guión elabora unha sinxela táboa dun modelo e a presenta,
	amosando os valores <math>P</math> en troques dos asteriscos relativos
	ao nivel de significación:
      </para>
      <code>
	open data9-7
	ols 1 0 2 3 4
	modeltab add
	ols 1 0 2 3
	modeltab add
	bundle myopts = _(pvalues=1, asterisks=0)
	modeltab show --options=myopts
      </code>
    </description>

    <gui-access>
      <menu-path>Xanela de iconas de sesión: icona de Táboa de modelos</menu-path>
    </gui-access>

  </command>

  <command name="modprint" section="Printing"
    label="Presentar un modelo definido polo usuario" context="cli">

    <usage>
      <arguments>
        <argument>matrizcoef</argument>
        <argument>nomes</argument>
	      <argument optional="true">estadicionais</argument>
      </arguments>
      <options>
	<option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía o resultado ao ficheiro especificado</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Presenta a táboa de coeficientes e estatísticos adicionais optativos
	para un modelo estimado <quote>á man</quote>; é útil sobre todo para
	funcións escritas polo usuario.
      </para>
      <para>
	O argumento <repl>matrizcoef</repl> debe de ser unha matriz de
	dimensión <math>k</math> por 2, que contén <math>k</math>
	coeficientes e <math>k</math> desvíos padrón asociados.
	O argumento <repl>nomes</repl> debe de proporcionar polo
	menos <math>k</math> nomes para etiquetar os coeficientes.
	Podes indicalo co formato: (a) dunha cadea de texto literal
	(contornada entre comiñas) ou dunha variable de cadea, que
	conteña os nomes separados por comas ou espazos, ou (b) un
	arranxo xa definido de cadeas de texto.
      </para>
      <para>
	O argumento <repl>estadicionais</repl> (opcional) é un vector que
	contén <math>p</math> estatísticos adicionais que se amosan
	debaixo da táboa de coeficientes. Se indicas este argumento,
	entón <repl>nomes</repl> debe de conter <math>k + p</math>
	nomes, de forma que os <math>p</math> nomes agregados
	se asocien aos estatísticos adicionais.
      </para>
      <para>
	Se non indicas o argumento <repl>estadicionais</repl> e a matriz
	<repl>matrizcoef</repl> ten adxuntos os nomes das filas, entón podes
	omitir o argumento <repl>nomes</repl>.
      </para>
      <para>
	Para colocar o resultado nun ficheiro, utiliza a opción
	<opt>output=</opt> máis un nome de ficheiro. Cando o nome
	de ficheiro teña o sufixo <quote><lit>.tex</lit></quote>, o
	resultado vai estar en formato &tex;; cando o sufixo sexa
	<quote><lit>.rtf</lit></quote>, o resultado terá formato RTF;
	e se non, vai estar en texto plano. No caso dun resultado
	&tex;, por defecto xérase un <quote>anaco</quote> axeitado
	para incluír nun documento; en cambio, se queres un documento
	independente, usa a opción <opt>complete</opt>.
      </para>
      <para>
	O ficheiro resultante escríbese no cartafol (<cmdref targ="workdir"/>)
	establecido nese momento, agás que a cadea <repl>nomeficheiro</repl>
	conteña unha especificación completa da ruta.
      </para>
    </description>

  </command>

  <command name="modtest" section="Tests" label="Probas do modelo"
    context="cli">

    <usage>
      <arguments>
        <argument optional="true">nivel</argument>
      </arguments>
      <options>
        <option>
	  <flag>--normality</flag>
	  <effect>Normalidade das perturbacións</effect>
        </option>
        <option>
	  <flag>--logs</flag>
	  <effect>Non linearidade: logaritmos</effect>
        </option>
        <option>
	  <flag>--squares</flag>
	  <effect>Non linearidade: cadrados</effect>
        </option>
        <option>
	  <flag>--autocorr</flag>
	  <effect>Autocorrelación</effect>
        </option>
        <option>
	  <flag>--arch</flag>
	  <effect>ARCH</effect>
        </option>
        <option>
	  <flag>--white</flag>
	  <effect>Heterocedasticidade: proba de White</effect>
        </option>
        <option>
	  <flag>--white-nocross</flag>
	  <effect>Proba de White: só cadrados</effect>
        </option>
        <option>
	  <flag>--breusch-pagan</flag>
	  <effect>Heterocedasticidade: proba de Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Estimación con varianzas robustas para Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--panel</flag>
	  <effect>Heterocedasticidade: por grupos</effect>
        </option>
        <option>
	  <flag>--comfac</flag>
	  <effect>Restrición de factor común: só modelos AR1</effect>
        </option>
        <option>
	  <flag>--xdepend</flag>
	  <effect>Dependencia de sección cruzada: só con datos de panel</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os detalles</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
        </option>
      </options>
	  <examples>
	<demos>
	  <demo>credscore.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Debe de seguir inmediatamente a unha instrución de estimación.
	A discusión de abaixo aplícase á utilización desta instrución a
	continuación da estimación dun modelo dunha única ecuación;
	consulta o <guideref targ="chap:var"/> para unha exposición de
	como opera <cmd>modtest</cmd> despois da estimación dun VAR.
      </para>
      <para>
	Dependendo da opción que indiques, esta instrución efectúa unha destas
	accións: a proba de Normalidade da perturbación de Doornik&ndash;Hansen;
	unha proba de Non Linearidade (logaritmos ou cadrados) con Multiplicadores
	de Lagrange; a proba de Heterocedasticidade de White (con ou sen
	produtos cruzados) ou a de Breusch&ndash;Pagan
	(<cite key="breusch-pagan79">Breusch e Pagan, 1979</cite>); a proba LMF
	de Autocorrelación <cite key="kiviet86" p="true">(Kiviet, 1986)</cite>;
	unha proba de ARCH (Heterocedasticidade Condicional Autorregresiva;
	consulta tamén a instrución <cmd>arch</cmd>); unha proba da restrición
	de Factor Común implícita na estimación AR(1); ou unha proba de
	Dependencia de sección cruzada en modelos con datos de panel. Coa
	excepción das probas de Normalidade, de Factor Común e de Dependencia
	de sección cruzada, a meirande parte das opcións destas probas só
	están dispoñibles para modelos estimados mediante MCO, pero mira máis
	abaixo para obter máis detalles en relación con Mínimos Cadrados en 2
	Etapas.
      </para>
      <para>
	O argumento <lit>nivel</lit> (opcional) é importante só no caso de
	que escollas as opcións <opt>autocorr</opt> ou <opt>arch</opt>.
	Por defecto, estas probas execútanse utilizando un nivel de retardos
	igual á periodicidade dos datos, pero podes axustar isto indicando
	un nivel de retardos específico.
      </para>
      <para>
	A opción <opt>robust</opt> aplícase unicamente cando seleccionas
	a proba de Breusch&ndash;Pagan; o seu efecto consiste en que se
	utiliza o estimador robusto da varianza proposto por
	<cite key="koenker81">Koenker (1981)</cite>, facendo a proba
	menos sensible ao suposto de Normalidade.
      </para>
      <para>
	A opción <opt>panel</opt> está dispoñible só cando o modelo se
	estima con datos de panel; e neste caso, realízase unha proba de
	heterocedasticidade por grupos (é dicir, de varianzas das perturbacións
	diferentes entre as unidades de sección cruzada).
      </para>
      <para>
	A opción <opt>comfac</opt> está dispoñible só cando o modelo se
	estima mediante un método AR(1) tal como o de Hildreth&ndash;Lu.
	A regresión auxiliar toma a forma dun modelo dinámico relativamente
	non restrinxido, que se utiliza para probar a restrición de factor
	común implícita na especificación AR(1).
      </para>
      <para>
	A opción <opt>xdepend</opt> está dispoñible só para modelos
	estimados con datos de panel. O estatístico de proba é o
	desenvolvido por <cite key="pesaran04">Pesaran (2004)</cite>.
	A hipótese nula é que a perturbación distribúese independentemente
	entre as unidades atemporais ou os individuos.
      </para>
      <para>
	Por defecto, o programa presenta a regresión auxiliar na que se
	basea o estatístico de proba, se é aplicable. Podes eliminar isto
	utilizando a opción <opt>quiet</opt> (presentación mínima de
	resultados) ou a opción <opt>silent</opt> (non presenta ningún
	resultado). Podes recuperar o estatístico de proba e a súa
	probabilidade asociada (valor p) utilizando os accesorios
	<fncref targ="$test"/> e <fncref targ="$pvalue"/>, respectivamente.
      </para>
      <para>
	Cando un modelo se estima por Mínimos Cadrados en 2 Etapas (consulta
	<cmdref targ="tsls"/>), ráchase o principio de Máxima Verosimilitude e
	GRETL ofrece algúns equivalentes: a opción <flag>--autocorr</flag>
	calcula o estatístico de Godfrey para probar autocorrelación
	<cite key="godfrey94" p="true">(Godfrey, 1994)</cite> mentres que a opción
	<flag>--white</flag> produce o estatístico da proba HET1 de heterocedasticidade
	<cite key="pesaran99" p="true">(Pesaran e Taylor, 1999)</cite>.
      </para>
      <para>
	Para probas adicionais de diagnóstico sobre os modelos,
	consulta <cmdref targ="chow"/>, <cmdref targ="cusum"/>,
	<cmdref targ="reset"/> e <cmdref targ="qlrtest"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas</menu-path>
    </gui-access>

  </command>

  <command name="mpi" section="Programming"
	   label="Interface de Paso de Mensaxes">
    <usage>
      <arguments>
	<argument>Mira abaixo</argument>
      </arguments>
    </usage>
    <description>
      <para>
	A instrución <lit>mpi</lit> empeza un bloque de expresións (que deben
	rematarse con <lit>end mpi</lit>) para executarse utilizando o cómputo
	en paralelo da MPI (Interface de Paso de Mensaxes). Consulta
	<doc>gretl-mpi.pdf</doc> para obter un informe completo desta prestación.
      </para>
    </description>
  </command>

  <command name="mpols" section="Estimation" label="MCO de alta precisión">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
	<option>
	  <flag>--simple-print</flag>
	  <effect>Non presenta os estatísticos auxiliares</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcula as estimacións de MCO para o modelo especificado, utilizando
	aritmética de punto flotante con precisión múltiple, coa axuda da
	biblioteca Gnu Multiple Precision (GMP). Por defecto, utilízanse 256
	bits de precisión nos cálculos, pero podes aumentar isto mediante a
	variable de contorna <lit>GRETL_MP_BITS</lit>. Por exemplo, cando
	utilizas o intérprete Bash se te podería ocorrer a seguinte instrución
	para establecer unha precisión de 1024 bits antes de comezar GRETL.
      </para>
      <code>
	export GRETL_MP_BITS=1024
      </code>

      <para context="cli">
	Dispós dunha opción (máis ben rebuscada) para esta instrución,
	principalmente co propósito de facer probas: cando a lista
	<repl>indepvars</repl> vai seguida dun punto e coma, máis dunha
	lista posterior de números, eses números tómanse como potencias de
	<repl>x</repl> que se engaden á regresión, onde <repl>x</repl> é a
	última variable de <repl>indepvars</repl>. Estes termos adicionais
	calcúlanse e gárdanse con precisión múltiple. No seguinte exemplo,
	faise a regresión de <lit>y</lit> sobre <lit>x</lit> máis a segunda,
	terceira e cuarta potencias dese <lit>x</lit>:
      </para>
      <code context="cli">
	mpols y 0 x ; 2 3 4
      </code>
    </description>

    <gui-access>
      <menu-path>/Modelar/Outros Modelos Lineais/MCO Lineais de Alta Precisión</menu-path>
    </gui-access>

  </command>

  <command name="nadarwat" section="Estimation" label="Nadaraya-Watson"
	   context="gui">
    <description>
      <para>
	Calcula <math>m(x)</math>, o estimador non paramétrico de
	Nadaraya&ndash;Watson da media condicionada da variable
	dependente, para cada valor non ausente da variable
	independente.
      </para>
      <para>
	A función núcleo (kernel) ven determinada por
	<math>K = exp(-x</math><sup>2</sup><math>/2h)</math>
	para <math>|x|&lt;T</math>, e cero noutro caso. <math>T</math> é
	un parámetro de recorte, por defecto igual a 4<math>h</math>.
      </para>
      <para>
	O largo de banda <math>h</math>, que habitualmente é un número
	pequeno, controla a suavidade de <math>m(x)</math> (os valores
	máis grandes producen series máis suaves). Por defecto, este
	valor está determinado polos datos e resulta proporcional a
	<math>n</math><sup>-0.2</sup>, sendo <math>n</math> o tamaño
	da mostra.
      </para>
      <para>
	Se marcas o cadriño de <quote>deixar unha fóra</quote>, emprégase
	unha variante do estimador na que a <math>i</math>-ésima observación
	non se utiliza para avaliar <math>m(x</math><sub>i</sub><math>)</math>.
	Isto fai que o algoritmo sexa numericamente máis robusto, e a súa
	utilización aconséllase normalmente cando o estimador se calcula co
	propósito de facer inferencias.
      </para>
      <para>
	Para obter máis detalles sobre a estimación non paramétrica, consulta o
	<guideref targ="chap:nonparam"/>.
      </para>
     </description>
  </command>

  <command name="negbin" section="Estimation"
    label="Regresión Binomial Negativa">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	      <argument separated="true" optional="true">exposición</argument>
      </arguments>
      <options>
	<option>
	  <flag>--model1</flag>
	  <effect>Utiliza o modelo NegBin 1</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>Matriz de covarianzas CMV (QML)</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para unha explicación</effect>
        </option>
	<option>
	  <flag>--opg</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
      </options>
	 <examples>
	<demos>
	  <demo>camtriv.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Estima un modelo Binomial Negativo. Tómase a variable dependente para
	representar un reconto do número de veces que ocorre un suceso dalgún
	tipo, e debe de ter só valores enteiros non negativos. Por defecto,
	utilízase o modelo NegBin 2 no que a varianza condicionada do reconto
	ven determinada por &mu;(1 + &alpha;&mu;), onde &mu; denota a media
	condicionada. Pero se indicas a opción <opt>model1</opt>, a varianza
	condicionada é &mu;(1 + &alpha;).
      </para>
      <para>
	A serie de exposición (<lit>offset</lit>, opcional) funciona do mesmo xeito
	que para a instrución <cmdref targ="poisson"/>. O modelo de Poisson é unha
	forma restrinxida da Binomial Negativa na que &alpha; = 0 por construción.
      </para>
      <para>
	Por defecto, os desvíos padrón calcúlanse utilizando unha
	aproximación numérica á matriz Hessiana na converxencia. Pero
	se indicas a opción <opt>opg</opt>, a matriz de covarianzas
	baséase no Produto Externo do vector Gradiente, PEG (OPG), e
	se indicas a opción <opt>robust</opt>, calcúlanse os desvíos
	padrón CMV (QML), utilizando un <quote>emparedado</quote>
	entre a inversa da matriz Hessiana e o PEG.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Variable Dependente Limitada/Datos de Reconto</menu-path>
    </gui-access>
  </command>

  <command name="nls" section="Estimation"
    label="Mínimos Cadrados Non Lineais">

    <usage>
      <arguments>
        <argument>función</argument>
        <argument optional="true">derivadas</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta o modelo estimado</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
	</option>
	<option>
	  <flag>--no-gradient-check</flag>
	  <effect>Mira abaixo</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>wg_nls.inp</demo>
	  <demo>ects_nls.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Realiza a estimación de Mínimos Cadrados Non Lineais (MCNL
	ou NLS) utilizando unha versión modificada do algoritmo de
	Levenberg&ndash;Marquardt. Debes de proporcionar a especificación
	dunha función; e aínda que non é imprescindible, recoméndase que
	tamén proporciones as expresións das derivadas desta función con
	respecto a cada un dos parámetros, se é posible. Se non ofreces as
	derivadas, no seu lugar debes de indicar unha lista dos parámetros
	que se van estimar (separados por espazos ou comas), precedida pola
	palabra chave <lit>params</lit>; estes poden ser ben escalares, ben
	vectores ou ben calquera combinación dos dous.
      </para>
      <para>
	Exemplo: Supón que tes un conxunto de datos coas variables
	<math>C</math> e <math>Y</math> (&eg; <lit>greene11_3.gdt</lit>)
	e que desexas estimar unha función non linear de consumo coa
	expresión
	<equation status="display"
	  tex="\[C = \alpha + \beta Y^{\gamma}\]"
	  ascii="C = alpha + beta * Y^gamma"
	  graphic="greene_Cfunc"/>
      </para>
      <para>
	En primeiro lugar, debes de engadir os parámetros alfa, beta
	e gamma ao conxunto de datos, ademais de darlles uns valores iniciais.
	Podes escribir as liñas apropiadas na xanela de especificacións de
	MC Non Lineais antes de definir a función.
      </para>
      <para>
	Na xanela MC Non Lineais, escribes as seguintes liñas:
      </para>
      <code>
	C = alfa + beta * Y^gamma
	deriv alfa = 1
	deriv beta = Y^gamma
	deriv gamma = beta * Y^gamma * log(Y)
      </code>
      <para>
	A primeira liña especifica a función de regresión, e as seguintes
	3 liñas proporcionan as derivadas desa función con respecto a
	cada parámetro, de un en un. Se non indicas as liñas 'deriv',
	calcúlase unha aproximación numérica ao Xacobiano.
      </para>
      <para>
	Se non enuncias previamente os parámetros alfa, beta
	e gamma, podes preceder as liñas de arriba con algo como
	o seguinte:
      </para>
      <code>
	scalar alfa = 1
	scalar beta = 1
	scalar gamma = 1
      </code>
      <para>
	Para outros detalles sobre a estimación MCNL (NLS), consulta o <guideref targ="chap:nls"/>.
      </para>
    </description>

    <description context="cli">
      <para>
	Realiza a estimación de Mínimos Cadrados Non Lineais (MCNL
	ou NLS) utilizando unha versión modificada do algoritmo de
	Levenberg&ndash;Marquardt. Debes de indicar a especificación
	dunha función e de enunciar os parámetros desta, ademais de
	darlles uns valores iniciais antes da estimación. Como
	opción, podes especificar as derivadas da función de regresión
	con respecto a cada un dos parámetros. Se non proporcionas
	as derivadas, no seu lugar debes de indicar unha lista dos
	parámetros que se van estimar (separados por espazos ou
	comas), precedida pola palabra chave <lit>params</lit>. Neste
	último caso, calcúlase unha aproximación numérica ao Xacobiano.
      </para>
      <para>
	Resulta máis doado amosar o que se require mediante un exemplo.
	O que segue é un guión completo para estimar a función non linear
	de consumo establecida no libro <book>Econometric Analysis</book>
	(capítulo 11 da 4a edición ou capítulo 9 da 5a) de William Greene.
	Os números á esquerda das liñas son só para tomar como referencia
	e non son parte das instrucións. Ten en conta que calquera indicador
	de opción, como sería <opt>vcv</opt> para presentar a matriz de
	covarianzas dos estimadores dos parámetros, deberías de engadilo
	á instrución final, <lit>end nls</lit>.
      </para>
      <code>
	1   open greene11_3.gdt
	2   ols C 0 Y
	3   scalar alfa = $coeff(0)
	4   scalar beta = $coeff(Y)
	5   scalar gamma = 1.0
	6   nls C = alfa + beta * Y^gamma
	7    deriv alfa = 1
	8    deriv beta = Y^gamma
	9    deriv gamma = beta * Y^gamma * log(Y)
	10  end nls --vcv
      </code>
      <para>
	Con frecuencia é conveniente iniciar os parámetros cunha referencia a
	un modelo linear relacionado; isto lógrase aquí coas liñas da 2 á 5.
	Os parámetros alfa, beta e gamma poden establecerse con calquera valor
	inicial (non necesariamente baseados nun modelo estimado con MCO),
	aínda que a converxencia do procedemento de MCNL non está garantida
	para calquera punto de inicio que se te antolle.
      </para>
      <para>
	As auténticas instrucións de MCNL ocupan as liñas da 6 ata a 10.
	Na liña 6 indícase a instrución <cmd>nls</cmd> na que se declara
	a variable dependente, cun signo de igualdade a continuación, e
	seguido este da especificación dunha función. A sintaxe para o
	lado dereito da expresión é a mesma que a da instrución
	<cmd>genr</cmd>. As seguintes 3 liñas especifican as derivadas
	da función de regresión con respecto a cada un dos parámetros,
	de un en un. Cada liña comeza coa palabra chave <cmd>deriv</cmd>,
	establece o nome dun parámetro, un signo de igualdade e unha
	expresión pola que pode calcularse a derivada. En lugar de
	proporcionar as derivadas analíticas, como alternativa podes
	substituír as liñas da 7 á 9, polo seguinte:
      </para>
      <code>
	params alfa beta gamma
      </code>
      <para>
	A liña 10, <cmd>end nls</cmd>, completa a instrución e solicita
	a estimación. Calquera opción deberás de engadila a esta liña.
      </para>
      <para>
	Se proporcionas as derivadas analíticas, por defecto GRETL executa
	unha verificación numérica da súa credibilidade. Algunhas veces isto
	pode producir falsos positivos, por situacións nas que as derivadas
	correctas semellan ser incorrectas e a estimación rexéitase. Para
	ter isto en conta ou para acadar unha pouca velocidade adicional,
	podes indicar a opción <opt>no-gradient-check</opt>. Obviamente,
	debes de facer isto só cando teñas certeza de que o vector gradiente
	que especificaches é correcto.
      </para>
      <subhead>Nomes de parámetros</subhead>
      <para>
	Ao estimar un modelo non linear, con frecuencia é conveniente nomear
	os parámetros de forma sucinta. Agora ben, ao presentar os resultados,
	pode que desexes utilizar etiquetas máis informativas. Isto o podes
	lograr mediante a palabra chave adicional <lit>param_names</lit>
	dentro do bloque de instrucións. Para un modelo con <math>k</math>
	parámetros, o argumento que sigue a esta palabra chave debe de ser
	unha cadea de texto literal entre comiñas que conteña <math>k</math>
	nomes separados por espazos, o nome dunha variable de cadea que
	conteña <math>k</math> deses nomes, ou o nome dun arranxo con
	<math>k</math> cadeas de texto.
      </para>
      <para>
	Para obter outros detalles sobre a estimación MCNL (NLS), consulta
	o <guideref targ="chap:nls"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Mínimos Cadrados Non Lineais</menu-path>
    </gui-access>

  </command>

  <command name="normtest" section="Tests" label="Proba de Normalidade">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--dhansen</flag>
	  <effect>Proba de Doornik&ndash;Hansen, por defecto</effect>
        </option>
	<option>
	  <flag>--swilk</flag>
	  <effect>Proba de Shapiro&ndash;Wilk</effect>
        </option>
	<option>
	  <flag>--lillie</flag>
	  <effect>Proba de Lilliefors</effect>
        </option>
	<option>
	  <flag>--jbera</flag>
	  <effect>Proba de Jarque&ndash;Bera</effect>
        </option>
	<option>
	  <flag>--all</flag>
	  <effect>Fai todas as probas</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Realiza unha proba de Normalidade para a <repl>serie</repl> indicada.
	O tipo concreto de proba contrólase co indicador de opción (e
	execútase a proba de Doornik&ndash;Hansen cando non indicas ningunha
	opción). Advertencia: As probas de Doornik&ndash;Hansen e Shapiro&ndash;Wilk
	son máis recomendables que as outras, tendo en conta as súas mellores
	propiedades en mostras pequenas.
      </para>
      <para>
	Mediante os accesorios <fncref targ="$test"/> e <fncref targ="$pvalue"/>
	podes recuperar o estatístico de proba e a súa probabilidade asociada
	(valor p), respectivamente. Ten en conta que cando indicas a opción
	<opt>all</opt>, o resultado gardado é o da proba de Doornik&ndash;Hansen.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Probas de Normalidade</menu-path>
    </gui-access>

  </command>

  <command name="nulldata" section="Dataset"
    label="Xerar un banco de datos baldeiro">

    <usage>
      <arguments>
        <argument>lonxitude</argument>
      </arguments>
      <options>
	<option>
	  <flag>--preserve</flag>
	  <effect>Retén as variables que non son series</effect>
        </option>
      </options>
      <examples>
        <example>nulldata 500</example>
      </examples>
    </usage>

    <description>
      <para>
	Establece un conxunto de datos <quote>en branco</quote> que: inclúe
	só unha constante máis unha variable índice, ten periodicidade 1 e
	contén o número de observacións especificado no argumento. Podes
	utilizar isto coa intención de facer simulacións, pois funcións coma
	<cmd>uniform()</cmd> e <cmd>normal()</cmd> xeran series artificiais
	comezando polo principio, para reencher o conxunto de datos. Esta
	instrución pode ser moi útil en combinación con <cmd>loop</cmd>.
	Consulta tamén a opción <quote>seed</quote> (semente) da instrución
	<cmdref targ="set"/>.
      </para>
      <para>
	Por defecto, esta instrución libra todos os datos do espazo vixente
	de traballo de GRETL, non só as series senón tamén as matrices, os
	escalares, as cadeas de texto, etc. Agora ben, cando indicas a opción
	<opt>preserve</opt>, retense calquera variable que non sexa unha serie
	e estea definida nese momento.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ficheiro/Novo conxunto de datos</menu-path>
    </gui-access>

  </command>

  <command name="ols" section="Estimation" label="Mínimos Cadrados Ordinarios">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Desvíos padrón agrupados</effect>
        </option>
        <option>
	  <flag>--jackknife</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--simple-print</flag>
	  <effect>Non presenta estatísticos auxiliares</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
        </option>
        <option>
	  <flag>--anova</flag>
	  <effect>Presenta unha táboa ANOVA</effect>
        </option>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>Elimina a corrección dos graos de liberdade</effect>
        </option>
        <option>
	  <flag>--print-final</flag>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
      <examples>
        <example>ols 1 0 2 4 6 7</example>
	<example>ols y 0 x1 x2 x3 --vcv</example>
	<example>ols y 0 x1 x2 x3 --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Calcula as estimacións de mínimos cadrados ordinarios (MCO ou OLS)
	para o modelo especificado.
      </para>

      <para context="cli">
	Calcula as estimacións de mínimos cadrados ordinarios (MCO ou OLS)
	sendo <repl>depvar</repl> a variable dependente, e <repl>indepvars</repl>
	unha lista de variables independentes. Podes especificar as variables
	co nome ou co número; e utilizar o número cero para indicar o termo
	constante.
      </para>

      <para>
	Aparte das estimacións dos coeficientes e dos desvíos padrón, o programa
	tamén presenta as probabilidades asociadas (valores p) aos estatísticos
	<math>t</math> (con dúas colas) e <math>F</math>. Un 'valor p' por debaixo de
	0.01 indica significación estatística a un nivel do 1 por cento, e márcase con
	<lit>***</lit>. A marca <lit>**</lit> indica niveles de significación entre 1
	e 5 por cento, e a marca <lit>*</lit> indica niveles entre 5 e 10 por cento.
	Tamén preséntanse os estatísticos para elixir modelos (o Criterio de Información
	de Akaike ou AIC, e o Criterio de Información Baiesiano de Schwarz). A fórmula
	utilizada para o AIC é a proporcionada por <cite key="akaike74">Akaike (1974)</cite>,
	en concreto, menos dúas veces o logaritmo da verosimilitude maximizada máis
	dúas veces o número de parámetros estimados.
	    </para>

      <para context="cli">
	Se indicas a opción <opt>no-df-corr</opt>, non se aplica a corrección habitual dos graos de liberdade ao calcular
	a varianza estimada da perturbación (e polo tanto, tampouco os desvíos padrón dos estimadores dos parámetros).
	    </para>

      <para context="cli">
	A opción <opt>print-final</opt> é aplicable só no contexto dun bucle
	(<cmdref targ="loop"/>), e dispón que a regresión se execute
	silandeiramente en todas as iteracións do bucle, agás na derradeira.
	Consulta o <guideref targ="chap:looping"/> para obter máis detalles.
      </para>

      <para context="cli">
	Podes recuperar varias variables internas despois da estimación.
	Por exemplo:
      </para>
      <code context="cli">
	series uh = $uhat
      </code>
      <para context="cli">
	garda os erros da estimación baixo o nome <lit>uh</lit>. Consulta a
	sección <quote>Accesorios</quote> da Guía de funcións de GRETL para
	obter máis detalles.
      </para>

      <para context="cli">
	Podes axustar a fórmula (versión <quote>HC</quote>) específica
	que se vai utilizar para xerar os desvíos padrón robustos
	cando indicas a opción <opt>robust</opt>, mediante a instrución
	<cmdref targ="set"/>. A opción <opt>jackknife</opt> ten como
	consecuencia a selección dunha <lit>hc_version</lit> de <lit>3a</lit>.
	A opción <opt>cluster</opt> anula a selección da versión HC, e
	produce os desvíos padrón robustos agrupando as observacións
	segundo os distintos valores de <repl>clustvar</repl>. Consulta o
	<guideref targ="chap:robust_vcv"/> para obter máis detalles.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Mínimos Cadrados Ordinarios</menu-path>
      <other-access>Botón co símbolo beta na barra de ferramentas</other-access>
    </gui-access>

  </command>

  <command name="omit" section="Tests" label="Excluír variables">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--test-only</flag>
	  <effect>Non substitúe o modelo vixente</effect>
	</option>
	<option>
	  <flag>--chi-square</flag>
	  <effect>Devolve a forma Khi-cadrado da proba de Wald</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Presenta só os resultados básicos da proba</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas do modelo reducido</effect>
	</option>
	<option>
	  <flag>--auto</flag>
	  <optparm optional="true">criterio</optparm>
	  <effect>Eliminación secuencial, mira abaixo</effect>
	</option>
      </options>
      <examples>
        <example>omit 5 7 9</example>
        <example>omit seasonals --quiet</example>
        <example>omit --auto=BIC</example>
        <example>omit --auto=0.05</example>
	 <demos>
	  <demo>restrict.inp</demo>
	  <demo>sw_ch12.inp</demo>
	  <demo>sw_ch14.inp</demo>
	 </demos>
     </examples>
    </usage>

    <description context="gui">
      <para>
	A forma básica desta instrución volve estimar o modelo indicado,
	logo de excluír as variables especificadas. Aparte do resultado
	habitual do modelo, presenta unha proba da significación conxunta
	das variables excluídas. A hipótese nula supón que os verdadeiros
	coeficientes de todos os regresores excluídos son iguais a cero.
      </para>
      <para>
	Se escolles a opción <quote>Proba de Wald</quote>, avalíase a
	significación conxunta das variables especificadas por medio
	dunha proba de Wald baseada na matriz de varianzas-covarianzas
	do modelo indicado, e non se volve realizar a estimación.
      </para>
      <subhead>As opcións secuenciais</subhead>
      <para>
	A opción de <quote>eliminación secuencial</quote> invoca unha
	regresión secuencial cara atrás. Nese caso, interprétase que
	<repl>listavariables</repl> é unha lista de regresores
	<emphasis>candidatos</emphasis> a ser omitidos do modelo orixinal.
	En cada unha das etapas, o método atopa o candidato que proporciona
	a maior mellora de acordo co criterio especificado (valor <math>P</math>
	bilateral ou criterio de información), se hai algún. O algoritmo detense
	cando non é posible unha mellora posterior. Entón, amósanse as
	estimacións do modelo reducido, agás que resulte que non se omite
	ningún dos regresores.
      </para>
      <para>
	Cando se selecciona un método secuencial, a lista de variables a
	omitir ignórase por defecto, a beneficio de tratar tódolos regresores
	como candidatos a ser omitidos. Porén, podes limitar os candidatos
	mediante a marcaxe da caixiña titulada
	<quote>Probar só as variables seleccionadas</quote>.
      </para>
    </description>

    <description context="cli">
      <para>
	Esta instrución debe de ir despois dunha instrución de estimación.
	Na súa forma básica, calcula o estatístico de proba de Wald para a
	significación conxunta das variables de <repl>listavariables</repl>,
	que debe ser un subconxunto (aínda que non necesariamente un subconxunto
	axeitado) das variables independentes do último modelo estimado.
	Podes recuperar os resultados da proba utilizando os accesorios
	<fncref targ="$test"/> e <fncref targ="$pvalue"/>.
      </para>
      <para>
	Agás que a restrición elimine todos os regresores orixinais, por
	defecto, estímase o modelo restrinxido e este substitúe ao orixinal
	como <quote>modelo vixente</quote> se tes intención, por exemplo,
	de recuperar os erros con <lit>$uhat</lit> ou facer probas posteriores.
	Podes impedir este comportamento mediante a opción
	<opt>test-only</opt>.
      </para>
      <para>
	Por defecto, rexístrase a forma <math>F</math> da proba de Wald;
	pero podes utilizar a opción <opt>chi-square</opt> para recoller
	a forma Khi-cadrado no seu lugar.
      </para>
      <para>
	Se tanto estimas como representas o modelo restrinxido, a opción
	<opt>vcv</opt> ten o efecto de presentar a súa matriz de covarianzas;
	se non, esta opción ignórase.
      </para>
      <subhead>A opción automática</subhead>
      <para>
	A opción <opt>auto</opt> (que non pode combinarse coa opción
	<opt>test-only</opt>) reclama a regresión secuencial cara atrás.
	Nese caso, considérase que <repl>listavariables</repl> é unha lista
	de regresores <emphasis>candidatos</emphasis> a ser omitidos do modelo
	orixinal. En cada unha das etapas, o método determina que candidato
	podería ser mellor eliminar de acordo co <repl>criterio</repl>
	especificado (indicado como parámetro desta opción). O algoritmo detense
	cando non é posible unha mellora posterior. O criterio debe tomar unha
	das seguintes formas:
      </para>
      <ilist>
	<li>
	  <para>
	    Un Criterio de Información: <lit>AIC</lit>, <lit>BIC</lit> ou
	    <lit>HQC</lit>. Entón, o <quote>mellor</quote> candidato en
	    cada etapa é aquel cuxa omisión proporciona a maior mellora
	    (redución) no criterio seleccionado &mdash;ata que non haxa
	    ningún candidato cuxa omisión proporcione unha mellora;
	    momento no que o algoritmo se detén.
	  </para>
	</li>
	<li>
	  <para>
	    Un valor &alpha; (como fracción decimal positiva). Neste caso,
	    o regresor ao que corresponda o maior valor <math>P</math>
	    bilateral, elíxese para ser omitido &mdash;ata que non haxa
	    ningún candidato cuxo valor <math>P</math> sexa maior que
	    &alpha;; momento no que o algoritmo se detén.
	  </para>
	</li>
      </ilist>
      <para>
        Se non se especifica ningún <repl>criterio</repl> na opción
        <opt>auto</opt>, por defecto se utiliza o método do valor
        <math>P</math> con &alpha; = 0.10.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas/Excluír variables</menu-path>
    </gui-access>

  </command>

  <command name="online" section="Dataset" context="gui"
    label="Acceso a bancos de datos en liña">

    <description>
      <para>
	GRETL é capaz de acceder a bancos de datos da Universidade Wake
	Forest (o teu ordenador debe de estar conectado a Internet para
	que isto funcione).
      </para>
      <para>
	Baixo o menú <quote>Ficheiro: Bancos de datos</quote>, escolle a
	opción <quote>No servidor de bancos de datos</quote>. Debera de
	aparecer unha xanela, amosando unha listaxe dos bancos de datos
	de GRETL dispoñibles na Wake Forest. (Dependendo da túa localización
	e da velocidade da túa conexión a Internet, isto pode tardar uns
	poucos segundos.) Xunto co nome do banco de datos e unha curta
	descrición, aparece unha anotación <quote>Estado local</quote>:
	esta indica se tes instalado localmente un dos bancos de datos
	(no disco duro do teu ordenador) e no caso de ser así, se está
	ou non actualizado en comparación coa versión dispoñible no
	servidor.
      </para>
      <para>
	Se tes un determinado banco de datos xa instalado localmente, e está
	actualizado, non tes ningunha vantaxe accedendo a el por medio do
	servidor. Pero para un banco de datos que non está aínda instalado
	nin actualizado, poderías querer obter unha listaxe das súas series
	de datos; entón preme un clic sobre <quote>Listar as series</quote>.
	Isto abre unha xanela máis, desde a que podes representar os valores
	dunha das series de datos que elixas, debuxar eses valores ou mesmo
	importalos ao espazo de traballo de GRETL. Podes completar estas
	tarefas utilizando o menú <quote>Series</quote>, ou mediante o menú
	emerxente que aparece cando premes o botón dereito do rato sobre
	unha determinada serie. Tamén podes buscar a listaxe dunha variable
	de interese (no elemento <quote>Buscar</quote> do menú).
      </para>
      <para>
	Se queres un acceso máis rápido aos datos, ou desexas acceder ao
	banco de datos fóra de liña, entón escolle a liña que amosa o banco
	de datos que queres (na xanela inicial do banco de datos) e preme
	o botón <quote>Instalar</quote>. Isto vai descargar o banco de
	datos en formato comprimido, logo descomprimilo e instalalo no
	teu disco duro. En adiante xa deberas de ser capaz de atopalo
	baixo <quote>Ficheiro, Bancos de datos, Propio de GRETL</quote>
	no menú.
      </para>
    </description>
  </command>

  <command name="open" section="Dataset"
    label="Abrir un ficheiro de datos" context="cli">

    <usage>
      <arguments>
        <argument>nomeficheiro</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta a lista das series</effect>
	</option>
	<option>
	  <flag>--preserve</flag>
	  <effect>Retén as variables que non son series</effect>
	</option>
	<option>
	  <flag>--select</flag>
	  <optparm>seleccion</optparm>
	  <effect>Ler só as series indicadas, mira abaixo</effect>
	</option>
	<option>
	  <flag>--frompkg</flag>
	  <optparm>nomepaquete</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--all-cols</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--www</flag>
	  <effect>Utiliza un banco de datos do servidor de GRETL</effect>
	</option>
	<option>
	  <flag>--odbc</flag>
	  <effect>Utiliza un banco de datos ODBC</effect>
	</option>
	<optnote>Mira abaixo para opcións adicionais especiais</optnote>
      </options>
      <examples>
        <example>open data4-1</example>
        <example>open voter.dta</example>
       	<example>open fedbog.bin --www</example>
        <example>open dbnomics</example>
      </examples>
    </usage>

    <description>
      <para>
	Abre un ficheiro de datos ou un banco de datos (consulta o
	<guideref targ="chap:datafiles"/> para ver unha explicación desta
	distinción). As consecuencias son algo diferentes nos dous casos.
	Cando abres un <emphasis>ficheiro de datos</emphasis>, léese o
	seu contido no espazo de traballo de GRETL, substituíndo o banco de
	datos vixente (se hai algún). Para engadir datos ao conxunto vixente,
	en troques de substituílo, consulta <cmdref targ="append"/> ou (para
	ter maior flexibilidade) <cmdref targ="join"/>. Cando abres un
	<emphasis>banco de datos</emphasis>, non se carga inmediatamente
	ningún dato; mais ben, establécese a fonte para chamadas posteriores da
	instrución <cmdref targ="data"/>, que se utiliza para importar series
	concretas. Para obter máis detalles en relación aos bancos de datos,
	consulta a sección titulada <quote>Abrindo un banco de datos</quote>
	máis abaixo.
      </para>
      <para>
	Se non indicas <repl>nomeficheiro</repl> cunha ruta completa, GRETL
	procura nalgunhas rutas destacadas para tratar de atopar o ficheiro, das
	que o cartafol vixente (<cmdref targ="workdir"/>) é a primeira elección.
	Se non indicas o sufixo no nome de ficheiro (como no primeiro exemplo
	de arriba), GRETL asume que é un ficheiro de datos propio con sufixo
	<lit>.gdt</lit>. Baseándose no nome do ficheiro e varias regras
	heurísticas, GRETL tratará de detectar o formato do ficheiro de
	datos (propio, texto plano, CSV, MS Excel, Stata, SPSS, etc.).
      </para>
      <para>
	Cando se utiliza a opción <opt>frompkg</opt>, GRETL vai procurar o
	ficheiro especificado de datos no subcartafol asociado ao paquete
	de funcións especificado por <repl>nomepaquete</repl>.
      </para>
      <para>
	Se o argumento <repl>nomeficheiro</repl> toma a forma dun
	identificador de recursos uniforme (URI) que comeza por
	<lit>http://</lit> ou por <lit>https://</lit>, entón GRETL tratará
	de descargar o ficheiro de datos indicado, antes de abrilo.
      </para>
      <para>
	Por defecto, ao abrir un novo ficheiro de datos líbrase a sesión vixente
	de GRETL, o que inclúe a eliminación de todas as variables definidas,
	incluíndo matrices, escalares e cadeas de texto. Se queres manter as
	variables que teñas definidas nese momento (as que non sexan series, pois
	estas elimínanse obrigatoriamente), utiliza a opción <opt>preserve</opt>.
      </para>
      <subhead context="cli">Ficheiros de folla de cálculo</subhead>
      <para>
	Ao abrir un ficheiro de datos con formato de folla de cálculo (Gnumeric,
	Open Document ou MS Excel), podes facilitar tres parámetros adicionais
	despois do nome do ficheiro. Primeiro, podes escoller unha folla de
	cálculo concreta dentro do ficheiro. Isto faise, ben indicando o
	número de folla por medio da sintaxe (&eg;, <opt>sheet=2</opt>), ou
	ben indicando o nome da folla (se o sabes) entre comiñas, como
	en <opt>sheet="MacroData"</opt> pois, por defecto, vaise ler
	a primeira folla de cálculo do ficheiro. Tamén podes especificar
	un desprazamento de columna e/ou de fila dentro da folla de
	cálculo mediante, &eg;,
      </para>
      <code>
	--coloffset=3 --rowoffset=2
      </code>
      <para>
	o que vai provocar que GRETL ignore as 3 primeiras columnas e as 2
	primeiras filas. Por defecto, hai un desprazamento de 0 en ambas
	dimensións, é dicir, comézase a ler na cela de arriba á esquerda.
      </para>
      <subhead context="cli">Ficheiros de texto delimitado</subhead>
      <para>
	Con ficheiros de texto plano, GRETL habitualmente agarda atopar
	as columnas de datos delimitadas dalgún xeito estándar (en xeral
	mediante coma, tabulador, espazo, ou punto e coma). Por defecto,
	GRETL procura na primeira columna as etiquetas ou as datas das
	observacións, se o seu encabezamento ben está baleiro ou ben
	contén unha cadea de texto suxestiva tal como <quote>year</quote>,
	<quote>date</quote> ou <quote>obs</quote>. Podes evitar que
	GRETL trate de xeito especial a primeira columna indicando a opción 
	<opt>all-cols</opt>.
      </para>
      <subhead context="cli">Texto de formato fixo</subhead>
      <para>
	Un ficheiro de datos en texto con <quote>formato fixo</quote> é aquel
	que non ten delimitadores de columna, pero no que os datos dispóñense
	de acordo a un conxunto coñecido de especificacións como, por exemplo,
	<quote>a variable <math>k</math> ocupa 8 columnas comezando na columna 24</quote>.
	Para ler ese tipo de ficheiros, debes de engadir unha cadea de texto
	con <opt>fixed-cols=</opt><repl>colspec</repl>, onde <repl>colspec</repl>
	componse de números enteiros separados por comas. Estes
	enteiros se interpretan coma un conxunto de pares. O primeiro
	elemento de cada par denota unha columna de comezo, medida
	en bytes desde o principio da liña, na que o 1 indica o
	primeiro byte; e o segundo elemento de cada par indica
	cantos bytes se deben de ler para o campo indicado. Así,
	por exemplo, se indicas
      </para>
      <code>
	open fixed.txt --fixed-cols=1,6,20,3
      </code>
      <para>
	entón GRETL vai ler 6 bytes comezando na columna 1 para a
	variable 1; e para a variable 2, vai ler 3 bytes comezando na
	columna 20. As liñas que están en branco, ou que comezan con
	<lit>#</lit> ignóranse; pero en caso contrario aplícase o 
	padrón de lectura de columnas, e cando se atopa algo distinto
	a un valor numérico válido, amósase un fallo. Cando se len os
	datos satisfactoriamente, as variables vanse designar como
	<lit>v1</lit>, <lit>v2</lit>, etc. Está nas mans do usuario o
	facilitar nomes con significado e/ou descricións, utilizando para elo
	as instrucións <cmdref targ="rename"/> e/ou <cmdref targ="setinfo"/>.
      </para>
      <subhead context="gui">Series con valores en formato de cadea de texto</subhead>
      <para>
	Por defecto, cando importas un ficheiro que contén series con valores
	en formato de cadea de texto, ábrese unha caixa de texto amosándote
	o contido de <lit>string_table.txt</lit>, un ficheiro que contén a
	correspondencia entre as cadeas e a súa codificación numérica.
	Podes eliminar este proceder mediante a opción<opt>quiet</opt>.
      </para>
      <subhead context="cli">Cargando series seleccionadas</subhead>
      <para>
	O uso de <lit>open</lit> cun ficheiro de datos como argumento (ao
	contrario do caso cun banco de datos, mira abaixo) xeralmente implica
	cargar todas as series do ficheiro indicado. Porén, unicamente no
	caso de ficheiros orixinais de GRETL (<lit>gdt</lit> e <lit>gdtb</lit>)
	é posible especificar un subconxunto de series a cargar, mediante o
	seu nome. Isto se consegue por medio da opción <opt>select</opt>, o
	que require un argumento adxunto con algún destes tres formatos: o
	nome dunha única serie; unha lista de nomes, separados mediante espazos
	e contornados entre comiñas; ou o nome dun arranxo de cadeas de texto.
	Exemplos:
      </para>
      <code>
	# Serie única
	open somefile.gdt --select=x1
	# Máis dunha serie
	open somefile.gdt --select="x1 x5 x27"
	# Método alternativo
	strings Sel = defarray("x1", "x5", "x27")
	open somefile.gdt --select=Sel
	</code>
      <subhead context="cli">Abrindo un banco de datos</subhead>
      <para>
	Como se comentou antes, podes utilizar a instrución <lit>open</lit>
	para abrir un ficheiro cun banco de datos, e a continuación lelo coa
	instrución <cmdref targ="data"/>. Os tipos de ficheiros que se admiten
	son os bancos de datos propios de GRETL, RATS 4.0 e PcGive.
      </para>
      <para>
	Ademais da lectura destas clases de ficheiros na máquina local,
	se admiten outros tres casos máis. Primeiro, cando indicas a
	opción <lit>www</lit>, GRETL vai tratar de acceder a un banco de
	datos propio de GRETL co nome que proporciones, no servidor de
	GRETL (por exemplo, o banco de datos <lit>fedbog.bin</lit> cos
	tipos de interese da Reserva Federal do terceiro exemplo que se
	indicou máis arriba). En segundo lugar, podes usar a instrución
	<quote><lit>open dbnomics</lit></quote> para establecer que
	DB.NOMICS sexa a orixe para ler bancos de datos; sobre isto
	consulta <mnu targ="gretlDBN">dbnomics for gretl</mnu>. En
	terceiro lugar, se indicas a opción <opt>odbc</opt>, GRETL vai
	tratar de acceder a un banco de datos ODBC. Esta opción explícase
	detalladamente no <guideref targ="chap:odbc"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ficheiro/Abrir ficheiro de datos</menu-path>
      <other-access>Arrastrar un ficheiro de datos ata a xanela principal de GRETL</other-access>
    </gui-access>

  </command>

  <command name="orthdev" section="Transformations"
    label="Desviacións ortogonais" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Aplicable só con datos de panel. Obtense unha serie con desviacións
	ortogonais adiantadas para cada variable de <repl>listavariables</repl> e
	gárdase nunha nova variable co prefixo<lit>o_</lit>. Deste xeito
	<cmd>orthdev x y</cmd> xera as novas variables <lit>o_x</lit> e
	<lit>o_y</lit>.
      </para>
      <para>
	Os valores gárdanse un paso por diante da súa localización temporal
	verdadeira (é dicir, <lit>o_x</lit> na observación <math>t</math> vai
	conter a desviación que pertence a <math>t</math> &minus; 1, falando
	estritamente). Isto é por compatibilidade coas primeiras diferenzas pois
	así vaise perder a primeira observación de cada serie temporal, non a última.
      </para>
    </description>

  </command>

  <command name="outfile" section="Printing"
    label="Dirixir a presentación a un ficheiro" context="cli">

    <usage>
      <altforms>
	<altform><lit>outfile</lit> <repl>nomeficheiro</repl></altform>
	<altform><lit>outfile</lit> <lit>--buffer=</lit><repl>strvar</repl></altform>
	<altform><lit>outfile</lit> <lit>--tempfile=</lit><repl>strvar</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--append</flag>
	  <effect>Engadir a un ficheiro, só a primeira variante</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--buffer</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--tempfile</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--decpoint</flag>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	A instrución <lit>outfile</lit> inicia un bloque co que se desvía
	todo resultado a presentar, cara a un ficheiro ou buffer (ou, se
	o desexas, simplemente se descarta). Dito bloque remátase coa
	instrución <quote><lit>end outfile</lit></quote>, e despois dela
	os resultados volven á canle por defecto.
      </para>

      <subhead>Desvío cara a un ficheiro sinalado</subhead>
      <para>
	A primeira variante que se amosa abaixo envía os resultados cara ao
	ficheiro sinalado polo argumento <repl>nomeficheiro</repl>. Por defecto,
	créase un novo ficheiro (ou sobrescríbese un xa existente). O ficheiro
	resultante gardarase no cartafol <cmdref targ="workdir"/> vixente da
	configuración, agás que a cadea de texto <repl>nomeficheiro</repl> conteña
	unha especificación completa da ruta. Mais, se queres engadir resultados
	a un ficheiro xa existente, utiliza a opción <opt>append</opt>.
      </para>
      <para>
	No sinxelo exemplo que segue, os resultados dunha determinada
	regresión escríbense no ficheiro sinalado.
      </para>
      <code>
	open data4-10
	outfile regress.txt
	  ols ENROLL 0 CATHOL INCOME COLLEGE
	end outfile
      </code>
      <subhead>Nomes de ficheiros ficticios especiais</subhead>
      <para>
	Admítense tres valores especiais para <repl>nomeficheiro</repl>,
	do seguinte xeito:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>null</lit>: Elimínase a presentación de resultados ata que
	    remate a reorientación.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>stdout</lit>: O resultado se reorienta á canle de
	    <quote>resultado típico</quote>.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>stderr</lit>: O resultado se reorienta á canle de
	    <quote>erro típico</quote>.
	  </para>
	</li>
      </ilist>
      <subhead>Desvío cara a un buffer de cadea</subhead>
      <para>
	A opción <opt>buffer</opt> utilízase para gardar resultados nunha
	variable de cadea. O parámetro que se require para esta opción debe
	ser o nome dunha variable de cadea xa existente, cuxo contido vaise
	sobrescribir. Abaixo amósase o mesmo exemplo indicado anteriormente,
	modificado para gardar unha cadea. Neste caso, ao representar o contido
	de <lit>model_out</lit> vanse amosar os resultados redirixidos.
      </para>
      <code>
	open data4-10
	string model_out = ""
	outfile --buffer=model_out
	  ols ENROLL 0 CATHOL INCOME COLLEGE
	end outfile
	print model_out
      </code>

      <subhead>Desvío cara a un ficheiro temporal</subhead>
      <para>
	A opción <opt>tempfile</opt> utilízase para dirixir os resultados
	cara a un ficheiro temporal, cun nome xerado automaticamente
	que se garante que é único, no directorio <quote>punto</quote>
	do usuario. Igual que no caso do desvío a un buffer, o parámetro
	de opción debe ser o nome dunha variable de cadea: neste caso,
	o seu contido sobrescríbese co nome do ficheiro temporal.
	Atención: os ficheiros que se gardan no directorio 'punto', vanse
	depurar ao saír do programa, polo que non utilices esta modalidade
	se desexas que os resultados se conserven despois da túa sesión
	de GRETL.
      </para>
      <para>
	Repetimos o sinxelo exemplo de arriba, cun par de liñas extra
	para ilustrar a cuestión de que <repl>strvar</repl> indícache
	a onde van os resultados, e que podes recuperalos utilizando
	a función <fncref targ="readfile"/>.
      </para>
      <code>
	open data4-10
	string meutemp
	outfile --tempfile=meutemp
	  ols ENROLL 0 CATHOL INCOME COLLEGE
	end outfile
	printf "Os resultados dirixíronse a %s\n", meutemp
	printf "Os resultados foron:\n%s\n", readfile(meutemp)
	# Limpar cando non se necesita máis o ficheiro
	remove(meutemp)
      </code>
      <para>
	Nalgúns casos, podes querer exercer certo control sobre o nome
	do ficheiro temporal. Isto pódelo facer proporcionando unha variable
	de cadea de texto que conteña seis <lit>X</lit> consecutivas, como
	en
      </para>
      <code>
	string meutemp = "tmpXXXXXX.csv"
	outfile --tempfile=meutemp
	...
      </code>
      <para>
	Neste caso, vaise substituír <lit>XXXXXX</lit> por unha cadea de
	caracteres aleatorios que aseguren que o nome do ficheiro é único,
	pero vaise preservar o sufixo <quote><lit>.csv</lit></quote>. Ao igual
	que no caso máis simple de arriba, o ficheiro escríbese automaticamente
	no directorio <quote>dot</quote> do usuario, e modifícase o contido da
	variable de cadea expresada mediante o indicador opcional, para manter
	a ruta completa ao ficheiro temporal.
      </para>

      <subhead>Discreción</subhead>
      <para>
	Os efectos da opción <opt>quiet</opt> son: se desactiva que se volvan
	presentar as ordes de instrución, e se presentan as mensaxes auxiliares
	mentres os resultados estean redirixidos. É equivalente a facer
      </para>
      <code>
	set echo off
	set messages off
      </code>
      <para>
	agás que, cando remata a redirección, se restablecen os valores
	orixinais das variables <lit>echo</lit> e <lit>messages</lit>.
	Esta opción está dispoñible en todo caso.
      </para>

      <subhead>Carácter decimal</subhead>
      <para>
	O efecto da opción <opt>decpoint</opt> é asegurar que o carácter de
	punto decimal (en contraposición á vírgula) está vixente mentres a
	saída de resultados está desviada. Cando o bloque <lit>outfile</lit>
	remata, o carácter decimal volve ao estado no que estaba antes del.
	Esta opción resulta especialmente útil cando o ficheiro de texto que
	se vai crear, está destinado a ser unha entrada para algún outro programa
	que requira que os díxitos sigan as convencións do inglés, como podería
	ser o caso dun guión de Gnuplot ou de R, por exemplo.
      </para>

      <subhead>Niveis de redirección</subhead>
       <para>
	En xeral, só podes abrir un ficheiro deste xeito nun momento
	dado, polo que as chamadas a esta instrución non poden aniñarse.
	Porén, a utilización desta instrución permítese dentro de funcións
	definidas polo usuario (sempre que o ficheiro de resultados se peche
	desde dentro da mesma función) de forma que podes desviar eses
	resultados temporalmente, e logo devolvelos a un ficheiro de resultados
	orixinal no caso de que <lit>outfile</lit> estea en uso nese momento
	polo solicitante. Por exemplo, o código
      </para>
      <code>
	function void f (string s)
	    outfile interno.txt
	      print s
	    end outfile
	end function

	outfile externo.txt --quiet
	  print "Fóra"
	  f("Dentro")
	  print "De novo fóra"
	end outfile
      </code>
      <para>
	producirá un ficheiro chamado <quote>externo.txt</quote> que contén
	as dúas liñas
      </para>
      <code>
	Fóra
	De novo fóra
      </code>
      <para>
	e un ficheiro chamado <quote>interno.txt</quote> que contén a liña
      </para>
      <code>
	Dentro
      </code>
    </description>

  </command>

  <command name="packages" section="Utilities" label="Paquetes de funcións" context="gui">
    <description>
      <para>
	Podes ampliar as prestacións de GRETL mediante a utilización de
	paquetes de funcións que son de dúas clases: os <quote>Complementos</quote>
	oficiais e os paquetes de contribucións. En conxunto, cobren moitos
	estimadores e utilidades que non están dispoñibles como instrucións
	ou funcións integradas no programa.
      </para>
      <para>
	Os 'Complementos' oficiais están incluídos nos instaladores de GRETL
	para Windows e para Mac. Para Linux, se non se instalan previamente,
	entón descárganse cando se solicite. Podes verificar que os teus
	'Complementos' están actualizados mediante
	<mnu targ="Addons">Comprobar complementos</mnu> no menú Axuda.
      </para>
      <para>
	Podes botar unha ollada aos paquetes de contribucións instalados
	no teu ordenador mediante o elemento do menú
	<mnu targ="LocalGfn">Na máquina local</mnu> e, se estás conectado
	á rede, podes acceder  a unha lista de paquetes dispoñibles mediante
	o elemento <mnu targ="RemoteGfn">No servidor</mnu>. Ambos
	elementos atópanse baixo o elemento /Ficheiro/Paquetes de funcións.
      </para>
      <para>
	Moitos paquetes propoñen agregarse por si mesmos aos menús da Interface
	Gráfica de Usuario (GUI). Podes revisar estas anexións mediante
	<mnu targ="Registry">Rexistro de paquete</mnu> (accede a él mediante
	o botón de Preferencias no buscador de paquetes instalados).
      </para>
      <para>
	Para ter todos os detalles sobre instalar e traballar con paquetes de
	funcións, mira <mnu targ="Pkgbook">Manual de paquetes de funcións</mnu>
	(baixo o menú Axuda). Este manual tamén contén detalles sobre como
	escribir paquetes de funcións. Podes atopar un agradable e breve
	punto de vista sobre a elaboración de paquetes en
	<url>http://gretl.sf.net/gfnguide/gfn_for_dummies.html</url>.
      </para>
      <para>
	Para tratar con paquetes mediante a liña de instrucións de GRETL,
	consulta a instrución <cmdref targ="pkg"/>.
      </para>
    </description>
  </command>
  
  <command name="panel" section="Estimation" label="Modelos de panel">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
        <option>
	  <flag>--fixed-effects</flag>
	  <effect>Estima con efectos fixos por grupo</effect>
        </option>
        <option>
	  <flag>--random-effects</flag>
	  <effect>Modelo de efectos aleatorios ou MCX (GLS)</effect>
        </option>
        <option>
	  <flag>--nerlove</flag>
	  <effect>Utiliza a transformación de Nerlove</effect>
        </option>
        <option>
	  <flag>--pooled</flag>
	  <effect>Estima mediante MCO combinados</effect>
        </option>
        <option>
	  <flag>--between</flag>
	  <effect>Estima o modelo entre-grupos</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos; mira abaixo</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>cvar</optparm>
	  <effect>Desvíos padrón conglomerados; mira abaixo</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>Inclúe variables ficticias temporais</effect>
        </option>
        <option>
	  <flag>--unit-weights</flag>
	  <effect>Mínimos Cadrados Ponderados</effect>
        </option>
        <option>
	  <flag>--iterate</flag>
	  <effect>Estimación iterativa</effect>
        </option>
        <option>
	  <flag>--matrix-diff</flag>
	  <effect>Calcula a proba de Hausman mediante a matriz-diferenza</effect>
        </option>
        <option>
	  <flag>--unbalanced</flag>
	  <optparm>método</optparm>
	  <effect>Só efectos aleatorios; mira abaixo</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Resultados menos detallados</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Resultados máis detallados</effect>
        </option>
      </options>
	<examples>
	<demos>
	  <demo>penngrow.inp</demo>
	  <demo>panel-robust.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Estima un modelo de panel. Por defecto, utilízase o estimador
	de efectos fixos; isto ponse en práctica restándolles as medias
	de grupo ou unidade, aos datos orixinais.
      </para>
      <para context="cli">
	Cando indicas a opción  <opt>random-effects</opt>, calcúlanse as
	estimacións de efectos aleatorios, utilizando por defecto o método
	de <cite key="swamy72">Swamy e Arora (1972)</cite>. Unicamente
	neste caso, a opción <opt>matrix-diff</opt> forza o uso do método
	da matriz-diferenza (en contraposición ao método de regresión)
	para levar adiante a proba de Hausman sobre a consistencia do
	estimador de efectos aleatorios. Tamén é específica do estimador
	de efectos aleatorios, a opción <opt>nerlove</opt> que escolle
	o método de <cite key="nerlove71">Nerlove (1971)</cite> en
	contraposición ao de Swamy e Arora.
      </para>
      <para context="cli">
	Como alternativa, cando indicas a opción <opt>unit-weights</opt>,
	o modelo estímase mediante mínimos cadrados ponderados, coas
	ponderacións baseadas na varianza residual para as unidades
	respectivas de sección cruzada da mostra. Unicamente neste caso,
	podes engadir a opción <opt>iterate</opt> para xerar estimacións
	iterativas e, se a iteración converxe, as estimacións resultantes
	son Máximo Verosímiles.
      </para>
      <para context="cli">
	Como posterior alternativa, se indicas a opción <opt>between</opt>,
	estímase o modelo entre-grupos (é dicir, faise unha regresión MCO
	utilizando as medias dos grupos).
      </para>
      <para context="cli">
	O procedemento por defecto para calcular Desvíos padrón robustos
	en modelos con datos de panel, é o estimador HAC de
	<cite key="arellano03">Arellano (2003)</cite>
	(conglomerado por unidade de panel). As alternativas son os
	<quote>Desvíos Padrón Corrixidos de Panel</quote>
	(<cite key="beck-katz95">Beck e Katz, 1995</cite>) e os desvíos padrón
	<quote>Consistentes de Correlación Espacial</quote>
	(<cite key="driscoll_kraay98">Driscoll e Kraay, 1998</cite>). Estes se
	poden seleccionar mediante a instrución <lit>set panel_robust</lit> cos
	argumentos <lit>pcse</lit> e <lit>scc</lit>, respectivamente. Outras
	alternativas a estas tres opcións están dispoñibles mediante a opción
	<opt>cluster</opt>; por favor, consulta o <guideref targ="chap:robust_vcv"/>
	para obter máis detalles. Cando se especifican os desvíos padrón robustos,
	execútase a proba conxunta <math>F</math> sobre os efectos fixos
	utilizando o método robusto de <cite key="welch51">Welch (1951)</cite>.
      </para>
      <para context="gui">
	Se marcas o cadriño <quote>Efectos aleatorios</quote>, vanse calcular
	as estimacións (MCX) de efectos aleatorios. Por defecto, utilízase o
	método de Swamy e Arora para a transformación MCX, pero está
	dispoñible o método de Nerlove como opción (mediante o botón para
	despregar). O método de <quote>Swamy-Arora/Baltagi-Chang</quote>
	tamén é unha opción adicional, pois no caso dun panel non equilibrado
	fai unha chamada a unha modificación do método de Swamy-Arora ideada
	por <cite key="baltagi-chang94">Baltagi and Chang (1994)</cite>.
	Se non, simplemente é equivalente ao método normal de Swamy-Arora.
      </para>
      <para context="cli">
	A opción <opt>unbalanced</opt> está dispoñible só para modelos
	con efectos aleatorios, e podes usala para elixir o método ANOVA
	que empregar cun panel desequilibrado. Por defecto, GRETL emprega
	o método de Swamy&ndash;Arora igual que se fai para os paneis
	equilibrados, agás que utiliza a media armónica das longuras das
	series de tempo individuais en vez da <math>T</math> habitual.
	Baixo esta opción podes especificar, ben <lit>bc</lit> para usar o
	método de <cite key="baltagi-chang94">Baltagi e Chang (1994)</cite>,
	ou ben usar <lit>stata</lit> para emular a opción <lit>sa</lit> da
	instrución <lit>xtreg</lit> de Stata.
      </para>
      <para>
	Para obter máis detalles sobre a estimación dun panel, consulta o
	<guideref targ="chap:panel"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Panel</menu-path>
    </gui-access>

  </command>

  <command name="panel-between" section="Estimation" context="gui"
    label="Modelo entre-grupos">

    <description>
      <para>
	Este diálogo te permite introducir unha especificación para o modelo
	<quote>between</quote> no contexto de datos de panel. Esta regresión
	utiliza as medias de grupo dos datos, ignorando polo tanto a variación
	dentro dos grupos. Este modelo raramente resulta de gran interese por
	si mesmo, pero pode serte útil co fin de facer comparacións (por
	exemplo, co modelo de efectos fixos).
      </para>
    </description>

  </command>

  <command name="panel-mode" section="Dataset" context="gui"
    label="Organización de datos de panel">

    <description>
      <para>
	Este diálogo ofrece ata 4 opcións para definir un conxunto de datos
	como un panel. As dúas primeiras opcións requiren que o conxunto
	de datos estea xa organizado no formato dun panel (incluso mesmo que
	GRETL aínda non o teña recoñecido). A terceira opción require que o
	conxunto de datos conteña variables que representen a estrutura dun
	panel. E a cuarta require que o conxunto de datos teña a estrutura
	dunha serie temporal.
      </para>
      <para>
	<emphasis>Series temporais amontoadas</emphasis>: Supón que
	<repl>N</repl> é o total de unidades de sección cruzada do conxunto de
	datos, e que <repl>T</repl> = o número observacións das series temporais
	por unidade. Escollendo esta opción estaslle indicando a GRETL que o
	conxunto de datos componse nese momento de <repl>N</repl> bloques
	consecutivos de <repl>T</repl> observacións de series temporais, un
	por cada unidade de sección cruzada. A seguinte etapa será especificar
	o valor de <repl>N</repl>.
      </para>
      <para>
	<emphasis>Seccións cruzadas amontoadas</emphasis>: Estaslle indicando
	a GRETL que o conxunto de datos componse nese momento de
	<repl>T</repl> bloques consecutivos de <repl>N</repl> observacións
	de sección cruzada, un por cada período de tempo. A seguinte etapa,
	de novo, será especificar o valor de
	<repl>N</repl>.
      </para>
      <para>
	Se o número total de observacións do conxunto vixente de datos é primo,
	non tes dispoñibles as dúas opcións mencionadas arriba.
      </para>
      <para>
	<emphasis>Utilizar variables índice</emphasis>: Aplicado se o conxunto
	de datos está organizado nese momento de xeito descoidado (non importa
	como), pero contén dúas variables que indexan as unidades de sección
	cruzada e os períodos de tempo, respectivamente. A seguinte etapa será
	escoller esas dúas variables. As variables índices dun panel non deben
	ter nada agás valores enteiros non negativos, sen valores ausentes. Se
	non hai esas variables no conxunto de datos, non dispós desta
	opción.
      </para>
      <para>
	<emphasis>Converter de series temporais xuntas unhas con outras</emphasis>:
	Esta opción só está dispoñible se o conxunto de datos vixente ten
	unha estrutura de series temporais e contén varias variables. Cando se
	selecciona esta opción, os detalles se proporcionan mediante o botón
	da Axuda no seguinte paso.
      </para>
    </description>

  </command>

  <command name="ts-to-panel" section="Dataset" context="gui"
    label="Series temporais en paralelo unhas coas outras, a panel">

    <description>
      <para>
	Imos explicar para que é conveniente esta instrución, por medio de
	dous exemplos.
      </para>
      <para>
	<emphasis>Exemplo 1</emphasis>: Un conxunto de datos de series temporais
	ten catro series (aparte de <lit>const</lit>), que conteñen o PIB de
	Francia, Alemaña, Italia e España. Seleccionas 1 (o predeterminado)
	para o <quote>Número de bloques en paralelo uns cos outros</quote>, e
	ves 4 para o <quote>Número de unidades de sección cruzada</quote>.
	Entón podes pasar as catro series a unha única serie de panel co PIB;
	os datos por país están amontoados na orde do conxunto de datos.
      </para>
      <para>
	<emphasis>Exemplo 2</emphasis>: O conxunto de datos é como o descrito
	no Exemplo 1, agás que as series de PIB por país están seguidas por
	catro series máis, que conteñen datos de desemprego <emphasis>para os
	mesmos catro países, na mesma orde que as series do PIB</emphasis>.
	Seleccionas 2 bloques en paralelo uns cos outros, e ves 4 para o número
	de unidades de sección cruzada. O procesamento vaite proporcionar dúas
	series de panel, unha para o PIB e outra para o desemprego.
      </para>
      <para>
	Pode haber tantos bloques de series (e conseguintemente tantas series
	de panel) como queiras, posto que cada bloque contén datos para o
	mesmo conxunto de unidades de sección cruzada, proporcionados na mesma
	orde. En caso contrario, o conxunto de datos de <quote>panel</quote>
	resultante sería absurdo.
      </para>
      <para>
	Como proba de corrección, o número total de series temporais debe
	ser exactamente divisible polo número de bloques en paralelo uns cos
	outros. Iso significa que se o conxunto de datos orixinal contén un
	número primo de series, a única opción que se ofrece é convertelas
	nunha única serie de panel. Se o conxunto de datos contén algunha
	serie adicional extraña, debes eliminala antes de intentar esta
	operación.
      </para>
    </description>
  </command>

  <command name="panel-wls" section="Estimation" context="gui"
    label="Mínimos Cadrados Ponderados por grupos">

    <description>
      <para>
	Mínimos cadrados ponderados por grupos para datos de panel. Calcula
	as estimacións de mínimos cadrados ponderados (MCP ou WLS), coas
	ponderacións baseadas nas varianzas estimadas da perturbación para
	as respectivas unidades de sección cruzada da mostra.
      </para>
      <para>
	Cando seleccionas a opción de iteración, o procedemento repítese. En
	cada ciclo, os erros vólvense calcular utilizando as estimacións MCP
	actuais dos parámetros; con eles xérase un novo conxunto de estimacións
	das varianzas das perturbacións e, a parir delas, un novo conxunto de
	ponderacións. As iteracións rematan cando (a) a máxima diferenza nas
	estimacións dos parámetros dun ciclo ao seguinte, cae por debaixo de
	0.0001, ou (b) o número de iteracións chega a 20. Se a iteración converxe,
	as estimacións resultantes son Máximo Verosímiles.
      </para>
    </description>

  </command>

  <command name="panplot" section="Graphs"
   label="Debuxa unha serie de panel" context="cli">

    <usage>
      <arguments>
        <argument>vardebuxar</argument>
      </arguments>
      <options>
        <option>
	  <flag>--means</flag>
	  <effect>Serie temporal coas medias de grupo</effect>
        </option>
        <option>
	  <flag>--overlay</flag>
	  <effect>Gráfica por grupo, superpostas, N &lt;= 130</effect>
        </option>
        <option>
	  <flag>--sequence</flag>
	  <effect>Gráfica por grupo, en secuencia, N &lt;= 130</effect>
        </option>
        <option>
	  <flag>--grid</flag>
	  <effect>Gráfica por grupo, en cuadrícula, N &lt;= 16</effect>
        </option>
        <option>
	  <flag>--stack</flag>
	  <effect>Gráfica por grupo, amoreadas, N &lt;= 6</effect>
        </option>
        <option>
	  <flag>--boxplots</flag>
	  <effect>Gráfica de caixa por grupo, en secuencia, N &lt;= 150</effect>
        </option>
        <option>
	  <flag>--boxplot</flag>
	  <effect>Gráfica única de caixa, todos os grupos</effect>
        </option>
	<option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Enviar o resultado a un ficheiro específico</effect>
        </option>
      </options>
      <examples>
        <example>panplot x --overlay</example>
        <example>panplot x --means --output=display</example>
      </examples>
    </usage>

    <description>
      <para>
	Instrución de debuxo específica para datos de panel: a serie
	<repl>vardebuxar</repl> se debuxa do xeito que se especifica
	con algunha das opcións.
      </para>
      <para>
	Ademais das opcións <opt>means</opt> e <opt>boxplot</opt>, a
	gráfica representa explicitamente as variacións nas dúas dimensións,
	a de serie temporal e a de sección cruzada. Semellantes gráficas
	están limitadas no que se refire ao número de grupos (ou tamén
	coñecidos como individuos ou unidades) no rango da mostra vixente
	do panel. Por exemplo, a opción <opt>overlay</opt>, que presenta
	unha serie temporal para cada grupo nunha única gráfica, só está
	dispoñible se o número de grupos, <math>N</math>, é menor ou igual
	a 130. (Doutro xeito, a gráfica chegaría a ser densa de máis para
	resultar instrutiva.) Se un panel é longo de máis para permitir a
	especificación gráfica desexada, podes escoller provisionalmente
	un rango reducido de grupos ou de unidades, como en
      </para>
      <code>
	smpl 1 100 --unit
	panplot x --overlay
	smpl full
      </code>
      <para>
	Podes usar a opción <opt>output=</opt><repl>nomeficheiro</repl>
	para controlar a forma e o destino do resultado; consulta a instrución
	<cmdref targ="gnuplot"/> para obter máis detalles.
      </para>

    </description>

    <gui-access>
      <other-access>Xanela principal: Menú emerxente (selección única)</other-access>
    </gui-access>

  </command>

  <command name="panspec" section="Tests" label="Especificación de panel">
    <usage>
      <options>
	<option>
	  <flag>--nerlove</flag>
	  <effect>Utiliza o método de Nerlove para efectos aleatorios</effect>
	</option>
	<option>
	  <flag>--matrix_diff</flag>
	  <effect>Utiliza o método da matriz-diferenza para a proba de Hausman</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Suprime a presentación de resultados</effect>
	</option>
      </options>
    </usage>
    <description>
      <para>
	Esta instrución está dispoñible unicamente despois de estimar un modelo
	con datos de panel utilizando MCO (consulta tamén <cmd>setobs</cmd>).
	Comproba a especificación combinada simple fronte ás principais alternativas,
	a de efectos fixos e a de efectos aleatorios.
      </para>
      <para>
	A especificación de efectos fixos permite que a ordenada na orixe da
	regresión varíe dunha unidade de sección cruzada a outra. Preséntase
	unha proba <math>F</math> de Wald para a hipótese nula de que as ordenadas
	na orixe non difiren. A especificación de efectos aleatorios descompón a
	varianza de cada perturbación en dúas partes, unha parte específica
	da unidade de sección cruzada e outra parte específica de cada
	observación concreta. (Pódese calcular este estimador só cando o
	número de unidades de sección cruzada no conxunto de datos supera
	ao número de parámetros a estimar.) O estatístico de Multiplicadores
	de Lagrange de Breusch&ndash;Pagan comproba a hipótese nula de
	que MCO combinados é axeitado fronte á alternativa de efectos
	aleatorios.
      </para>
      <para>
	MCO combinados poden rexeitarse fronte a ambas as dúas alternativas.
	En tanto que a perturbación específica por unidade ou grupo non estea
	correlacionada coas variables independentes, o estimador de efectos
	aleatorios será máis eficiente que o de efectos fixos; se non, o estimador
	de efectos aleatorios será inconsistente e serán preferibles os efectos
	fixos. A hipótese nula da proba de Hausman indica que a perturbación
	específica de grupo <emphasis>non</emphasis> está así correlacionada
	(e por iso prefírese o estimador de efectos aleatorios). Un valor baixo
	da probabilidade asociada (valor p) ao estatístico desta proba vai en
	contra dos efectos aleatorios e a favor dos efectos fixos.
      </para>
      <para>
	As dúas primeiras opcións desta instrución corresponden á estimación de efectos
	aleatorios. Por defecto, utilízase o método de Swamy e Arora, mediante
	o cálculo do estatístico de proba de Hausman, utilizando o método
	de regresión. As opcións permiten utilizar o estimador alternativo
	da varianza de Nerlove, e /ou a aproximación da matriz-diferenza
	ao estatístico de Hausman.
      </para>
      <para>
	Cando se completa con éxito, os accessorios <fncref targ="$test"/>
	e <fncref targ="$pvalue"/> proporcionan 3 vectores que conteñen
	os estatísticos de proba e os valores p para as tres probas indicadas
	arriba: combinabilidade (Wald), combinabilidade (Breusch&ndash;Pagan),
	e Hausman. Se só queres os resultados desta forma, podes indicar
	a opción <opt>quiet</opt> para saltarte a presentación de resultados.
      </para>
      <para>
	Cae na conta de que despois de estimar a especificación de efectos
	aleatorios coa instrución <cmd>panel</cmd>, a proba de Hausman
	execútase automaticamente e podes recuperar os resultados mediante
	o accesorio <fncref targ="$hausman"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas/Especificacións de panel</menu-path>
    </gui-access>

  </command>

  <command name="pca" section="Statistics"
    label="Análise de Compoñentes Principais">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--covariance</flag>
	  <effect>Utiliza a matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--save</flag>
	  <optparm optional="true">n</optparm>
	  <effect>Garda as compoñentes máis importantes</effect>
        </option>
        <option>
	  <flag>--save-all</flag>
	  <effect>Garda todas as compoñentes</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
	Análise de Compoñentes Principais. Presenta os autovalores da
	matriz de correlacións (ou da matriz de covarianzas se marcas o
	cadriño de opcións) para as variables de <repl>listavariables</repl>,
	xunto coa proporción da varianza conxunta representada por cada
	compoñente. Tamén presenta os correspondentes autovectores (ou
	<quote>pesos das compoñentes</quote>).
      </para>
      <para>
	Na xanela que presenta os resultados, tes a posibilidade de gardar
	as Compoñentes Principais como series, no conxunto de datos.
      </para>
    </description>

    <description context="cli">
      <para>
	Análise de Compoñentes Principais. Agás cando indicas a
	opción <opt>quiet</opt>, presenta os valores propios da
	matriz de correlacións (ou da matriz de covarianzas cando
	indicas a opción <opt>covariance</opt>) para as variables
	que forman <repl>listavariables</repl>, xunto coa proporción da
	varianza conxunta representada por cada compoñente. Tamén
	presenta os correspondentes autovectores ou
	<quote>pesos das compoñentes</quote>.
      </para>
      <para>
	Se indicas a opción <opt>save-all</opt>, entón gárdanse
	tódalas compoñentes como series no conxunto de datos, cos
	nomes <lit>PC1</lit>, <lit>PC2</lit>, etcétera. Estas variables
	artificiais fórmanse como a suma dos produtos de (o peso da
	compoñente) por (<math>X</math><sub>i</sub> tipificada), onde
	<math>X</math><sub>i</sub> denota a variable <math>i</math>-ésima
	de <repl>listavariables</repl>.
      </para>
      <para>
	Se indicas a opción <opt>save</opt> sen un valor do parámetro,
	gárdanse as compoñentes con valores propios maiores ca media
	(o que significa maiores ca 1.0 cando a análise se basea na
	matriz de correlacións) no conxunto de datos, tal como se
	describiu arriba. Se indicas un valor para <repl>n</repl>
	con esta opción, entón gárdanse as <repl>n</repl> compoñentes
	máis importantes.
      </para>
      <para>
	Consulta tamén a función <fncref targ="princomp"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Compoñentes principais</menu-path>
    </gui-access>

  </command>

  <command name="pergm" section="Statistics" label="Periodograma">

    <usage>
      <arguments>
        <argument>serie</argument>
        <argument optional="true">anchobanda</argument>
      </arguments>
      <options>
        <option>
	  <flag>--bartlett</flag>
	  <effect>Utiliza a xanela de retardo de Bartlett</effect>
        </option>
        <option>
	  <flag>--log</flag>
	  <effect>Utiliza a escala logarítmica</effect>
        </option>
        <option>
	  <flag>--radians</flag>
	  <effect>Amosa a frecuencia en radiáns</effect>
        </option>
        <option>
	  <flag>--degrees</flag>
	  <effect>Amosa a frecuencia en graos</effect>
        </option>
        <option>
	  <flag>--plot</flag>
	  <optparm>modo-ou-nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>Omite a presentación do resultado</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcula e amosa o espectro da serie especificada. Por defecto,
	indícase o periodograma da mostra, pero utilízase opcionalmente
	unha xanela de retardo de Bartlett ao estimar o espectro, (consulta
	por exemplo, o libro de Greene <book>Econometric Analysis</book>
	para ver unha discusión sobre isto). A largura por defecto da xanela
	de Bartlett é de dúas veces a raíz cadrada do tamaño da mostra, pero
	podes establecer isto de xeito manual utilizando o parámetro
	<repl>anchobanda</repl>, ata un máximo da metade do tamaño da mostra.
      </para>
      <para>
	Cando indicas a opción <opt>log</opt>, represéntase o espectro
	nunha escala logarítmica.
      </para>
      <para>
	As opcións (mutuamente excluíntes) <opt>radians</opt> e
	<opt>degrees</opt> afectan ao aspecto do eixe de frecuencias
	cando se debuxa o periodograma. Por defecto, a frecuencia
	escálase polo número de períodos da mostra, pero esas dúas
	opcións provocan que o eixe se etiquete desde 0 ata &pi;
	radiáns ou desde 0 a 180&deg;, respectivamente.
      </para>
      <para>
	Por defecto, se GRETL non está en modo de procesamento por
	lotes, amósase unha gráfica do periodograma. Podes axustar isto
	mediante a opción <opt>plot</opt>. Os parámetros admisibles para
	esta opción son <lit>none</lit> (para suprimir a gráfica),
	<lit>display</lit> (para representar unha gráfica mesmo en modo
	de procesamento por lotes), ou un nome de ficheiro. O efecto de
	indicar un nome de ficheiro é como se describe para a opción
	<opt>output</opt> da instrución <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Periodograma</menu-path>
      <other-access>Xanela principal: Menú emerxente (selección única)</other-access>
    </gui-access>
  </command>

  <command name="pkg" section="Utilities" context="cli">
    <usage>
      <arguments>
      	<argument>acción</argument>
        <argument>nomepaquete</argument>
      </arguments>
      <options>
        <option>
	  <flag>--local</flag>
	  <effect>Instala desde un ficheiro local</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--staging</flag>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
     <examples>
        <example>pkg install armax</example>
        <example>pkg install /path/to/myfile.gfn --local</example>
        <example>pkg query ghosts</example>
        <example>pkg run-sample ghosts</example>
        <example>pkg unload armax</example>
     </examples>
    </usage>

    <description>
      <para>
	Esta instrución proporciona un xeito de instalar, consultar,
	descargar, eliminar ou indexar paquetes de funcións de GRETL.
	O argumento <repl>acción</repl> debe ser algún de entre
	<lit>install</lit>, <lit>query</lit>, <lit>run&#8209;sample</lit>,
	<lit>unload</lit>, <lit>remove</lit> ou <lit>index</lit>, respectivamente.
	Unha extensión para dar soporte a paquetes de ficheiros de datos
	descríbese máis abaixo.
      </para>
      <para>
	<lit>install</lit>: Na súa forma máis elemental, sen ningún indicador
	de opción e co argumento <repl>nomepaquete</repl> expresado
	como o nome <quote>plano</quote> dun paquete de funcións de
	GRETL (como no primeiro exemplo de arriba), o efecto desta opción
	consiste en descargar o paquete que se especifica do servidor de
	GRETL (agás que <repl>nomepaquete</repl> comece con <lit>http://</lit>),
	e instalalo na máquina local. Neste caso, non é necesario
	expresar unha extensión no nome do ficheiro. Porén, cando indicas
	a opción <opt>local</opt>, o argumento <repl>nomepaquete</repl>
	debe de ser a ruta a un ficheiro de paquete na máquina local, que
	aínda non estea instalado, e expresado con unha extensión correcta
	(<lit>.gfn</lit> ou <lit>.zip</lit>). Neste caso, o efecto consiste
	en copiar o ficheiro no seu sitio (<lit>gfn</lit>), ou descomprimilo
	no seu sitio (<lit>zip</lit>), significando <quote>no seu sitio</quote>
	alí onde o vai atopar a instrución <cmdref targ="include"/>.
      </para>
      <para>
	<lit>query</lit>: Por defecto, a consecuencia desta opción é a
	presentación de información básica sobre o paquete especificado
	(autor, versión, etc.). Se o paquete inclúe recursos extra (ficheiros
	de datos e/ou guións adicionais) inclúese unha lista deses ficheiros.
	Se engades a opción <opt>quiet</opt>, non se presenta nada; en troques,
	gárdase a información do paquete en forma dun feixe de GRETL, ao
	que se pode acceder mediante <fncref targ="$result"/>. Se non pode
	atoparse ningunha información, este feixe estará
	baleiro.
      </para>
      <para>
	<lit>run-sample</lit>: Proporciona un recurso mediante liña de instrucións
	para executar o guión de proba incluído no paquete especificado.
      </para>
      <para>
	<lit>unload</lit>: Debes de indicar o argumento <repl>pkgname</repl>
	en modo 'plano', sen ruta nin extensión, como no derradeiro exemplo de
	arriba. A consecuencia disto é a descarga dese paquete en cuestión da
	memoria de GRETL (se está cargado nese momento), e tamén eliminalo do
	menú da Interface Gráfica (GUI) ao que estea engadido, se o está a algún.
      </para>
      <para>
	<lit>remove</lit>: Realiza as accións indicadas para <lit>unload</lit>
	e, ademais, elimina do disco o(s) ficheiro(s) asociado(s) co
	paquete indicado.
      </para>
      <para>
	<lit>index</lit>: É un caso especial no que <repl>nomepaquete</repl>
	debe substituírse pola palabra chave <quote><lit>addons</lit></quote>:
	a consecuencia disto é que se actualiza o índice dos paquetes estándar
	que se coñecen como <quote>Engadidos</quote> (ou Complementos). Esa
	actualización faise automaticamente de cando en vez, pero nalgúns casos
	pode resultar útil unha actualización manual. Neste caso, a opción
	<opt>verbose</opt> provoca un resultado impreso sobre onde fixo GRETL
	a procura, e o que atopou. Sendo claros, aquí tes o xeito de acadar
	un resultado co índice completo:
      </para>
      <code>
	pkg index addons --verbose
      </code>
	<subhead>Paquetes de ficheiros de datos</subhead>
	    <para>
	Ademais da súa utilización con paquetes de funcións, a instrución
	<lit>pkg install</lit> tamén se pode usar con paquetes de ficheiros
	de datos do tipo <lit>tar.gz</lit> como se indican na listaxe de
	<url>https://gretl.sourceforge.net/gretl_data.html</url>. Por exemplo,
	para instalar os ficheiros de datos de Verbeek, pódese facer
	    </para>
	    <code>
	pkg install verbeek.tar.gz
	    </code>
	    <para>
  Cae na conta de que <lit>install</lit> é a única operación admitida
  para eses ficheiros.
      </para>
  <subhead>Montaxe</subhead>
      <para>
	A opción <opt>staging</opt> é un elemento de conveniencia para os
	desenvolvedores e está dispoñible unicamente en conxunción coa
	acción <lit>install</lit> cando se aplica a un paquete de función.
	O seu efecto consiste en que se descarga o paquete en cuestión da
	área de montaxe (<lit>staging</lit>) de Sourceforge en troques de
	facelo dunha área pública. Os paquetes en montaxe aínda non están
	aprobados para uso xeral; por iso, ignora esta opción a non ser que
	saibas o que estás a facer.
      </para>
    </description>
	
    <gui-access>
      <menu-path>/Ficheiro/Paquetes de funcións/No servidor</menu-path>
    </gui-access>
  </command>

  <command name="pkg-assign" section="Programming"
	   label="Debe asignarse" context="gui">
    <description>
      <para>
  Por que poderías querer insistir en que o usuario asigne o valor de
  retorno de unha ou máis funcións públicas do teu paquete, no contexto
  da GUI?
      </para>
      <para>
  A cuestión é que algunhas funcións se deseñan simplemente para
  proporcionar un resultado, en formato dunha serie ou matriz ou calquera
  outro, sen amosar ningunha saída de resultados nin presentar ningunha
  gráfica. Para esas funcións, se o usuario fai clic en <quote>OK</quote>
  sen asignar o valor de retorno, precisamente non acontecerá nada,
  e isto podería resultar desconcertante. Ao determinar a opción
  <quote>Debe asignarse</quote> estás indicando efectivamente ao
  usuario que <emphasis>non</emphasis> agarde nada da función indicada
  que non sexa o seu valor de retorno.
      </para>
    </description>
  </command>

  <command name="pkg-depends" section="Programming"
	   label="Dependencias" context="gui">
    <description>
      <para>
	Por <quote>dependencias</quote> queremos referirnos aos paquetes de
	funcións dos que depende o teu propio paquete para algunha das
	súas funcionalidades; e que, en consecuencia, debes de ter descargados
	e instalados co fin de que o teu paquete funcione correctamente. Podes
	especificar ata catro de eses paquetes neste diálogo.
      </para>
      <para>
	Por exemplo, supón que utilizas unha ou máis funcións do paquete
	<lit>extra</lit>, que contén varias utilidades para a redacción con
	HANSL. Nese caso, poderías escribir
      </para>
      <code>
	extra
      </code>
      <para>
	nun dos ocos dispoñibles (no primeiro se non hai ningunha
	outra dependencia). Advirte que debes de indicar o nome
	'plano' do paquete, sen poñer a ruta completa nin o sufixo
	<lit>.gfn</lit> nin <lit>.zip</lit>.
      </para>
      <para>
	Opcionalmente, podes marcar a primeira dependencia como un
	<quote>fornecedor</quote>. O efecto disto é o de propiciar que o teu
	paquete teña acceso a calquera función privada do paquete especificado.
	Xeralmente, isto non vai facer falta pero pode serte útil cando deseñas
	dous paquetes para que funcionen en estreita colaboración.
      </para>
    </description>
  </command>

  <command name="plot" section="Graphs" context="cli">
    <usage>
      <arguments>
        <argument optional="true">datos</argument>
      </arguments>
      <options>
        <option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía o resultado ao ficheiro especificado</effect>
        </option>
        <option>
	  <flag>--outbuf</flag>
	  <optparm>nomecadea</optparm>
	  <effect>Envía o resultado á cadea de texto especificada</effect>
        </option>
      </options>
	<examples>
	<demos>
	  <demo>nile.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	O bloque <lit>plot</lit> proporciona unha alternativa á instrución
	<cmdref targ="gnuplot"/> que pode ser máis conveniente cando estás
	xerando unha gráfica complicada (con varias opcións e/ou instrucións
	Gnuplot para que se insiran no ficheiro gráfico). Ademais da seguinte
	explicación, por favor, consulta tamén o <guideref targ="chap:graphs"/>
	para ver outros exemplos.
      </para>
      <para>
	Un bloque de tipo <lit>plot</lit> comeza coa palabra de instrución
	<lit>plot</lit>. Habitualmente vai seguida por un argumento de
	<repl>datos</repl> que especifica os datos que se van representar,
	e que debe de indicar o nome dunha lista, dunha matriz ou dunha única
	serie. Se non especificas datos de entrada, o bloque debe de conter
	no seu lugar cando menos unha directriz para debuxar unha fórmula;
	ese tipo de directivas podes indicalas mediante liñas do tipo
	<lit>literal</lit> ou <lit>printf</lit> (mira abaixo).
      </para>
      <para>
	Cando indicas unha lista (ou unha matriz), asúmese que o último termo
	(ou a última columna da matriz) é a variable do eixe <math>x</math>
	e que os(as) outros(as) son as variables do eixe <math>y</math>, agás
	cando indicas a opción <opt>time-series</opt>, en cuxo caso todos os
	datos especificados van no eixe <math>y</math>. A opción de proporcionar
	o nome dunha soa serie restrínxese aos datos de series temporais, en
	cuxo caso asúmese que queres unha gráfica de series temporais;
	se non, amósase un fallo.
      </para>
      <para>
	A liña de comezo pódese preceder da expresión
	<quote><repl>savename</repl> <lit>&lt;-</lit></quote> para que
	se garde unha gráfica como icona no programa de Interface Gráfica
	de Usuario (GUI). O bloque remata con <lit>end plot</lit>.
      </para>
      <para>
	Dentro do bloque tes cero ou máis liñas dos seguintes tipos,
	identificadas pola palabra chave inicial:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>option</lit>: Especifica unha opción simple.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>options</lit>: Especifica múltiples opcións nunha soa liña,
	  separadas por espazos.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>literal</lit>: Unha instrución que se vai pasar literalmente
	    a Gnuplot.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>printf</lit>: Un enunciado printf cuxo resultado se pasará
	    literalmente a Gnuplot.
	  </para>
	</li>
      </ilist>
      <para>
	Ten en conta que a carón das opcións <opt>output</opt> e <opt>outbuf</opt>
	(que se deben engadir á liña con que remata o bloque), tódalas opcións
	que admite a instrución <cmdref targ="gnuplot"/> tamén as admite a
	instrución <lit>plot</lit>, pero deben indicarse dentro do bloque,
	utilizando a sintaxe descrita máis arriba. Neste contexto, non é
	necesario proporcionar o habitual dobre guión antes do indicador
	de opción. Para obter máis detalles sobre os efectos das distintas
	opcións, consulta <cmdref targ="gnuplot"/>.
      </para>
      <para>
	A intención de utilizar o bloque <lit>plot</lit> ilústrase mellor co
	exemplo:
      </para>
      <code>
	string title = "Meu título"
	string xname = "Miña variable X"
	plot plotmat
	    options with-lines fit=none
	    literal set linetype 3 lc rgb "#0000ff"
	    literal set nokey
	    printf "set title '%s'", title
	    printf "set xlabel '%s'", xname
	end plot --output=display
      </code>
      <para>
	Este exemplo asume que <lit>plotmat</lit> é o nome dunha matriz que
	ten 2 columnas polo menos (ou unha lista que ten 2 elementos polo
	menos). Cae na conta de que se considera unha boa praxe colocar
	(unicamente) a opción <opt>output</opt> na derradeira liña do bloque;
	outras opcións deberías colocalas dentro do bloque.
      </para>
      <subhead>Debuxar unha gráfica sen datos</subhead>
      <para>
	O seguinte exemplo amosa un caso de como especificar a representación
	dunha gráfica sen ter unha fonte de datos.
      </para>
      <code>
	plot
	    literal set title 'Utilidade CRRA'
	    literal set xlabel 'c'
	    literal set ylabel 'u(c)'
	    literal set xrange[1:3]
	    literal set key top left
	    literal crra(x,s) = (x**(1-s) - 1)/(1-s)
	    printf "plot crra(x, 0) t 'sigma=0', \\"
	    printf " log(x) t 'sigma=1', \\"
	    printf " crra(x,3) t 'sigma=3"
	end plot --output=display
      </code>
    </description>

  </command>

  <command name="polyweights" section="Transformations" context="gui"
    label="Axustar unha tendencia polinómica">

    <description>
      <para>
	Ao axustar unha tendencia polinómica a unha serie temporal podes
	querer darlles un peso adicional ás observacións do principio e
	do final da mostra. (Os puntos no medio do rango da mostra teñen
	veciños a ambos lados que é probable que estean tirando do axuste
	na mesma dirección común.)
      </para>
      <para>
	Podes utilizar os esquemas de ponderación (cuadrático, coseno-campá
	e por pasos) que se ofrecen aquí con ese propósito. Se escolles un
	destes esquemas, debes de elixir dúas opcións adicionais. Primeiro:
	Que ponderación máxima se debe de utilizar (a mínima ponderación
	básica é 1.0)? Segundo: A que fracción central da mostra se lle
	debe de aplicar unha ponderación uniforme (a mínima)?
      </para>
      <para>
	Supón, por exemplo, que elixes unha ponderación máxima de 3.0 e
	unha fracción central de 0.4. Isto significa que o 40 por cento
	central dos datos teñen unha ponderación de 1.0. Se seleccionas
	a forma <quote>steps</quote>, o primeiro e o último 30 por cento
	das observacións teñen unha ponderación de 3.0; se non, para
	o primeiro 30 por cento de observacións, as ponderacións declinan
	gradualmente desde 3.0 ata 1.0 e, para o último 30 por cento, as
	ponderacións aumentan desde 1.0 ata 3.0.
      </para>
    </description>

  </command>

  <command name="poisson" section="Estimation"
    label="Estimación de Poisson">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
        <argument separated="true" optional="true">exposición</argument>
      </arguments>
      <options>
        <option>
          <flag>--robust</flag>
          <effect>Desvíos padrón robustos</effect>
        </option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para máis explicacións</effect>
        </option>
        <option>
          <flag>--vcv</flag>
          <effect>Presenta a matriz de covarianzas</effect>
        </option>
        <option>
          <flag>--verbose</flag>
          <effect>Presenta os detalles das iteracións</effect>
        </option>
	      <option>
	        <flag>--quiet</flag>
	        <effect>Non presenta os resultados</effect>
	      </option>
      </options>
      <examples>
        <example>poisson y 0 x1 x2</example>
	<example>poisson y 0 x1 x2 ; S</example>
	<demos>
	  <demo>camtriv.inp</demo>
	  <demo>greene19_3.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Estima unha regresión de Poisson. Cóllese a variable dependente
	para representar o acaecemento de sucesos dalgún tipo, e debe de
	ter só valores enteiros non negativos.
      </para>
      <para>
	Se unha variable aleatoria discreta <math>Y</math> segue unha
	distribución de Poisson, entón
        <equation status="display"
          tex="\[\mathrm{Pr}(Y = y) = \frac{e^{-v} v^y}{y!}\]"
          ascii="Pr(Y = y) = exp(-v) * v^y / y!"
          graphic="poisson1"/>
	para <math>y</math> = 0, 1, 2,&hellip;. A media e a varianza
	da distribución son ambas iguais a <math>v</math>. No modelo
	de regresión de Poisson, o parámetro <math>v</math> está
	representado como unha función dunha ou máis variables
	independentes. A versión máis habitual (e a única que admite
	GRETL) cumpre
        <equation status="display"
          tex="\[v = \mathrm{exp}(\beta_0+\beta_1 x_1+\beta_2 x_2 + \cdots)\]"
          ascii="v = exp(b0 + b1*x1 + b2*x2 + ...)"
          graphic="poisson2"/>
	ou, noutras palabras, o logaritmo de <math>v</math>
	é unha función linear das variables
	independentes.
      </para>
      <para>
	Como opción, podes engadir unha variable de exposición (<quote>offset</quote>)
	á especificación. Esta é unha variable de escala, e o logaritmo dela
	engádese á función linear de regresión (implicitamente, cun coeficiente de
	1.0). Isto ten sentido se agardas que o número de ocorrencias do evento
	en cuestión é proporcional (manténdose o demais constante) a algún
	factor coñecido. Por exemplo, podes supoñer que o número de accidentes
	de tráfico é proporcional ao volume de tráfico (manténdose o demais
	constante) e, nese caso, o volume de tráfico pode expresarse como unha
	variable <quote>de exposición</quote> nun modelo de Poisson do cociente
	de accidentes. A variable de exposición debe de ser estritamente positiva.
      </para>
      <para>
	Por defecto, calcúlanse os desvíos padrón utilizando a inversa
	negativa da matriz Hessiana. Se especificas a opción <opt>robust</opt>,
	entón calcúlanse no seu lugar os desvíos padrón CMV (QML) ou de
	Huber&ndash;White. Neste caso, a matriz de covarianzas estimada é un
	<quote>emparedado</quote> entre a inversa da matriz Hessiana estimada
	e o produto externo do vector gradiente.
      </para>
      <para>
	Consulta tamén <cmdref targ="negbin"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Variable Dependente Limitada/Datos de Reconto</menu-path>
    </gui-access>

  </command>

  <command name="print" section="Printing"
    label="Presentar datos ou cadeas de texto" context="cli">

    <usage>
      <altforms>
        <altform><lit>print</lit> <repl>listavariables</repl></altform>
	<altform><lit>print</lit></altform>
	<altform><lit>print</lit> <repl>nomesobxectos</repl></altform>
        <altform><lit>print</lit> <repl>cadealiteral</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--byobs</flag>
	  <effect>Por observacións</effect>
	</option>
	<option>
	  <flag>--no-dates</flag>
	  <effect>Utiliza números de observación simples</effect>
	</option>
	<option>
	  <flag>--range</flag>
	  <optparm>inicio:parada</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--midas</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--tree</flag>
	  <effect>Específico para feixes (bundles); mira abaixo</effect>
	</option>
      </options>
      <examples>
	<example>print x1 x2 --byobs</example>
	<example>print my_matrix</example>
	<example>print "Isto é unha cadea"</example>
	<example>print my_array --range=3:6</example>
	<example>print hflist --midas</example>
      </examples>
    </usage>

    <description>
      <para>
	Ten en conta que <lit>print</lit> é máis ben unha instrución
	<quote>básica</quote> (coa intención principal de presentar
	os valores das series). Consulta <cmdref targ="printf"/> e
	<cmdref targ="eval"/> para outras alternativas máis avanzadas
	e menos restritivas.
      </para>
      <para>
	Na primeira variante amosada arriba (consulta o primeiro exemplo
	tamén), <repl>listavariables</repl> debe de ser unha lista de series (ben
	unha lista xa definida, ou ben unha lista especificada mediante os
	nomes ou números ID das series, separados por espazos). Neste caso,
	esta instrución presenta os valores das series da lista. Por defecto,
	os datos preséntanse <quote>por variable</quote>, pero se engades
	a opción <opt>byobs</opt> preséntanse por observación. Cando se
	presentan por observación, por defecto amósase a data (con datos
	de series temporais) ou a cadea de texto do marcador de observación
	(en caso de que o haxa) ao comezo de cada liña. Mediante a opción
	<opt>no-dates</opt> elimínase a presentación das datas ou dos
	marcadores; no seu lugar amósase un simple número de observación.
	Consulta o parágrafo final destes comentarios para ver o efecto da
	opción <opt>midas</opt> (que se aplica só a unha lista xa definida
	de series).
      </para>
      <para>
	Cando non indicas ningún argumento (a segunda variante amosada arriba)
	entón o efecto é similar ao primeiro caso, agás que se van presentar
	<emphasis>todas</emphasis> as series do conxunto vixente de datos.
	As opcións que se admiten son como se describiron máis arriba.
      </para>
      <para>
	A terceira variante (co argumento <repl>nomesobxectos</repl>;
	mira o segundo exemplo) agarda unha lista de nomes, separados
	por espazos, de obxectos básicos de GRETL que non sexan series
	(escalares, matrices, cadeas de texto, feixes, arranxos); e amósase
	o valor destes obxectos. No caso dos feixes, as súas compoñentes
	ordénanse por tipo e alfabeticamente.
      </para>
      <para>
	Na cuarta forma (terceiro exemplo), <repl>cadealiteral</repl>
	debe de ser unha cadea de texto contornada entre comiñas
	(e non debe de haber nada máis seguindo á liña de instrución).
	Preséntase a cadea de texto en cuestión, seguida dun carácter
	de liña nova.
      </para>
      <para>
	Podes utilizar a opción <opt>range</opt> para controlar o volume de
	información que se presenta. Os valores (enteiros) dos marcadores
	de <repl>inicio</repl> e <repl>parada</repl> poden referirse a
	observacións de series e de listas, a filas de matrices, a elementos
	de arranxos, e a liñas de cadeas de texto. En todos os casos, o
	valor mínimo de <repl>inicio</repl> é 1, e o máximo valor de
	<repl>parada</repl> é o <quote>tamaño en forma de filas</quote> do
	obxecto en cuestión. Os valores negativos destes marcadores se usan
	para dispoñer unha conta cara atrás, dende o final. Podes indicar
	estes marcadores en formato numérico, ou mediante nomes de variables
	escalares previamente definidas. Se omites <repl>inicio</repl>, se
	considera implicitamente igual a 1; e se omites <repl>parada</repl>,
	iso significa ir ata o final de todo. Con series e listas, cae na
	conta de que os marcadores refírense ao rango mostral vixente.
      </para>
      <para>
	A opción <opt>tree</opt> é específica para presentar un feixe
	(bundle) de GRETL. O efecto diso é que, se o feixe especificado
	contén outros feixes ou arranxos deles, se presentan os seus
	contidos. Se non, só se presentan os elementos do nivel superior
	do feixe.
      </para>
      <para>
	A opción <opt>midas</opt> é especial para presentar unha lista de series
	e, máis aínda, é específica para conxuntos de datos que conteñen unha
	ou máis series de alta frecuencia, cada unha representada por unha
	<cmdref targ="MIDAS_list"/>. Cando indicas unha desas listas como
	argumento e agregas esta opción, a serie preséntase por observación
	da súa frecuencia <quote>orixinal</quote>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos/Amosar valores</menu-path>
    </gui-access>

  </command>

  <command name="printf" section="Printing"
    label="Presentación con formato" context="cli">

    <usage>
      <arguments>
        <argument>formato</argument>
	      <argpunct>, </argpunct>
        <argument>elementos</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Presenta valores escalares, series, matrices ou cadeas de texto
	baixo o control dunha cadea de texto para dar formato (ofrecendo
	unha parte da función <lit>printf</lit> da linguaxe de programación
	C). Os formatos numéricos recoñecidos son <lit>%e</lit>,
	<lit>%E</lit>, <lit>%f</lit>, <lit>%g</lit>, <lit>%G</lit>,
	<lit>%d</lit> e <lit>%x</lit>, en cada caso cos diversos
	reguladores dispoñibles en C. Exemplos: o formato <lit>%.10g</lit>
	presenta un valor con 10 cifras significativas, e <lit>%12.6f</lit>
	presenta un valor cun largo de 12 caracteres dos que 6 son
	decimais. Porén, ten en conta que en GRETL o formato <lit>%g</lit>
	é unha boa elección por defecto para todos os valores numéricos,
	e non tes necesidade de complicarte demasiado. Debes de
	utilizar o formato <lit>%s</lit> para as cadeas de texto.
      </para>
      <para>
	A propia cadea de formato debe de estar contornada entre comiñas,
	e os valores que se van presentar deben de ir despois desa cadea
	de formato, separados por comas. Estes valores deben de ter a forma
	de, ou ben (a) os nomes das variables, ou ben (b) expresións que xeren
	algunha clase de resultado que sexa presentable, ou ben (c) as funcións
	especiais <lit>varname()</lit> ou <lit>date()</lit>. O seguinte
	exemplo presenta os valores de dúas variables, máis o dunha expresión
	que se calcula:
      </para>
      <code>
	ols 1 0 2 3
	scalar b = $coeff[2]
	scalar se_b = $stderr[2]
	printf "b = %.8g, Desvío padrón %.8g, t = %.4f\n",
          b, se_b, b/se_b
      </code>
      <para>
	As seguintes liñas ilustran o uso das funcións 'varname' e 'date',
	que presentan respectivamente o nome dunha variable (indicado
	polo seu número ID) e unha cadea de texto cunha data (dada por
	un número natural positivo que indica unha observación).
      </para>
      <code>
	printf "O nome da variable %d é %s\n", i, varname(i)
	printf "A data da observación %d é %s\n", j, date(j)
      </code>
      <para>
	Cando indicas un argumento matricial asociado a un formato
	numérico, preséntase a matriz enteira utilizando o formato
	especificado para cada elemento. O mesmo aplícase ás series,
	agás que o rango de valores presentados se rexe pola configuración
	vixente da mostra.
      </para>
      <para>
	A lonxitude máxima dunha cadea de formato é de 127 caracteres.
	Recoñécense as secuencias de escape <lit>\n</lit> (nova liña),
	<lit>\r</lit> (salto de liña), <lit>\t</lit> (tabulación), <lit>\v</lit>
	(tabulación vertical) e <lit>\\</lit> (barra inclinada á esquerda
	literal). Para presentar un signo por cento literal, utiliza
	<lit>%%</lit>.
      </para>
      <para>
	Como en C, podes indicar os valores numéricos que forman parte
	do formato (o largo e/ou a precisión) directamente como números,
	como en <lit>%10.4f</lit>, ou como variables. Neste último caso,
	póñense asteriscos na cadea de formato e proporciónanse os
	argumentos correspondentes por orde. Por exemplo:
      </para>
      <code>
	scalar largo = 12
	scalar precision = 6
	printf "x = %*.*f\n", largo, precision, x
      </code>
    </description>

  </command>

  <command name="probit" section="Estimation"
    label="Modelo Probit">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para máis explicacións</effect>
        </option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>Amosa os valores p en vez das pendentes</effect>
	</option>
	<option>
	  <flag>--estrella</flag>
	  <effect>Escolle a variante pseudo-R-cadrado</effect>
	</option>
	<option>
	  <flag>--random-effects</flag>
	  <effect>Estima un modelo Probit de panel con efectos aleatorios, EA</effect>
	</option>
	<option>
	  <flag>--quadpoints</flag>
	  <optparm>k</optparm>
	  <effect>Número de puntos de cuadratura para a estimación con EA</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>ooballot.inp</demo>
	  <demo>oprobit.inp</demo>
	  <demo>reprobit.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Se a variable dependente é unha variable binaria (todos os seus
	valores son 0 ou 1), obtéñense estimacións máximo verosímiles
	dos coeficientes das variables de <repl>indepvars</repl> mediante
	o método de Newton&ndash;Raphson. Como o modelo é non linear,
	as pendentes están condicionadas polos valores das variables
	independentes. Por defecto, calcúlanse as pendentes con respecto a
	cada unha das variables independentes (nas medias desas variables)
	e estas pendentes substitúen aos valores p habituais no resultado
	da regresión. Podes prescindir deste proceder indicando a opción
	<opt>p-values</opt>. O estatístico khi-cadrado proba a hipótese
	nula de que todos os coeficientes son cero, agás o da
	constante.
      </para>
      <para context="cli">
	Por defecto, os desvíos padrón calcúlanse utilizando a inversa negativa
	da matriz Hessiana. Se indicas a opción <opt>robust</opt>, entón calcúlanse
	no seu lugar os desvíos padrón CMV (QML) ou de Huber&ndash;White. Neste
	caso, a matriz de covarianzas estimadas é un <quote>emparedado</quote>
	entre a inversa da matriz Hessiana estimada e o produto externo do vector
	gradiente. Para obter máis detalles, consulta o capítulo 10 do libro de
	<cite key="davidson-mackinnon04">Davidson e MacKinnon (2004)</cite>.
      </para>
      <para context="cli">
	Por defecto, vaise amosar o estatístico pseudo-R-cadrado que foi
	suxerido por <cite key="mcfadden74">McFadden (1974)</cite>;
	mais no caso binario, se indicas a opción <opt>estrella</opt>
	vaise amosar en troques a variante recomendada por
	<cite key="estrella98">Estrella (1998)</cite>. Esta variante
	previsiblemente imita de xeito máis semellante as propiedades do
	<math>R</math><sup>2</sup> habitual no contexto da estimación
	de mínimos cadrados.
      </para>
      <para context="gui">
	Por defecto, os desvíos padrón calcúlanse utilizando a inversa
	negativa da matriz Hessiana. Se marcas o cadriño de
	<quote>Desvíos padrón robustos</quote>, entón calcúlanse en
	troques os desvíos padrón CMV (QML) ou de Huber&ndash;White.
	Neste caso, a matriz de covarianzas estimadas é un
	<quote>emparedado</quote> entre a inversa da matriz Hessiana
	estimada e o produto externo do vector gradiente. Consulta o capítulo
	10 do libro de Davidson e MacKinnon para obter máis detalles.
      </para>
      <para>
	Se a variable dependente non é binaria senón discreta, entón se
	obteñen as estimacións dun Probit Ordenado. (Se a variable elixida
	como dependente non é discreta, amósase un fallo.)
      </para>
      <subhead>Probit para datos de panel</subhead>
      <para>
	Coa opción <opt>random-effects</opt>, asúmese que cada perturbación
	está composta por dúas compoñentes Normalmente distribuídas:
	(a) un termo invariante no tempo que é específico da unidade de
	sección cruzada ou <quote>individuo</quote> (e que se coñece
	como efecto individual), e (b) un termo que é específico da
	observación concreta.
      </para>
      <para>
	A avaliación da verosimilitude deste modelo implica utilizar a
	cuadratura de Gauss-Hermite para aproximar o valor das esperanzas
	de funcións de variables Normais. Podes escoller o número de puntos
	de cuadratura utilizados mediante a opción <opt>quadpoints</opt>
	(por defecto é de 32). Utilizando máis puntos mellórase a precisión
	dos resultados, pero co custo de máis tempo de cálculo; así, con
	moitos puntos de cuadratura, a estimación cun conxunto de datos
	moi grande pode consumir tempo de máis.
      </para>
      <para>
	Amais das estimacións habituais dos parámetros (e dos estatísticos
	asociados) relacionados cos regresores incluídos, preséntase
	algunha información adicional sobre a estimación desta clase de
	modelo:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>lnsigma2</lit>: A estimación máximo verosímil do logaritmo
	    da varianza do efecto individual;
	  </para>
	</li>
	<li>
	  <para>
	    <lit>sigma_u</lit>: A estimación do desvío padrón do efecto
	    individual; e
	  </para>
	</li>
	<li>
	  <para>
	    <lit>rho</lit>: A estimación da parte do efecto individual na
	    varianza composta da perturbación (tamén coñecida como a
	    correlación intra-clase).
	  </para>
	</li>
      </ilist>
      <para>
	A proba de Razón de Verosimilitudes respecto á hipótese nula de que
	<lit>rho</lit> é igual a cero, proporciona un xeito de avaliar se é
	necesaria a especificación de efectos aleatorios. Se a hipótese nula
	non se rexeita, iso suxire que é axeitada unha simple especificación
	Probit combinada.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelar/Variable Dependente Limitada/Probit</menu-path>
    </gui-access>

  </command>

  <command name="pvalue" section="Statistics" label="Calcular probabilidades asociadas" context="cli">

    <usage>
      <arguments>
        <argument>distribución</argument>
        <argument optional="true">parámetros</argument>
	      <argument>xvalor</argument>
      </arguments>
      <examples>
        <example>pvalue z zscore</example>
	<example>pvalue t 25 3.0</example>
	<example>pvalue X 3 5.6</example>
	<example>pvalue F 4 58 fval</example>
	<example>pvalue G shape scale x</example>
	<example>pvalue B bprob 10 6</example>
	<example>pvalue P lambda x</example>
	<example>pvalue W shape scale x</example>
    <demos>
	  <demo>mrw.inp</demo>
	  <demo>restrict.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Calcula a área que queda á dereita do valor <repl>xvalor</repl> na
	distribución especificada (<lit>z</lit> para a Normal, <lit>t</lit>
	para a <math>t</math> de Student, <lit>X</lit> para a Khi-cadrado,
	<lit>F</lit> para a <math>F</math>, <lit>G</lit> para a Gamma,
	<lit>B</lit> para a Binomial, <lit>P</lit> para a Poisson,
	<lit>exp</lit> para a Exponencial, ou <lit>W</lit> para a Weibull).
      </para>
      <para>
	Dependendo do tipo de distribución, debes de indicar a seguinte
	información antes do valor <repl>xvalor</repl>: para as distribucións
	<math>t</math> e khi-cadrado, os graos de liberdade; para a
	<math>F</math>, os graos de liberdade de numerador e denominador;
	para a Gamma, os parámetros de forma e de escala; para a distribución
	Binomial, a probabilidade de <quote>éxito</quote> e o número de
	intentos; para a distribución de Poisson, o parámetro &lgr; (que é
	tanto a media como a varianza); para a Exponencial, un parámetro de
	escala; e para a distribución de Weibull, os parámetros de forma e
	de escala. Como se amosou nos exemplos de arriba, podes indicar
	os parámetros numéricos en formato numérico ou como nomes de
	variables.
      </para>
      <para>
	Os parámetros para a distribución Gamma indícanse ás veces como
	media e varianza en lugar de forma e escala. A media é o produto da
	forma e a escala; a varianza é o produto da forma e o cadrado da
	escala. Deste xeito, podes calcular a escala dividindo a varianza
	entre a media, e podes calcular a forma dividindo a media entre a
	escala.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ferramentas/Buscador do valor P</menu-path>
    </gui-access>

  </command>

  <command name="qlrtest" section="Tests" label="Proba de Razón de Verosimilitudes de Quandt">

    <usage>
      <options>
	<option>
	  <flag>--limit-to</flag>
	  <optparm>lista</optparm>
	  <effect>Limita a proba a un subconxunto de regresores</effect>
	</option>
	<option>
	  <flag>--plot</flag>
	  <optparm>modo-ou-nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Para un modelo estimado con datos de series temporais mediante
	MCO, realiza a proba da Razón de Verosimilitudes de Quandt (QLR)
	para un cambio estrutural nun punto descoñecido no tempo, cun 15
	por cento de recorte ao comezo e ao final do período da mostra.
      </para>
      <para>
	Para cada punto potencial de cambio dentro do 70 por cento
	central das observacións, realízase unha proba de Chow. Consulta
	<cmdref targ="chow"/> para obter máis detalles; pois, de igual
	xeito que coa proba común de Chow, esta é unha proba robusta
	de Wald cando o modelo orixinal se estima coa opción
	<opt>robust</opt>, e unha proba F noutro caso. Entón o estatístico
	QLR é o máximo dos estatísticos de proba particulares.
      </para>
      <para>
	Obtense unha probabilidade asociada (valor p) asintótica utilizando
	o método de <cite key="hansen97">Bruce Hansen (1997)</cite>.
      </para>
      <para>
	Ademais dos accesorios <fncref targ="$test"/> e <fncref targ="$pvalue"/>
	típicos das probas de hipóteses, podes utilizar <fncref targ="$qlrbreak"/>
	para recuperar o índice da observación na que o estatístico de proba
	se maximiza.
      </para>
      <para context="cli">
	Podes utilizar a opción <opt>limit-to</opt> para limitar o conxunto
	de interaccións coa variable ficticia de corte nas probas de Chow,
	a un subconxunto dos regresores orixinais. O parámetro para esta
	opción debe de ser unha lista xa definida na que todos os seus
	elementos se atopen entre os regresores orixinais, e na que non
	debes de incluír a constante.
      </para>
      <para>
	Cando executas de xeito interactivo (unicamente) esta instrución,
	amósase por defecto unha gráfica do estatístico de proba de Chow,
	pero podes axustar isto mediante a opción <opt>plot</opt>. Os
	parámetros que se admiten nesta opción son <lit>none</lit> (para
	eliminar a gráfica), <lit>display</lit> (para amosar unha gráfica mesmo
	cando non se está en modo interactivo), ou un nome de ficheiro. O
	efecto de proporcionar un nome de ficheiro é como o descrito para a
	opción <opt>output</opt> da instrución <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas/Proba de RV de Quandt</menu-path>
    </gui-access>

  </command>

  <command name="qqplot" section="Graphs" label="Gráfica Q-Q">

    <usage>
      <altforms>
	<altform><lit>qqplot</lit> <repl>y</repl></altform>
	<altform><lit>qqplot</lit> <repl>y</repl> <repl>x</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--z-scores</flag>
	  <effect>Mira abaixo</effect>
  </option>
  <option>
	  <flag>--raw</flag>
	  <effect>Mira abaixo</effect>
  </option>
  <option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía a gráfica ao ficheiro especificado</effect>
  </option>
      </options>
    </usage>

    <description>
      <para context="gui">
	Cunha única serie seleccionada, amosa unha gráfica dos cuantís
	empíricos desa serie dada, fronte aos cuantís da distribución Normal.
	A serie debe de incluír cando menos 20 observacións válidas no rango
	vixente da mostra. Por defecto, os cuantís empíricos debúxanse fronte
	aos cuantís dunha distribución Normal que ten as mesmas media e
	varianza que os datos da mostra, pero dispós de dúas alternativas:
	podes tipificar os datos (trocalos en puntuacións z) antes de debuxalos,
	ou podes debuxar os cuantís empíricos <quote>en bruto</quote> fronte
	aos cuantís da distribución Normal estándar.
      </para>
      <para context="cli">
	Indicando como argumento unha única serie, amosa unha gráfica dos
	cuantís empíricos da serie seleccionada (indicada polo seu nome ou
	o seu número ID) fronte aos cuantís da distribución Normal. A serie
	debe de incluír cando menos 20 observacións válidas no rango vixente
	da mostra. Por defecto, os cuantís empíricos debúxanse fronte aos
	cuantís dunha distribución Normal que ten as mesmas media e varianza
	que os datos da mostra, pero dispós de dúas alternativas: se indicas
	a opción <opt>z-scores</opt>, os datos se tipifican; mentres que se
	indicas a opción <opt>raw</opt>, debúxanse os cuantís empíricos
	<quote>en bruto</quote> fronte aos cuantís da distribución Normal
	estándar.
      </para>
      <para context="cli">
	A opción <opt>output</opt> ten como efecto o envío do resultado ao
	ficheiro especificado; utiliza <quote>display</quote> para forzar
	que o resultado se presente na pantalla. Consulta a instrución
	<cmdref targ="gnuplot"/> para obter máis detalles sobre esta opción.
      </para>
      <para>
	Dadas dúas series como argumentos, <repl>y</repl> e <repl>x</repl>,
	amósase unha gráfica dos cuantís empíricos de <repl>y</repl> fronte
	aos de <repl>x</repl>. Os valores dos datos non se tipifican.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Gráfica Q-Q normal</menu-path>
      <menu-path>/Ver/Gráfica de variables indicadas/Gráfica Q-Q</menu-path>
    </gui-access>

  </command>

  <command name="quantreg" section="Estimation"
    label="Regresión de cuantís">

    <usage>
      <arguments>
	      <argument>tau</argument>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
  </option>
  <option>
	  <flag>--intervals</flag>
	  <optparm optional="true">nivelconf</optparm>
	  <effect>Calcula os intervalos de confianza</effect>
  </option>
  <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
  </option>
  <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
  </option>
      </options>
      <examples>
	<example>quantreg 0.25 y 0 xlista</example>
	<example>quantreg 0.5 y 0 xlista --intervals</example>
	<example>quantreg 0.5 y 0 xlista --intervals=.95</example>
	<example>quantreg tauvec y 0 xlista --robust</example>
	<demos>
	  <demo>mrw_qr.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Regresión de cuantís. Por defecto, os desvíos padrón
	calcúlanse de acordo coa fórmula asintótica indicada por
	<cite key="koenker-bassett78">Koenker e Bassett (1978)</cite>, pero
	se marcas o cadriño de <quote>Desvíos padrón robustos</quote>,
	utilízase a variante robusta á heterocedasticidade
	de <cite key="koenker-zhao94">Koenker e Zhao (1994)</cite>.
      </para>
      <para>
	Se marcas a opción <quote>Calcular os intervalos de confianza</quote>,
	GRETL calcula os intervalos de confianza para os coeficientes
	en troques dos desvíos padrón. E o cadriño de validación
	de <quote>Desvíos padrón robustos</quote> ten outro efecto:
	se non se marca, os intervalos calcúlanse baixo o suposto
	de perturbacións IID; e ao marcalo, GRETL utiliza o estimador
	robusto desenvolvido por
	<cite key="koenker-machado99">Koenker e Machado (1999)</cite>.
	Ten en conta que estes intervalos non son exactamente
	<quote>máis ou menos tantos desvíos padrón</quote> pois, en xeral,
	son asimétricos a respecto das estimacións puntuais dos coeficientes.
	    </para>
      <para>
	Podes indicar unha lista de cuantís (consulta a lista despregable para
	algunhas posibilidades xa definidas con anterioridade). Nese caso, GRETL
	calcula as estimacións de cuantís e, ou ben os desvíos padrón ou
	ben os intervalos de confianza para cada un dos valores especificados.
      </para>
      <para>
	Para seguir a pista das referencias indicadas arriba, consulta o
	<guideref targ="chap:quantreg"/>.
      </para>
    </description>

    <description context="cli">
      <para>
	Regresión de cuantís. O primeiro argumento (<repl>tau</repl>) é o cuantil
	condicionado para o que se quere a estimación. Podes indicalo, ben cun
	valor numérico, ou ben co nome dunha variable escalar definida previamente;
	e o valor debe de estar no rango de 0.01 a 0.99. (Como alternativa, podes
	indicar un vector de valores para <repl>tau</repl>; mira abaixo para obter
	máis detalles.) O segundo e subseguintes argumentos compoñen unha lista
	de regresión co mesmo padrón ca <cmdref targ="ols"/>.
      </para>
      <para>
	Sen a opción <opt>intervals</opt>, preséntanse os desvíos
	padrón para as estimacións dos cuantís. Por defecto, estas
	calcúlanse de acordo coa fórmula asintótica indicada por
	<cite key="koenker-bassett78">Koenker e Bassett (1978)</cite>,
	pero cando indicas a opción <opt>robust</opt>, calcúlanse
	os desvíos padrón que son robustos con respecto á
	heterocedasticidade, utilizando o método de
	<cite key="koenker-zhao94">Koenker e Zhao (1994)</cite>.
      </para>
      <para>
	Cando escolles a opción <opt>intervals</opt>, preséntanse os
	intervalos de confianza para as estimacións dos parámetros en
	troques dos desvíos padrón. Estes intervalos calcúlanse usando
	o método da inversión do rango e, en xeral, son asimétricos a
	respecto das estimacións puntuais. As especificidades do cálculo
	están mediatizadas pola opción <opt>robust</opt>: sen esta, os
	intervalos calcúlanse baixo o suposto de perturbacións IID
	<cite key="koenker94" p="true">(Koenker, 1994)</cite>; e con ela
	se utiliza o estimador robusto desenvolvido por
	<cite key="koenker-machado99">Koenker e Machado (1999)</cite>.
      </para>
      <para>
	Por defecto, xéranse intervalos de confianza do 90 por cento. Podes
	trocar isto engadindo un nivel de confianza (expresado como unha fracción
	decimal) á opción de intervalos, como en <opt>intervals=0.95</opt>.
      </para>
      <para>
	Vector <repl>tau</repl> de valores: en troques de proporcionar un escalar,
	podes indicar o nome dunha matriz definida previamente. Neste caso, as
	estimacións calcúlanse para todos os valores <repl>tau</repl> indicados,
	e os resultados preséntanse nun formato especial, amosando a secuencia
	das estimacións de cuantís para cada regresor, de un en un.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Estimación Robusta/Regresión de cuantís</menu-path>
    </gui-access>

  </command>

  <command name="quit" section="Utilities"
    label="Saír do programa" context="cli">

    <description>
      <para>
	Sae da modalidade vixente de GRETL.
      </para>
      <ilist>
	<li>
	  <para>
	Cando esta instrución se invoca desde un guión, remátase a execución
	de ese guión. No contexto de gretlcli en modo de procesamento por
	lotes, o propio gretlcli remata; noutro caso, o programa recúa a
	modo interactivo.
	  </para>
	</li>
	<li>
	  <para>
  Cando se invoca desde a consola do programa de Interface Gráfica
  de Usuario (GUI), péchase a xanela da consola.
	  </para>
	</li>
	<li>
	  <para>
	Cando se invoca desde gretlcli en modo interactivo, este programa
	remata.
	  </para>
	</li>
      </ilist>
      <para>
	Cae na conta de que esta instrución non pode invocarse desde dentro
	de funcións nin de bucles.
      </para>
      <para>
	A instrución <lit>quit</lit> en ningún caso provoca que remate o
	programa de Interface Gráfica de Usuario (GUI) de GRETL. Isto faise
	ben mediante a opción <lit>Saír</lit> do apartado <lit>Ficheiro</lit>
	do menú, ben mediante <lit>Ctrl+Q</lit>, ou ben premendo co rato o
	control de peche na barra do título da xanela principal de GRETL.
      </para>
    </description>
  </command>

  <command name="regls" section="Estimation"
	   label="Mínimos Cadrados Regularizados" context="gui">
    <description>
      <para>
	Este diálogo te permite o acceso á función <lit>regls</lit> para
	Mínimos Cadrados Regularizados.
      </para>
      <para>
	Se toleran tres estimadores: LASSO, que limita a suma dos valores absolutos
	dos coeficientes; Ridge (crista), que limita a suma dos coeficientes
	cadrados; e Elastic net (malla elástica), que é unha combinación das
	dúas primeiras rexida polo 'hiperparámetro' &alpha; de xeito que
	&alpha; = 1 proporciona LASSO, &alpha; = 0 proporciona Ridge, e
	valores intermedios proporcionan unha combinación ponderada.
      </para>
      <para>
	O termo &lgr; especifica o grao ata o que se penaliza a suma de
	coeficientes absolutos ou cadrados. Podes ben indicar unha única
	fracción &lgr; desde 0 (sen penalización) ata 1 (máxima penalización),
	ou ben un grupo de valores &lgr;. No segundo caso, os valores de
	penalización escálanse automaticamente.
      </para>
      <para>
	Se elixes varios valores para &lgr;, vaise habilitar a opción de
	validación cruzada. Nese caso, vas poder escoller tanto o número de
	<quote>pregos</quote> para os datos de ensaio (por defecto é 10),
	como se estes pregos deben de ser subconxuntos aleatorios ou
	contiguos de observacións. Tamén poderás escoller se queres que
	se amose unha gráfica coas medias do Erro Cadrado Medio (MSE) fronte
	ás fraccións &lgr;.
      </para>
      <para>
	O botón <quote>Avanzado</quote> abre un novo diálogo que proporciona
	en certa maneira un maior grao de control sobre o procedemento de
	regularización. Mais cae na conta de que podes exercer un control
	máis detallado invocando á función <lit>regls</lit> mediante a redacción
	de guións; para máis detalles consulta <doc>regls.pdf</doc>.
      </para>
    </description>
  </command>

  <command name="regls-advanced" section="Estimation"
	   label="Outras opcións para regls" context="gui">
    <description>
      <para>
	As escollas feitas mediante este diálogo aplícanse unicamente cando
	son relevantes, en función das eleccións feitas no diálogo principal
	<quote>reglsbest</quote>. Vanse lembrar mentres dure a sesión de GRETL.
      </para>
      <ilist>
	<li>
	  <para>
	Elección de algoritmo: Podes escoller o método Descenso de Coordenada
	Cíclico (CCD) tanto para o LASSO como para a regresión Ridge (crista),
	en contraste co método por defecto; é dicir, o Método de Multiplicadores
	de Dirección Alterna (ADMM) para o LASSO e a Descomposición
	do Valor Singular (SVD) para o Ridge.
	  </para>
	</li>
	<li>
	  <para>
	O criterio por defecto para que renda <quote>mellor</quote>
	a validación cruzada é minimizar o Erro Cadrado Medio (MSE),
	pero podes seleccionar a regra alternativa
	<quote>un desvío padrón</quote>. Esta alternativa, que
	favorece a sobriedade, escolle o maior factor de penalización
	cuxo MSE está a menos dun desvío padrón do mínimo.
	  </para>
	</li>
	<li>
	  <para>
	Semente para os pregos aleatorios: Se queres obter resultados
	replicables na validación cruzada con pregos aleatorios, é
	necesario especificar unha semente para o xerador de números
	aleatorios.
	  </para>
	</li>
	<li>
	  <para>
	Por defecto, regls utilizará MPI (se está dispoñible) nun esforzo por
	acelerar a validación cruzada. O recadro para MPI (que se amosa só
	cando se compila GRETL con soporte MPI) te permite desactivar isto,
	o que pode producir unha aceleración para bancos pequenos de datos.
	  </para>
	</li>
	<li>
	  <para>
	A opción de amosar o tempo de execución pode serte útil se queres
	comparar o comportamento de diferentes algoritmos, ou comprobar
	se paga a pena usar o MPI. O tempo que se amosa no resultado
	corresponde á execución do código C subxacente.
	  </para>
	</li>
      </ilist>
    </description>
  </command>

  <command name="rename" section="Dataset" label="Cambiar o nome dunha variable" context="cli">
    <usage>
      <arguments>
	      <argument>serie</argument>
	      <argument>novonome</argument>
      </arguments>
      <options>
  <option>
	  <flag>--quiet</flag>
	  <effect>Suprime a presentación de resultados</effect>
  </option>
  <option>
    <flag>--case</flag>
    <effect>Troca o formato dos nomes de tódalas series; mira abaixo</effect>
  </option>
      </options>
      <examples>
        <example>rename x2 ingreso</example>
        <example>rename --case=lower</example>
      </examples>
    </usage>

    <description>
      <para>
        Sen a opción <opt>--case</opt>, esta instrución troca o nome de
        <repl>serie</repl> (identificada polo seu nome ou seu número ID) a
        <repl>novonome</repl>. O novo nome debe ter 31 caracteres como
        máximo, comezar cunha letra e estar formado só por letras, díxitos
        e/ou o carácter de barra baixa. Ademais, non debe ser o nome dun
        obxecto de calquera tipo que xa exista.
      </para>
      <para>
        A opción <opt>--case</opt> permite trocar o formato de
        <emphasis>tódolos</emphasis> nomes das series no conxunto de datos
        aberto vixente. Cando se utiliza esta opción, non se debe indicar
        ningún nome para <repl>serie</repl> nin para <repl>novonome</repl>.
        Admítense os seguintes tipos de formato:
      </para>
      <ilist>
        <li>
          <para>
      <repl>lower</repl>: Converte tódolos nomes das series a minúsculas.
          </para>
        </li>
        <li>
          <para>
      <repl>upper</repl>: Converte tódolos nomes das series a versais.
          </para>
        </li>
        <li>
          <para>
      <repl>camel</repl>: Converte tódolos nomes das series a formato
      camelo; o que significa que se eliminan as barras baixas e o carácter
      seguinte ás mesmas (se hai algún) pónse en versais. Por exemplo,
	    <lit>algunha_cousa</lit> vólvese <lit>algunhaCousa</lit>.
          </para>
        </li>
        <li>
          <para>
      <repl>snake</repl>: Converte tódolos nomes das series a formato
      serpe; o que significa que calquera letra versal (agás a primeira do
      nome) convértense a minúsculas, precedida por unha barra baixa.
      Por exemplo, <lit>algunhaCousa</lit> vólvese <lit>algunha_cousa</lit>.
          </para>
        </li>
      </ilist>
    </description>

    <gui-access>
      <menu-path>/Variable/Editar atributos</menu-path>
      <other-access>Xanela principal: Menú emerxente (selección única)</other-access>
    </gui-access>

  </command>

  <command name="reprobit" section="Estimation" label="Probit de efectos aleatorios"
	   context="gui">

    <description>
      <para>
	O estimador Probit de efectos aleatorios proporciona un medio de
	estimar un modelo Probit (binario) con datos de panel. Asúmese que
	cada perturbación está composta por dúas compoñentes Normalmente
	distribuídas: (a) un termo invariante respecto ao tempo que é
	especifico da unidade de sección cruzada ou <quote>individuo</quote>
	(e que se coñece como efecto individual), e (b) un termo que é
	específico da observación concreta.
      </para>
      <para>
	A avaliación da verosimilitude deste modelo implica utilizar a cuadratura
	de Gauss-Hermite para aproximar o valor das esperanzas de funcións de
	variables Normais. Neste diálogo, podes escoller o número de puntos de
	cuadratura utilizados. Usando máis puntos mellórase a precisión dos
	resultados, pero co custo de máis tempo de cálculo; así con moitos
	puntos de cuadratura, a estimación cun conxunto de datos moi grande
	pode consumir tempo de máis.
      </para>
      <para>
	Amais das estimacións habituais dos parámetros (e dos estatísticos
	asociados) relacionados cos regresores incluídos, preséntase
	algunha información adicional sobre a estimación desta clase de
	modelo:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>lnsigma2</lit>: A estimación máximo verosímil do logaritmo
	    da varianza do efecto individual;
	  </para>
	</li>
	<li>
	  <para>
	    <lit>sigma_u</lit>: A estimación do desvío padrón do efecto
	    individual; e
	  </para>
	</li>
	<li>
	  <para>
	    <lit>rho</lit>: A estimación da parte do efecto individual na
	    varianza composta da perturbación (tamén coñecida como a
	    correlación intra-clase).
	  </para>
	</li>
      </ilist>
      <para>
	A proba de Razón de Verosimilitudes respecto á hipótese nula de que
	<lit>rho</lit> é igual a cero, proporciona un xeito de avaliar se é
	necesaria a especificación de efectos aleatorios. Se a hipótese nula
	non se rexeita, iso suxire que é axeitada unha simple especificación
	Probit combinada.
      </para>
      <para>
	En modo guión, o modelo Probit de efectos aleatorios estímase
	utilizando a instrución <lit>probit</lit> coa opción
	<opt>random-effects</opt>.
      </para>
    </description>
  </command>

  <command name="reset" section="Tests" label="RESET de Ramsey">

    <usage>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta a regresión auxiliar</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
	</option>
	<option>
	  <flag>--squares-only</flag>
	  <effect>Calcula a proba usando só os cadrados</effect>
	</option>
	<option>
	  <flag>--cubes-only</flag>
	  <effect>Calcula a proba usando só os cubos</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>Usa erros padrón robustos na regresión auxiliar</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Debe de ir despois da estimación dun modelo mediante MCO. Leva a
	cabo a proba RESET de Ramsey sobre a especificación (non linear)
	dun modelo, engadíndolle á regresión os cadrados e/ou os cubos
	dos valores axustados, e calculando o estatístico <math>F</math>
	para probar a hipótese nula de que os parámetros dos termos
	engadidos son cero. Por razóns numéricas, os cadrados e os cubos
	se reescalan utilizando o desvío padrón dos valores axustados.
      </para>
      <para context="cli">
	Vanse engadir tanto os cadrados como os cubos, agás que
	indiques unha das opcións <opt>squares-only</opt> ou
	<opt>cubes-only</opt>.
      </para>
      <para context="cli">
	Podes utilizar a opción <opt>silent</opt> se tes intención de facer
	uso dos accesorios <fncref targ="$test"/> e/ou <fncref targ="$pvalue"/>
	para gardar os resultados da proba.
      </para>
      <para context="cli">
	A opción <opt>robust</opt> está implícita cando na regresión que se
	vai comprobar se utilizaron erros padrón robustos.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas/Proba RESET de Ramsey</menu-path>
    </gui-access>

  </command>

  <command name="restrict" section="Tests" context="cli"
    label="Probar restricións">

    <usage>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta as estimacións restrinxidas</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
	</option>
	<option>
	  <flag>--wald</flag>
	  <effect>Só estimadores de sistema, mira abaixo</effect>
	</option>
	<option>
	  <flag>--bootstrap</flag>
	  <effect>Cálculo da proba con remostraxe automática, se é posible</effect>
	</option>
	<option>
	  <flag>--full</flag>
	  <effect>Só MCO e VECMs, mira abaixo</effect>
	</option>
      </options>
    <examples>
	<demos>
	  <demo>hamilton.inp</demo>
	   <demo>restrict.inp</demo>
	</demos>
    </examples>
    </usage>

    <description>
      <para>
	Impón un conxunto de restricións (habitualmente lineais)
	sobre: (a) o último modelo estimado ou (b) un sistema de
	ecuacións que se definiu e nomeou previamente. En todos
	os casos, debes de comezar o conxunto de restricións coa
	palabra chave <quote>restrict</quote> e rematalo con
	<quote>end restrict</quote>.
      </para>
      <para>
	No caso dunha única ecuación, as restricións sempre se aplican
	implicitamente ao último modelo, e avalíanse tan pronto como se
	peche o bloque <lit>restrict</lit>.
      </para>
      <para>
	No caso dun sistema de ecuacións (definido mediante a instrución
	<cmdref targ="system"/>), podes poñer o nome do sistema de
	ecuacións definido previamente, despois do <quote>restrict</quote>
	inicial. Cando omites iso e o último modelo foi un sistema, entón
	as restricións aplícanse a ese derradeiro modelo. Por defecto, as
	restricións avalíanse cando o sistema acaba de estimarse, usando
	a instrución <cmdref targ="estimate"/>. Pero cando indicas a opción
	<opt>wald</opt>, a restrición compróbase inmediatamente a través
	da proba khi-cadrado de Wald en relación á matriz de covarianzas.
	Ten en conta que esta opción vai xerar un fallo se xa definiches un
	sistema, pero aínda non o estimaches.
      </para>
      <para>
	Dependendo do contexto, podes expresar de varios xeitos as
	restricións que queiras probar. O máis simple é como se indica
	deseguido: cada restrición exprésase como unha ecuación, cunha
	combinación linear de parámetros á esquerda do signo de igualdade
	e un valor escalar á dereita (ben unha constante numérica, ou ben
	o nome dunha variable escalar).
      </para>
      <para>
	No caso dunha única ecuación, podes referirte aos parámetros
	da mesma co formato <lit>b[</lit><repl>i</repl><lit>]</lit>, onde
	<repl>i</repl> representa a posición na lista de regresores
	(comezando no 1), ou co formato
	<lit>b[</lit><repl>nomevar</repl><lit>]</lit>, onde
	<repl>nomevar</repl> é o nome do regresor en cuestión. No caso
	dun sistema, a referencia aos parámetros faise utilizando a letra
	<lit>b</lit> xunto con dous números colocados entre corchetes.
	O primeiro número representa a posición da ecuación dentro do
	sistema, e o segundo número indica a posición do regresor
	dentro da lista deles. Por exemplo, <lit>b[2,1]</lit> denota
	o primeiro parámetro da segunda ecuación, mentres que
	<lit>b[3,2]</lit> denota o segundo parámetro da terceira ecuación.
	Podes antepoñer multiplicadores numéricos aos elementos
	<lit>b</lit> da ecuación que representa unha restrición, por exemplo
	<lit>3.5*b[4]</lit>.
      </para>
      <para>
	Aquí tes un exemplo dun conxunto de restricións para un modelo
	estimado previamente:
      </para>
      <code>
	restrict
	 b[1] = 0
	 b[2] - b[3] = 0
	 b[4] + 2*b[5] = 1
	end restrict
      </code>
      <para>
	E aquí tes un exemplo dun conxunto de restricións para aplicar a
	un sistema xa definido. (Se o nome do sistema non contén espazos,
	as comiñas que o contornan non fan falta.)
      </para>
      <code>
	restrict "Sistema 1"
	 b[1,1] = 0
	 b[1,2] - b[2,2] = 0
	 b[3,4] + 2*b[3,5] = 1
	end restrict
      </code>
      <para>
	No caso dunha única ecuación, as restricións avalíanse por defecto por
	medio da proba de Wald, usando a matriz de covarianzas do modelo en
	cuestión. Se estimaches o modelo orixinal con MCO, entón preséntanse as
	estimacións dos coeficientes restrinxidos; para eliminar isto, engade a
	opción <opt>quiet</opt> á instrución <lit>restrict</lit> inicial. Como
	alternativa á proba de Wald, para modelos estimados unicamente mediante
	MCO ou MCP, podes indicar a opción <opt>bootstrap</opt> para realizar
	a proba da restrición con remostraxe automática (bootstrap).
      </para>
      <para>
	No caso dun sistema, o estatístico de proba depende do estimador elixido:
	un estatístico de Razón de Verosimilitudes cando o sistema se estima
	utilizando un método de Máxima Verosimilitude, ou un estatístico
	<math>F</math> asintótico, noutro caso.
      </para>
      <subhead>Restricións lineais: sintaxe alternativa</subhead>
      <para>
	Tes dúas alternativas ao método para expresar as restricións descrito
	máis arriba. Primeiro, podes escribir de forma compacta un conxunto
	de <math>g</math> restricións sobre o vector cos <math>k</math>
	parámetros (&bgr;), como <math>R</math>&bgr; &minus; <math>q</math> = 0,
	onde <math>R</math> é unha matriz de dimensión <by r="g" c="k"/> e
	<math>q</math> é un vector de dimensión <math>g</math>. Podes expresar
	unha restrición indicando os nomes de matrices definidas previamente,
	cómodas para utilizar como <math>R</math> e <math>q</math>,
	como en
      </para>
      <code>
	restrict
	  R = Rmat
	  q = qvec
	end restrict
      </code>
      <para>
	En segundo lugar, como variante que te pode ser útil cando uses a
	función <lit>restrict</lit> dentro doutra función, podes elaborar
	o conxunto de enunciados de restrición co formato dun arranxo de
	cadeas de texto. Despois utiliza a palabra chave <lit>inject</lit>
	co nome do arranxo. Este é un exemplo sinxelo:
      </para>
      <code>
	strings RS = array(2)
	RS[1] = "b[1,2] = 0"
	RS[2] = "b[2,1] = 0"
	restrict
	  inject RS
	end restrict	
      </code>
      <para>
	Co uso actual deste método, posiblemente preferirás utilizar a función
	<fncref targ="sprintf"/> para elaborar as cadeas de texto, en base
	á entrada para unha función.
      </para>
      <subhead>Restricións non lineais </subhead>
      <para>
	Se queres probar unha restrición non linear (o que actualmente só está
	dispoñible para modelos dunha única ecuación), debes indicar a restrición
	co nome dunha función, precedida por <quote><lit>rfunc = </lit></quote>,
	como en
      </para>
      <code>
	restrict
	  rfunc = nosafuncion
	end restrict
      </code>
      <para>
	A función de restrición debe de ter un único argumento <lit>const matrix</lit>,
	e isto complétase automaticamente co vector de parámetros. E debera
	de devolver un vector que é cero baixo a hipótese nula, e non nulo
	noutro caso. A dimensión do vector é igual ao número de restricións.
	Esta función utilízase como unha <quote>chamada de volta</quote> da
	rutina numérica para o Jacobiano, de GRETL, que calcula o estatístico
	de proba de Wald mediante o método delta.
      </para>
      <para>
	Aquí tes un exemplo sinxelo dunha función apropiada para comprobar
	unha restrición non linear, concretamente que dous pares de valores
	dos parámetros teñen unha razón común.
      </para>
      <code>
	function matrix restr (const matrix b)
	  matrix v = b[1]/b[2] - b[4]/b[5]
	  return v
	end function
      </code>
      <para>
	Cando se completa con éxito a instrución <lit>restrict</lit>, os accesorios
	<fncref targ="$test"/> e <fncref targ="$pvalue"/> proporcionan o estatístico
	de proba e a súa probabilidade asociada (valor p), respectivamente.
      </para>
      <para>
	Cando se proban restricións sobre un modelo dunha única ecuación que foi
	estimado mediante MCO ou sobre un Modelo de Vectores de Corrección do
	Erro (VECM), podes utilizar a opción <opt>full</opt> para dispoñer que
	as estimacións restrinxidas sexan o <quote>último modelo</quote>, coa
	intención de facer probas máis adiante ou de usar accesorios como
	<lit>$coeff</lit> e <lit>$vcv</lit>. Cae na conta de que se aplican algúns
	detalles especiais no caso de que probes restricións sobre un VECM.
	Consulta o <guideref targ="chap:vecm"/> para obter máis detalles.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: Probas/Restricións lineais</menu-path>
    </gui-access>

  </command>

  <command name="restrict-model" section="Tests" context="gui"
    label="Restricións nun modelo">

    <description>
      <para>
	Debes de expresar cada restrición do conxunto como unha ecuación, cunha
	combinación linear de parámetros á esquerda do signo de igualdade e un
	valor numérico á dereita. Podes referirte aos seus parámetros co formato
	<lit>b[</lit><repl>i</repl><lit>]</lit>, onde <repl>i</repl> representa
	a posición na lista de regresores (comezando no 1), ou co formato
	<lit>b[</lit><repl>nomevar</repl><lit>]</lit>, onde <repl>nomevar</repl>
	é o nome do regresor en cuestión.
      </para>
      <para>
	Podes antepoñer multiplicadores numéricos aos elementos <lit>b</lit>
	da ecuación que representa unha restrición, utilizando <lit>*</lit>
	para indicar a multiplicación, por exemplo <lit>3.5*b[4]</lit>.
      </para>
      <para>
	Aquí tes un exemplo dun conxunto de restricións:
      </para>
      <code>
	b[1] = 0
	b[2] - b[3] = 0
	b[4] + 2*b[5] = 1
      </code>
    </description>

  </command>

  <command name="restrict-system" section="Tests" context="gui"
    label="Restricións nun sistema de ecuacións">

    <description>
      <para>
	Debes de expresar cada restrición do conxunto como unha ecuación, cunha
	combinación linear de parámetros á esquerda do signo de igualdade e un
	valor numérico á dereita. A referencia aos parámetros faise utilizando a
	letra <lit>b</lit> xunto con dous números colocados entre corchetes. O
	primeiro número representa a posición da ecuación dentro do sistema, e
	o segundo número indica a posición do regresor dentro da lista deles,
	comezando por 1 en ambos casos. Por exemplo, <lit>b[2,1]</lit> denota
	o primeiro parámetro da segunda ecuación, mentres que <lit>b[3,2]</lit>
	denota o segundo parámetro da terceira ecuación.
      </para>
      <para>
	Podes antepoñer multiplicadores numéricos aos elementos <lit>b</lit>
	da ecuación que representa unha restrición, utilizando <lit>*</lit>
	para indicar a multiplicación, por exemplo <lit>3.5*b[1,4]</lit>.
      </para>
      <para>Aquí tes un exemplo dun conxunto de restricións:
      </para>
      <code>
	b[1,1] = 0
	b[1,2] - b[2,2] = 0
	b[3,4] + 2*b[3,5] = 1
      </code>
    </description>

  </command>

  <command name="restrict-vecm" section="Tests" context="gui"
    label="Restricións nun VECM">

    <description>
      <para>
	Utiliza esta instrución para establecer restricións lineais sobre
	as relacións de cointegración (beta) e/ou os coeficientes de axuste
	(alfa) nun Modelo de Vectores de Corrección do Erro (VECM).
      </para>
      <para>
	Debes de expresar cada restrición do conxunto como unha ecuación, cunha
	combinación linear de parámetros á esquerda do signo de igualdade e un
	valor numérico á dereita. As restricións sobre beta poden ser non
	homoxéneas (con valores distintos de cero á dereita), pero as restricións
	sobre alfa deben de ser homoxéneas (con ceros á dereita).
      </para>
      <para>
	Se o VECM é de rango 1, a referencia aos parámetros faise utilizando
	o formato <lit>b[</lit><repl>i</repl><lit>]</lit>, onde <repl>i</repl>
	representa a posición no vector de cointegración, comezando en 1. Por
	exemplo, <lit>b[2]</lit> denota o segundo elemento de beta. Pero se o
	rango é maior ca 1, utiliza <lit>b</lit> xunto con dous números
	colocados entre corchetes. Por exemplo, <lit>b[2,1]</lit> denota o
	primeiro elemento do segundo vector de cointegración.
      </para>
      <para>
	Para referirte aos elementos de alfa, utiliza <lit>a</lit> en vez de
	<lit>b</lit>.
      </para>
      <para>
	Podes antepoñer multiplicadores numéricos aos identificadores dos
	parámetros da ecuación que representa unha restrición, utilizando
	<lit>*</lit> para indicar a multiplicación, por exemplo <lit>3.5*b[4]</lit>.
      </para>
      <para>Aquí tes un exemplo dun conxunto de restricións nun VECM de rango 1.
      </para>
      <code>
	b[1] + b[2] = 0
	b[1] + b[3] = 0
      </code>
      <para>
	Consulta tamén o <guideref targ="chap:vecm"/>.
      </para>
    </description>

  </command>

  <command name="rmplot" section="Graphs" label="Gráfica Rango-Media">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--trim</flag>
	  <effect>Mira abaixo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	</option>
	<option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Gráfica Rango&ndash;Media: Esta instrución xera unha gráfica sinxela
	para axudar a decidir se unha serie temporal, <math>y</math>(t), ten
	unha varianza constante ou non. Cóllese a mostra completa (t=1,...,T)
	e divídese en pequenas submostras de tamaño arbitrario <math>k</math>.
	A primeira submostra está composta por
	<math>y</math>(1),...,<math>y</math>(k), a segunda por
	<math>y</math>(k+1), ..., <math>y</math>(2k), etcétera.
	Para cada submostra, calcúlase a media da serie na mostra e o rango
	(= máximo menos mínimo), e constrúese unha gráfica coas medias
	no eixe horizontal e os rangos no vertical. Así cada submostra
	se representa mediante un punto neste plano. Se a varianza da
	serie é constante, agardaríase que o rango da submostra sexa
	independente da media da submostra. Por iso, se observamos que
	os puntos se aproximan a unha liña con pendente positiva, isto
	suxire que a varianza das series aumenta a medida que o fai a
	media; e se os puntos se aproximan a unha liña con pendente
	negativa, isto suxire que a varianza decrece ao aumentar a media.
      </para>
      <para>
	Ademais da gráfica, GRETL amosa as medias e rangos para cada
	submostra, xunto co coeficiente da pendente dunha regresión MCO
	do rango sobre a media, e coa probabilidade asociada ao estatístico
	para probar a hipótese nula de que esta pendente é cero. Se o
	coeficiente da pendente é significativo cun nivel de significación
	do 10 por cento, entón amósase na gráfica a liña axustada da
	regresión do rango sobre a media. Se rexistran tanto o estatístico
	<math>t</math> para probar a hipótese nula como a probabilidade
	asociada correspondente, e podes recuperalos usando os accesorios
	<fncref targ="$test"/> e <fncref targ="$pvalue"/>, respectivamente.
      </para>
      <para context="cli">
	Cando indicas a opción <opt>trim</opt>, descártanse os valores
	mínimo e máximo de cada submostra antes de calcular a media e
	o rango. Isto fai que sexa menos probable que os valores atípicos
	provoquen unha distorsión na análise.
      </para>
      <para context="cli">
	Cando indicas a opción <opt>quiet</opt>, non se amosa a gráfica nin se
	presenta o resultado; só se indican o estatístico <math>t</math> e a súa
	probabilidade asociada (valor p). Por outra banda, podes controlar o formato
	da gráfica mediante a opción <opt>output</opt>; e isto funciona como se
	describe en conexión coa instrución <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Gráfica Rango-Media</menu-path>
    </gui-access>

  </command>

  <command name="run" section="Programming"
    label="Executar un guión" context="cli">

    <usage>
      <arguments>
        <argument>nomeficheiro</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Executa as instrucións de <repl>nomeficheiro</repl> e logo devolve
	o control ao indicador interactivo. Esta instrución está pensada
	para que a utilices co programa de liñas de instrución
	<program>gretlcli</program> ou coa <quote>consola de GRETL</quote>
	no programa de Interface Gráfica de Usuario (GUI).
      </para>
      <para>
	Consulta tamén <cmdref targ="include"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Icona 'Executar' na xanela do editor de guións</menu-path>
    </gui-access>

  </command>

  <command name="runs" section="Tests" label="Proba de ringleiras">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--difference</flag>
	  <effect>Utiliza as primeiras diferenzas da variable</effect>
	</option>
	<option>
	  <flag>--equal</flag>
	  <effect>Os valores positivos e negativos son equiprobables</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Realiza a proba non paramétrica <quote>de ringleiras</quote> para
	comprobar o carácter aleatorio da <repl>serie</repl> indicada, onde
	as ringleiras defínense como secuencias de valores consecutivos
	positivos ou negativos. Se queres probar o carácter aleatorio das
	desviacións respecto á mediana, para unha variable chamada
	<lit>x1</lit> que ten unha mediana non nula, podes facer o seguinte:
      </para>
      <code>
	series signx1 = x1 - median(x1)
	runs signx1
      </code>
      <para>
	Cando indicas a opción <opt>difference</opt>, vanse calcular as
	primeiras diferenzas da serie antes da análise, polo que as ringleiras
	se interpretarían como secuencias de aumentos ou de diminucións
	consecutivas do valor da variable.
      </para>
      <para>
	Cando indicas a opción <opt>equal</opt>, a hipótese nula tamén
	incorpora o suposto de que os valores positivos e negativos son
	igual de probables; se non, o estatístico de proba resulta
	invariante con respecto á <quote>neutralidade</quote> do proceso
	que xerou a secuencia de valores, e a proba céntrase unicamente
	na independencia.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ferramentas/Probas non paramétricas</menu-path>
    </gui-access>

  </command>

  <command name="sampling" section="Dataset" context="gui"
    label="Configurando a mostra">

    <description>
      <para>
	O menú Mostra ofrece varios xeitos de seleccionar unha submostra do
	conxunto vixente de datos.
      </para>
      <para>
	Se escolles <quote>Mostra/Restrinxir, a partir do criterio...</quote>
	é necesario que indiques unha expresión booleana (lóxica), do mesmo
	tipo que usarías para definir unha variable ficticia. Por exemplo, a
	expresión <quote>sqft &gt; 1400</quote> seleccionará só os casos nos que
	a variable 'sqft' ten un valor maior ca 1400. Podes encadear as condicións
	utilizando os operadores lóxicos <quote>&amp;&amp;</quote> (AND)
	e <quote>||</quote> (OR), e podes aplicar a negación utilizando
	<quote>!</quote> (NOT). Se o conxunto de datos xa contén variables
	ficticias, tamén tes a posibilidade de escoller unha delas para
	definir a mostra (as observacións que teñan o valor 1 na variable
	ficticia escollida, vanse incluír, e as outras vanse excluír).
      </para>
      <para>
	O elemento do menú <quote>Mostra/Prescindir das observacións con valores ausentes</quote>
	volve definir a mostra, para excluír todas as observacións para as que os valores
	dunha ou máis variables están ausentes (deixando só os casos completos).
      </para>
      <para>
	Para seleccionar observacións para as que unha variable concreta ten
	valores non ausentes, usa <quote>Restrinxir, a partir do criterio...</quote>
	e indica a condición booleana <quote>ok(nomevar)</quote> (substitúe
	<quote>nomevar</quote> co nome da variable que queiras usar).
      </para>
      <para>
	Se as observacións teñen etiquetas, podes excluír observacións
	concretas utilizando, por exemplo, <lit>obs!="Francia"</lit> como
	criterio booleano. Debes de contornar o nome da observación con
	comiñas.
      </para>
      <para>
	Debes de ter en conta a seguinte cuestión en relación á definición dunha
	mostra en base a unha variable ficticia, a unha expresión booleana ou ao
	criterio de valores ausentes. Calquera información <quote>estrutural</quote>
	no ficheiro cabeceira dos datos pérdese (en relación á temporalidade das series
	ou á natureza de panel dos datos). Pero podes volver forzar a estrutura co
	elemento <quote>Estrutura do conxunto de datos</quote> do menú de Datos.
      </para>
      <para>
	Consulta o <guideref targ="chap:sampling"/> para obter outros detalles.
      </para>
    </description>
  </command>

  <command name="save-labels" section="Utilities"
    label="Gardar ou eliminar etiquetas das series" context="gui">
    <description>
      <para>
	Se escolles aquí 'Exportar', GRETL escribe un ficheiro que contén as
	etiquetas descritivas de calquera serie (que teña etiquetas) do
	conxunto vixente de datos. Ese ficheiro é de texto plano cunha liña
	por variable, pero a liña estará baleira para as variables que non
	teñan etiqueta descritiva.
      </para>
      <para>
	Cando escolles 'Borrar', elimínanse as etiquetas descritivas de todas
	as series que teñan etiquetas. Isto unicamente será oportuno no caso
	de que as etiquetas actuais se engadiran dalgún xeito debido a un
	fallo.
      </para>
    </description>
  </command>

  <command name="add-labels" section="Utilities"
    label="Engadir etiquetas das series" context="gui">
    <description>
      <para>
	Se aquí escolles a opción 'Si', se te ofrece unha caixa de diálogo para
	abrir ficheiros, co fin de que selecciones un de texto plano que conteña
	as etiquetas descritivas para as series do conxunto vixente de datos. O
	ficheiro deberá de conter unha etiqueta por liña, e unha liña en branco
	significará que non hai etiqueta. GRETL tratará de ler tantas etiquetas
	como series haxa no conxunto de datos, excluíndo a constante.
      </para>
    </description>
  </command>

  <command name="save-script" section="Utilities"
    label="Gardar instrucións?" context="gui">
    <description>
      <para>
	Se aquí escolles 'Si', GRETL escribe un ficheiro que contén un rexistro
	das instrucións que executaches na sesión vixente. A meirande parte das
	instrucións que executas mediante <quote>apuntar e facer clic</quote>
	teñen unha contrapartida de <quote>guión</quote>, e estas instrucións
	de guión son as que se gardarán. Así poderás coller o ficheiro como base
	para escribir un guión de instrucións de GRETL.
      </para>
      <para>
	Se non che importa que se te avise para gardar un rexistro das instrucións
	ao saír, non poñas a marca na caixa do diálogo para gardar instrucións.
      </para>
    </description>
  </command>

  <command name="save-session" section="Utilities"
    label="Gardar esta sesión de GRETL?" context="gui">
    <description>
      <para>
	Se aquí escolles 'Si', GRETL escribe un ficheiro que contén unha
	<quote>foto instantánea</quote> da sesión vixente, incluíndo unha copia
	do conxunto de datos co que se traballa, xunto con calquera modelo, gráfica
	ou outro obxecto que gardaras <quote>como icona</quote>. Podes volver abrir este
	ficheiro máis tarde para recrear o estado de GRETL tal como era no momento no que
	saíches da sesión (consulta o menú <quote>Ficheiro/Ficheiros de sesión</quote>).
      </para>
      <para>
	Se traballas con GRETL utilizando a maioría das veces guións de
	instrucións (o que se recomenda para un traballo econométrico
	<quote>serio</quote>), probablemente non necesites gardar a
	sesión, pero debes de asegurarte de gardar calquera cambio no
	teu guión, que queiras manter. Tamén podes querer gardar calquera
	cambio no teu conxunto de datos, agás que sexa dun tipo que podas
	repetir doadamente executando un guión.
      </para>
      <para>
	Se traballas con guións e non che importa que se te avise para
	gardar a túa sesión ao saír, non poñas a marca na caixa do
	diálogo para gardar sesión.
      </para>
    </description>
  </command>

  <command name="scatters" section="Graphs"
    label="Varias gráficas de dúas variables">

    <usage>
      <arguments>
        <argument>yvar</argument>
        <argument separated="true">xvars</argument>
	      <argument alternate="true">yvars ; xvar</argument>
      </arguments>
      <options>
	<option>
	  <flag>--with-lines</flag>
	  <effect>Xera gráficas de liñas</effect>
	</option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nomematriz</optparm>
	  <effect>Representa as columnas da matriz indicada</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía o resultado ao ficheiro especificado</effect>
        </option>
      </options>
      <examples>
        <example>scatters 1 ; 2 3 4 5</example>
        <example>scatters 1 2 3 4 5 6 ; 7</example>
	<example>scatters y1 y2 y3 ; x --with-lines</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Xera gráficas de dúas variables, ben de <repl>yvar</repl> fronte
	a todas as variables de <repl>xvars</repl>, ou ben de todas as
	variables de <repl>yvars</repl> fronte a <repl>xvar</repl>. No
	primeiro exemplo de arriba, se coloca a variable 1 no eixe
	<math>y</math> e se debuxan 4 gráficas: a primeira ten a
	variable 2 no eixe <math>x</math>, a segunda coa variable 3 no
	eixe <math>x</math>, etcétera. O segundo exemplo representa
	cada unha das variables da 1 á 6, fronte á variable 7 no eixe
	<math>x</math>. Repasar un conxunto desas gráficas pode ser
	un paso conveniente na análise exploratoria de datos. O número
	máximo de gráficas é de 16, polo que vaise ignorar calquera
	variable adicional na lista.
      </para>
      <para context="cli">
	Por defecto, os datos amósanse con puntos, pero se indicas a
	opción <opt>with-lines</opt> serán gráficas de liñas.
      </para>
      <para context="cli">
	Para obter máis detalles sobre o uso da opción <opt>output</opt>,
	consulta a instrución <cmdref targ="gnuplot"/>.
      </para>
      <para context="cli">
	Se especificas unha matriz xa definida como orixe dos datos, debes
	expresar as listas <repl>x</repl> e <repl>y</repl> con números naturais
	positivos para indicar a columna. En caso contrario, se non indicas esas
	listas, represéntanse todas as columnas fronte ao tempo ou a unha variable índice.
      </para>
      <para context="gui">
	Xera gráficas de dúas variables, da <quote>Variable do eixe Y</quote>
	escollida, fronte a cada unha das <quote>Variables do eixe X</quote>
	escollidas, unha por unha. (Ou podes escoller varias variables para
	o eixe Y e unha para o eixe X.) Repasar un conxunto desas gráficas
	pode ser un paso conveniente na análise exploratoria de datos. O
	número máximo de gráficas é de 16, polo que vaise ignorar calquera
	variable adicional na lista.
      </para>
      <para context="gui">
	Por defecto, os datos amósanse con puntos, pero se indicas a
	opción <quote>Usar liñas</quote> serán gráficas de liñas.
      </para>
      <para>
	Consulta tamén a instrución <cmdref targ="tsplots"/> para ver un
	xeito sinxelo de xerar gráficas múltiples de series temporais, e a
	instrución <cmdref targ="gridplot"/> para ver un modo máis flexible
	de combinar gráficas nunha grella.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Gráficas múltiples/Gráficas X-Y (scatters)</menu-path>
    </gui-access>

  </command>

  <command name="script-editor" section="Utilities" context="gui"
    label="Preferencias do editor de guións">

    <description>
      <para>
	Cae na conta de que algunhas destas preferencias só se aplican cando
	se editan guións de GRETL orixinais (Tabulador e Intro espelidos, Usar
	lapelas no editor de guións), e que outras tamén se aplican cando se edita
	ou mira calquera guión (Amosar os números de liña, Estilo de resalte).
      </para>
      <para>
	<emphasis>Tabulador e Intro espelidos</emphasis>: Se marcas
	esta opción, entón cando premes a tecla <lit>Tabulador</lit> ao
	comezo dunha liña nun guión de HANSL, en troques de introducir tan
	só un salto de tabulación, o programa vai tratar de axustar o
	nivel de sangrado da liña consistentemente con outras liñas que
	xa se introduciran antes. Igualmente, cando premes a tecla
	<lit>Intro</lit>, o programa vai tratar de asegurar que o sangrado
	da liña completada é correcta.
      </para>
      <para>
	<emphasis>Amosar os números de liña</emphasis>: Presenta os
	números de liña na marxe esquerda do editor de guións ou do visor.
      </para>
      <para>
	<emphasis>Usar lapelas no editor de guións</emphasis>: Afecta
	ao comportamento do programa cando esteas editando máis dun
	guión ao mesmo tempo. Se marcas isto, entón amósase cada guión
	nunha <quote>lapela</quote> dunha xanela con estilo de caderno
	de notas; e se non, cada guión ten a súa propia xanela.
      </para>
      <para>
	<emphasis>Habilitar autorecheo</emphasis>: Se está dispoñible esta
	opción e marcas o cadriño, se te ofrecerá a posibilidade de completar
	a palabra que esteas tecleando, ben mentres escribes ou ben en
	resposta á tecla de tabulación. Para escoller unha das posibilidades,
	utiliza as teclas de frechas arriba/abaixo e de tabulación; ou
	simplemente segue tecleando para descartar os termos suxeridos.
      </para>
      <para>
	<emphasis>Habilitar autocorchetes</emphasis>: Se marcas isto,
	entón cando tecleas unha paréntese, corchete ou chave esquerdos
	ao final dunha liña, vaise engadir automaticamente o delimitador
	correspondente do lado dereito, e vaise colocar o cursor entre os
	dous delimitadores.
      </para>
      <para>
	<emphasis>Número de espazos por tabulador</emphasis>: Canto queres
	que sexa de longo un salto de tabulador ou o nivel de sangría? Un
	valor enteiro de 2 a 8.
      </para>
      <para>
	<emphasis>Estilo de resalte</emphasis>: Proporciona unha lista que
	se desprega cara abaixo, con estilos para resaltar a sintaxe. Algúns
	destes son 'escuro sobre claro' e algúns son 'claro sobre escuro':
	experimenta e atopa o que che guste.
      </para>
    </description>

  </command>

  <command name="sdiff" section="Transformations"
    label="Calcular diferenzas estacionais" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Obtense a diferenza estacional de cada unha das variables de
	<repl>listavariables</repl>, e gárdase o resultado nunha nova variable
	co prefixo <lit>sd_</lit>. Esta instrución está dispoñible só para
	series de tempo estacionais.
      </para>
    </description>

    <gui-access>
      <menu-path>/Engadir/Diferenzas estacionais das variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="set" section="Programming"
    label="Establecer os parámetros do programa" context="cli">

    <usage>
      <altforms>
	<altform><lit>set</lit> <repl>variable</repl> <repl>valor</repl></altform>
	<altform><lit>set --to-file=</lit><repl>nomeficheiro</repl></altform>
	<altform><lit>set --from-file=</lit><repl>nomeficheiro</repl></altform>
	<altform><lit>set stopwatch</lit></altform>
	<altform><lit>set</lit></altform>
      </altforms>
      <examples>
        <example>set svd on</example>
        <example>set csv_delim tab</example>
	<example>set horizon 10</example>
	<example>set --to-file=mysettings.inp</example>
      </examples>
    </usage>

    <description>
      <para>
	O uso máis común desta instrución é a primeira variante amosada
	arriba, na que se utiliza para establecer o valor dun parámetro
	escollido do programa (isto discútese con detalle máis abaixo).
	Os outros usos son: con <opt>to-file</opt> para escribir un
	ficheiro de guión que conteña todas as configuracións actuais
	dos parámetros; con <opt>from-file</opt> para ler un ficheiro
	de guión que conteña as configuracións dos parámetros e para
	aplicalas á sesión vixente; con <lit>stopwatch</lit> para poñer
	a cero o <quote>cronómetro</quote> de GRETL que podes usar para
	medir o tempo de CPU (consulta os comentarios para o accesorio
	<fncref targ="$stopwatch"/>); ou para presentar as configuracións
	actuais, cando indicas só a palabra <lit>set</lit>.
      </para>
      <para>
	Os valores establecidos mediante esta instrución seguen vixentes
	durante a duración da sesión de GRETL, agás que os troques por
	medio dunha chamada posterior a <cmd>set</cmd>. Os parámetros
	que podes establecer deste xeito enuméranse máis abaixo. Ten en
	conta que se utilizan as configuracións de <lit>hc_version</lit>,
	<lit>hac_lag</lit> e <lit>hac_kernel</lit> cando indicas a opción
	<opt>robust</opt> nunha instrución de estimación.
      </para>
      <para>
	As configuracións dispoñibles agrúpanse baixo as seguintes categorías:
	interacción e comportamento do programa, métodos numéricos, xeración
	de números aleatorios, estimación robusta, filtrado, estimación de
	series temporais e interacción con GNU R.
      </para>

      <subhead>Interacción e comportamento do programa</subhead>

      <para>
	Estas configuracións utilízanse para controlar diversos aspectos
	do xeito no que GRETL interactúa co usuario.
      </para>
      <ilist>
	<li>
	  <para><lit>workdir</lit>: <repl>path</repl>. Establece o cartafol
	  por defecto para escribir e ler ficheiros nos casos nos que non se
	  especifican as rutas completas.
	  </para>
	</li>
	<li>
	  <para><lit>use_cwd</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Manexa a configuración do cartafol de traballo (<lit>workdir</lit>)
	  inicial: se está en <lit>on</lit>, hérdase o cartafol de traballo
	  desde o intérprete; se non, establécese onde queira que se
	  seleccionou na sesión previa de GRETL.
	  </para>
	</li>
	<li>
	  <para><lit>echo</lit>: <lit>off</lit> ou <lit>on</lit> (por defecto).
	  Elimina (ou acurta) a resonancia dos textos das instrucións nos
	  resultados de GRETL.
	  </para>
	</li>
	<li>
	  <para><lit>messages</lit>: <lit>off</lit> ou <lit>on</lit> (por defecto).
	  Elimina (ou acurta) a presentación de mensaxes sen fallo asociados
	  a diversas instrucións, por exemplo cando se xera unha nova variable
	  ou cando se cambia o rango da mostra.
	  </para>
	</li>
	<li>
	  <para><lit>verbose</lit>: <lit>off</lit>, <lit>on</lit> (por defecto) ou
	  <lit>comments</lit>. Funciona como un <quote>interruptor mestre</quote>
	  para <lit>echo</lit> e <lit>messages</lit> (mira máis abaixo),
	  apagando ou acendendo os dous simultaneamente. O argumento
	  <lit>comments</lit> apaga a resonancia e a aparición de mensaxes,
	  pero mantén a presentación de comentarios dun guión.
	  </para>
	</li>
	<li>
	  <para><lit>warnings</lit>: <lit>off</lit> ou <lit>on</lit> (por defecto).
	  Elimina (ou acurta) a presentación de mensaxes de advertencia cando
	  xorden problemas numéricos; por exemplo, se un cálculo produce
	  valores non finitos ou se a converxencia dun proceso de optimización
	  é cuestionable.
	  </para>
	</li>
	<li>
	  <para><lit>csv_delim</lit>: <lit>comma</lit> (coma, por defecto), <lit>space</lit> (espazo),
	  <lit>tab</lit> (tabulación) ou <lit>semicolon</lit> (punto e coma). Establece o delimitador
	  de columnas que se usa cando se gardan datos nun ficheiro con formato CSV.
	  </para>
	</li>
	<li>
	  <para><lit>csv_write_na</lit>: A cadea de texto que se utiliza para
	  representar os valores ausentes cando se escriben datos nun ficheiro
	  con formato CSV. Máximo = 7 caracteres; por defecto é <lit>NA</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>csv_read_na</lit>: A cadea de texto que se colle para
	  representar valores ausentes (NAs) cando se len datos co formato CSV
	  (máximo 7 caracteres). A cadea por defecto depende de que se atope
	  unha columna de datos que conteña datos numéricos (a maioría das
	  veces) ou valores de cadea. Para datos numéricos, considérase que o
	  seguinte indica NAs: unha cela baldeira ou calquera das cadeas
	  <lit>NA</lit>, <lit>N.A.</lit>, <lit>na</lit>,
	  <lit>n.a.</lit>, <lit>N/A</lit>, <lit>#N/A</lit>,
	  <lit>NaN</lit>, <lit>.NaN</lit>, <lit>.</lit>,
	  <lit>..</lit>, <lit>-999</lit>, e <lit>-9999</lit>. Para datos con
	  forma de cadeas de texto con valores, tan só se conta como NA unha
	  cela en branco ou unha cela que conteña unha cadea baldeira. Podes
	  volver a impoñer eses valores por defecto indicando <lit>default</lit>
	  como o valor de <lit>csv_read_na</lit>. Para especificar que tan
	  só se len as celas baldeiras como NAs, indica o valor <lit>""</lit>.
	  Ten en conta que as celas baldeiras sempre se len como NAs con
	  independencia de como estea configurada esta variable.
	  </para>
	</li>
	<li>
	  <para><lit>csv_digits</lit>: Un enteiro positivo que especifica o
	  número de díxitos significativos a usar cando se escriben datos en
	  formato CSV. Por defecto, utilízanse ata 15 díxitos dependendo da
	  precisión dos datos orixinais. Ten en conta que o resultado CSV
	  emprega a función <lit>fprintf</lit> da librería de C coa conversión
	  <quote><lit>%g</lit></quote> , o que significa que se prescinde
	  dos ceros que quedan atrás.
	  </para>
	</li>
	<li>
	  <para><lit>display_digits</lit>: Un enteiro de 3 a 6 que especifica
	  o número de díxitos significativos a usar cando se amosan os
	  coeficientes da regresión e os desvíos padrón (sendo 6
	  por defecto). Tamén podes utilizar esta configuración para
	  limitar o número de díxitos que se amosan coa instrución
	  <cmdref targ="summary"/>; sendo neste caso 5 por defecto (e
	  tamén o máximo).
	  </para>
	</li>
	<li>
	  <para><lit>mwrite_g</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Cando se escribe unha matriz como texto nun ficheiro, GRETL
	  por defecto utiliza notación científica con 18 díxitos de
	  precisión, asegurando deste xeito que os valores gardados
	  son unha representación fiable dos números en memoria.
	  Cando se escriben datos básicos con non máis ca 6 díxitos
	  de precisión, podes preferir utilizar o formato <lit>%g</lit>
	  para ter un ficheiro máis compacto e doado de ler; podes
	  facer este cambio mediante <lit>set mwrite_g on</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>force_decpoint</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Forza a GRETL a utilizar o carácter de punto decimal, nun
	  escenario onde outro carácter (probablemente a coma) é o
	  separador decimal estándar.
	  </para>
	</li>
	<li>
	  <para><lit>loop_maxiter</lit>: Un valor enteiro non negativo
	  (por defecto é 100000). Establece o número máximo de iteracións
	  que se lle permite a un bucle <lit>while</lit>, antes de parar
	  (consulta <cmdref targ="loop"/>). Cae na conta de que esta
	  configuración só afecta á variante <lit>while</lit>; a súa
	  intención é protexerse ante infinitos bucles que xurdan de
	  forma inadvertida. Establecer que este valor sexa 0 ten o
	  efecto de inhabilitar o límite (utilízao con precaución).
	  </para>
	</li>
	<li>
	  <para><lit>max_verbose</lit>: <lit>off</lit> (por defecto),
	  <lit>on</lit> ou <lit>full</lit>. Controla a verborrea das instrucións
	  e das funcións que utilizan métodos de optimización numérica.
	  A opción <lit>on</lit> só se aplica a funcións (tales como
	  <fncref targ="BFGSmax"/> e <fncref targ="NRmax"/>) que funcionan
	  por defecto con discreción; o seu efecto consiste en que se amosa
	  información básica sobre as iteracións. Podes usar a opción
	  <lit>full</lit> para provocar un resultado máis detallado, que
	  inclúe os valores dos parámetros e o seu respectivo gradiente da
	  función obxectivo, en cada iteración. Esta opción aplícase tanto
	  ás funcións do tipo mencionado antes, como ás instrucións que se
	  basean en optimización numérica como <cmdref targ="arima"/>,
	  <cmdref targ="probit"/> e <cmdref targ="mle"/>. No caso das
	  instrucións, o seu efecto consiste en facer que a súa opción
	  <opt>verbose</opt> proporcione un maior detalle. Consulta
	  tamén o <guideref targ="chap:numerical"/>.
	</para>
	</li>
	<li>
	  <para><lit>debug</lit>: <lit>1</lit>, <lit>2</lit> ou <lit>0</lit> (por defecto).
	  Isto utilízase coas funcións definidas polo usuario. Establecer
	  <lit>debug</lit> igual a 1 equivale a activar <lit>messages</lit>
	  dentro de todas esas funcións, e establecer esta variable igual a
	  <lit>2</lit> ten o efecto adicional de activar <lit>max_verbose</lit>
	  dentro de todas as funcións.
	  </para>
	</li>
	<li>
	  <para><lit>shell_ok</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Permite executar programas externos desde GRETL mediante o
	  intérprete de sistema. Isto non está habilitado por defecto
	  por razóns de seguridade, e só podes habilitalo mediante a
	  Interface Gráfica de Usuario (Ferramentas/Preferencias/Xeral).
	  Porén, unha vez activada, esta configuración permanecerá activa
	  para sesións futuras ata que se desactive explicitamente.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_verbskip</lit>: Un enteiro. Esta configuración
	  afecta ao comportamento da opción <opt>verbose</opt> naquelas
	  instrucións que utilizan BFGS como algoritmo de optimización, e se
	  usa para compactar o resultado. Se <lit>bfgs_verbskip</lit> se
	  establece en 3, por exemplo, entón a opción <opt>verbose</opt>
	  vai provocar que se presenten as iteracións 3, 6, 9, etcétera.
	  </para>
	</li>
	<li>
	  <para><lit>skip_missing</lit>: <lit>on</lit> (por defecto)
	  ou <lit>off</lit>. Controla o comportamento de GRETL cando
	  se constrúe unha matriz a partir de series de datos: por
	  defecto sáltanse as filas de datos que conteñen un ou máis
	  valores ausentes, pero cando se pon <lit>skip_missing</lit>
	  en <lit>off</lit>, os valores ausentes convértense en NaNs.
	  </para>
	</li>
	<li>
	  <para><lit>matrix_mask</lit>: O nome dunha serie ou a
	  palabra chave <lit>null</lit>. Ofrece un maior control ca
	  <lit>skip_missing</lit> cando se constrúen matrices a partir
	  de series: as filas de datos seleccionadas para as matrices
	  son aquelas con valores non nulos (e non ausentes) das series
	  especificadas. A careta escollida permanece en vigor ata que se
	  substitúe, ou se elimina mediante a palabra chave <lit>null</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>quantile_type</lit>: Debes escoller entre <lit>Q6</lit> (por
	  defecto), <lit>Q7</lit> ou <lit>Q8</lit>. Selecciona o método concreto
	  que utiliza a función <fncref targ="quantile"/>. Para obter máis
	  detalles, consulta <cite key="hyndman96">Hyndman e Fan (1996)</cite>
	  ou a entrada da Wikipedia dispoñible en
	  <url>https://en.wikipedia.org/wiki/Quantile</url>.
	  </para>
	</li>
	<li>
	  <para><lit>huge</lit>: Un número positivo moi grande (por
	  defecto, 1.0E100). Esta configuración controla o valor que
	  devolve o accesorio <fncref targ="$huge"/>.
	  </para>
	</li>
	<li>
	  <para><lit>assert</lit>: <lit>off</lit> (por defecto), <lit>warn</lit>
	  ou <lit>stop</lit>. Controla as consecuencias dun fallo
	  (que o valor que se devolva sexa igual a 0) da función
	  <fncref targ="assert"/>.
	  </para>
	</li>
	<li>
	  <para><lit>datacols</lit>: Un número enteiro entre 1 e 15, cuxo valor
	  por defecto é 5. Establece o número máximo de series que se presentan
	  conxuntamente cando os datos se representan por observación.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>plot_collection</lit>: <lit>on</lit>, <lit>auto</lit> ou <lit>off</lit>.
	  Esta configuración afecta ao xeito no que se amosan as gráficas durante
	  o uso interactivo. Se está en <lit>on</lit>, as gráficas do mesmo tamaño
	  en pixels reúnense nunha <quote>colección de gráficas</quote>, é dicir,
	  nunha única xanela de saída de resultados na que podes navegar entre
	  as diversas gráficas indo cara adiante e cara atrás. Co axuste en
	  <lit>off</lit>, pola contra vaise xerar unha xanela distinta para cada
	  gráfica, como nas versións anteriores de GRETL. Finalmente, o axuste
	  en <lit>auto</lit> ten como efecto que permite o modo de colección de
	  gráficas só para as gráficas que se xeran antes de que pasen 1.25
	  segundos despois de outra (por exemplo, como resultado da execución
	  de instrucións de representación gráfica dentro dun bucle).
	  </para>
	</li>
      </ilist>

      <subhead>Métodos numéricos</subhead>

      <para>
	Estas configuracións utilízanse para controlar os algoritmos
	numéricos que utiliza GRETL para a estimación.
	</para>
      <ilist>
	<li>
	  <para><lit>optimizer</lit>: ou <lit>auto</lit> (por defecto), ou
	  <lit>BFGS</lit>, ou ben <lit>newton</lit>. Establece o algoritmo de
	  optimización que se utiliza para varios estimadores Máximo Verosímiles,
	  nos casos onde o BFGS e o de Newton&ndash;Raphson se poden
	  aplicar ambos. Por defecto, utilízase o de Newton&ndash;Raphson
	  cando se dispoña dunha matriz Hessiana analítica; se non, BFGS.
	  </para>
	</li>
	<li>
	  <para><lit>bhhh_maxiter</lit>: Un enteiro, o número máximo de
	  iteracións para a rutina interna BHHH de GRETL, que se utiliza na
	  instrución <cmd>arma</cmd> para a estimación MV condicional.
	  Se a converxencia non se acada logo de <lit>bhhh_maxiter</lit>,
	  o programa devolve un fallo. Por defecto, establécese en 500.
	  </para>
	</li>
	<li>
	  <para><lit>bhhh_toler</lit>: Un valor de punto flotante ou a
	  cadea <lit>default</lit>. Isto utilízase na rutina interna
	  BHHH de GRETL para verificar se a converxencia se acadou.
	  O algoritmo remata de repetirse tan pronto como o incremento
	  no logaritmo da verosimilitude entre iteracións sexa menor ca
	  <lit>bhhh_toler</lit>. O valor por defecto é 1.0E&minus;06,
	  e podes restablecer este valor tecleando
	  <lit>default</lit> en troques dun valor numérico.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_maxiter</lit>: Un enteiro, o número máximo de
	  iteracións para a rutina BFGS de GRETL, que se utiliza para
	  <cmd>mle</cmd> (EMV), <cmd>gmm</cmd> (MGM) e varios
	  estimadores específicos. Se non se acada a converxencia no
	  número indicado de iteracións, o programa devolve un fallo.
	  O valor por defecto depende do contexto, pero habitualmente
	  é da orde de 500.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_toler</lit>: Un valor de punto flotante ou a
	  cadea <lit>default</lit>. Isto utilízase na rutina interna BFGS
	  de GRETL para verificar se a converxencia se acadou. O
	  algoritmo remata de repetirse tan pronto como a melloría
	  relativa na función obxectivo entre iteracións sexa menor ca
	  <lit>bfgs_toler</lit>. O valor por defecto é igual á precisión
	  de máquina elevada a 3/4, e podes restablecer este
	  valor tecleando <lit>default</lit> en lugar dun valor numérico.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_maxgrad</lit>: Un valor de punto flotante. Isto
	  utilízase na rutina interna BFGS de GRETL, para verificar se a norma
	  do vector gradiente está razoablemente preto de cero cando se
	  acada o criterio <lit>bfgs_toler</lit>. Vaise presentar unha
	  advertencia cando a norma do vector gradiente exceda de 1; e
	  amósase un fallo se a norma excede <lit>bfgs_maxgrad</lit>.
	  Actualmente, por defecto o valor de tolerancia é de 5.0.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_richardson</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Utiliza a extrapolación de Richardson cando calcules as
	  derivadas numéricas no contexto da maximización
	  BFGS.
	  </para>
	</li>
	<li>
	  <para><lit>initvals</lit>: O nome dunha matriz que fose definida
	  previamente. Permite establecer manualmente o vector inicial de
	  parámetros en determinadas instrucións de estimación que implican
	  realizar optimización numérica como <lit>arma</lit>, <lit>garch</lit>,
	  <lit>logit</lit>, <lit>probit</lit>, <lit>tobit</lit>, <lit>intreg</lit>,
	  <lit>biprobit</lit>, <lit>duration</lit>; e tamén cando se impoñen
	  certos tipos de restricións que están vencelladas a modelos VEC.
	  A diferenza doutras configuracións, <lit>initvals</lit> non é
	  persistente, pois se restablece o seu valor ao de inicio por
	  defecto, despois da súa primeira utilización. Para obter
	  detalles en relación coa estimación ARMA consulta
	  <guideref targ="chap:timeseries"/>.
	  </para>
	</li>
	<li>
	  <para><lit>lbfgs</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Utiliza a versión de memoria limitada de BFGS (L-BFGS-B)
	  en troques do algoritmo habitual. Isto pode ser vantaxoso cando
	  a función que se maximiza non é globalmente cóncava.
	  </para>
	</li>
	<li>
	  <para><lit>lbfgs_mem</lit>: Un valor enteiro no rango de
	  3 a 20 (cun valor por defecto de 8). Isto determina o número
	  de correccións que se utilizan na matriz de memoria limitada
	  cando se emprega L-BFGS-B.
	  </para>
	</li>
	<li>
	<para>
	  <lit>nls_toler</lit>: Un valor de punto flotante. Establece a
	  tolerancia que se utiliza ao xulgar se a converxencia se acada
	  ou non, nunha estimación de mínimos cadrados non lineais
	  utilizando a instrución <cmdref targ="nls"/>. O valor por
	  defecto é igual á precisión de máquina elevada a 3/4, e
	  podes restablecer este valor tecleando <lit>default</lit>
	  en lugar dun valor numérico.
	</para>
	</li>
	<li>
	  <para>
	  <lit>svd</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Utiliza a Descompisición en Valores Singulares (SVD) en troques das
	  descomposicións de Cholesky ou a QR, nos cálculos de mínimos cadrados.
	  Esta opción aplícase á función <lit>mols</lit> así como a varios
	  cálculos internos, pero non á instrución <cmdref targ="ols"/> habitual.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>force_qr</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Isto aplícase á instrución <cmdref targ="ols"/>. Por defecto,
	  esta instrución calcula as estimacións de MCO utilizando a
	  descomposición de Cholesky (o método máis rápido), con QR
	  como último recurso se os datos semellan demasiado mal
	  condicionados. Podes utilizar <lit>force_qr</lit> para saltarte
	  o paso de Cholesky, pois nos casos <quote>dubidosos</quote>
	  isto pode asegurar unha maior precisión.
	  </para>
	</li>
	<li>
	  <para><lit>fcp</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Utiliza o algoritmo de Fiorentini, Calzolari e Panattoni en vez do
	  código propio de GRETL, cando se calculan as estimacións GARCH.
	  </para>
	</li>
	<li>
	  <para><lit>gmm_maxiter</lit>: Un enteiro, o número máximo de
	  iteracións da instrución <cmdref targ="gmm"/> de GRETL cando
	  se está en modo iterativo (en contraposición ao dun paso ou
	  ao de dous pasos). O valor por defecto é 250.
	  </para>
	</li>
	<li>
	  <para><lit>nadarwat_trim</lit>: Un enteiro, o parámetro de
	  recorte utilizado na función <fncref targ="nadarwat"/>.
	  </para>
	</li>
	<li>
	  <para><lit>fdjac_quality</lit>: Un enteiro (0, 1 ou 2) que indica
	  o algoritmo utilizado pola función <fncref targ="fdjac"/>; por
	  defecto é 0.
	  </para>
	</li>
	<li>
	  <para><lit>gmp_bits</lit>: Un enteiro, que debe ser unha potencia
	  de 2 con expoñente enteiro (o valor predeterminado e mínimo é 256,
	  e o máximo é 8192). Isto controla o número de bits que se utilizan
	  para representar un número de punto flotante cando se invoca a GMP
	  (a Biblioteca da Aritmética de Precisión Múltiple de GNU), principalmente
	  por medio da instrución <lit>mpols</lit>. Os valores máis grandes
	  dese enteiro proporcionan maior precisión ao custo dun maior tempo
	  de cálculo. Esta configuración tamén se pode controlar mediante a
	  variable de entorno <lit>GRETL_MP_BITS</lit>.
	  </para>
	</li>
      </ilist>

      <subhead>Xénese de números aleatorios</subhead>

      <ilist>
	<li>
	  <para><lit>seed</lit>: Un número natural positivo ou a palabra chave
	  <lit>auto</lit>. Establece a semente para o xerador de números
	  pseudoaleatorios. Por defecto, isto establécese a partir do tempo
	  do sistema; pero se queres xerar secuencias repetibles de números
	  aleatorios debes de establecer a semente manualmente. Para restablecer
	  a semente a un valor automático baseado no tempo, usa <lit>auto</lit>.
	  </para>
	</li>
      </ilist>

      <subhead>Estimación robusta</subhead>

      <ilist>
	<li>
	  <para><lit>bootrep</lit>: Un enteiro. Establece o número de
	  repeticións da instrución <cmdref targ="restrict"/> coa opción
	  <opt>bootstrap</opt>.
	  </para>
	</li>
	<li>
	  <para><lit>garch_vcv</lit>: <lit>unset</lit>, <lit>hessian</lit>,
	  <lit>im</lit> (matriz de información), <lit>op</lit> (matriz de
	  produto externo), <lit>qml</lit> (estimador CMV ou QML), ou <lit>bw</lit>
	  (Bollerslev&ndash;Wooldridge). Especifica a variante que se vai
	  utilizar para estimar a matriz de covarianzas dos coeficientes para
	  modelos GARCH. Cando indicas <lit>unset</lit> (caso por defecto)
	  entón utilízase a matriz Hessiana, agás que se indique a opción
	  <quote>robust</quote> para a instrución garch, en cuxo caso
	  utilízase CMV (QML).
	  </para>
	</li>
	<li>
	  <para><lit>arma_vcv</lit>: <lit>hessian</lit> (caso por defecto)
	  ou <lit>op</lit> (matriz de produto externo). Especifica a variante
	  que se vai utilizar cando se calcula a matriz de covarianzas para
	  modelos ARIMA.
	  </para>
	</li>
	<li>
	  <para><lit>force_hc</lit>: <lit>off</lit> (por defecto) ou <lit>on</lit>.
	  Por defecto, con datos de series temporais e cando indicas a
	  opción<opt>robust</opt> con <lit>ols</lit> (MCO), utilízase o
	  estimador HAC. Se pos <lit>force_hc</lit> en <quote>on</quote>,
	  isto forza o cálculo da Matriz de Covarianzas Consistente ante
	  Heterocedasticidade (HCCM) habitual, que non ten en conta a
	  autocorrelación. Cae na conta de que os VARs trátanse como
	  un caso especial, pois cando indicas a opción <opt>robust</opt>
	  o método por defecto é o da HCCM habitual, pero podes utilizar
	  a opción <opt>robust-hac</opt> para forzar que se empregue un
	  estimador HAC.
	  </para>
	</li>
	<li>
	  <para><lit>robust_z</lit>: <lit>off</lit> (por defecto) ou <lit>on</lit>.
	  Isto controla a distribución que se utiliza cando se calculan as
	  probabilidades asociadas (valores p) baseadas nos desvíos
	  padrón robustos, no contexto dos estimadores de mínimos cadrados.
	  Por defecto, GRETL utiliza a distribución <math>t</math> de Student
	  pero se activas <lit>robust_z</lit>, utilízase unha distribución
	  Normal.
	  </para>
	</li>
	<li>
	  <para><lit>hac_lag</lit>: <lit>nw1</lit> (por defecto), <lit>nw2</lit>,
	  <lit>nw3</lit> ou un enteiro. Establece o valor do retardo máximo
	  ou largo de banda (<math>p</math>) utilizado cando se calculan
	  os desvíos padrón HAC (Consistentes ante Heterocedasticidade
	  e Autocorrelación) utilizando o enfoque de Newey-West, para datos
	  de series temporais. As opcións <lit>nw1</lit> e <lit>nw2</lit>
	  representan dúas variantes de cálculo automático baseadas no
	  tamaño da mostra <math>T</math>: para nw1,
	  <equation status="inline"
	    tex="$p = 0.75 \times T^{1/3}$"
	    ascii="p = 0.75 * T^(1/3)"
	    graphic="nw1"/>, e para nw2,
	  <equation status="inline"
	    tex="$p = 4 \times (T/100)^{2/9}$"
	    ascii="p = 4 * (T/100)^(2/9)"
	    graphic="nw2"/>. A <lit>nw3</lit>
	  solicita unha elección do largo de banda que se basea nos datos. Consulta
	  tamén máis abaixo <lit>qs_bandwidth</lit> e <lit>hac_prewhiten</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>hac_kernel</lit>: <lit>bartlett</lit> (por defecto),
	  <lit>parzen</lit> ou <lit>qs</lit> (Espectral cadrado). Establece
	  o 'kernel', ou padrón de ponderacións, que se utiliza cando se
	  calculan os desvíos padrón HAC.
	  </para>
	</li>
	<li>
	  <para><lit>hac_prewhiten</lit>: <lit>on</lit> ou <lit>off</lit> (por defecto).
	  Utiliza o 'branqueo' previo e a 'volta a colorear' de Andrews-Monahan
	  cando se calculan os desvíos padrón HAC. Isto tamén implica
	  utilizar unha elección do largo de banda que se basea nos datos.
	  </para>
	</li>
	<li>
	  <para><lit>hac_missvals</lit>: <lit>es</lit> (predeterminado),
	  <lit>am</lit> ou <lit>off</lit>. Establece a política a respecto do
	  cálculo dos desvíos padrón HAC cando a mostra utilizada na
	  estimación inclúe observacións incompletas: <lit>es</lit> invoca
	  o método da Mesma Separación (Equal Spacing) de
	  <cite key="datta-du12">Datta e Du (2012)</cite>; <lit>am</lit>
	  selecciona o método da Modulación da Amplitude (Amplitude Modulation)
	  de <cite key="parzen63">Parzen (1963)</cite>; e <lit>off</lit>
	  provoca que GRETL rexeite dita estimación. Para obter máis detalles,
	  consulta o <guideref targ="chap:robust_vcv"/>.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>hc_version</lit>: 0, 1, 2, 3 ou 3a. Establece a variante que se
	  usa ao calcular os Desvíos Padrón Consistentes ante Heterocedasticidade
	  (HC) con datos de sección cruzada. As 4 primeiras opcións se
	  corresponden con HC0, HC1, HC2 e HC3 discutidas por Davidson e
	  MacKinnon no capítulo 5 de <book>Econometric Theory and Methods</book>.
	  HC0 produce os denominados habitualmente como
	  <quote>desvíos padrón de White</quote>. A variante 3a é o procedemento
	  da <quote>navalla</quote> de MacKinnon&ndash;White. A configuración
	  predeterminada habitualmente é 1, pero isto pódese cambiar no
	  cliente GUI, seleccionando a lapela <quote>HCCME</quote> no menú
	  <quote>Ferramentas/Preferencias/Xeral</quote>. Cae na conta de que
	  unha configuración feita mediante GUI persiste ao longo das sesións
	  de GRETL, en oposición ao uso da instrución <lit>set</lit> que
	  unicamente vai afectar á sesión vixente.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>panel_robust</lit>: <lit>arellano</lit> (por defecto),
	  <lit>pcse</lit> ou <lit>scc</lit>. Isto selecciona o estimador da
	  matriz de covarianzas robustas para utilizar cos modelos con
	  datos de panel. Consulta la instrucción <cmdref targ="panel"/> y
	  <guideref targ="chap:robust_vcv"/> para obtener más detalles.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>qs_bandwidth</lit>: Largo de banda para a estimación
	  HAC no caso de que selecciones o kernel Espectral Cadrado (QS).
	  (A diferenza dos 'kernels' de Bartlett e de Parzen, o largo de banda
	  QS non require ser un enteiro.)
	  </para>
	</li>
      </ilist>

      <subhead>Series temporais</subhead>

      <ilist>
	<li>
	  <para>
	  <lit>horizon</lit>: Un enteiro (por defecto baséase na frecuencia
	  dos datos). Establece o horizonte para as respostas ao impulso
	  e as descomposicións da varianza de predición no contexto de
	  autorregresións de vectores.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>vecm_norm</lit>: <lit>phillips</lit> (por defecto),
	  <lit>diag</lit>, <lit>first</lit> ou <lit>none</lit>.
	  Usada no contexto da estimación VECM mediante a instrución
	  <cmdref targ="vecm"/> para identificar os vectores de
	  cointegración. Consulta o <guideref targ="chap:vecm"/>
	  para obter máis detalles.
	  </para>
	</li>
	<li>
	  <para>
    <lit>boot_iters</lit>: Un enteiro, <math>B</math>. Establece o
    número de iteracións 'bootstrap' que se utilizan cando se calculan
    funcións de resposta ao impulso con intervalos de confianza. O
    valor por defecto é 1999. É recomendable que <math>B</math> + 1
    sexa sempre divisible por 100&alpha;/2 de xeito que, por exemplo con
    &alpha; = 0.1, <math>B</math>+1 debería ser múltiplo de 5. O mínimo
    valor aceptable para B é 499.
	  </para>
	</li>
      </ilist>

	    <subhead>Interacción con R</subhead>

      <ilist>
	<li>
	  <para><lit>R_lib</lit>: <lit>on </lit>(por defecto) ou <lit>off</lit>.
	  Cando se envían instrucións para que as execute R, utiliza
	  a biblioteca compartida de R mellor ca o executable de R, se a
	  biblioteca está dispoñible.
	  </para>
	</li>
	<li>
	  <para><lit>R_functions</lit>: <lit>off</lit> (por defecto) ou <lit>on</lit>.
	  Recoñece funcións definidas en R como se foran funcións
	  propias (para iso requírese o prefixo de asignación de
	  nomes <quote><lit>R.</lit></quote>). Consulta o
	  <guideref targ="chap:gretlR"/> para obter máis detalles
	  sobre este elemento e o anterior.
	  </para>
	</li>
      </ilist>

      <subhead>Miscelánea</subhead>

      <ilist>
	<li>
	  <para><lit>mpi_use_smt</lit>: <lit>on</lit> ou ben <lit>off</lit>
	  (por defecto). Este interruptor afecta ao número de procesos
	  que se inician nun bloque <lit>mpi</lit> dentro dun guión. Se
	  o interruptor está en <lit>off</lit>, a cantidade por defecto
	  destes procesos é igual ao número de núcleos físicos da máquina
	  local; se está en <lit>on</lit>, a cantidade por defecto destes
	  procesos é igual ao número máximo de subprocesos, que cadrará
	  co dobre do número de núcleos físicos cando estes podan soportar
	  SMT (Multiproceso Simultáneo, tamén coñecido como Hiperproceso).
	  Isto se aplica unicamente se o usuario non indica o número
	  de procesos, ben de xeito directo ou ben de xeito indirecto
	  (mediante a especificación dun ficheiro <lit>hosts</lit> para
	  utilizar con MPI).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>graph_theme</lit>: unha cadea de texto a escoller entre
	    <lit>altpoints</lit>, <lit>classic</lit>, <lit>dark2</lit>
	    (a vixente por defecto), <lit>ethan</lit>, <lit>iwanthue</lit>
	    ou <lit>sober</lit>. Isto establece o <quote>tema</quote> que
	    se utiliza para as gráficas que xera GRETL. A opción
	    <lit>classic</lit> supón volver ao sinxelo tema que estaba
	    vixente con antelación á versión 2020c de GRETL.
	  </para>
	</li>
      </ilist>

    </description>
  </command>

  <command name="setinfo" section="Dataset" label="Editar os atributos dunha variable">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--description</flag>
	  <optparm>cadea</optparm>
	  <effect>Establece a descrición</effect>
	</option>
	<option>
	  <flag>--graph-name</flag>
	  <optparm>cadea</optparm>
	  <effect>Establece o nome da gráfica</effect>
	</option>
	<option>
	  <flag>--discrete</flag>
	  <effect>Marca a serie como discreta</effect>
	</option>
	<option>
	  <flag>--continuous</flag>
	  <effect>Marca a serie como continua</effect>
	</option>
	<option>
	  <flag>--coded</flag>
	  <effect>Marca como unha codificación</effect>
	</option>
	<option>
	  <flag>--numeric</flag>
	  <effect>Marca como non codificación</effect>
	</option>
	<option>
	  <flag>--midas</flag>
	  <effect>Marca como compoñente de datos de alta frecuencia</effect>
	</option>
      </options>
      <examples>
        <example>setinfo x1 --description="Descrición de x1"</example>
        <example>setinfo y --graph-name="Algunha cadea"</example>
	<example>setinfo z --discrete</example>
      </examples>
    </usage>

    <description context="cli">
      <para>
	Se activas as opcións <opt>description</opt> ou <opt>graph-name</opt>,
	o argumento debe de ser unha única serie; se non, poderá ser
	unha lista de series, en cuxo caso a instrución funciona sobre todos
	os elementos da lista. Esta instrución configura 4 atributos como se
	indica deseguido.
      </para>
      <para>
	Cando indicas a opción <opt>description</opt> seguida dunha
	cadea de texto entre comiñas, esa cadea utilízase para establecer
	a etiqueta descritiva da variable. Esta etiqueta amósase en resposta
	á instrución <cmdref targ="labels"/>, e tamén amósase na xanela
	principal do programa de Interface Gráfica de Usuario (GUI).
      </para>
      <para>
	Cando especificas a opción <opt>graph-name</opt> seguida dunha
	cadea de texto entre comiñas, esa cadea vaise utilizar nas gráficas
	en lugar do nome da variable.
      </para>
      <para>
	Cando indicas un dos dous indicadores de opción <opt>discrete</opt>
	ou <opt>continuous</opt>, o carácter numérico da variable establécese
	en consonancia con iso. Por defecto, trátanse todas as series como
	continuas, entón determinar que unha serie sexa discreta vai afectar
	ao xeito no que se manexa a variable en outras instrucións e
	funcións, como por exemplo con <cmdref targ="freq"/> ou con
	<fncref targ="dummify"/>.
      </para>
      <para>
	Cando indicas algunha das dúas opcións <opt>coded</opt> ou <opt>numeric</opt>,
	o status da serie indicada establécese dacordo con iso. Por defecto,
	trátanse todos os valores numéricos como que teñen sentido coma tales,
	polo menos na acepción habitual; pero establecer que unha serie é
	<lit>coded</lit> quere dicir que os valores numéricos son unha
	codificación arbitraria de características cualitativas.
      </para>
      <para>
	A opción <opt>midas</opt> establece unha indicación que alude a que
	unha determinada serie contén datos dunha frecuencia maior que a
	frecuencia base do conxunto de datos; por exemplo, se o conxunto de
	datos é trimestral, e as series conteñen valores para o mes 1, 2 ou 3
	de cada trimestre. (MIDAS = Mixed Data Sampling.)
      </para>
    </description>

    <description context="gui">

      <para>
	Nesta caixa de diálogo podes:</para>

	<para>* Renomear unha variable (tipo serie).</para>

	    <para>* Engadir ou editar a descrición da variable que aparece ao lado do nome destas, na xanela principal de GRETL.
	    </para>

	    <para>* Engadir ou editar o 'nome a amosar' dunha variable (se a variable
	é unha serie, non un escalar). Esta cadea de texto (de 19 caracteres como
	máximo) amósase en troques do nome da variable, cando esta se representa nunha
	gráfica. Así, por exemplo, podes asociar unha cadea máis comprensible tal como
	'Tipo da letra do tesouro' cunha variable nomeada abreviadamente 'tb3'.
	    </para>

	    <para>* Determinar o método para compactar unha variable (para
	datos de series temporais). Ese método vaise utilizar cando decidas
	reducir a frecuencia do conxunto de datos, ou cando actualices unha
	variable importándoa dun banco de datos onde esa variable ten unha
	frecuencia maior que no conxunto de datos de traballo.
      </para>

	    <para>* Marcar unha variable como discreta (para series que só
	teñen valores enteiros). Isto afecta ao xeito no que se manexa a
	variable cando pides unha gráfica de frecuencias.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Editar atributos</menu-path>
      <other-access>Xanela principal: Menú emerxente</other-access>
    </gui-access>

  </command>

  <command name="setmiss" section="Dataset"
    label="Código de valor ausente">

    <usage>
      <arguments>
        <argument>valor</argument>
        <argument optional="true">listavariables</argument>
      </arguments>
      <examples>
        <example>setmiss -1</example>
        <example>setmiss 100 x2</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Permite que o programa interprete algún valor específico de
	dato numérico (o primeiro parámetro da instrución) como un
	código para <quote>ausente</quote>, no caso de importar datos.
	Cando este valor é o único parámetro (como no primeiro exemplo
	de arriba), esa interpretación vaise aplicar a todas as series
	do conxunto de datos. Cando <repl quote="true">valor</repl> vai
	seguido dunha lista de variables (indicadas por nome ou número),
	a interpretación limítase á(s) variable(s) especificada(s). Así,
	no segundo exemplo, o valor 100 dos datos interprétase como un
	código para <quote>ausente</quote>, pero só para a variable
	<lit>x2</lit>.
      </para>

      <para context="gui">
	Establece un valor numérico que vai interpretarse como 'ausente' ou
	'non aplicable', ben para unha serie de datos en concreto (baixo o
	menú Variable) ou globalmente para todo o conxunto de datos (baixo
	o menú Datos).
	    </para>

      <para context="gui">
	GRETL ten a súa propia codificación interna para os valores ausentes,
	pero ás veces cos datos que se importan púidose empregar un código
	diferente. Por exemplo, se unha serie en concreto está codificada de
	xeito que o valor -1 significa 'non aplicable', podes seleccionar
	'Establecer código de valor ausente' baixo o menú Variable, e
	teclear o valor '-1' (sen comiñas). Entón GRETL lerá os valores -1
	como observacións ausentes.
      </para>

    </description>

    <gui-access>
      <menu-path>/Datos/Establecer código de valor ausente</menu-path>
    </gui-access>

  </command>

  <command name="setobs" section="Dataset" context="cli"
    label="Establecer a frecuencia e a observación de inicio">

    <usage>
      <altforms>
        <altform><lit>setobs</lit> <repl>periodicidade</repl> <repl>obsinicio</repl></altform>
	      <altform><lit>setobs</lit> <repl>varunidades</repl> <repl>vartempo</repl> <lit>--panel-vars</lit></altform>
      </altforms>
      <options>
        <option>
	  <flag>--cross-section</flag>
	  <effect>Interpreta como de sección cruzada</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>Interpreta como serie temporal</effect>
        </option>
        <option>
	  <flag>--special-time-series</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--stacked-cross-section</flag>
	  <effect>Interpreta como datos de panel</effect>
        </option>
        <option>
	  <flag>--stacked-time-series</flag>
	  <effect>Interpreta como datos de panel</effect>
        </option>
        <option>
	  <flag>--panel-vars</flag>
	  <effect>Utiliza variables índice, mira abaixo</effect>
        </option>
        <option>
	  <flag>--panel-time</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--panel-groups</flag>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
      <examples>
        <example>setobs 4 1990:1 --time-series</example>
        <example>setobs 12 1978:03</example>
	<example>setobs 1 1 --cross-section</example>
        <example>setobs 20 1:1 --stacked-time-series</example>
	<example>setobs unit year --panel-vars</example>
      </examples>
    </usage>

    <description>
      <para>
	Esta instrución forza ao programa a interpretar que o conxunto
	de datos ten unha estrutura específica.
      </para>
      <para>
	Na primeira forma da instrución, debes de indicar a <repl>periodicidade</repl>
	mediante un enteiro que represente a frecuencia no caso de que os datos
	sexan series temporais (1 = anuais; 4 = trimestrais; 12 = mensuais;
	52 = semanais; 5, 6, ou 7 = diarios; 24 = horarios). No caso de datos de
	panel, a periodicidade indica o número de liñas por bloque de datos; polo
	tanto, isto expresa ou ben o número de unidades consecutivas cando indicas que
	son 'seccións cruzadas amontoadas', ou ben o número de períodos de tempo
	consecutivos cando indicas 'series de tempo amontoadas'. No caso de datos
	simples de sección cruzada, a periodicidade debe de establecerse en 1.
      </para>
      <para>
	A observación de inicio representa a data inicial, no caso de tratarse de
	datos de series temporais. Podes indicar os anos mediante 2 ou 4 díxitos;
	e debes de separar os subperíodos (por exemplo, trimestres ou meses) do
	ano mediante dous puntos. No caso de datos de panel, debes de indicar
	a observación inicial como 1:1, e no caso de datos de sección cruzada,
	como 1. Debes de indicar as observacións iniciais para datos diarios ou
	semanais co formato YYYY-MM-DD (ou simplemente como 1 para datos
	sen datar).
      </para>
      <para>
	Algunhas periodicidades de series temporais teñen interpretacións
	estándar (por exemplo, 12 = mensuais e 4 = trimestrais). Pero se
	tes datos de series temporais pouco habituais para as que non se
	aplica a interpretación estándar, podes sinalar isto indicando a
	opción <opt>special-time-series</opt>. Nese caso, GRETL non vai
	advertir de que os teus datos de (por exemplo) frecuencia igual
	a 12, sexan mensuais.
      </para>
      <para>
	Cando non seleccionas un indicador de opción explícito para determinar a
	estrutura dos datos, o programa vai tratar de adiviñar a estrutura a partir
	da información proporcionada.
      </para>
      <para>
	A segunda forma da instrución (que require que indiques a opción
	<opt>panel-vars</opt>) pode utilizarse para impoñer unha interpretación de
	panel, cando o conxunto de datos contén variables que identifican de forma
	inequívoca as unidades de sección cruzada e os períodos de tempo. O conxunto
	de datos vaise ordenar como series de tempo amontoadas, en función dos
	valores ascendentes da variable de unidades (<repl>varunidades</repl>).
      </para>
      <subhead>Opcións específicas de Panel</subhead>
      <para>
	Podes usar opcións <opt>panel-time</opt> e <opt>panel-groups</opt>
	unicamente cun conxunto de datos que xa foi definido previamente como
	un panel.
      </para>
      <para>
	A intención da opción <opt>panel-time</opt> é determinar información
	adicional relacionada coa dimensión temporal do panel. Debes de indicar
	esta seguindo o padrón do primeiro formato de <lit>setobs</lit> apuntado
	máis arriba. Por exemplo, podes utilizar a seguinte forma de indicar
	que a dimensión temporal dun panel é trimestral, comezando no primeiro
	trimestre de 1990:
      </para>
      <code>
	setobs 4 1990:1 --panel-time
      </code>
      <para>
	A intención da opción <opt>panel-groups</opt> é crear unha serie con
	valores en cadeas de texto, que conteña os nomes dos grupos (individuos,
	unidades atemporais) do panel. (Isto vaise utilizar cando sexa adecuado
	en gráficas de panel.) Con esta opción indicas un ou dous argumentos,
	como se indica deseguido.
      </para>
      <para>
	Primeiro caso: Un único argumento é o nome dunha serie con valores
	en cadeas de texto. Se o número de valores diferentes é igual ao
	número de grupos do panel, esa serie utilízase para definir os nomes
	dos grupos. Se resulta necesario, o contido numérico da serie vaise
	axustar de forma que os valores sexan todos 1 para o primeiro grupo,
	todos 2 para o segundo grupo, etcétera. Cando o número de valores
	diferentes en cadeas de texto non coincide co número de grupos,
	amósase un fallo.
      </para>
      <para>
	Segundo caso: O primeiro argumento é o nome dunha serie, e o segundo
	é unha cadea de texto literal ou unha variable de cadea que contén
	un nome para cada grupo. As series vanse xerar se non existen xa.
	Cando o segundo argumento é unha cadea de texto literal ou unha
	variable de cadea, os nomes dos grupos deben de estar separados por
	espazos; pero se un nome inclúe espazos, debe de contornarse con
	comiñas precedidas (cada unha) de barra inversa. Alternativamente,
	o segundo argumento pode ser un arranxo de cadeas de texto.
      </para>
      <para>
	Por exemplo, o seguinte código xera unha serie que se vai chamar
	<lit>Estado</lit> na que os nomes da cadea <lit>cstrs</lit> repítense
	cada un <math>T</math> veces, e sendo <math>T</math> a longura das
	series de tempo do panel.
      </para>
      <code>
	string cstrs = sprintf("Francia Alemaña Italia \"Reino Unido\"")
	setobs Estado cstrs --panel-groups
      </code>
    </description>

    <gui-access>
      <menu-path>/Datos/Estrutura do conxunto de datos</menu-path>
    </gui-access>

  </command>

  <command name="setopt" section="Programming" context="cli"
    label="Configurar as opcións da próxima instrución">

    <usage>
      <arguments>
	      <argument>instrución</argument>
	      <argument optional="true">acción</argument>
	      <argument>opcións</argument>
      </arguments>
      <examples>
        <example>setopt mle --hessian</example>
        <example>setopt ols persist --quiet</example>
	<example>setopt ols clear</example>
	<demos>
	  <demo>gdp_midas.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Esta instrución permite a configuración previa de opcións para unha
	instrución concreta. Normalmente isto non fai falta, pero pode ser
	útil para os autores de funcións en HANSL, cando queren facer que
	algunhas opcións das instrucións estean condicionadas ao valor dun
	argumento que proporcione quen as solicita.
      </para>
      <para>
	Por exemplo, supón que unha función ofrece un interruptor booleano
	<quote><lit>quiet</lit></quote>, cuxa intención é que se
	suprima a presentación de resultados dunha determinada regresión
	que se executa dentro da propia función. Nese caso, poderíase
	escribir:
      </para>
      <code>
	if quiet
	  setopt ols --quiet
	endif
	ols ...
      </code>
      <para>
	Entón, a opción <opt>quiet</opt> vaise aplicar á vindeira instrución
	<lit>ols</lit> unicamente se a variable <lit>quiet</lit> ten un valor
	non nulo.
      </para>
      <para>
	Por defecto, as opcións que se establecen deste xeito só se aplican
	á seguinte petición da <repl>instrución</repl>; polo que non son
	persistentes. Porén, se indicas <lit>persist</lit> como valor para
	<repl>acción</repl>, as opcións se continuarán aplicando á instrución
	indicada ata novo aviso. O 'antídoto' á acción <lit>persist</lit> é
	<lit>clear</lit>, pois este elimina calquera configuración gardada
	para a instrución especificada.
      </para>
      <para>
	Debes de ter en conta que as opcións establecidas mediante
	<lit>setopt</lit> combínanse con calquera opción agregada
	directamente á instrución apuntada. Así, por exemplo, pódese
	engadir a opción <opt>hessian</opt> a unha instrución <lit>mle</lit>
	de forma incondicional, pero utilizar <lit>setopt</lit> para engadir
	<opt>quiet</opt> de forma condicional.
      </para>
    </description>
  </command>

  <command name="shell" section="Utilities"
    label="Executar instrucións do intérprete" context="cli">

    <usage>
      <arguments>
        <argument>instrucshell</argument>
      </arguments>
      <examples>
        <example>! ls -al</example>
        <example>! dir c:\users</example>
        <example>launch notepad</example>
        <example>launch emacs myfile.txt</example>
      </examples>
    </usage>

    <description>
      <para>
	A prestación que se describe aquí non está activada por defecto.
	Mira máis abaixo para os detalles.
      </para>
      <para>
	Un signo de exclamación (<cmd>!</cmd>) ao comezo dunha liña de
	instrución se interpreta como unha escapada do intérprete de usuario.
	Así podes executar instrucións do intérprete ao teu antollo desde dentro
	de <program>GRETL</program>. O argumento <repl>instrucshell</repl>
	pásase a <lit>/bin/sh</lit> en sistemas de tipo Unix como Linux e
	macOS, ou a <lit>cmd.exe</lit> en MS Windows. Execútase de forma
	síncrona; é dicir, <program>GRETL</program> vai agardar a que se
	complete a instrución antes de proseguir. Se a instrución dá como
	resultado algún texto, este se presenta na consola ou na xanela de
	resultados de guións.
      </para>
      <para>
	Unha variante do acceso síncrono co intérprete, permite ao usuario
	<quote>capturar</quote> o resultado dunha instrución nunha variable
	de cadea de texto. Isto pódese acadar envolvendo a instrución entre
	parénteses, precedidos por un signo dólar, como en
      </para>
      <code>
	string s = $(ls -l $HOME)
      </code>
      <para>
	Por outra banda, a clave <cmd>launch</cmd>, executa un programa
	externo de xeito asíncrono (sen agardar a que se complete), como
	no terceiro e no cuarto exemplos de arriba. Isto está pensado para
	abrir unha aplicación en modo interactivo. A <lit>RUTA</lit> do
	usuario vaise procurar para o executable especificado. En MS Windows,
	a instrución vaise executar directamente, sen pasala a <lit>cmd.exe</lit>
	(dese xeito as variables de contorna non se van expandir de forma
	automática).
      </para>
      <subhead>Activación</subhead>
      <para>
	Por razóns de seguridade, a prestación de acceso co intérprete
	non se permite por defecto. Para activala, marca o cadriño
	<quote>Permitir instrucións do intérprete</quote> baixo o menú
	Ferramentas/Preferencias/Xeral no programa de Interface Gráfica de Usuario
	(GUI). Isto tamén fai que estean dispoñibles as instrucións do intérprete
	no programa de instrucións en liñas (e resulta o único xeito de facelo).
      </para>
    </description>

  </command>

  <command name="smpl" section="Dataset"
    label="Establecer o rango da mostra" context="cli">

    <!-- don't break the lines below or the text version will get messed
    up -->

    <usage>
      <altforms>
	<altform><lit>smpl</lit> <repl>obsinicio obsfin</repl></altform>
	<altform><lit>smpl</lit> <repl>+i -j</repl></altform>
	<altform><lit>smpl</lit> <repl>varficticia</repl> <lit>--dummy</lit></altform>
	<altform><lit>smpl</lit> <repl>condición</repl> <lit>--restrict</lit></altform>
	<altform><lit>smpl</lit> <lit>--no-missing [ </lit><repl>listavariables</repl> <lit>]</lit></altform>
	<altform><lit>smpl</lit> <lit>--no-all-missing [ </lit><repl>listavariables</repl> <lit>]</lit></altform>
	<altform><lit>smpl</lit> <lit>--contiguous [ </lit><repl>listavariables</repl> <lit>]</lit></altform>
	<altform><lit>smpl</lit> <repl>n</repl> <lit>--random</lit></altform>
	<altform><lit>smpl full</lit></altform>
	<altform><lit>smpl</lit></altform>
      </altforms>
      <options>
        <option>
	  <flag>--dummy</flag>
	  <effect>O argumento é unha variable ficticia</effect>
        </option>
        <option>
	  <flag>--restrict</flag>
	  <effect>Aplica unha restrición booleana</effect>
        </option>
        <option>
	  <flag>--replace</flag>
	  <effect>Substitúe calquera restrición booleana existente</effect>
        </option>
        <option>
	  <flag>--no-missing</flag>
	  <effect>Limitarse a observacións válidas</effect>
        </option>
        <option>
	  <flag>--no-all-missing</flag>
	  <effect>Omite observacións baleiras (mira abaixo)</effect>
        </option>
        <option>
	  <flag>--contiguous</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--random</flag>
	  <effect>Xera unha submostra aleatoria</effect>
        </option>
        <option>
	  <flag>--permanent</flag>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--preserve-panel</flag>
	  <effect>Datos de panel: mira abaixo</effect>
        </option>
        <option>
	  <flag>--unit</flag>
	  <effect>Datos de panel: mostra na dimensión atemporal</effect>
        </option>
        <option>
	  <flag>--time</flag>
	  <effect>Datos de panel: mostra na dimensión temporal</effect>
        </option>
        <option>
	  <flag>--dates</flag>
	  <effect>Interpreta os números de observación como datas</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non amosa o rango mostral</effect>
	      </option>
      </options>
      <examples>
        <example>smpl 3 10</example>
	<example>smpl 1960:2 1982:4</example>
	<example>smpl +1 -1</example>
	<example>smpl x &gt; 3000 --restrict</example>
	<example>smpl y &gt; 3000 --restrict --replace</example>
	<example>smpl 100 --random</example>
      </examples>
    </usage>

    <description>
      <para>
	Esta instrución só pode utilizarse cando está preparado un conxunto
	de datos. Cando non indicas ningún argumento, presenta o rango mostral
	vixente; noutro caso, establece o rango mostral. Podes definir o rango
	de varios xeitos. Na primeira alternativa (e nos dous primeiros exemplos)
	de arriba, <repl>obsinicio</repl> e <repl>obsfin</repl> deben ser
	consistentes coa periodicidade dos datos. Podes substituír calquera
	dos dous mediante un punto e coma para deixar ese valor sen cambiar.
	(Para máis detalles sobre <repl>obsinicio</repl> e <repl>obsfin</repl>,
	consulta a sección titulada <quote>Datas versus Índices secuenciais</quote>
	máis abaixo.) Na segunda forma, os números enteiros <repl>i</repl>
	e <repl>j</repl> (poden ser positivos ou negativos, e deben de ter
	o seu signo) considéranse como variacións en relación ao rango da
	mostra existente. Na terceira forma, <repl>varficticia</repl> debe
	de ser unha variable de sinalización con valores 0 ou 1 en cada
	observación; así a mostra vaise restrinxir ás observacións nas que
	o valor é 1. A cuarta forma, que utiliza <opt>restrict</opt>, restrinxe
	a mostra ás observacións que cumpren a condición booleana que se
	indica.
      </para>
      <para>
	Podes empregar as opcións <opt>no-missing</opt> e <opt>no-all-missing</opt>
	para excluír da mostra aquelas observacións para as que hai ausencia
	de datos. A primeira variante exclúe aquelas filas do conxunto de
	datos para as que, polo menos unha variable, ten un valor ausente;
	mentres que a segunda variante exclúe unicamente aquelas filas
	nas que <emphasis>todas</emphasis> as variables teñen valores
	ausentes. En cada caso, a comprobación limítase ás variables de
	<repl>listavariables</repl> cando indicas este argumento; se non,
	aplícase a todas as series (coa reserva de que, no caso de non
	ter <repl>listavariables</repl> e indicar <opt>no-all-missing</opt>,
	as variables xenéricas <lit>index</lit> e <lit>time</lit>
	ignóranse).
      </para>
      <para>
	A opción <opt>contiguous</opt> de <lit>smpl</lit> está pensada para
	usar con datos de series temporais. O seu efecto consiste en recortar
	calquera observación ao comezo e ao final do rango da mostra vixente
	que conteña valores ausentes (ben para as variables de
	<repl>listavariables</repl>, ou ben para todas as series de datos se
	non indicas <repl>listavariables</repl>). Entón realízase unha
	verificación para comprobar se hai algún valor ausente no rango que
	queda; e se é así, amósase un fallo.
      </para>
      <para>
	Coa opción <opt>random</opt>, o número de casos especificado
	escóllese aleatoriamente do conxunto vixente de datos (sen
	substitución). Se queres ser capaz de replicar esa selección,
	debes de establecer primeiro a semente para o xerador de números
	aleatorios (consulta a instrución <cmdref targ="set"/>).
      </para>
      <para>
	A forma final (<lit>smpl full</lit>) restablece o rango completo de
	datos.
      </para>
      <para>
	Ten en conta que as restricións mostrais son, por defecto, acumulativas;
	é dicir, o punto de partida de calquera instrución <lit>smpl</lit>
	é a mostra vixente. Se queres que a instrución actúe substituíndo
	calquera restrición xa existente, podes engadir o indicador de opción
	<opt>replace</opt> ao final da instrución. (Pero esta opción non é
	compatible coa opción <opt>contiguous</opt>.)
      </para>
      <para>
	Podes utilizar a variable interna <lit>obs</lit> xunto coa opción
	<opt>restrict</opt> de <lit>smpl</lit> para excluír observacións
	concretas da mostra. Por exemplo
      </para>
      <code>
	smpl obs!=4 --restrict
      </code>
      <para>
	vai prescindir unicamente da cuarta observación. Se os casos
	dos datos se identifican mediante etiquetas,
      </para>
      <code>
	smpl obs!="USA" --restrict
      </code>
      <para>vai prescindir da observación coa etiqueta <quote>USA</quote>.
      </para>
      <para>
	Debe de apuntarse unha cuestión en relación ás opcións
	<opt>dummy</opt>, <opt>restrict</opt> e <opt>no-missing</opt> da
	instrución <lit>smpl</lit>: a información <quote>estrutural</quote>
	do ficheiro de datos (relacionada coa natureza de series de tempo
	ou de panel, dos datos) probablemente vaise perder cando se execute
	esta instrución; pero podes volver impoñer a estrutura coa instrución
	<cmdref targ="setobs"/> (consulta tamén a opción <opt>preserve-panel</opt>
	máis abaixo).
      </para>

      <subhead>Datas versus Índices secuenciais</subhead>
      <para>
	Podes utilizar a opción <opt>dates</opt> para solucionar algunha posible
	ambigüidade ao interpretar <repl>obsinicio</repl> e <repl>obsfin</repl>
	no caso de usar datos de series de tempo anuais. Por exemplo,
	debería considerarse que <lit>2010</lit> se refire ao ano 2010, ou
	á dous mil décima observación? Na maioría dos casos, isto debera
	saír ben automaticamente, pero podes forzar a interpretación en
	forma de data se o precisas. Esta opción tamén se pode utilizar con
	datos que estean datados diariamente para lograr que <lit>smpl</lit>
	interprete, por exemplo, 20100301 como o primeiro de marzo de 2010
	en troques dun índice secuencial corrente. Cae na conta de que esta
	ambigüidade non xurde coas frecuencias de series de tempo que sexan
	distintas á anual e á diaria; datas como 1980:3 (terceiro trimestre
	de 1980) e 2020:03 (marzo de 2020) non poden confundirse con índices
	correntes.
      </para>

      <subhead>Opcións específicas para datos de panel</subhead>
      <para>
	As opcións <opt>unit</opt> e <opt>time</opt> son específicas para
	datos de panel. Te permiten indicar, respectivamente, un rango de
	<quote>unidades</quote> ou de períodos de tempo. Por exemplo:
      </para>
      <code>
	# Limita a mostra ás primeiras 50 unidades
	smpl 1 50 --unit
	# Limita a mostra aos períodos de tempo de 2 a 20
	smpl 2 20 --time
      </code>
      <para>
	Cando se especifica a dimensión temporal dun conxunto de datos de
	panel mediante a instrución <cmdref targ="setobs"/> coa opción
	<opt>panel-time</opt>, a instrución <lit>smpl</lit> coa opción
	<opt>time</opt> pode expresarse en termos de datas en troques de
	números de observación planos. Este é un exemplo:
      </para>
      <code>
	# Especificar o tempo dun panel como trimestral, comezando no primeiro de 1990
	setobs 4 1990:1 --panel-time
	# Limitar a mostra desde 2000:1 ata 2007:1
	smpl 2000:1 2007:1 --time
      </code>
      <para>
	En GRETL, un conxunto de datos de panel debe estar sempre
	<quote>teoricamente equilibrado </quote>&mdash;é dicir, cada unidade
	debe ter o mesmo número de filas de datos, aínda que algunhas filas
	non conteñan máis que <lit>NA</lit>s. Extraer unha submostra mediante
	as opcións <opt>restrict</opt> ou <opt>dummy</opt> pode rachar esta
	estrutura. Nese caso, podes engadir a opción <opt>preserve-panel</opt>
	para solicitar que se reconstitúa un panel teoricamente equilibrado, por
	medio da inserción das <quote>filas ausentes</quote> que fagan falta.
      </para>

      <subhead>Establecer a mostra como permanente ou provisional</subhead>
      <para>
	Por defecto, podes desfacer as limitacións que establezas sobre o
	rango da mostra vixente, pois executando <lit>smpl full</lit> podes
	restaurar o conxunto de datos completo. Porén, podes utilizar a
	opción <opt>permanent</opt> para substituír o conxunto de datos
	restrinxido en lugar do orixinal. O efecto de indicar a opción
	<opt>permanent</opt> sen outros argumentos nin opcións, é o de
	reducir o banco de datos ao rango da mostra vixente.
      </para>

      <para>
	Consulta o <guideref targ="chap:sampling"/> para obter outros detalles.
      </para>

    </description>

    <gui-access>
      <menu-path>/Mostra</menu-path>
    </gui-access>

  </command>

  <command name="spearman" section="Statistics"
    label="Correlación por rangos de Spearman">

    <usage>
      <arguments>
        <argument>serie1</argument>
        <argument>serie2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--verbose</flag>
	  <effect>Presenta os datos por rangos</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Presenta o coeficiente da correlación por rangos de Spearman para
	as series <repl>serie1</repl> e <repl>serie2</repl>. Non tes que
	xerarquizar manualmente as variables por adiantado, pois a función
	xa ten conta diso.
      </para>
      <para context="gui">
	Presenta o coeficiente da correlación por rangos de Spearman para
	un par especificado de series. Non tes que xerarquizar manualmente
	as series por adiantado, pois a función xa ten conta diso.
      </para>
      <para>
	A forma automática de xerarquizar é de maior a menor (&ie; o valor
	máis grande dos datos acada o rango 1). Se necesitas inverter esta
	forma de xerarquizar, xera unha nova variable que sexa a negativa
	da orixinal. Por exemplo:
      </para>
      <code>
	series altx = -x
	spearman altx y
      </code>
    </description>

    <gui-access>
      <menu-path>/Ferramentas/Probas non paramétricas/Correlación</menu-path>
    </gui-access>

  </command>

  <command name="square" section="Transformations"
    label="Xerar cadrados de variables" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--cross</flag>
	  <effect>Xera os produtos cruzados así como os cadrados</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Xera novas series que son os cadrados das series de <repl>listavariables</repl>
	(ademais das variables cos produtos cruzados entre cada dúas, cando
	indicas a opción <opt>cross</opt>). Por exemplo, <cmd>square x y</cmd>
	vai xerar as variables <lit>sq_x</lit> = <lit>x</lit> ao cadrado,
	<lit>sq_y</lit> = <lit>y</lit> ao cadrado e (opcionalmente con 'cross')
	<lit>x_y</lit> = <lit>x</lit> por <lit>y</lit>. Cando unha determinada
	variable é unha variable ficticia, non se calcula o seu cadrado pois
	obteríamos a mesma variable.
      </para>
    </description>

    <gui-access>
      <menu-path>/Engadir/Cadrados das variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="stdize" section="Transformations"
    label="Tipificar series">

    <usage>
      <arguments>
        <argument>listavar</argument>
      </arguments>
      <options>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>Sen corrección de graos de liberdade</effect>
        </option>
        <option>
	  <flag>--center-only</flag>
	  <effect>Sen dividir por desvío padrón</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
	Por defecto, esta instrución engade ao conxunto de datos vixente, novas
	series que son versións tipificadas das series orixinais, e que se
	nomean co prefixo <lit>s_</lit>. Por exemplo, <lit>s_x</lit> fórmase
	restándolle a media a <lit>x</lit>, e dividindo o resultado polo
	desvío padrón mostral de <lit>x</lit> (coa corrección de 1, nos
	graos de liberdade). Pero podes elixir que se divida polo desvío
	padrón sen ningunha corrección dos graos de liberdade, é dicir, o
	estimador máximo-verosímil.
      </para>
      <para>
	Tamén dispós da opción de formar series que son o resultado de
	unicamente centrar as orixinais (réstase a media, pero non se aplica
	o cambio de escala). Neste caso, os nomes das novas series teñen o
	prefixo <lit>c_</lit> en troques de <lit>s_</lit>.
      </para>
    </description>

    <description context="cli">
      <para>
	Por defecto, obtense unha versión tipificada de cada unha das
	variables de <repl>listavar</repl>, e cada resultado gárdase
	nunha nova serie co prefixo <lit>s_</lit>. Así, por exemplo, a
	expresión <cmd>stdize x y</cmd> crea as novas series <lit>s_x</lit>
	e <lit>s_y</lit>, cada unha como resultado de centrar e dividir a
	orixinal polo seu desvío padrón mostral (coa corrección de 1,
	nos graos de liberdade).
      </para>
      <para>
	Cando indicas a opción <opt>no-df-corr</opt>, non se vai aplicar
	ningunha corrección dos graos de liberdade no desvío padrón
	que se utiliza; será o estimador máximo-verosímil. Se indicas a
	opción <opt>center-only</opt>, as series resultan de unicamente
	restar a media e, nese caso, os nomes das resultantes van ter o
	prefixo <lit>c_</lit> en troques de <lit>s_</lit>.
      </para>
      <para>
	A funcionalidade desta instrución está dispoñible de xeito en certo
	modo máis flexible, por medio da función <fncref targ="stdize"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Engadir/Tipificar as variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="store" section="Dataset" label="Gardar os datos">

    <usage>
      <arguments>
        <argument>nomeficheiro</argument>
        <argument optional="true">listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--omit-obs</flag>
	  <effect>Mira abaixo, sobre o formato CSV</effect>
        </option>
        <option>
	  <flag>--no-header</flag>
	  <effect>Mira abaixo, sobre o formato CSV</effect>
        </option>
        <option>
	  <flag>--gnu-octave</flag>
	  <effect>Utiliza o formato GNU Octave</effect>
        </option>
        <option>
	  <flag>--gnu-R</flag>
	  <effect>Formato tratable con read.table</effect>
        </option>
        <option>
	  <flag>--gzipped</flag>
	  <optparm optional="true">nivel</optparm>
	  <effect>Aplica a compresión gzip</effect>
        </option>
        <option>
	  <flag>--jmulti</flag>
	  <effect>Utiliza o formato ASCII JMulti</effect>
        </option>
        <option>
	  <flag>--dat</flag>
	  <effect>Utiliza o formato ASCII PcGive</effect>
        </option>
        <option>
	  <flag>--decimal-comma</flag>
	  <effect>Utiliza a coma como carácter decimal</effect>
        </option>
        <option>
	  <flag>--database</flag>
	  <effect>Utiliza o formato de banco de datos de GRETL</effect>
        </option>
        <option>
	  <flag>--overwrite</flag>
	  <effect>Mira abaixo, sobre o formato de banco de datos</effect>
        </option>
        <option>
	  <flag>--comment</flag>
	  <optparm>cadea</optparm>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nomematriz</optparm>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Garda os datos en <repl>nomeficheiro</repl>. Por defecto, gárdanse
	todas as series xa definidas nese momento, pero podes utilizar o
	argumento <repl>listavariables</repl> (opcional) para escoller un
	subconxunto de series. Se o conxunto de datos é unha submostra, só
	se gardan as observacións do rango vixente da mostra.
      </para>
      <para>
	O ficheiro resultante vai escribirse no cartafol (<cmdref targ="workdir"/>)
	establecido nese momento, agás que a cadea <repl>nomeficheiro</repl>
	conteña unha especificación completa da ruta.
      </para>
      <para>
	Cae na conta de que a instrución <lit>store</lit> compórtase de xeito
	especial no contexto dun <quote>bucle progresivo</quote>; consulta
	o <guideref targ="chap:looping"/> para obter máis detalles.
      </para>
      <subhead>Formatos propios</subhead>
      <para>
	Se <repl>nomeficheiro</repl> ten extensión <lit>.gdt</lit> ou
	<lit>.gtdb</lit>, isto implica que se garden os datos nun dos formatos
	propios de GRETL. Amais, se non indicas unha extensión, considérase
	implicitamente a <lit>.gdt</lit> e este sufixo engádese de xeito
	automático. O formato <lit>gdt</lit> é de tipo XML, opcionalmente
	comprimido en gzip; mentres que o formato <lit>gdtb</lit> é binario.
	O primeiro recoméndase para conxuntos de datos de tamaño moderado
	(digamos que ata varios centos de quilobytes de datos); co formato
	binario é moito maior a velocidade con conxuntos de datos moi grandes.
      </para>
      <para>
	Cando gardas os datos en formato <lit>gdt</lit>, podes utilizar a
	opción <opt>gzipped</opt> para comprimilos. O parámetro (optativo)
	desta opción controla o nivel de compresión (de 0 a 9): os valores
	maiores xeran un ficheiro máis pequeno, pero a compresión leva
	máis tempo. O nivel por defecto é o 1; e un nivel de 0 significa
	que non se aplica ningunha compresión.
      </para>
      <para>
	Admítese un tipo especial de gardado <quote>propio</quote> no
	programa de interface GUI: se <repl>nomeficheiro</repl> ten extensión
	<lit>.gretl</lit> e omites o argumento <repl>listavariables</repl>,
	entón grávase un ficheiro de sesión de GRETL. Este tipo de ficheiros
	inclúen o conxunto de datos vixente xunto con calquera obxecto que
	teña un nome, como modelos, gráficas e matrices.
      </para>
      <subhead>Outros formatos</subhead>
      <para>
	Ata certo punto, podes controlar o formato no que se escriben os
	datos mediante a extensión ou sufixo de <repl>nomeficheiro</repl>,
	como se indica deseguido:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>.csv</lit>: Valores Separados por Comas (CSV).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.txt</lit> ou <lit>.asc</lit>: valores separados por
	    espazos.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.m</lit>: Formato matricial GNU Octave.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.dta</lit>: Formato dta de Stata (versión 113).
	  </para>
	</li>
      </ilist>
      <para>
	Podes usar os indicadores de opción relacionados co formato amosados
	arriba para forzar a elección do formato, con independencia do nome do
	ficheiro (ou para lograr que GRETL escriba nos formatos de PcGive ou JMulTi).
      </para>
      <subhead>Opcións CSV</subhead>
      <para>
	Os indicadores de opción <opt>omit-obs</opt> e <opt>no-header</opt>
	son específicos para gardar datos no formato CSV. Por defecto,
	se os datos son series temporais ou de panel, ou se o conxunto de
	datos inclúe marcadores específicos de observación, o ficheiro resultante
	inclúe unha primeira columna que identifica as observacións (&eg; por data).
	Cando indicas a opción <opt>omit-obs</opt>, esta columna omítese. A
	opción <opt>no-header</opt> elimina a habitual representación dos
	nomes das variables no encabezamento das columnas.
      </para>
      <para>
	O indicador de opción <opt>decimal-comma</opt> está tamén limitado
	a CSV. O seu efecto consiste en substituír o punto decimal coa coma
	decimal; e, por engadido, fórzase a que o separador de columnas sexa
	o punto e coma, en troques da coma.
      </para>
      <subhead>Gardar nun banco de datos</subhead>
      <para>
	A posibilidade de gardar no formato de banco de datos de GRETL
	está pensada para construír longos conxuntos de series, con mesturas
	de frecuencias e rangos de observacións. Neste momento, esta opción
	só está dispoñible para datos de series temporais de tipo anual,
	trimestral ou mensual, ou para datos sen data (de sección cruzada).
	Un banco de datos de GRETL toma a forma de dous ficheiros: un co
	sufixo <lit>.bin</lit> para gardar os datos en formato binario, e un
	ficheiro de texto plano co sufixo <lit>.idx</lit> para os metadatos.
	Para indicar o nome do ficheiro de saída na liña de instrucións,
	debes indicar o sufixo <lit>.bin</lit> ou non indicar ningún.
      </para>
      <para>
	Cando se garda nun banco de datos que xa existe, o efecto por defecto
	consiste en engadir series ao contido existente no banco de datos. Neste
	contexto, é un fallo que algunha das series que se van gardar teña o
	mesmo nome ca algunha que xa está presente no banco de datos. A opción
	<opt>overwrite</opt> ten como consecuencia que, se hai nomes de variables
	en común, os datos recentemente gardados substitúen aos valores previos.
      </para>
      <para>
	A opción <opt>comment</opt> está dispoñible cando se gardan datos como
	banco de datos ou como CSV. O parámetro que se require é unha
	cadea nunha liña, entre comiñas, ligada ao indicador de opción mediante
	un signo de igualdade. A cadea de texto insírese como comentario no
	ficheiro índice do banco de datos ou no encabezamento do CSV.
      </para>
      <subhead>Escribir unha matriz como conxunto de datos</subhead>
      <para>
	A opción <opt>matriz</opt> precisa dun parámetro: o nome dunha
	matriz (que non estea baleira). Entón a consecuencia da instrución
	<lit>store</lit> é efectivamente converter a matriz nun conxunto de datos
	<quote>en segundo plano</quote>, e escribilo como tal nun ficheiro.
	As columnas da matriz pasan a ser series cuxos nomes se toman ben dos
	nomes adxuntos ás columnas da matriz (no caso de habelos), ou ben se
	asignan por defecto como <lit>v1</lit>, <lit>v2</lit>, etc. Se a matriz
	ten nomes adxuntos ás filas, estes utilízanse no conxunto de datos
	como <quote>marcadores das observacións</quote>.
      </para>
      <para>
	Cae na conta de que podes escribir as matrices como tales en ficheiros,
	consulta para elo a función <fncref targ="mwrite"/>. Pero ás veces pode
	resultarche útil escribilas en forma de conxuntos de datos.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ficheiro/Gardar datos; /Ficheiro/Exportar datos</menu-path>
    </gui-access>

  </command>

  <command name="summary" section="Statistics"
    label="Estatísticas descritivas" context="cli">

    <usage>
      <altforms>
	<altform><lit>summary [</lit> <repl>listavariables</repl> ]</altform>
	<altform><lit>summary --matrix=</lit><repl>nomematriz</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--simple</flag>
	  <effect>Só estatísticos básicos</effect>
        </option>
        <option>
	  <flag>--weight</flag>
	  <optparm>wtvar</optparm>
	  <effect>Variable de ponderación</effect>
        </option>
        <option>
	  <flag>--by</flag>
	  <optparm>byvar</optparm>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
	  <examples>
	<demos>
	  <demo>frontier.inp</demo>
	</demos>
	  </examples>
    </usage>

    <description>
      <para>
	Na súa primeira forma, esta instrución presenta un resumo estatístico
	das variables de <repl>listavariables</repl>, ou de todas as variables
	do conxunto de datos cando omites <repl>listavariables</repl>. Por
	defecto, o resultado consiste na media, mediana, mínimo, máximo,
	desvío padrón (dp), coeficiente de variación (= dp/media),
	coeficiente de asimetría, exceso de curtose, percentiles do 5% e 95%,
	rango intercuartílico e número de observacións ausentes. Mais
	cando indicas a opción <opt>simple</opt>, o resultado limítase
	á media, á mediana, o desvío padrón, o mínimo e o
	máximo.
      </para>
      <para>
	Se indicas a opción <opt>weight</opt>, en cuxo caso o parámetro
	<repl>wvar</repl> debería ser o nome dunha serie que ofreza as
	ponderacións de cada observación, os estatísticos pondéranse de
	acordo con iso.
      </para>
      <para>
	Cando indicas a opción <opt>by</opt>, en cuxo caso o parámetro
	<repl>byvar</repl> debe de ser o nome dunha variable discreta,
	entón preséntanse os estatísticos para as submostras que se
	corresponden cos diferentes valores que toma <repl>byvar</repl>.
	Por exemplo, cando <repl>byvar</repl> é unha variable ficticia
	(binaria), preséntanse os estatísticos para os casos nos que
	<lit>byvar=0</lit> e <lit>byvar=1</lit>. Advertencia: Neste
	momento, esta opción é incompatible coa opción
	<opt>weight</opt>.
      </para>
      <para>
	Cando indicas a forma alternativa, utilizando unha matriz xa definida,
	entón preséntase o resumo estatístico para cada columna da matriz.
	Neste caso, a opción <opt>by</opt> non está dispoñible.
      </para>
      <para>
	Podes obter, en forma de matriz, a táboa de estatísticos xerada
	pola instrución <lit>summary</lit>, mediante o accesorio
	<fncref targ="$result"/>. Cando indiques a opción <opt>by</opt>,
	xérase o efecto deste accesorio unicamente se <repl>varlist</repl>
	contén unha única serie.
      </para>
      <para>
	Consulta tamén a función <fncref targ="aggregate"/> para ver
	outros xeitos máis flexibles de produción de estatísticos
	<quote>factorizados</quote>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Estatísticos principais</menu-path>
      <other-access>Xanela principal: Menú emerxente</other-access>
    </gui-access>

  </command>

  <command name="system" section="Estimation" label="Sistemas de ecuacións">

    <usage>
      <altforms>
	<altform><lit>system method=</lit><repl>estimador</repl></altform>
	<altform><repl>sysname</repl><lit> &lt;- system</lit></altform>
      </altforms>
      <examples>
	<example>"Klein Model 1" &lt;- system</example>
        <example>system method=sur</example>
	<example>system method=3sls</example>
	<demos>
	  <demo>klein.inp</demo>
	  <demo>kmenta.inp</demo>
	  <demo>greene14_2.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Nesta xanela podes definir un sistema de ecuacións e escoller un
	estimador para o sistema. Aquí podes indicar 4 tipos de enunciado,
	como os seguintes:
      </para>

      <para context="cli">
	Comeza un sistema de ecuacións. Podes indicar unha das dúas
	formas da instrución, dependendo de se queres gardar o sistema
	para estimalo de varias formas, ou só estimar o sistema unha vez.
	    </para>

      <para context="cli">
	Para gardar o sistema debes de asignarlle un nome como no primeiro
	exemplo (se o nome contén espazos, debes de contornalo entre
	comiñas). Neste caso, estímase o sistema utilizando a instrución
	<cmdref targ="estimate"/>. Cun sistema de ecuacións xa gardado,
	podes impoñer restricións (incluídas restricións entre ecuacións)
	utilizando a instrución
	<cmdref targ="restrict"/>.
      </para>

      <para context="cli">
	Como alternativa, podes especificar un estimador para o sistema
	utilizando <lit>method=</lit> seguido dunha cadea que identifique
	un dos estimadores admitidos: <cmd>ols</cmd> (Mínimos Cadrados
	Ordinarios), <cmd>tsls</cmd> (Mínimos Cadrados en 2 Etapas)
	<cmd>sur</cmd> (Regresións Aparentemente Non Relacionadas),
	<cmd>3sls</cmd> (Mínimos Cadrados en 3 Etapas), <cmd>fiml</cmd>
	(Máxima Verosimilitude con Información Total) ou <cmd>liml</cmd>
	(Máxima Verosimilitude con Información Limitada). Neste caso, o
	sistema estímase unha vez que estea completa a súa definición.
      </para>

      <para context="cli">
	Un sistema de ecuacións remátase coa liña <cmd>end system</cmd>. Dentro
	do sistema poden indicarse 4 tipos de enunciado, como os seguintes.
      </para>

      <ilist>
	<li><para><cmdref targ="equation"/>: Especifica unha ecuación do sistema.
	    </para>
	</li>
	<li><para><cmd>instr</cmd>: Para estimar un sistema mediante
	    Mínimos Cadrados en 3 etapas, indícase unha lista de instrumentos
	    (mediante o nome da variable ou o seu número). Alternativamente,
	    podes poñer esta información na liña <cmd>equation</cmd> usando
	    a mesma sintaxe que na instrución <cmdref targ="tsls"/>.
	    </para>
	</li>
	<li><para><cmd>endog</cmd>: Para un sistema de ecuacións simultáneas,
	    indícase unha lista de variables endóxenas. En principio, isto está
	    pensado para utilizar coa estimación FIML, pero podes utilizar este
	    enfoque con Mínimos Cadrados en 3 Etapas en troques de indicar
	    unha lista <cmd>instr</cmd>; e entón todas as variables que non se
	    identifiquen como endóxenas, vanse utilizar como instrumentos.
	    </para>
	</li>
	<li><para><cmd>identity</cmd>: Para utilizar con Máxima Verosimilitude
	    con Información Completa (MVIC, FIML), indícase unha identidade que
	    enlaza dúas ou máis variables do sistema. Este tipo de enunciado se
	    ignora cando se utiliza un estimador diferente ao de MVIC.
	  </para>
	</li>
      </ilist>
	
      <para context="cli">
	Logo de facer a estimación utilizando as instrucións <cmd>system</cmd>
	ou <cmd>estimate</cmd>, podes usar os seguintes accesorios para recoller
	información adicional:
      </para>

      <ilist context="cli">
	<li><para><lit>$uhat</lit>: Matriz cos erros de estimación, cunha
	    columna por ecuación.
	  </para>
	</li>
	<li><para><lit>$yhat</lit>: Matriz cos valores axustados, cunha
	    columna por ecuación.
	  </para>
	</li>
	<li><para><lit>$coeff</lit>: Vector columna cos coeficientes das
	    ecuacións (todos os coeficientes da primeira ecuación, seguidos
	    polos da segunda ecuación, etcétera).
	  </para>
	</li>
	<li><para><lit>$vcv</lit>: Matriz coas covarianzas entre os coeficientes.
	    Cando hai <math>k</math> elementos no vector <lit>$coeff</lit>,
	    esta matriz ten unha dimensión de <math>k</math> por
	    <math>k</math>.
	  </para>
	</li>
	<li><para><lit>$sigma</lit>: Matriz coas covarianzas entre os erros
	de estimación das ecuacións cruzadas.
	  </para>
	</li>
	<li><para><lit>$sysGamma</lit>, <lit>$sysA</lit> e <lit>$sysB</lit>:
	    Matrices cos coeficientes na forma estrutural (mira abaixo).
	  </para>
	</li>
      </ilist>

      <para context="cli">
	Se queres recuperar os erros de estimación ou os valores axustados
	para unha ecuación en concreto, en forma de serie de datos, escolle
	unha columna da matriz <lit>$uhat</lit> ou <lit>$yhat</lit>, e asígnalle
	a serie como en
      </para>
      <code context="cli">
	series uh1 = $uhat[,1]
      </code>

      <para context="cli">
	As matrices na forma estrutural correspóndense coa seguinte representación
	dun modelo de ecuacións simultáneas:
	<equation status="display"
	  tex="\[\Gamma y_t=Ay_{t-1}+Bx_t+\epsilon_t\]"
	  ascii="Gamma y(t) = A y(t-1) + B x(t) + e(t)"
	  graphic="structural"/>
	Se hai <math>n</math> variables endóxenas e <math>k</math> variables
	esóxenas, &Gamma; é unha matriz de dimensión <by r="n" c="n"/> e
	<math>B</math> é <by r="n" c="k"/>. Cando o sistema non contén
	ningún retardo das variables endóxenas, entón a matriz <math>A</math>
	non está presente. Se o retardo máximo dun regresor endóxeno é
	<math>p</math>, a matriz <math>A</math> é de dimensión
	<by r="n" c="np"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelar/Ecuacións Simultáneas</menu-path>
    </gui-access>

  </command>

  <command name="tabprint" section="Printing"
    label="Presentar o modelo en formato de táboa" context="cli">

    <usage>
      <options>
        <option>
	  <flag>--output</flag>
	  <optparm>nomeficheiro</optparm>
	  <effect>Envía o resultado ao ficheiro especificado</effect>
        </option>
        <option>
	  <flag>--format="f1|f2|f3|f4"</flag>
	  <effect>Especifica o formato TeX personalizado</effect>
        </option>
	<option>
	  <flag>--complete</flag>
	  <effect>Relacionado con TeX, mira abaixo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Debe de ir despois da estimación dun modelo e presenta ese
	modelo en formato de táboa. O formato réxese pola extensión
	do <repl>nomeficheiro</repl> especificado:
	<quote><lit>.tex</lit></quote> para &latex;,
	<quote><lit>.rtf</lit></quote> para RTF (Microsoft's Rich Text
	Format) ou <quote><lit>.csv</lit></quote> para o formato con
	separación mediante comas. O ficheiro resultante vai escribirse
	no cartafol vixente (<cmdref targ="workdir"/>), agás que a cadea
	<repl>nomeficheiro</repl> conteña unha especificación completa da ruta.
      </para>
      <para>
	Cando seleccionas o formato CSV, os valores sepáranse con comas
	agás que a coma decimal estea vixente, en cuxo caso o separador
	é o punto e coma.
      </para>
      <subhead>Opcións específicas de resultados en &latex;</subhead>
      <para>
	Cando indicas a opción <opt>complete</opt>, o ficheiro &latex;
	é un documento completo, listo para procesar; se non, debe
	de incluírse nun documento.
      </para>
      <para>
	Se queres modificar a aparencia do resultado tabular, podes
	especificar un formato personalizado en filas utilizando a opción
	<opt>format</opt>. A cadea de formato debe de estar contornada entre
	comiñas e debe de estar ligada á opción cun signo de igualdade. O
	padrón para as cadeas de formato é o seguinte. Existen 4 campos que
	representan: o coeficiente, o desvío padrón, a razón <math>t</math>
	e a probabilidade asociada, respectivamente. Debes de separar estes
	campos mediante barras verticais; e, ou ben poden ter unha especificación
	de tipo <lit>printf</lit> para o formato do valor numérico en cuestión,
	ou ben poden deixarse en branco para eliminar a presentación desa
	columna (suxeito isto á condición de que non podes deixar todas as
	columnas en branco). Aquí tes uns poucos exemplos:
      </para>
      <code>
	--format="%.4f|%.4f|%.4f|%.4f"
	--format="%.4f|%.4f|%.3f|"
	--format="%.5f|%.4f||%.4f"
	--format="%.8g|%.8g||%.4f"
      </code>
      <para>
	A primeira destas especificacións presenta os valores de todas as
	columnas usando 4 díxitos decimais. A segunda elimina a probabilidade
	asociada e presenta as razóns <math>t</math> con 3 díxitos decimais.
	A terceira omite a razón <math>t</math>. A derradeira tamén omite a
	<math>t</math>, e presenta tanto o coeficiente como o desvío
	padrón con 8 cifras significativas.
      </para>
      <para>
	Unha vez que estableces un formato personalizado deste xeito,
	este lémbrase e utilízase ao longo do que dure a sesión de GRETL.
	Para reverter isto ao formato por defecto, podes utilizar a variante
	especial <opt>format=default</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>Xanela de modelo: LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="tdisagg" section="Dataset" context="gui"
    label="Desagregación temporal">

    <description>
      <para>
	Aquí tes un repaso das principais opcións no cadro de diálogo da
	desagregación temporal. Para obter unha explicación detallada,
	consulta o <guideref targ="chap:tdisagg"/>.
      </para>
      <ilist>
	<li>
	  <para>
	    Nome do resultado: Podes elixir entre sobrescribir unha serie
	    xa existente coa versión desagregada, ou dar un nome novo ao
	    resultado.
	  </para>
	</li>
	<li>
	  <para>
	    Tipo de agregación: Escolle <lit>sum</lit> se a suma dos valores
	    de alta frecuencia debe resultar igual ao valor de baixa frecuencia
	    proporcionado (ex. fluxos como o PIB e as súas compoñentes).
	    Elixe <lit>avg</lit> se a media dos valores de alta frecuencia
	    debe resultar igual ao valor de baixa frecuencia proporcionado
	    (ex. índices, cocientes, ou fluxos <quote>en taxas anuais</quote>).
	    Opta por <lit>last</lit> ou <lit>first</lit> se o derradeiro ou
	    primeiro valor de alta frecuencia debe ser igual ao valor de
	    baixa frecuencia (como pode ser o caso das variables de stock,
	    como a cantidade de diñeiro).
	  </para>
	</li>
	<li>
	  <para>
	    Baseado en regresión fronte a Denton: En xeral, recoméndase o
	    primeiro. Se escolles <quote>Baseado en regresión</quote>, vas
	    poder seleccionar o método de Fernández se pensas que a serie
	    que te interesa ten unha raíz unitaria; en caso contrario, opta
	    por Chow&ndash;Lin. Se escolles Denton, asúmese que sabes o que
	    estás facendo pois os métodos Denton son en primeiras diferenzas,
	    tal como os modificou Cholette.
	  </para>
	</li>
      </ilist>
    </description>
  </command>

  <command name="textplot" section="Graphs"
    label="Gráfica ASCII" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--time-series</flag>
	  <effect>Gráfica por observación</effect>
        </option>
        <option>
	  <flag>--one-scale</flag>
	  <effect>Forza unha escala única</effect>
        </option>
        <option>
	  <flag>--tall</flag>
	  <effect>Usa 40 filas</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Gráficas ASCII rápidas e sinxelas. Sen a opción <opt>time-series</opt>,
	<repl>listavariables</repl> debe de conter cando menos 2 series, a última
	delas tómase como a variable para o eixe <math>x</math>, e xérase unha
	gráfica de dispersión. Neste caso, podes utilizar a opción <opt>tall</opt>
	para xerar unha gráfica na que o eixe <math>y</math> se representa
	mediante 40 filas de caracteres (por defecto son 20 filas).
      </para>
      <para>
	Coa opción <opt>time-series</opt>, xérase unha gráfica por observación.
	Neste caso, podes utilizar a opción <opt>one-scale</opt> para forzar o
	uso dunha escala única; se non, se <repl>listavariables</repl>
	contén máis dunha serie, os datos poden escalarse. Cada liña representa
	unha observación, cos valores dos datos debuxados horizontalmente.
      </para>
      <para>
	Consulta tamén <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>


  <command name="tobit" section="Estimation" label="Modelo Tobit">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--llimit</flag>
	  <optparm>cotaesq</optparm>
	  <effect>Especifica a cota da esquerda</effect>
        </option>
        <option>
	  <flag>--rlimit</flag>
	  <optparm>cotader</optparm>
	  <effect>Especifica a cota da dereita</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
        <option>
	  <flag>--opg</flag>
	  <effect>Mira máis abaixo</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para máis explicacións</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Presenta os detalles das iteracións</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	      </option>
      </options>
    </usage>

    <description>
      <para>
	Estima un modelo Tobit, que pode ser o adecuado cando a variable
	dependente está <quote>censurada</quote>. Por exemplo, cando se
	observan valores positivos e nulos na adquisición de bens duradeiros
	por parte dos fogares, e ningún valor negativo, mesmo pode pensarse
	que as decisións sobre esas compras son o resultado dunha disposición
	subxacente e inobservada a comprar, que pode ser negativa nalgúns
	casos.
      </para>
      <para context="cli">
	Por defecto, asúmese que a variable dependente está 'censurada'
	no cero pola esquerda, e que non está 'censurada' pola dereita.
	Porén, podes usar as opcións <opt>llimit</opt> e <opt>rlimit</opt>
	para especificar un padrón diferente para facer a 'censura'. Ten
	en conta que se especificas unicamente unha cota pola dereita,
	entón o que se supón é que a variable dependente non está
	'censurada' pola esquerda.
      </para>
      <para context="gui">
	Por defecto, asúmese que a variable dependente está 'censurada' no
	cero pola esquerda, e que non está 'censurada' pola dereita. Porén,
	podes usar as caixas de anotación marcadas <quote>Cota esquerda</quote>
	e <quote>Cota dereita</quote> para especificar un padrón diferente
	de censura. Introduce un valor numérico ou <lit>NA</lit> para non
	facer censura.
      </para>
      <para>
	O modelo Tobit é un caso especial da regresión por intervalos.
	Consulta a instrución <cmdref targ="intreg"/> para obter detalles
	adicionais, incluída unha explicación das opcións <opt>robust</opt>
	e <opt>opg</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Variable Dependente Limitada/Tobit</menu-path>
    </gui-access>

  </command>

  <command name="transpos" section="Dataset" label="Traspoñer os datos"
    context="gui">

    <description>
      <para>
	Traspón o conxunto vixente de datos. É dicir, cada observación (fila)
	do conxunto vixente de datos vaise tratar como unha variable (columna),
	e cada variable como unha observación. Esta instrución pode resultar
	útil cando se len os datos dalgunha orixe externa, na que as filas
	da táboa de datos representan variables.
      </para>
      <para>
	Consulta tamén <cmdref targ="dataset"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos/Traspoñer datos</menu-path>
    </gui-access>

  </command>

  <command name="tsls" section="Estimation"
    label="Regresión con Variables Instrumentais">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	      <argument separated="true">instrumentos</argument>
      </arguments>
      <options>
        <option>
	  <flag>--no-tests</flag>
	  <effect>Non fai probas de diagnose</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
	      </option>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>Sen corrección dos graos de liberdade</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Desvíos padrón agrupados</effect>
        </option>
        <option>
	  <flag>--matrix-diff</flag>
	  <effect>Calcula a proba de Hausman mediante diferenza de matrices</effect>
        </option>
        <option>
	  <flag>--liml</flag>
	  <effect>Utiliza Máxima Verosimilitude con Información Limitada</effect>
        </option>
        <option>
	  <flag>--gmm</flag>
	  <effect>Utiliza o Método Xeneralizado dos Momentos</effect>
        </option>
      </options>
      <examples>
        <example>tsls y1 0 y2 y3 x1 x2 ; 0 x1 x2 x3 x4 x5 x6</example>
	<demos>
		<demo>penngrow.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Calcula as estimacións de Variables Instrumentais (VI), utilizando por
	defecto Mínimos Cadrados en 2 Etapas (TSLS), pero mira máis abaixo para
	outras opcións. A variable dependente é <repl>depvar</repl>, mentres
	que <repl>indepvars</repl> expresa unha lista de regresores (presuponse
	que inclúe cando menos unha variable endóxena), e <repl>instrumentos</repl>
	indica unha lista de instrumentos (variables esóxenas e/ou predeterminadas).
	Se a lista <repl>instrumentos</repl> non é cando menos tan longa como
	<repl>indepvars</repl>, o modelo non está identificado.
      </para>

      <para context="cli">
	No exemplo de arriba, as <lit>y</lit>s son as variables endóxenas e
	as <lit>x</lit>s son as variables esóxenas. Cae na conta de que os
	regresores esóxenos deben de aparecer en ambas listas.
      </para>
      <para context="cli">
	Para obter máis detalles en relación aos efectos das opcións
	<opt>robust</opt> e <opt>cluster</opt>, consulta a axuda para
	<cmdref targ="ols"/>.
      </para>

      <para context="gui">
	A instrución require que se seleccionen 2 listas de variables:
	as variables independentes que aparecen no modelo indicado e
	un conxunto de instrumentos. Ten en conta que calquera regresor
	esóxeno debe de aparecer en ambas listas.
      </para>
      <subhead>Probas específicas para MC2E</subhead>
      <para>
	O resultado das estimacións de Mínimos Cadrados en 2 Etapas inclúen
	a proba de Hausman e (se o modelo está sobreidentificado) a proba de
	sobreidentificación de Sargan. Para unha boa explicación das dúas
	probas, consulta o capítulo 8 de
	<cite key="davidson-mackinnon04">Davidson e MacKinnon (2004)</cite>.
      </para>
      <para>
	Na proba de Hausman, a hipótese nula é que as estimacións MCO
	son consistentes ou, noutras palabras, que a estimación por medio
	de variables instrumentais en realidade non se necesita. Por
	defecto, esta proba aplícase polo método de regresión pero se
	indicas a opción <opt>matrix-diff</opt> utilízase o método de
	<cite key="papadopoulos23">Papadopoulos (2023)</cite>. Nos dous
	casos podes empregar unha variante robusta se indicas a opción
	<opt>robust</opt>.
      </para>
      <para>
	Un modelo desta clase está sobreidentificado se hai máis instrumentos
	dos estritamente requiridos. A proba de sobreidentificación
	de Sargan <cite key="sargan58" p="true">(Sargan, 1958)</cite>
	baséase nunha regresión auxiliar dos erros da estimación do modelo,
	mediante Mínimos Cadrados en 2 Etapas sobre a lista completa
	de instrumentos. A hipótese nula sostén que todos os instrumentos
	son válidos; pero sospéitase da validez desta hipótese se a
	regresión auxiliar ten un grao de poder explicativo que é
	significativo.
      </para>
      <para>
	Estes estatísticos están dispoñibles despois da conclusión satisfactoria
	da instrución, cos nomes <fncref targ="$hausman"/> e
	<fncref targ="$sargan"/> (se é aplicable), respectivamente.
      </para>
      <subhead>Instrumentos débiles</subhead>
      <para>
	Tanto para MC2E (TSLS) como para a estimación MVIL (LIML), amósase
	o resultado dunha proba adicional, posto que o modelo estímase baixo
	o suposto de perturbacións IID (é dicir, non se escolle a opción
	<opt>robust</opt>). Esta é unha proba da debilidade dos instrumentos,
	pois instrumentos débiles poden levar a serios problemas na regresión
	de VI: estimacións nesgadas e/ou tamaño incorrecto das probas de
	hipóteses baseadas na matriz de covarianzas, con taxas de rexeite
	que superan moito o nivel de significación nominal
	<cite key="stock-wright-yogo02" p="true">(Stock, Wright e Yogo, 2002)</cite>.
	O estatístico é o da proba <math>F</math> da primeira etapa se o
	modelo ten tan só un regresor endóxeno; se non, é o valor
	propio máis pequeno da matriz de contrapartida do <math>F</math> da
	primeira etapa. Amósanse os puntos críticos baseados na análise Monte
	Carlo de <cite key="stock-yogo03">Stock e Yogo (2003)</cite>, cando
	estean dispoñibles.
      </para>
      <subhead>R-cadrado</subhead>
      <para>
	O valor de R-cadrado que se presenta para modelos estimados mediante
	Mínimos Cadrados en 2 Etapas é o cadrado da correlación entre a variable
	dependente e a variable cos valores axustados.
      </para>
      <subhead>Estimadores alternativos</subhead>
      <para context="cli">
	Como alternativas a MC2E, o modelo pode estimarse mediante Máxima
	Verosimilitude con Información Limitada (opción <opt>liml</opt>) ou
	mediante o Método Xeneralizado dos Momentos (opción <opt>gmm</opt>).
	Cae na conta de que, se o modelo está simplemente identificado, estes
	métodos deberían xerar os mesmos resultados que MC2E; pero se está
	sobreidentificado, os resultados en xeral van diferir.
      </para>

      <para context="cli">
	Cando se escolle a estimación MXM (GMM), as seguintes opcións
	adicionais pasan a estar dispoñibles:
      </para>

      <ilist context="cli">
	<li>
	  <para>
	    <opt>two-step</opt>: Realiza MXM en 2 etapas en troques de facelo
	    en 1 etapa (por defecto).
	  </para>
	</li>
	<li>
	  <para>
	    <opt>iterate</opt>: Reitera MXM ata a converxencia.
	  </para>
	</li>
	<li>
	  <para>
	    <opt>weights=</opt><repl>Wmat</repl>: Especifica unha matriz cadrada de
	    ponderacións para utilizar cando se calcula a función do criterio MXM.
	    A dimensión desta matriz debe de ser igual ao número de instrumentos.
	    Por defecto, é unha matriz identidade de dimensión axeitada.
	  </para>
	</li>
      </ilist>

    </description>

    <gui-access>
      <menu-path>/Modelar/Variables Instrumentais</menu-path>
    </gui-access>

  </command>

  <command name="tsplots" section="Graphs"
	   label="Gráficas de múltiples series temporais">
    <usage>
      <arguments>
        <argument>listavar</argument>
      </arguments>
      <options>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nome</optparm>
	  <effect>Representa as columnas da matriz citada</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nomefich</optparm>
	  <effect>Envía o resultado ao ficheiro indicado</effect>
        </option>
      </options>
      <examples>
        <example>tsplots 1 2 3 4</example>
        <example>tsplots 1 2 3 4 --matrix=X</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Proporciona un xeito sinxelo de representar graficamente múltiples series
	temporais (ata un máximo de 16) nun único cadro. Podes indicar o
	argumento <repl>listavar</repl> como unha lista de números ID (ou de nomes
	de series), ou como números de columnas no caso de introducir unha matriz.
      </para>
      <para context="cli">
	Consulta tamén <cmdref targ="scatters"/> para ver formas de xerar
	múltiples gráficas de dispersión, e <cmdref targ="gridplot"/> para ver
	un xeito máis flexible de combinar gráficas nunha grella.
      </para>
      <para context="gui">
	Proporciona un xeito sinxelo de representar graficamente múltiples series
	temporais (ata un máximo de 16) nun único cadro. Consulta tamén
	<cmdref targ="scatters"/> para ver formas de xerar múltiples gráficas
	de dispersión, e <cmdref targ="gridplot"/> para ver un xeito máis
	flexible de combinar gráficas nunha grella.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Gráficas múltiples/Series Temporais</menu-path>
    </gui-access>
  </command>

  <command name="var" section="Estimation"
    label="Autorregresión de vectores (VAR)">

    <usage>
      <arguments>
        <argument>nivel</argument>
        <argument>ylista</argument>
	      <argument separated="true" optional="true">xlista</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>Sen constante</effect>
        </option>
        <option>
	  <flag>--trend</flag>
	  <effect>Con tendencia linear</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>Con variables ficticias estacionais</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
        <option>
	  <flag>--robust-hac</flag>
	  <effect>Desvíos padrón HAC</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non amosa os resultados das ecuacións individuais</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>Presenta as respostas ao impulso</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>Presenta as descomposicións da varianza</effect>
        </option>
        <option>
	  <flag>--lagselect</flag>
	  <effect>Amosa os criterios de selección de retardos</effect>
        </option>
        <option>
	  <flag>--minlag</flag>
	  <optparm>retardo mínimo</optparm>
	  <effect>Só selección de retardo, mira abaixo</effect>
        </option>
      </options>
      <examples>
        <example>var 4 x1 x2 x3 ; time mydum</example>
	<example>var 4 x1 x2 x3 --seasonals</example>
	<example>var 12 x1 x2 x3 --lagselect</example>
	<demos>
	  <demo>sw_ch14.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Esta instrución require a especificación de:
      </para>
      <ilist context="gui">
	<li><para context="gui">o nivel de retardos, é dicir, o número de
	    retardos de cada variable que debería de incluírse no sistema;
	    </para>
	</li>
	<li><para context="gui">calquera variable esóxena (pero ten en conta que se inclúe
	    unha constante automaticamente, agás que indiques outra cousa; podes engadir
	    unha tendencia usando o recadro de selección de tendencia; e podes engadir
	    variables ficticias estacionais usando o recadro de selección da estacionalidade); e
	    </para>
	</li>
	<li><para context="gui">unha lista de variables endóxenas, das que se inclúen
	    os seus retardos no lado dereito de cada ecuación. (Nota: Non inclúas
	    variables retardadas nesta lista, pois vanse engadir automaticamente).
	    </para>
	</li>
      </ilist>
      <para context="gui">
	Vaise executar unha regresión por separado para cada variable do sistema.
	O resultado para cada ecuación inclúe as probas F de restricións cero
	sobre todos os retardos de cada unha das variables; e unha proba F para
	o retardo máximo, xunto con (opcionalmente) as descomposicións da
	varianza de predición e as funcións de resposta ao impulso.
      </para>
      <para context="cli">
	Establece e estima (utilizando MCO) unha autorregresión de vectores
	(VAR). O primeiro argumento especifica o nivel de retardos (ou
	o nivel máximo de retardos, no caso de que indiques a opción
	<opt>lagselect</opt>, mira máis abaixo). O nivel podes indicalo
	numericamente ou co nome dunha variable escalar preexistente.
	A continuación segue a configuración da primeira ecuación. Non
	inclúas retardos entre os elementos de <repl>ylista</repl> pois
	vanse engadir automaticamente. O punto e coma vai separar as
	variables estocásticas (para as que se vai incluír un
	<repl>nivel</repl> de retardos) de calquera variable esóxena de
	<repl>xlista</repl>. Ten en conta que: (a) inclúese unha constante
	automaticamente (agás que indiques a opción <opt>nc</opt>),
	(b) podes engadir unha tendencia coa opción <opt>trend</opt>,
	e (c) podes engadir variables ficticias estacionais utilizando a
	opción <opt>seasonals</opt>.
      </para>
      <para context="cli">
	Mentres que unha especificación VAR habitualmente inclúe tódolos
	retardos desde 1 ata o máximo que indiques, tamén podes escoller un
	grupo de retardos. Para facer isto, substitúe o argumento rutineiro
	<repl>nivel</repl> (escalar), ben co nome dun vector xa definido
	previamente, ou ben cunha lista de retardos separados con comas e
	contornada entre chaves. Debaixo amósanse dous xeitos de especificar
	que un VAR debe de incluír os retardos 1, 2 e 4 (pero non o 3):
      </para>
      <code context="cli">
	var {1,2,4} ylista
	matrix p = {1,2,4}
	var p ylista
      </code>
      <para context="cli">
	Devólvese unha regresión por separado para cada unha das variables
	de <repl>ylista</repl>. Os resultados para cada ecuación inclúen as
	probas <math>F</math> para restricións cero en todos os retardos
	de cada unha das variables, unha proba <math>F</math> sobre a
	significación do retardo máximo e, cando especificas a opción
	<opt>impulse-responses</opt>, as descomposicións da varianza da
	predición e as respostas ao impulso.
      </para>
      <para>
	As descomposicións da varianza da predición e as respostas ao
	impulso baséanse na descomposición de Cholesky da matriz de
	covarianzas contemporánea e, neste contexto, ten importancia a
	orde na que indicas as variables (estocásticas). Así, a primeira
	variable da lista asúmese que é a <quote>máis esóxena</quote>
	dentro do período. Podes establecer o horizonte para as
	descomposicións da varianza e as respostas ao impulso, utilizando
	a instrución <cmdref targ="set"/>. Para recuperar unha función
	concreta de resposta ao impulso en forma matricial, consulta a
	función <fncref targ="irf"/>.
      </para>
      <para context="cli">
	Cando indicas a opción <opt>robust</opt>, os desvíos padrón 
	corríxense do efecto da heterocedasticidade. Como alternativa, podes
	indicar a opción <opt>robust-hac</opt> para dar lugar a desvíos
	padrón que sexan robustos con respecto tanto á heterocedasticidade como
	á autocorrelación (HAC). En xeral, esta última corrección non debera
	de ser necesaria se o VAR inclúe un número suficiente de retardos.
      </para>
      <subhead context="cli">Selección de retardo</subhead>
      <para context="cli">
	Cando indicas a opción <opt>lagselect</opt>, non se vai presentar o
	resultado habitual do VAR. En troques, vaise tomar o primeiro argumento
	como nivel <emphasis>máximo</emphasis> de retardo, e a saída de
	resultados vai consistir nunha táboa que amosa cifras comparativas
	calculadas para VARs que van desde o nivel 1 (predeterminado) ata o
	máximo especificado. A táboa inclúe o logaritmo da verosimilitude e
	o valor <math>P</math> dunha proba de Razón de Verosimilitudes
	(RV ou LR), seguidos dos Criterios de Información de Akaike (AIC),
	de Schwarz (BIC) e de Hannan&ndash;Quinn (HQC). A proba RV (LR)
	compara a especificación da fila <math>i</math> coa da fila
	<math>i</math> &minus; 1, considerando como hipótese nula que
	tódolos parámetros engadidos na fila <math>i</math> teñen valores nulos.
	Podes recuperar a táboa cos resultados, en formato de matriz, mediante
	o accesorio <fncref targ="$test"/>.
      </para>
      <para>
	Unicamente no contexto da selección do retardo, podes usar a opción
	<opt>minlag</opt> para axustar o nivel mínimo de retardos. Fai que
	sexa 0 para permitir a posibilidade de que o nivel óptimo de retardos
	sexa cero (querendo isto dicir realmente que non se require un VAR
	para nada). Pola contra, poderías facer que <opt>minlag=4</opt> se
	cres que necesitas cando menos 4 retardos, de xeito que se aforre
	un pouco de tempo de cálculo.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Series temporais multivariantes</menu-path>
    </gui-access>

  </command>

  <command name="VAR-lagselect" section="Tests" context="gui"
    label="Selección da longura de retardos do VAR">

    <description>
      <para>
	Nesta caixa de diálogo, especifica un VAR como sempre, pero utiliza o botón (con
	frechas arriba/abaixo) do nivel de retardos, para indicar o número máximo a probar.
      </para>
      <para>
	O resultado consiste nunha táboa que amosa os valores dos criterios
	de información de Akaike (AIC), de Schwarz (BIC) e de
	Hannan&ndash;Quinn (HQC), calculados para VARs de niveis desde 1 ata
	o máximo elixido. Amais, o logaritmo da verosimilitude amósase para
	cada especificación, xunto co valor <math>P</math> dunha proba de
	Razón de Verosimilitudes sobre a hipótese nula de que tódolos parámetros
	engadidos na fila <math>i</math>, en relación cos da fila
	<math>i</math> &minus; 1, teñen valores nulos.
      </para>
      <para>
	Isto está pensado para axudar na selección do nivel óptimo do
	retardo.
      </para>
    </description>
  </command>

  <command name="VAR-omit" section="Tests" context="gui"
    label="Probar as variables esóxenas dun VAR">

    <description>
      <para>
	Utiliza esta caixa de diálogo para especificar un subconxunto de
	variables esóxenas dun VAR. Estas variables vanse quitar do VAR
	orixinal, e o sistema volve estimarse.
      </para>
      <para>
	Preséntase unha proba de Razón de Verosimilitudes, na que a hipótese
	nula é que os verdadeiros valores dos parámetros das variables omitidas
	son cero, en todas as ecuacións do VAR. A proba baséase na diferenza
	entre o logaritmo do determinante da matriz de varianzas do sistema
	sen restrinxir, e o do sistema restrinxido omitindo as variables elixidas.
      </para>
    </description>

  </command>

  <command name="varlist" section="Dataset"
    label="Listar as variables" context="cli">

    <usage>
      <options>
	<option>
	  <flag>--type</flag>
	  <optparm>nometipo</optparm>
	  <effect>Eido da listaxe</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Por defecto, presenta unha listaxe das series do conxunto vixente de
	datos (se hai algunha); e podes utilizar <cmd>ls</cmd> como alcume.
      </para>
      <para>
	Cando indicas a opción <opt>type</opt>, debe de ir seguida (despois
	dun signo de igualdade) por un dos seguintes tipos: <lit>series</lit>,
	<lit>scalar</lit>, <lit>matrix</lit>, <lit>list</lit>, <lit>string</lit>,
	<lit>bundle</lit>, <lit>array</lit> ou <lit>accessor</lit>. O seu
	efecto consiste en presentar os nomes de tódolos obxectos do tipo
	indicado que estean definidos nese
	momento.
      </para>
      <para>
	Como caso especial, se o tipo é <lit>accessor</lit>, os nomes
	que se presentan son aqueles das variables internas dispoñibles
	nese momento como <quote>accesorios</quote>, como poden ser
	<fncref targ="$nobs"/> e <fncref targ="$uhat"/> (sexan os que sexan
	os seus tipos concretos).
      </para>
    </description>

  </command>

  <command name="vartest" section="Tests" label="Probar a diferenza de varianzas">

    <usage>
      <altforms>
        <altform><lit>vartest</lit> <repl>x</repl> <repl>y</repl> </altform>
        <altform><lit>vartest</lit> <repl>x</repl> <lit>--split-by=</lit><repl>ficticia</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>Elimina a presentación de resultados</effect>
        </option>
        <option>
	  <flag>--robust</flag>
          <optparm>método</optparm>
	  <effect>Mira abaixo</effect>
        </option>
      </options>
      <examples>
        <example>vartest x y</example>
        <example>meantest x --split-by=d</example>
        <example>meantest x y --robust=median</example>
        <example>meantest x y --robust=trimmed,5</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	No seu uso básico, calcula o estatístico <math>F</math> para probar
	a hipótese nula de que as varianzas poboacionais son iguais para as
	series <repl>x</repl> e <repl>y</repl>, e amosa un resultado que
	inclúe a súa probabilidade asociada (valor p). Os resultados se
	poden recuperar utilizando os accesorios <fncref targ="$test"/> e
	<fncref targ="$pvalue"/>, en cuxo caso pódese utilizar a opción
	<opt>quiet</opt> para omitir a impresión.
      </para>
      <para>
	Por exemplo, o seguinte código:
      </para>
      <code>
		open AWM18.gdt
		vartest EEN EXR
		eval $test
		eval $pvalue
      </code>
    <para>
	proporciona o resultado que se amosa abaixo:
  	</para>
  	  <code>
		Proba de igualdade de varianzas

		EEN: Número de observacións = 192
		EXR: Número de observacións = 188
		Cociente entre varianzas mostrais = 3.70707
		Hipótese nula: As dúas varianzas das poboacións son iguais
		Estatístico de proba: F(191,187) = 3.70707
		valor p (con dúas colas) = 1.94866e-18

		3.7070716
		1.9486605e-18
	    </code>
      <para context="cli">
	Na súa forma alternativa, coa opción <opt>split-by</opt>, as mostras
	para as que se proba a igualdade das súas varianzas son dous subconxuntos
	da serie <repl>x</repl>, para as que a serie <repl>ficticia</repl>
	toma os valores 0 e 1, respectivamente.
      </para>

      <subhead context="cli">Probas robustas</subhead>
      <para context="cli">
	A proba <math>F</math> típica baséase no suposto de Normalidade
	e pode provocar en exceso o rexeite da hipótese nula se os datos
	realmente son Non-Normais. A opción <opt>robust</opt> ofrece tres
	alternativas, do seguinte xeito:
      </para>
      <ilist context="cli">
        <li>
          <para>
            Cando <repl>método</repl> é <lit>mean</lit>: a proba definida
            por <cite key="levene60">Levene (1960)</cite>. En realidade
            isto é un ANOVA dun factor que usa os desvíos absolutos
            dos datos orixinais respecto das súas respectivas medias mostrais.
          </para>
        </li>
        <li>
          <para>
            Cando <repl>método</repl> é <lit>median</lit>: unha variante
            da proba de Levene suxerida por
            <cite key="brown-forsythe">Brown e Forsythe (1974)</cite>,
            na que o centrado inicial utiliza a mediana mostral en
            troques da media. Isto recoméndase cando os datos
            están bastante nesgados.
          </para>
        </li>
        <li>
          <para>
            Cando <repl>método</repl> é <lit>trimmed</lit>: unha segunda
            variante debida a Brown e Forsythe, na que o centrado é
            respecto a unha media recortada. Isto pode ser preferible se
            os datos teñen colas grosas pero son razoablemente simétricos.
            Por defecto, utilízase o recorte do 10 por cento (é dicir,
            calcúlase a media despois de omitir o 10 por cento das
            observacións con menores valores e con maiores valores) pero
            isto pódese axustar engadindo unha coma e un valor enteiro,
            como en <opt>robust=trimmed,5</opt> onde se especifica que
            se recorta o 5 por cento.
          </para>
        </li>
      </ilist>
      <para context="gui">
	Calcula o estatístico <math>F</math> para probar a hipótese nula de
	que as varianzas poboacionais das dúas series elixidas son iguais, e
	amosa a súa probabilidade asociada (valor p).
      </para>
    </description>

    <gui-access>
      <menu-path>/Ferramentas/Calculadora de probas</menu-path>
    </gui-access>

  </command>

  <command name="vecm" section="Estimation"
    label="Modelo de Vectores de Corrección do Erro">

    <usage>
      <arguments>
        <argument>nivel</argument>
        <argument>rango</argument>
        <argument>ylista</argument>
	     <argblock optional="true" separated="true">
	      <argument>xlista</argument>
	     </argblock>
	     <argblock optional="true" separated="true">
	      <argument>rxlista</argument>
	     </argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>Sen constante</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>Constante restrinxida</effect>
        </option>
        <option>
	  <flag>--uc</flag>
	  <effect>Constante non restrinxida</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>Constante e tendencia restrinxida</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>Constante e tendencia non restrinxida</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>Inclúe variables ficticias estacionais centradas</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non amosa os resultados das ecuacións individuais</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>Non presenta nada</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>Presenta as respostas ao impulso</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>Presenta as descomposicións da varianza</effect>
        </option>
      </options>
      <examples>
        <example>vecm 4 1 Y1 Y2 Y3</example>
        <example>vecm 3 2 Y1 Y2 Y3 --rc</example>
	<example>vecm 3 2 Y1 Y2 Y3 ; X1 --rc</example>
	<demos>
	  <demo>denmark.inp</demo>
	  <demo>hamilton.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Un VECM é unha forma de autorregresión de vectores ou VAR (consulta
	<cmdref targ="var"/>), aplicable cando as variables do modelo son
	individualmente integradas de orde 1 (polo tanto son paseos aleatorios,
	con ou sen deriva) pero presentan cointegración. Esta instrución está
	intimamente relacionada coa proba de cointegración de Johansen
	(consulta <cmdref targ="johansen"/>).
      </para>
      <para context="cli">
	O parámetro <repl>nivel</repl> desta instrución representa o nivel de
	retardos do sistema VAR. O número de retardos no propio VECM (onde a
	variable dependente se indica como unha primeira diferenza) é de un
	menos ca <repl>nivel</repl>.
      </para>
      <para context="gui">
	O nivel de retardos escollido na caixa de diálogo do VECM é o do sistema
	VAR. O número de retardos no propio VECM (onde a variable dependente
	indícase como unha primeira diferenza) é de un menos ca ese número.
      </para>
      <para context="cli">
	O parámetro <repl>rango</repl> representa o rango de cointegración
	ou, noutras palabras, o número de vectores cointegrantes. Este debe
	de ser maior ca cero, e menor ou igual (xeralmente menor) que o número
	de variables endóxenas indicadas en <repl>ylista</repl>.
      </para>
      <para context="gui">
	O <quote>rango</quote> representa o número de vectores
	cointegrantes. Este debe de ser maior ca cero, e menor ou
	igual (xeralmente menor) que o número de variables endóxenas
	escollidas.
      </para>
      <para context="cli">
	O argumento <repl>ylista</repl> proporciona a lista de variables
	endóxenas, expresadas en niveis. A inclusión de termos de tipo
	determinístico no modelo, contrólase cos indicadores de opción.
	Por defecto, cando non indicas ningunha opción, inclúese unha
	<quote>Constante non restrinxida</quote>, o que permite que haxa
	unha ordenada na orixe non nula nas relacións de cointegración,
	así como unha tendencia nos niveis das variables endóxenas. A
	literatura derivada do traballo de Johansen (por exemplo, podes
	consultar o seu libro de 1995) habitualmente refírese a isto como
	o <quote>caso 3</quote>. As primeiras 4 opcións indicadas arriba
	(mutuamente excluíntes) xeran os casos 1, 2, 4 e 5, respectivamente.
	Os significados destes casos e os criterios que se usan para escoller
	un caso, explícanse no <guideref targ="chap:vecm"/>.
      </para>
      <para context="cli">
	As listas (opcionais) <repl>xlista</repl> e <repl>rxlista</repl> te
	permiten especificar conxuntos de variables esóxenas que forman
	parte do modelo, ben sen restricións (<repl>xlista</repl>) ou ben
	restrinxidas ao espazo de cointegración (<repl>rxlista</repl>). Estas
	listas sepáranse de <repl>ylista</repl> e unhas das outras, mediante
	punto e coma.
      </para>
      <para context="gui">
	No cadriño <quote>Variables endóxenas </quote> podes escoller
	o vector de variables endóxenas, expresadas en niveis. A inclusión
	de termos de tipo determinístico no modelo contrólase mediante
	o botón da caixa de opcións. Por defecto, inclúese unha
	<quote>Constante non restrinxida</quote>, o que permite que haxa
	unha ordenada na orixe non nula nas relacións de cointegración, así
	como unha tendencia nos niveis das variables endóxenas. A literatura
	derivada do traballo de Johansen (por exemplo, consulta o seu libro
	de 1995) habitualmente refírese a isto como o <quote>caso 3</quote>.
	As outras 4 opcións xeran os casos 1, 2, 4 e 5, respectivamente. Os
	significados destes casos e os criterios que se usan para escoller
	un caso, explícanse no <guideref targ="chap:vecm"/>.
      </para>
      <para context="gui">
	No cadriño <quote>Variables esóxenas</quote> podes engadir determinadas
	variables esóxenas. Por defecto, estas entran no modelo de forma non
	restrinxida (indicada cun <lit>U</lit> á beira do nome da variable).
	Se queres que unha determinada variable esóxena estea restrinxida ao
	espazo de cointegración, preme un clic co botón dereito do rato sobre
	ela e selecciona <quote>Restrinxida</quote> no menú emerxente. Entón
	o símbolo á beira da variable vai trocarse en R.
      </para>
      <para context="cli">
	A opción <opt>seasonals</opt>, que podes combinar con calquera das
	outras opcións, especifica a inclusión dun conxunto de variables
	ficticias estacionais centradas. Esta opción unicamente está dispoñible
	para datos trimestrais ou mensuais.
      </para>
      <para context="gui">
	Se os datos son trimestrais ou mensuais, amósase un cadro de verificación que
	te permite incluír un conxunto de variables ficticias estacionais centradas. En
	todos os casos, outro cadriño de verificación (<quote>Amosar os detalles das regresións</quote>)
	permite presentar as regresións auxiliares que forman o punto de
	inicio do procedemento de estimación Máximo Verosímil de Johansen.
      </para>
      <para context="cli">
	O primeiro exemplo de arriba especifica un VECM, cun nivel de retardos de 4 e
	un único vector de cointegración. As variables endóxenas son <lit>Y1</lit>,
	<lit>Y2</lit> e <lit>Y3</lit>. O segundo exemplo usa as mesmas variables pero
	especifica un nivel de retardos de 3, e dous vectores de cointegración; tamén
	especifica unha <quote>Constante restrinxida</quote>, que é adecuada cando
	os vectores de cointegración poden ter ordenada na orixe non nula pero as
	variables <lit>Y</lit> non teñen tendencia.
      </para>
      <para context="cli">
	A continuación da estimación dun VECM, tes dispoñibles algúns accesorios
	especiais: <lit>$jalpha</lit>, <lit>$jbeta</lit> e <lit>$jvbeta</lit>
	recuperan as matrices &agr; e &bgr;, e a varianza estimada de &bgr;,
	respectivamente. Para recuperar a función de resposta ante un impulso
	determinado, en forma de matriz, consulta a función
	<fncref targ="irf"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Series temporais multivariante</menu-path>
    </gui-access>

  </command>

  <command name="vif" section="Tests" context="cli"
    label="Factores de Inflación da Varianza">
    <usage>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>Non presenta nada</effect>
        </option>
      </options>
	  <examples>
	<demos>
	  <demo>longley.inp</demo>
	</demos>
    </examples>
    </usage>

    <description>
      <para>
	Debe de ir despois da estimación dun modelo que inclúa cando
	menos 2 variables independentes. Calcula e amosa información de
	diagnóstico relacionada coa multicolinearidade.
      </para>
      <para>
	O Factor de Inflación da Varianza (FIV) do regresor <math>j</math>
	defínese como <equation status="display" tex="\[\frac{1}{1-R_j^2}\]"
	ascii="1/(1 - Rj^2)" graphic="vif"/>
	onde <math>R</math><sub>j</sub> é o coeficiente de correlación
	múltiple entre ese regresor <math>j</math> e os demais regresores.
	O factor ten un valor mínimo de 1.0 cando a variable en cuestión
	é ortogonal con respecto ás outras variables independentes.
	<cite key="neter-etal90">Neter, Wasserman e Kutner (1990)</cite>
	suxiren revisar o valor máis grande dos FIV, para diagnosticar
	un alto grao de multicolinearidade; así, un valor maior ca 10 
	considérase ás veces indicativo dun grao de multicolinearidade
	problemático.
      </para>
      <para>
	Despois de utilizar esta instrución, podes usar o accesorio
	<fncref targ="$result"/> para obter un vector columna que inclúa
	os FIV. Para ter un enfoque máis sofisticado para diagnosticar a
	multicolinearidade, consulta a instrución <cmdref targ="bkw"/>.
      </para>
    </description>
    <gui-access>
      <menu-path>Xanela de modelo: Análise/Multicolinearidade</menu-path>
    </gui-access>

  </command>

  <command name="wls" section="Estimation"
    label="Mínimos Cadrados Ponderados">

    <usage>
      <arguments>
        <argument>varponder</argument>
        <argument>depvar</argument>
	      <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta a matriz de covarianzas</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desvíos padrón robustos</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Non presenta os resultados</effect>
        </option>
	<option>
	  <flag>--allow-zeros</flag>
	  <effect>Mira abaixo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Calcula as estimacións de mínimos cadrados ponderados (MCP, WLS)
	utilizando <repl>varponder</repl> como ponderación, <repl>depvar</repl>
	como variable dependente e <repl>indepvars</repl> como lista de
	variables independentes. Sexa <repl>w</repl> a raíz cadrada positiva
	de <lit>varponder</lit>, entón MCP é basicamente equivalente á
	regresión MCO de <repl>w</repl> <lit>*</lit> <repl>depvar</repl>
	sobre <repl>w</repl> <lit>*</lit> <repl>indepvars</repl>. Porén,
	o <emphasis>R</emphasis>-cadrado calcúlase de xeito especial,
	concretamente como
	<equation status="display"
	  tex="\[R^2 = 1 - \frac{\rm ESS}{\rm WTSS}\]"
	  ascii="R^2 = 1 - ESS / WTSS"
	  graphic="wlsr2"/>
	onde ESS é a suma de erros cadrados da regresión ponderada, e WTSS
	denota a <quote>Suma de cadrados totais ponderados</quote>, que é
	igual á suma de erros cadrados da regresión da variable dependente
	ponderada sobre unicamente a constante ponderada.
      </para>
      <para context="cli">
	Como caso especial, se <repl>varponder</repl> é unha variable ficticia
	0/1, a estimación MCP (WLS) é equivalente a MCO (OLS) nunha mostra na
	que se exclúen todas as observacións que teñen un valor de cero para
	<repl>varponder</repl>. Pola contra, a inclusión de ponderacións iguais
	a cero se considera un fallo, pero se realmente desexas mesturar
	ponderacións iguais a cero con ponderacións positivas, podes engadir
	a opción <opt>allow-zeros</opt>.
      </para>
      <para context="cli">
	Para aplicar a estimación de Mínimos Cadrados Ponderados a datos
	de panel, baseada nas varianzas do erro específico de cada unidade,
	consulta a instrución <cmdref targ="panel"/> xunto coa opción
	<opt>unit-weights</opt>.
	    </para>
      <para context="gui">
	Sexa 'varponder' a variable escollida no cadriño 'Variable de ponderacións'.
	Execútase unha regresión MCO, onde a variable dependente é o produto
	da raíz cadrada positiva de 'varponder' e a variable dependente elixida,
	e as variables independentes se multiplican tamén pola raíz cadrada
	de 'varponder'. Os estatísticos como <emphasis>R</emphasis>-cadrado
	baséase nos datos ponderados. Se 'varponder' é unha variable ficticia,
	a estimación de mínimos cadrados ponderados é equivalente á que
	resulta ao eliminar todas as observacións que teñen un valor de cero
	para 'varponder'.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelar/Outros Modelos Lineais/Mínimos Cadrados Ponderados</menu-path>
    </gui-access>

  </command>

  <command name="workdir" section="Utilities" label="Cartafol de traballo"
    context="gui">

    <description>
      <para>
	O cartafol de traballo (ou <quote>workdir</quote>) é onde GRETL fai
	a procura por defecto ao ler ou escribir ficheiros de datos ou guións,
	mediante os diálogos 'Abrir ficheiro de datos' e 'Gardar datos'.
	Ademais, é a localización por defecto para
      </para>
      <ilist>
	<li>
	  <para>
	    ler ficheiros mediante instrucións tales como <lit>append</lit>,
	    <lit>open</lit>, <lit>run</lit> e <lit>include</lit>;
	    e
	  </para>
	</li>
	<li>
	  <para>
	    escribir ficheiros mediante instrucións tales como <lit>eqnprint</lit>,
	    <lit>tabprint</lit>, <lit>gnuplot</lit>, <lit>outfile</lit>
	    e <lit>store</lit>.
	  </para>
	</li>
      </ilist>
      <para>
	Podes determinar o cartafol de traballo dun destes dous xeitos:
	(a) utilizando o diálogo ao que se accede mediante o elemento
	<quote>Cartafol de traballo</quote> no menú Ficheiro, ou (b)
	usando a instrución <cmdref targ="set"/>, como en
      </para>
      <code>
	set workdir /ruta/a/unsitio
      </code>
      <para>
	Podes revisar o valor vixente da variable <lit>workdir</lit> no
	diálogo que se acaba de mencionar, ou mediante a instrución
      </para>
      <code>
	eval $workdir
      </code>
      <para>
	Por defecto, o valor de <lit>workdir</lit> mantense ao longo das sesións
	de GRETL. Porén, os usuarios que queiran traballar co indicador de
	instrucións (lanzando GRETL desde unha xanela dun terminal) poden
	preferir ter o cartafol de traballo determinado automaticamente,
	desde o principio, como cartafol vixente (de acordo co intérprete).
	Podes escoller esta opción no diálogo ou mediante a instrución
      </para>
      <code>
	set use_cwd on
      </code>
      <para>
	(<quote>cwd</quote> = cartafol de traballo vixente).
      </para>
      <para>
	O diálogo do cartafol de traballo tamén te permite determinar o
	comportamento do selector de ficheiros da Interface Gráfica de Usuario
	(GUI). Así, se abres ou gardas un ficheiro nun determinado cartafol, o
	selector debe de lembralo e volver ao mesmo cartafol na seguinte solicitude?
	Ou o selector debe de visitar sempre o cartafol de traballo elixido?
      </para>
    </description>

    <gui-access>
      <menu-path>/Ficheiro/Cartafol de traballo</menu-path>
    </gui-access>

  </command>

  <command name="x12a" section="Utilities" context="gui"
    label="ARIMA X-12">

    <description>
      <para>
	Aquí hai dúas opcións para proceder, controladas polo conxunto
	que te ofrece o botón inferior de selección.
      </para>
      <para>
	Se escolles <quote>Executar directamente ARIMA-X-12 </quote> entón
	GRETL escribe un ficheiro de instrucións para ARIMA X-12, e solicita
	que o programa 'x12a' execute as instrucións. Neste caso, tes a
	posibilidade de xerar unha gráfica, e/ou gardar series escollidas do
	resultado no conxunto de datos de GRETL.
      </para>
      <para>
	Se escolles <quote>Preparar un ficheiro de instrucións de ARIMA X-12</quote>,
	GRETL escribe un ficheiro de instrucións para ARIMA X-12 (igual que no
	caso de arriba), pero entón abre este ficheiro nunha xanela do editor.
	Nesta xanela podes facer cambios e gardar o ficheiro co nome que ti
	elixas. Tamén podes enviar o ficheiro para que o execute 'x12a' (premendo
	un clic no botón <quote>Executar</quote> na barra de ferramentas da
	xanela do editor) e comprobar o resultado. Pero neste caso, non tes a
	posibilidade de gardar os datos como series, nin de xerar unha gráfica
	de GRETL.
      </para>
    </description>

  </command>

  <command name="xcorrgm" section="Statistics" label="Correlograma cruzado">

    <usage>
      <arguments>
        <argument>serie1</argument>
        <argument>serie2</argument>
        <argument optional="true">nivel</argument>
      </arguments>
      <options>
       <option>
	  <flag>--plot</flag>
	  <optparm>modo-ou-nomeficheiro</optparm>
	  <effect>Mira abaixo</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>Omite a presentación do resultado</effect>
        </option>
      </options>
      <examples>
        <example>xcorrgm x y 12</example>
      </examples>
    </usage>

    <description>
      <para>
	Presenta e/ou debuxa o correlograma cruzado de <repl>serie1</repl>
	con <repl>serie2</repl>, as que podes especificar mediante os seus
	nomes ou os seus números. Os valores son os coeficientes de
	correlación na mostra entre o valor vixente de <repl>serie1</repl>
	e os sucesivos adiantos e retardos de
	<repl>serie2</repl>.
      </para>
      <para>
	Se especificas un valor para <repl>nivel</repl>, a longura do
	correlograma cruzado limítase a ese número de adiantos e retardos
	(cando menos); se non, a longura determínase de forma
	automática en función da frecuencia dos datos e do número de
	observacións.
      </para>
      <para>
	Por defecto, cando GRETL non está en modo de procesamento por lotes,
	amósase unha gráfica do correlograma cruzado. Podes axustar isto
	mediante a opción <opt>plot</opt>. Os parámetros admisibles para esta
	opción son <lit>none</lit> (para omitir a gráfica), <lit>display</lit>
	(para xerar unha gráfica Gnuplot aínda que sexa en modo de procesamento
	por lotes), ou un nome de ficheiro. O efecto de proporcionar un
	nome de ficheiro é como se describiu para a opción <opt>output</opt>
	da instrución <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Correlograma cruzado</menu-path>
      <other-access>Xanela principal: Menú emerxente (tras selección múltiple)</other-access>
    </gui-access>

  </command>

  <command name="xtab" section="Statistics" label="Tabulación cruzada de variables">

    <usage>
      <arguments>
        <argument>listay</argument>
	      <argument optional="true" separated="true">listax</argument>
      </arguments>
      <options>
        <option>
	  <flag>--row</flag>
	  <effect>Amosa as porcentaxes de fila</effect>
        </option>
        <option>
	  <flag>--column</flag>
	  <effect>Amosa as porcentaxes de columna</effect>
        </option>
        <option>
	  <flag>--zeros</flag>
	  <effect>Amosa un cero nas entradas nulas</effect>
        </option>
        <option>
	  <flag>--no-totals</flag>
	  <effect>Elimina a presentación dos recontos marxinais</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nomematr</optparm>
	  <effect>Usa as frecuencias da matriz indicada</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Suprime a presentación de resultados</effect>
        </option>
	      <option>
	  <flag>--tex</flag>
	  <optparm optional="true">nomeficheiro</optparm>
	  <effect>Saída como &latex;</effect>
	      </option>
	      <option>
	  <flag>--equal</flag>
	  <effect>Consulta o caso &latex; debaixo</effect>
	      </option>
      </options>
      <examples>
	<example>xtab 1 2</example>
	<example>xtab 1 ; 2 3 4</example>
	<example>xtab --matrix=A</example>
	<example>xtab 1 2 --tex="xtab.tex"</example>
	<demos>
	  <demo>ooballot.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="cli">
      <para>
	Indicando unicamente o argumento <repl>listay</repl>, calcula (e
	presenta por defecto) unha táboa de continxencia ou unha tabulación
	cruzada para cada combinación das variables incluídas nesa lista.
	Cando indicas unha segunda lista (<repl>listax</repl>), cada variable
	de <repl>listay</repl> crúzase nunha táboa por fila fronte a cada
	variable de <repl>listax</repl> (por columna). Podes referirte ás
	variables destas listas mediante os seus nomes ou os seus números.
	Ten en conta que todas as variables teñen que estar marcadas como
	discretas. Como alternativa, cando indicas a opción <opt>matrix</opt>,
	se trata a matriz indicada como un conxunto calculado previamente de
	frecuencias a presentar como tabulación cruzada (consulta tamén a
	función <fncref targ="mxtab"/>). Neste caso deberás de omitir o
	argumento <repl>list</repl>.
      </para>
      <para>
	Por defecto, a anotación de cada cela indica o reconto da frecuencia de
	casos. As opcións <opt>row</opt> e <opt>column</opt> (que se exclúen
	mutuamente) substitúen os recontos coas porcentaxes para cada fila
	ou columna, respectivamente. Por defecto, as celas cun reconto de
	cero casos déixanse en branco, mais a opción <opt>zeros</opt> ten
	como efecto a presentación explícita dos ceros, o que pode serche
	útil para importar a táboa con un outro programa tal como unha folla
	de cálculo.
      </para>
      <para>
	A proba de independencia khi-cadrado de Pearson amósase se a
	frecuencia agardada baixo independencia é cando menos de 1.0e-7
	para todas as celas. Unha regra xeral habitual da validez deste
	estatístico é que, polo menos o 80 por cento das celas deben de
	ter frecuencias agardadas iguais a 5 ou máis; e se este criterio
	non se cumpre, preséntase unha advertencia.
      </para>
      <para>
	Se unha táboa de continxencia é 2 por 2, amósase a Proba Exacta de
	independencia de Fisher. Cae na conta de que esta proba baséase no
	suposto de que os totais por fila e por columna son fixos, o que pode
	ser ou non ser adecuado dependendo de como se xeraron os datos. Debes
	de utilizar a probabilidade asociada (valor p) da esquerda cando a hipótese
	alternativa á de independencia é a asociación negativa (os valores tenden
	a agruparse nas celas de abaixo á esquerda, e de arriba á dereita); e
	debes de utilizar o valor p da dereita se a alternativa é a asociación
	positiva. O valor p de dúas colas para esta proba calcúlase mediante o
	método (b) da sección 2.1 de <cite key="agresti92">Agresti (1992)</cite>:
	isto é a suma das probabilidades de todas as táboas posibles que teñan
	os totais de filas e columnas indicados, e que teñan unha probabilidade
	non maior á da táboa observada.
      </para>

      <subhead>O caso bivariante</subhead>
      <para>
	No caso dunha tabulación cruzada bivariante (cando se indica tan
	só unha lista que ten dous elementos) gárdanse algúns resultados.
	Podes recuperar a táboa de continxencia en forma de matriz mediante
	o accesorio <fncref targ="$result"/>. Amais, se se cumpre a condición
	do valor agardado, podes recuperar o estatístico da proba khi-cadrado
	de Pearson e a súa probabilidade asociada (valor p) mediante os
	accesorios <fncref targ="$test"/> e <fncref targ="$pvalue"/>. Se
	estes son os resultados que te interesan, podes utilizar a opción
	<opt>quiet</opt> para eliminar a presentación habitual de resultados.
      </para>

      <subhead>Saída &latex;</subhead>
      <para>
	Cando indicas a opción <opt>tex</opt>, a tabulación cruzada se
	presenta co formato dun contorno <lit>tabular</lit> &latex; en
	liña (de onde podería copiarse e pegarse) ou, cando se engade
	o parámetro <repl>nomeficheiro</repl>, envíase ao ficheiro aí
	indicado. (Se en <repl>nomeficheiro</repl> non se especifica
	unha ruta completa, o ficheiro escríbese no directorio vixente
	establecido, <cmdref targ="workdir"/>.) Non se calcula ningún
	estatístico de proba. Podes utilizar <opt>equal</opt> como
	opción adicional para sinalar (mostrado en letra grosa) o reconto
	ou porcentaxe de celas nas que as variables da fila e columna
 	teñen o mesmo valor numérico. Esta opción ignórase agás que
	indiques a opción <opt>tex</opt>; e tamén cando unha ou as dúas
	variables da tabulación cruzada teña valores de cadea de texto.
      </para>
    </description>

    <description context="gui">
      <para>
	Amosa unha táboa de continxencia ou unha tabulación cruzada para
	cada combinación das variables escollidas. Ten en conta que todas as
	variables deben de ser discretas.
      </para>
      <para>
	Por defecto, nas celas e nas marxes da táboa amósanse os valores que
	contan a frecuencia. Porén, podes escoller que se amosen no seu lugar
	as porcentaxes, ben por filas, ou ben por columnas.
      </para>
      <para>
	Por defecto, as celas cun reconto de cero casos amósanse como baldeiras,
	pero podes escoller que se amose explicitamente o valor cero.
      </para>
      <para>
	A proba de independencia khi-cadrado de Pearson amósase se a
	frecuencia agardada baixo independencia é cando menos de 1.0e-7
	para todas as celas. Unha regra xeral habitual da validez deste
	estatístico é que, polo menos o 80 por cento das celas, deben de
	ter frecuencias agardadas iguais a 5 ou máis; e se este criterio
	non se cumpre, preséntase unha advertencia.
      </para>
      <para>
	Se unha táboa de continxencia é 2 por 2, amósase a Proba Exacta
	de independencia de Fisher. Cae na conta de que esta proba baséase
	no suposto de que os totais por fila e por columna son fixos, o
	que pode ser ou non ser adecuado dependendo de como se xeraron
	os datos. Debes de utilizar a probabilidade asociada (valor p) da
	esquerda cando a hipótese alternativa á de independencia é a d
	asociación negativa (os valores tenden a agruparse nas celas de abaixo
	á esquerda e de arriba á dereita); e debes de utilizar o valor p da
	dereita se a alternativa é a de asociación positiva. O valor p de dúas
	colas para esta proba calcúlase mediante o método (b) da sección 2.1
	de <cite key="agresti92">Agresti (1992)</cite>: isto é a suma das
	probabilidades de todas as táboas posibles que teñan os totais de
	filas e columnas indicados, e que teñan unha probabilidade menor
	ou igual á da táboa observada.
      </para>
    </description>

  </command>

</commandref>
