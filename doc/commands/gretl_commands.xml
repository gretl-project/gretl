<?xml version="1.0"?>
<!DOCTYPE commandlist SYSTEM "gretl_commands.dtd">

<commandlist language="english">

<?PSGML NOFILL label code altforms altform menu-path equation other-access?>

  <command name="add" section="Tests" label="Add variables to model">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--lm</flag>
	  <effect>do an LM test, OLS only</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>print only the basic test result</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>don't print anything</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix for augmented model</effect>
	</option>
	<option>
	  <flag>--both</flag>
	  <effect>IV estimation only, see below</effect>
	</option>	
      </options>
      <examples>
        <example>add 5 7 9</example>
        <example>add xx yy zz --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Must be invoked after an estimation command. Performs a joint
	test for the addition of the specified variables to the last
	model, the results of which may be retrieved using the
	accessors <lit>$test</lit> and <lit>$pvalue</lit>.
      </para>
      <para context="cli">
	By default an augmented version of the original model is
	estimated, including the variables in <repl>varlist</repl>.
	The test is a Wald test on the augmented model, which replaces
	the original as the <quote>current model</quote> for the
	purposes of, for example, retrieving the residuals as
	<lit>$uhat</lit> or doing further tests.
      </para>
      <para context="cli">
	Alternatively, given the <opt>--lm</opt> option (available
	only for the models estimated via OLS), an LM test is
	performed. An auxiliary regression is run in which the
	dependent variable is the residual from the last model and the
	independent variables are those from the last model plus
	<repl>varlist</repl>. Under the null hypothesis that the added
	variables have no additional explanatory power, the sample
	size times the unadjusted R-squared from this regression is
	distributed as chi-square with degrees of freedom equal to the
	number of added regressors. In this case the original model is
	not replaced.
      </para>
      <para context="cli">
	The <opt>--both</opt> option is specific to two-stage
	least squares: it specifies that the new variables
	should be added both to the list of regressors and the
	list of instruments, the default in this case being to
	add to the regressors only.
      </para>
      <para context="gui">
	The selected variables are added to the previous model and the
	new model estimated. A test statistic for the joint
	significance of the added variables is printed, along with its
	p-value.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Add variables</menu-path>
    </gui-access>

  </command>

  <command name="addline" section="Graphs" label="Add line to graph"
    context="gui">

    <description>
      <para>
	This dialog box allows you to add a line, defined via a formula,
	to a graph.  The formula must be an expression acceptable to
	gnuplot.  Use <lit>x</lit> to denote the value of the variable on
	the x-axis.  Please note that gnuplot uses <lit>**</lit> for
	exponentiation (raising to a power), and that the decimal
	character must be given as <quote>.</quote>.  Examples:
      </para>
      <code>
	10+0.35*x
	100+5.3*x-0.12*x**2
	sin(x)
	exp(sqrt(pi*x))
      </code>
    </description>
  </command>

  <command name="adf" section="Tests" label="Augmented Dickey-Fuller test">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>test without a constant</effect>
	</option>
	<option>
	  <flag>--c</flag>
	  <effect>with constant only</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>with constant and trend</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>with constant, trend and trend squared</effect>
	</option>
	<option>
	  <flag>--seasonals</flag>
	  <effect>include seasonal dummy variables</effect>
	</option>
	<option>
	  <flag>--gls</flag>
	  <effect>de-mean or de-trend using GLS</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print regression results</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>use first difference of variable</effect>
	</option>
	<option>
	  <flag>--test-down</flag>
	  <effect>automatic lag order</effect>
	</option>
      </options>
      <examples>
	<example>adf 0 y</example>
        <example>adf 2 y --nc --c --ct</example>
        <example>adf 12 y --c --test-down</example>
	<demos>
	  <demo>jgm-1996.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">
	This command needs an integer lag order; if the order is zero a
	standard (not augmented) Dickey&ndash;Fuller test is run. Computes
	a set of Dickey&ndash;Fuller tests on the selected variable, the
	null hypothesis being that the variable has a unit root.  (But if
	the differencing option is selected, the first difference of the
	variable is taken prior to testing, and the discussion below must
	be taken as referring to the transformed variable.)	
      </para>

      <para context="cli">
	The options shown above and the discussion which follows pertain
	to the use of the <lit>adf</lit> command with regular time series
	data. For use of this command with panel data please see below.
      </para>

      <para context="cli">
	Computes a set of Dickey&ndash;Fuller tests on each of the the
	listed variables, the null hypothesis being that the variable in
	question has a unit root.  (But if the <opt>--difference</opt>
	flag is given, the first difference of the variable is taken prior
	to testing, and the discussion below must be taken as referring to
	the transformed variable.)
      </para>

      <para context="cli">
	By default, two variants of the test are shown: one based on a
	regression containing a constant and one using a constant and
	linear trend.  You can control the variants that are presented by
	specifying one or more of the option flags.
      </para>

      <para>
	In all cases the dependent variable is the first difference of the
	specified variable, <math>y</math>, and the key independent variable
	is the first lag of <math>y</math>.  The model is constructed so that
	the coefficient on lagged <math>y</math> equals the root in question
	minus 1. For example, the model with a constant may be written as
	<equation status="display"
	tex="\[(1-L)y_t=\beta_0+(\alpha-1)y_{t-1}+\epsilon_t\]"
	ascii="(1 - L)y(t) = b0 + (a-1)y(t-1) + e(t)"
	  graphic="adf1"/> Under the null hypothesis of a unit root the
	coefficient on lagged <math>y</math> equals zero; under the
	alternative that <math>y</math> is stationary this coefficient is
	negative.
      </para>

      <para context="cli">
	If the lag order, <math>k</math>, is greater than 0, then
	<math>k</math> lags of the dependent variable are included on
	the right-hand side of the test regressions.  If the order is
	given as &minus;1, <math>k</math> is set following the
	recommendation of <cite key="schwert89">Schwert (1989)</cite>,
	namely 12(<math>T</math>/100)<sup>0.25</sup>, where
	<math>T</math> is the sample size.  In either case, however,
	if the <opt>--test-down</opt> option is given then
	<math>k</math> is taken as the <emphasis>maximum</emphasis>
	lag and the actual lag order used is obtained by testing down,
	using this algorithm:
      </para>

      <para context="gui">
	If the lag order, <math>k</math>, is greater than 0, then
	<math>k</math> lags of the dependent variable are included
	on the right-hand side of the test regressions, subject to the
	following qualification. If the box labeled <quote>test down from
	  maximum lag</quote> is checked, the selected lag order is taken
	as a maximum and the actual lag order used is obtained by testing
	down, using this algorithm:
      </para>

      <nlist>
	<li><para>Estimate the Dickey&ndash;Fuller regression with
	    <math>k</math> lags of the dependent variable.
	  </para>
	</li>
	<li><para>Is the last lag significant?  If so, execute the
	    test with lag order <math>k</math>.  Otherwise, let
	    <math>k</math> = <math>k</math> &minus; 1; if
	    <math>k</math> equals 0, execute the test with lag order
	    0, else go to step 1.
	  </para>
	</li>
      </nlist>

      <para>In the context of step 2 above, <quote>significant</quote>
	means that the <math>t</math>-statistic for the last lag
	has an asymptotic two-sided <emphasis>p</emphasis>-value,
	against the normal distribution, of 0.10 or less.
      </para> 

      <para context="cli">
	The <opt>--gls</opt> option can be used in conjunction with
	one or other of the flags <opt>--c</opt> and <opt>--ct</opt>
	(the model with constant, or model with constant and trend).
	The effect of this option is that the de-meaning or
	de-trending of the variable to be tested is done using the GLS
	procedure suggested by <cite key="ERS96">Elliott,
	Rothenberg and Stock (1996)</cite>, which gives a test of
	greater power than the standard Dickey&ndash;Fuller approach.
	This option is not compatible with <opt>--nc</opt>,
	<opt>--ctt</opt> or <opt>--seasonals</opt>.
      </para>

      <para><emphasis>P</emphasis>-values for the Dickey&ndash;Fuller
      tests are based on <cite key="mackinnon96">MacKinnon
      (1996)</cite>.  The relevant code is included by kind permission
      of the author.  In the case of the test with linear trend using
      GLS these <emphasis>P</emphasis>-values are not applicable;
      critical values from Table 1 in <cite
      key="ERS96">Elliott, Rothenberg and Stock (1996)</cite>
      are shown instead.
      </para>

      <subhead context="cli">Panel data</subhead>

      <para context="cli">
	When the <lit>adf</lit> command is used with panel data, to
	produce a panel unit root test, the applicable options and the
	results shown are somewhat different.
      </para>
      <para context="cli">
	First, while you may give a list of variables for testing in
	the regular time-series case, with panel data only one
	variable may be tested per command. Second, the options
	governing the inclusion of deterministic terms become mutually
	exclusive: you must choose between no-constant, constant only,
	and constant plus trend; the default is constant only. In
	addition, the <opt>--seasonals</opt> option is not available.
	Third, the <opt>--verbose</opt> option has a different meaning:
	it produces a brief account of the test for each individual
	time series (the default being to show only the overall
	result).
      </para>
      <para context="cli">
	The overall test (null hypothesis: the series in question has
	a unit root for all the panel units) is calculated in one or
	both of two ways: using the method of <cite key="IPS03">Im,
	Pesaran and Shin (Journal of Econometrics, 2003)</cite> or that
	of <cite key="choi01">Choi (Journal of International Money and
	Finance, 2001)</cite>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Unit root tests/Augmented Dickey-Fuller test</menu-path>
    </gui-access>

  </command>

  <command name="anova" label="ANOVA" section="Statistics">
    <usage>
      <arguments>
        <argument>response</argument>
        <argument>treatment</argument>
        <argument optional="true">block</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't print results</effect>
	</option>
      </options>
    </usage>
    <description>
      <para>
	Analysis of Variance: <repl>response</repl> is a series measuring some
	effect of interest and <repl>treatment</repl> must be a discrete
	variable that codes for two or more types of treatment (or
	non-treatment).  For two-way ANOVA, the <repl>block</repl> variable
	(which should also be discrete) codes for the values of some control
	variable.
      </para>
      <para context="cli">
	Unless the <opt>--quiet</opt> option is given, this command prints a
	table showing the sums of squares and mean squares along with an
	<math>F</math>-test.  The <math>F</math>-test and its P-value can be
	retrieved using the accessors <lit>$test</lit> and <lit>$pvalue</lit>
	respectively.  
      </para>
      <para>
	The null hypothesis for the <math>F</math>-test is that the mean
	response is invariant with respect to the treatment type, or in words
	that the treatment has no effect.  Strictly speaking, the test
	is valid only if the variance of the response is the same for
	all treatment types.
      </para>
      <para>
	Note that the results shown by this command are in fact a subset of
	the information given by the following procedure, which is easily
	implemented in gretl.  Create a set of dummy variables coding for all
	but one of the treatment types.  For two-way ANOVA, in addition create
	a set of dummies coding for all but one of the <quote>blocks</quote>.
	Then regress <repl>response</repl> on a constant and the dummies using
	<cmdref targ="ols"/>.  For a one-way design the ANOVA table is printed
	via the <opt>--anova</opt> option to <lit>ols</lit>.  In the two-way
	case the relevant <math>F</math>-test is found by using the <cmdref
	targ="omit"/> command.  For example (assuming <lit>y</lit> is the
	response, <lit>xt</lit> codes for the treatment, and <lit>xb</lit>
	codes for blocks):
      </para>
      <code>
	# one-way
	list dxt = dummify(xt)
	ols y 0 dxt --anova
	# two-way
	list dxb = dummify(xb)
	ols y 0 dxt dxb
	# test joint significance of dxt
	omit dxt --quiet
      </code>
    </description>

    <gui-access>
      <menu-path>/Model/Other linear models/ANOVA</menu-path>
    </gui-access>

  </command>

  <command name="append" section="Dataset" label="Append data" context="cli">

    <usage>
      <arguments>
        <argument>filename</argument>
      </arguments>
      <options>
	<option>
	  <flag>--time-series</flag>
	  <effect>see below</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Opens a data file and appends the content to the current
	dataset, if the new data are compatible.  The program will try
	to detect the format of the data file (native, plain text, CSV,
	Gnumeric, Excel, etc.). 
      </para>
      <para>
	The appended data may take the form of either additional observations
	on variables already present in the dataset, or new variables.
	in the case of adding variables, compatibility requires either
	(a) that the number of observations for the new data equals that
	for the current data, or (b) that the new data carries clear
	observation information so that gretl can work out how to place the
	values.  
      </para>
      <para>
	A special feature is supported for appending to a panel dataset. Let
	<math>n</math> denote the number of cross-sectional units in the panel,
	<math>T</math> denote the number of time periods, and <math>m</math>
	denote the number of observations for the new data. If <math>m =
	  n</math> the new data are taken to be time-invariant, and are copied
	into place for each time period. On the other hand, if <math>m =
	  T</math> the data are treated as non-varying across the panel units,
	and are copied into place for each unit. If the panel is
	<quote>square</quote>, and <math>m</math> equals both <math>n</math>
	and <math>T</math>, an ambiguity arises. The default in this case is
	to treat the new data as time-invariant, but you can force gretl to
	treat the new data as time series via the <opt>--time-series</opt>
	option.  (This option is ignored in all other cases.)
      </para>

    </description>

    <gui-access>
      <menu-path>/File/Append data</menu-path>
    </gui-access>

  </command>

  <command name="ar" section="Estimation" label="Autoregressive estimation">

    <usage>
      <arguments>
        <argument>lags</argument>
	<argument separated="true">depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
      </options>
      <examples>
        <example>ar 1 3 4 ; y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Computes parameter estimates using the generalized
	Cochrane&ndash;Orcutt iterative procedure; see Section 9.5 of
	<cite key="ramanathan02">Ramanathan (2002)</cite>. Iteration is
	terminated when successive error sums of squares do not differ by
	more than 0.005 percent or after 20 iterations.
      </para>

      <para context="gui">
	The <quote>list of AR lags</quote> specifies the structure of
	the error process.  For example, the entry <quote>1 3
	  4</quote> corresponds to the process: 
	<equation status="display" 
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho1*u(t-1) + rho3*u(t-3) + rho4*u(t-4)"
	  graphic="arlags"/>
      </para>

      <para context="cli">
	<repl quote="true">lags</repl> is a list of lags in the
	residuals, terminated by a semicolon. In the above example,
	the error term is specified as 
	<equation status="display" 
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho(1)*u(t-1) + rho(3)*u(t-3) + rho(4)*u(t-4)"
	  graphic="arlags"/>
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Time series/Autoregressive estimation</menu-path>
    </gui-access>

  </command>

  <command name="ar1" section="Estimation" label="AR(1) estimation">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--hilu</flag>
	  <effect>use Hildreth&ndash;Lu procedure</effect>
	</option>
	<option>
	  <flag>--pwe</flag>
	  <effect>use Prais&ndash;Winsten estimator</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--no-corc</flag>
	  <effect>do not fine-tune results with Cochrane-Orcutt</effect>
	</option>
      </options>
      <examples>
        <example>ar1 1 0 2 4 6 7</example>
	<example>ar1 y 0 xlist --hilu --no-corc</example>
	<example>ar1 y 0 xlist --pwe</example>
      </examples>
    </usage>

    <description>
      <para>
	Computes feasible GLS estimates for a model in which the error term is
	assumed to follow a first-order autoregressive process.
      </para>
      <para>
	The default method is the Cochrane&ndash;Orcutt iterative
	procedure; see for example section 9.4 of <cite
	key="ramanathan02">Ramanathan (2002)</cite>. Iteration is
	terminated when successive estimates of the autocorrelation
	coefficient do not differ by more than 0.001 or after 20
	iterations.
      </para>
      <para>
	If the <opt>--hilu</opt> option is given, the Hildreth&ndash;Lu search
	procedure is used.  The results are then fine-tuned using the
	Cochrane&ndash;Orcutt method, unless the <opt>--no-corc</opt> flag is
	specified.  (The latter option is ignored if <opt>--hilu</opt>
	is not specified.)
      </para>
      <para>
	If the <opt>--pwe</opt> option is given, the Prais&ndash;Winsten
	estimator is used.  This involves an an iteration similar to
	Cochrane&ndash;Orcutt; the difference is that while
	Cochrane&ndash;Orcutt discards the first observation,
	Prais&ndash;Winsten makes use of it. See, for example, Chapter 13
	of <cite key="greene00">Greene's <book>Econometric Analysis</book>
	(2000)</cite> for details.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/Cochrane-Orcutt</menu-path>
      <menu-path>/Model/Time series/Hildreth-Lu</menu-path>
      <menu-path>/Model/Time series/Prais-Winsten</menu-path>
    </gui-access>

  </command>

  <command name="arbond" section="Estimation" label="Arellano-Bond"
	   context="cli">

    <usage>
      <arguments>
	<argblock>
	  <argument>p</argument>
	  <argument optional="true">q</argument>
	</argblock>
	<argblock separated="true">
	  <argument>depvar</argument>
	  <argument>indepvars</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>instruments</argument>
	</argblock>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't show estimated model</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
        <option>
	  <flag>--two-step</flag>
	  <effect>perform 2-step GMM estimation</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>add time dummy variables</effect>
        </option>
        <option>
	  <flag>--asymptotic</flag>
	  <effect>uncorrected asymptotic standard errors</effect>
        </option>
      </options>
      <examples>
        <example>arbond 2 ; y Dx1 Dx2</example>
        <example>arbond 2 5 ; y Dx1 Dx2 ; Dx1</example>
	<example>arbond 1 ; y Dx1 Dx2 ; Dx1 GMM(x2,2,3)</example>
	<demos>
	  <demo>arbond91.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Carries out estimation of dynamic panel data models (that is,
	panel models including one or more lags of the dependent
	variable) using the GMM-DIF method set out by <cite
	key="arellano-bond91">Arellano and Bond (1991)</cite>.
	Please see <cmdref targ="dpanel"/> for an updated and
	more flexible version of this command which handles GMM-SYS
	as well as GMM-DIF.
      </para>
      <para>
	The parameter <repl>p</repl> represents the order of the
	autoregression for the dependent variable.  The optional parameter
	<repl>q</repl> indicates the maximum lag of the level of the
	dependent variable to be used as an instrument.  If this argument
	is omitted, or given as 0, all available lags are used.
      </para>
      <para>
	The dependent variable should be given in levels form; it will be
	automatically differenced (since this estimator uses differencing
	to cancel out the individual effects).  The independent variables
	are not automatically differenced; if you want to use differences
	(which will generally be the case for ordinary quantitative
	variables, though perhaps not for, say, time dummy variables) you
	should create the differences first then specify these as the
	regressors. 
      </para>
      <para>
	The last (optional) field in the command is for specifying
	instruments.  If no instruments are given, it is assumed that all
	the independent variables are strictly exogenous.  If you specify
	any instruments, you should include in the list any strictly
	exogenous independent variables.  For predetermined regressors,
	you can use the <lit>GMM</lit> function to include a specified
	range of lags in block-diagonal fashion.  This is illustrated in
	the third example above.  The first argument to <lit>GMM</lit> is
	the name of the variable in question, the second is the minimum
	lag to be used as an instrument, and the third is the maximum lag.
	If the third argument is given as 0, all available lags are used.
      </para>
      <para>
	By default the results of 1-step estimation are reported (with
	robust standard errors).  You may select 2-step estimation as an
	option.  In both cases tests for autocorrelation of orders 1 and 2
	are provided, as well as the Sargan overidentification test and a
	Wald test for the joint significance of the regressors.  Note that
	in this differenced model first-order autocorrelation is not a
	threat to the validity of the model, but second-order
	autocorrelation violates the maintained statistical assumptions.
      </para>
      <para>
	In the case of 2-step estimation, standard errors are by default
	computed using the finite-sample correction suggested by <cite
	key="windmeijer05">Windmeijer (2005)</cite>.  The standard
	asymptotic standard errors associated with the 2-step estimator
	are generally reckoned to be an unreliable guide to inference, but
	if for some reason you want to see them you can use the
	<opt>--asymptotic</opt> option to turn off the Windmeijer
	correction.
      </para>
      <para>
	If the <opt>--time-dummies</opt> option is given, a set of
	time dummy variables is added to the specified regressors.  
	The number of dummies is one less than the maximum number of
	periods used in estimation, to avoid perfect collinearity with
	the constant.  The dummies are entered in levels; if you wish
	to use time dummies in first-differenced form, you will have
	to define and add these variables manually.
      </para>
    </description>

  </command>

  <command name="arch" section="Estimation" label="ARCH model">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>depvar</argument>
	<argument>indepvars</argument>
      </arguments>
      <examples>
        <example>arch 4 y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	This command is retained at present for backward
	compatibility, but you are better off using the maximum
	likelihood estimator offered by the <cmdref targ="garch"/>
	command; for a plain ARCH model, set the first GARCH
	parameter to 0.
      </para>
      <para>
	Estimates the given model specification allowing for ARCH
	(Autoregressive Conditional Heteroskedasticity). The model is
	first estimated via OLS, then an auxiliary regression is run, in
	which the squared residual from the first stage is regressed on
	its own lagged values. The final step is weighted least squares
	estimation, using as weights the reciprocals of the fitted error
	variances from the auxiliary regression.  (If the predicted
	variance of any observation in the auxiliary regression is not
	positive, then the corresponding squared residual is used
	instead).
      </para>
      <para>
	The <lit>alpha</lit> values displayed below the coefficients
	are the estimated parameters of the ARCH process from the
	auxiliary regression.
      </para>
      <para>
	See also <cmdref targ="garch"/> and <cmdref targ="modtest"/> (the
	<opt>--arch</opt> option).  
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/ARCH</menu-path>
    </gui-access>

  </command>

  <command name="arima" section="Estimation" label="ARMA model">

    <usage>
      <arguments>
	<argblock>
	  <argument>p</argument>
	  <argument>d</argument>
	  <argument>q</argument>
	</argblock>
	<argblock separated="true" optional="true">
	  <argument>P</argument>
	  <argument>D</argument>
	  <argument>Q</argument>
	</argblock>
	<argument separated="true">depvar</argument>
	<argument optional="true">indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
        <option>
	  <flag>--hessian</flag>
	  <effect>see below</effect>
        </option>
        <option>
	  <flag>--opg</flag>
	  <effect>see below</effect>
        </option>
        <option>
	  <flag>--nc</flag>
	  <effect>do not include a constant</effect>
        </option>
        <option>
	  <flag>--conditional</flag>
	  <effect>use conditional maximum likelihood</effect>
        </option>
        <option>
	  <flag>--x-12-arima</flag>
	  <effect>use X-12-ARIMA for estimation</effect>
        </option>
	<option>
	  <flag>--lbfgs</flag>
	  <effect>use L-BFGS-B maximizer</effect>
	</option>
	<option>
	  <flag>--y-diff-only</flag>
	  <effect>ARIMAX special, see below</effect>
	</option>
	<option>
	  <flag>--save-ehat</flag>
	  <effect>see below</effect>
	</option>
      </options>
      <examples>
        <example>arima 1 0 2 ; y</example>
	<example>arima 2 0 2 ; y 0 x1 x2 --verbose</example>
	<example>arima 0 1 1 ; 0 1 1 ; y --nc</example>
      </examples>
    </usage>

    <description>

      <para context="cli">
	If no <repl>indepvars</repl> list is given, estimates a univariate
	ARIMA (Autoregressive, Integrated, Moving Average) model.  The
	values <repl>p</repl>, <repl>d</repl> and <repl>q</repl>
	represent the autoregressive (AR) order, the differencing order,
	and the moving average (MA) order respectively.  These values may be
	given in numerical form, or as the names of pre-existing scalar
	variables.  A <repl>d</repl> value of 1, for instance, means that
	the first difference of the dependent variable should be taken before
	estimating the ARMA parameters.
      </para>

      <para context="cli">
	If you wish to include only specific AR or MA lags in the model
	(as opposed to all lags up to a given order) you can substitute
	for <repl>p</repl> and/or <repl>q</repl> either (a) the name of a
	pre-defined matrix containing a set of integer values or (b) an
	expression such as <lit>{1 4}</lit>; that is, a set of lags
	separated by spaces and enclosed in braces.
      </para>

      <para context="cli">
	The optional integer values <repl>P</repl>, <repl>D</repl> and
	<repl>Q</repl> represent the seasonal AR, order for seasonal
	differencing and seasonal MA order respectively.  These are
	applicable only if the data have a frequency greater than 1 (for
	example, quarterly or monthly data).  These orders must be
	given in numerical form or as scalar variables.
      </para>

      <para context="cli">
	In the univariate case the default is to include an intercept
	in the model but this can be suppressed with the
	<opt>--nc</opt> flag.  If <repl>indepvars</repl> are added,
	the model becomes ARMAX; in this case the constant should be
	included explicitly if you want an intercept (as in the second
	example above).
      </para>

      <para context="cli">
	An alternative form of syntax is available for this command: if
	you do not want to apply differencing (either seasonal or
	non-seasonal), you may omit the <repl>d</repl> and <repl>D</repl>
	fields altogether, rather than explicitly entering 0.  In
	addition, <lit>arma</lit> is a synonym or alias for
	<lit>arima</lit>.  Thus for example the following command is a
	valid way to specify an ARMA(2, 1) model:
      </para>
      <code context="cli">
	arma 2 1 ; y
      </code>

      <para context="gui">
	Estimates an ARMA model, with or without exogenous regressors. If
	the order of differencing is greater than zero the model becomes
	ARIMA.  If the data have a frequency greater than 1 the option of
	including a seasonal component is presented.
      </para>

      <para context="gui">
	If you wish to include only specified AR or MA lags in the model
	(as opposed to all lags up to a given order) check the box to the
	right of the spinner and type a list of lags, separated by
	spaces, into the entry field.  Alternatively, if you have defined
	a matrix containing the desired set of lags you can type its name
	into the entry field.
      </para>

      <para>
	The default is to use the <quote>native</quote> gretl ARMA
	functionality, with estimation by exact ML using the Kalman
	filter; estimation via conditional ML is available as an option.
	(If <program>X-12-ARIMA</program> is installed you have the option
	of using it instead of native code.)  For details regarding these
	options, please see <guideref
	targ="arma-estimation"/>.
      </para>

      <para context="cli">
	When the native exact ML code is used, estimated standard errors are
	by default based on a numerical approximation to the (negative inverse
	of) the Hessian, with a fallback to the outer product of the gradient
	(OPG) if calculation of the numerical Hessian should fail. Two
	(mutually exclusive) option flags can be used to force the issue: the
	<opt>--opg</opt> option forces use of the OPG method, with no attempt
	to compute the Hessian, while the <opt>--hessian</opt> flag disables
	the fallback to OPG. Note that failure of the numerical Hessian
	computation is generally an indicator of a misspecified model.
      </para>

      <para context="cli">
	The option <opt>--lbfgs</opt> is specific to estimation using
	native ARMA code and exact ML: it calls for use of the 
	<quote>limited memory</quote> L-BFGS-B algorithm in place
	of the regular BFGS maximizer.  This may help in some
	instances where convergence is difficult to achieve.
      </para>

      <para context="cli">
	The option <opt>--y-diff-only</opt> is specific to estimation of
	ARIMAX models (models with a non-zero order of integration and
	including exogenous regressors), and applies only when gretl's native
	exact ML is used. For such models the default behavior is to
	difference both the dependent variable and the regressors, but when
	this option is specified only the dependent variable is differenced,
	the regressors remaining in level form.
      </para>

      <para context="cli">
	The option <opt>--save-ehat</opt> is applicable only when
	using native exact ML estimation. The effect is to make
	available a vector holding the optimal estimate as of period
	<math>t</math> of the <math>t</math>-dated disturbance or
	innovation: this can be retrieved via the accessor <lit>$ehat</lit>.
	These values differ from the residual series (<lit>$uhat</lit>),
	which holds the one-step ahead forecast errors.
      </para>

      <para>The AIC value given in connection with ARIMA models is
	calculated according to the definition used in
	<program>X-12-ARIMA</program>, namely
	  <equation status="display" 
	  tex="\[\mbox{AIC}=-2\ell + 2k\]"
	  ascii="AIC = -2L + 2k"
	  graphic="aic"/> where 
	<equation status="inline" 
	  tex="$\ell$" ascii="L"
	  graphic="ell"/> is the
	log-likelihood and <math>k</math> is the total number of
	parameters estimated.  Note that <program>X-12-ARIMA</program>
	does not produce information criteria such as AIC when estimation
	is by conditional ML.
      </para>

      <para context="tex">
	The AR and MA roots shown in connection with ARMA estimation
	are based on the following representation of an ARMA($p,q$)
	process:
	\[
	(1-\phi_1 L - \phi_2 L^2 - \cdots - \phi_p L^p)Y =
          c + (1 + \theta_1 L + \theta_2 L^2 + \cdots +
         \theta_q L^q)\varepsilon_t
        \]
        The AR roots are therefore the solutions to
        \[
         1 - \phi_1 z - \phi_2 z^2 - \cdots - \phi_p L^p = 0
        \]
        and stability requires that these roots lie outside the
	unit circle.
      </para>

      <para context="tex">
	The <quote>frequency</quote> figure printed in connection with
	the AR and MA roots is the $\lambda$ value that solves 
	$z=re^{i2\pi\lambda}$, where $z$ is the root in question
	and $r$ is its modulus.
      </para>

      <para context="notex">
	The AR and MA roots shown in connection with ARMA estimation
	are based on the following representation of an ARMA(p, q)
	process:
      </para>
      <mono context="notex">
	(1 - a_1*L - a_2*L^2 - ... - a_p*L^p)Y =
          c + (1 + b_1*L + b_2*L^2 + ... + b_q*L^q) e_t
      </mono>
      <para context="notex">
        The AR roots are therefore the solutions to
      </para>
      <mono context="notex">
         1 - a_1*z - a_2*z^2 - ... - a_p*L^p = 0
      </mono>
      <para context="notex">
        and stability requires that these roots lie outside the
	unit circle.
      </para>

      <para context="notex">
	The <quote>frequency</quote> figure
	printed in connection with AR and MA roots is the &lgr; value
	that solves <math>z</math> = <math>r</math> * exp(i*2*&pi;*&lgr;)
	where <math>z</math> is the root in question and <math>r</math> 
	is its modulus.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Time series/ARIMA</menu-path>
      <other-access>Main window pop-up menu (single selection)</other-access>
    </gui-access>

  </command>

  <command name="bfgs-config" section="Estimation" label="BFGS options"
    context="gui">
    <description>
      <para>
	This dialog allows you to control some aspects of the operation of the
	BFGS maximizer.  In case the maximizer fails to converge it may help
	matters, in some cases, to increase the number of iterations allowed
	and/or to increase (make more permissive) the convergence tolerance.
	However, you should be suspicious of results obtained using a high
	tolerance and should consider the possibility that the model you
	are estimating is misspecified. 
      </para>
      <para>
	For most applications we recommend use of the regular BFGS maximizer
	but for some problems the <quote>limited memory</quote> variant of the
	algorithm, L-BFGS-B, may produce more rapid convergence.  When
	L-BFGS-B is selected, you have the option of setting the number of
	corrections used in the limited memory matrix (between 3 and 20, with
	a default of 8).
      </para>
    </description>
  </command>

  <command name="biprobit" section="Estimation" label="Bivariate probit"
    context="cli">
    <usage>
      <arguments>
        <argument>depvar1</argument>
	<argument>depvar2</argument>
        <argument>indepvars1</argument>
	<argument separated="true" optional="true">indepvars2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
	<option>
	  <flag>--opg</flag>
	  <effect>see below</effect>
        </option>
	<option>
	  <flag>--save-xbeta</flag>
	  <effect>see below</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print extra information</effect>
        </option>
      </options>      
      <examples>
        <example>biprobit y1 y2 0 x1 x2</example>
	<example>biprobit y1 y2 0 x11 x12 ; 0 x21 x22</example>
	<demos>
	  <demo>biprobit.inp</demo>
	</demos>
      </examples>
    </usage>
    <description>
      <para>
	Estimates a bivariate probit model, using the
	Newton&ndash;Raphson method to maximize the likelihood.
      </para>
      <para>
	The argument list starts with the two (binary) dependent
	variables, followed by a list of regressors. If a second list
	is given, separated by a semicolon, this is interpreted as a
	set of regressors specific to the second equation, with
	<repl>indepvars1</repl> being specific to the first equation;
	otherwise <repl>indepvars1</repl> is taken to represent a
	common set of regressors.
      </para>
      <para>
	By default, standard errors are computed using a numerical
	approximation to the Hessian at convergence.  But if the
	<opt>--opg</opt> option is given the covariance matrix is based on
	the Outer Product of the Gradient (OPG), or if the
	<opt>--robust</opt> option is given QML standard errors are
	calculated, using a <quote>sandwich</quote> of the inverse of the
	Hessian and the OPG.
      </para>
      <para>
	After successful estimation, the accessor <lit>$uhat</lit>
	retrieves a matrix with two columns holding the generalized
	residuals for the two equations; that is, the expected values
	of the disturbances conditional on the observed outcomes and
	covariates.  By default <lit>$yhat</lit> retrieves a matrix
	with four columns, holding the estimated probabilities of the
	four possible joint outcomes for (<math>y</math><sub>1</sub>,
	<math>y</math><sub>2</sub>), in the order (1,1), (1,0), (0,1),
	(0,0). Alternatively, if the option <lit>--save-xbeta</lit> is
	given, <lit>$yhat</lit> has two columns and holds the values
	of the index functions for the respective equations.
      </para>
      <para>
	The output includes a likelihood ratio test of the null
	hypothesis that the disturbances in the two equations are
	uncorrelated.
      </para>
    </description>
  </command>

  <command name="bootstrap" section="Tests" label="Bootstrap options"
    context="gui">

    <description>

      <para>In this dialog you get to choose:</para>

      <ilist>
	<li>
	  <para>
	    The variable/coefficient to examine.  (You can test only one
	    coefficient at a time using this method.)
	  </para>
	</li>
	<li>
	  <para>
	    The sort of analysis to perform.  The default (95 percent)
	    confidence interval is based directly on the quantiles of the
	    bootstrap coefficient estimates.  The
	    <quote>studentized</quote> version is as per Davidson and
	    MacKinnon's <book>Economic Theory and Methods</book> (ETM),
	    chapter 5: at each bootstrap replication a
	    <math>t</math>-ratio is formed as (a) the difference
	    between the current and the baseline coefficient estimate,
	    divided by (b) the baseline estimated standard error. Then the
	    confidence interval is formed based on the quantiles of this
	    t-ratio, as explained in ETM.  The P-value option is based on
	    the distribution of the bootstrap <math>t</math>-ratio:
	    it is the proportion of the replications where the absolute
	    value of this statistic exceeds the absolute value of the
	    baseline <math>t</math>-ratio. 
	  </para>
	</li>
	<li>
	  <para>Resampled residuals versus simulate normal errors. In the
	    first case the original residuals (rescaled as suggested in
	    ETM) are resampled with replacement.  In the second case
	    pseudo-random normal values are generated with the original
	    residual variance.
	  </para>
	</li>
	<li>
	  <para>The number of replications to perform. Note that when
	    you're constructing a 95 percent confidence interval it is
	    desirable that 0.05(<math>B</math> + 1)/2 is an integer
	    (where <math>B</math> is the number of replications).
	    So gretl may adjust the chosen number of replications to
	    ensure this is the case.
	  </para>
	</li>
	<li>
	  <para>Whether or not to produce a graph of the bootstrap
	    distribution. This option employs gretl's kernel density
	    estimation facility.
	  </para>
	</li>
      </ilist>

    </description>
  </command>

  <command name="boxplot" section="Graphs" label="Boxplots">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--notches</flag>
	  <effect>show 90 percent interval for median</effect>
	</option>
	<option>
	  <flag>--factorized</flag>
	  <effect>see below</effect>
	</option>
	<option>
	  <flag>--panel</flag>
	  <effect>see below</effect>
	</option>
	<option>
	  <flag>--output</flag>
	  <optparm>filename</optparm>
	  <effect>send output to specified file</effect>
	</option>
      </options>
    </usage>

    <description>

      <para>
	These plots display the distribution of a variable. The
	central box encloses the middle 50 percent of the data, &ie;
	it is bounded by the first and third quartiles.  The
	<quote>whiskers</quote> extend to the minimum and maximum
	values.  A line is drawn across the box at the median.  A
	<quote>+</quote> sign is used to indicate the mean.  If the
	option of showing a confidence interval for the median is
	selected, this is computed via the bootstrap method and
	shown in the form of dashed horizontal lines above and/or
	below the median.
      </para>

      <para context="gui">
	The <quote>factorized</quote> option allows you to examine the
	distribution of a chosen variable conditional on the value of
	some discrete factor. For example, if a data set contains
	wages and a gender dummy variable you can select the wage
	variable as the target and gender as the factor, to see
	side-by-side boxplots of male and female wages.
      </para>
      
      <para context="cli">
	The <opt>factorized</opt> option allows you to examine the
	distribution of a chosen variable conditional on the value of
	some discrete factor. For example, if a data set contains
	wages and a gender dummy variable you can select the wage
	variable as the target and gender as the factor, to see
	side-by-side boxplots of male and female wages, as in
      </para>
      <code context="cli">
	boxplot wage gender --factorized
      </code>
      <para context="cli">
	Note that in this case you must specify exactly two variables,
	with the factor given second.
      </para>

      <para context="cli">
	If the current data set is a panel, and just one variable is
	specified, the <opt>panel</opt> option produces a series of
	side-by-side boxplots, one for each panel <quote>unit</quote>
	or group.
      </para>

      <para context="cli">
	In interactive mode the result is displayed immediately. In
	batch mode the default behavior is that a gnuplot command file
	is written in the user's working directory, with a name on the
	pattern <filename>gpttmpN.plt</filename>, starting with N =
	<lit>01</lit>. The actual plots may be generated later using
	<program>gnuplot</program> (under MS Windows,
	<program>wgnuplot</program>).  This behavior can be modified
	by use of the <lit>--output=</lit><repl>filename</repl>
	option.  For details, please see the <cmdref targ="gnuplot"/>
	command.
      </para>

    </description>

    <gui-access>
      <menu-path>/View/Graph specified vars/Boxplots</menu-path>
    </gui-access>

  </command>

  <command name="break" section="Programming" 
    label="Break from loop" context="cli">
    <description>
      <para>
	Break out of a loop.  This command can be used only within a loop; it
	causes command execution to break out of the current (innermost) loop.
	See also <cmdref targ="loop"/>.
      </para> 
    </description>
  </command>

  <command name="bwfilter" section="Transformations" context="gui"
    label="The Butterworth filter">

    <description>
      <para>
	The Butterworth filter is an appromixation to an ideal
	square-wave filter which allows frequencies over a certain
	range to pass at full strength while stopping all others.
      </para>
      <para>
	Higher values of the order parameter, <math>n</math>, produce
	a closer approximation to the ideal filter, in principle,
	but at the possible cost of numerical instability. The
	<quote>cutoff</quote> value sets the boundary between
	the pass band and the stop band. It is expressed in degrees,
	and must be greater than 0 and less than 180&deg; (or &pi;
	radians, corresponding to the highest frequency in the
	data). Smaller values of the cutoff produce a smoother
	trend.
      </para>
      <para>
	Inspecting the periodogram of the target series is a
	useful preliminary when you wish to apply this filter.  See
	<guideref targ="chap-genr"/> for details.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Filter/Butterworth</menu-path>
    </gui-access>

  </command>

  <command name="catch" section="Programming" 
    label="Catch errors" context="cli">
    <usage>
      <syntax>
        <lit>catch</lit> <repl>command</repl>
      </syntax>
    </usage>
    <description>
      <para>
	This is not a command in its own right but can be used as a prefix
	to most regular commands: the effect is to prevent termination of
	a script if an error occurs in executing the command. If an error
	does occur, this is registered in an internal error code which can
	be accessed as <lit>$error</lit> (a zero value indicates success).
	The value of <lit>$error</lit> should always be checked
	immediately after using <lit>catch</lit>, and appropriate action
	taken if the command failed.
      </para> 
      <para>
	The <lit>catch</lit> keyword cannot be used before <lit>if</lit>,
	<lit>elif</lit> or <lit>endif</lit>.
      </para>
    </description>
  </command>

  <command name="chow" section="Tests" label="Chow test">

    <usage>
      <altforms>
        <altform><lit>chow</lit> <repl>obs</repl></altform>
        <altform><lit>chow</lit> <repl>dummyvar</repl> <lit>--dummy</lit></altform>
      </altforms>
      <options>
	<option>
	  <flag>--dummy</flag>
	  <effect>use a pre-existing dummy variable</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't print estimates for augmented model</effect>
	</option>
      </options>
      <examples>
        <example>chow 25</example>
        <example>chow 1988:1</example>
	<example>chow female --dummy</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	This command needs either an observation number (or date, with dated
	data), or the name of a dummy variable.
      </para>

      <para>
	Must follow an OLS regression.  If an observation number or date is
	given, provides a test for the null hypothesis of no structural break
	at the given split point. The procedure is to create a dummy variable
	which equals 1 from the split point specified by <repl>obs</repl> to
	the end of the sample, 0 otherwise, and also interaction terms between
	this dummy and the original regressors. If a dummy variable is given,
	tests the null hypothesis of structural homogeneity with respect to
	that dummy. Again, interaction terms are added.  In either case an
	augmented regression is run including the additional terms.
      </para>
      <para>
	By default an <math>F</math> statistic is calculated, taking the
	augmented regression as the unrestricted model and the original as
	the restricted.  But if the original model used a robust estimator
	for the covariance matrix, the test statistic is a Wald chi-square
	value based on a robust estimator of the covariance matrix for the
	augmented regression.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Chow test</menu-path>
    </gui-access>
  </command>

  <command name="clear" section="Programming" context="cli">
    <usage>
      <options>
	<option>
	  <flag>--dataset</flag>
	  <effect>clear dataset only</effect>
	</option>
	<option>
	  <flag>--other</flag>
	  <effect>clear everything but the dataset</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	With no options, clears all saved objects, including the current
	dataset if any, out of memory. Note that opening a new dataset, or
	using the <cmd>nulldata</cmd> command to create an empty dataset,
	also has this effect, so use of <cmd>clear</cmd> is not usually
	necessary.
      </para>
      <para>
	If the <lit>--dataset</lit> option is given, then only the dataset
	is cleared; other saved objects such as named matrices and scalars
	are preserved.
      </para>
      <para>
	If the <lit>--other</lit> option is given, then the current
	dataset, if any, is preserved but all other saved objects are
	destroyed.
      </para>
    </description>
  </command>

  <command name="coeffsum" section="Tests" label="Sum of coefficients">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <examples>
        <example>coeffsum xt xt_1 xr_2</example>
	<demos>
	  <demo>restrict.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">This command needs a list of variables,
	selected from the set of independent variables in a given
	model.</para>
      <para context="gui">
	Calculates the sum of the coefficients on the variables in the
	specified list.  Prints this sum along with its standard error
	and the p-value for the null hypothesis that the sum is zero.
      </para>
      <para context="cli">
	Must follow a regression.  Calculates the sum of the
	coefficients on the variables in <repl>varlist</repl>.  Prints
	this sum along with its standard error and the p-value for the
	null hypothesis that the sum is zero.  
      </para>
      <para>Note the difference between this and <cmdref
	  targ="omit"/>, which tests the null
	hypothesis that the coefficients on a specified subset of
	independent variables are <emphasis>all</emphasis> equal to
	zero.</para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Sum of coefficients</menu-path>
    </gui-access>

  </command>

  <command name="coint" section="Tests" 
    label="Engle-Granger cointegration test">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>depvar</argument>
	<argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>do not include a constant</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>include constant and trend</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>include constant and quadratic trend</effect>
	</option>
	<option>
	  <flag>--skip-df</flag>
	  <effect>no DF tests on individual variables</effect>
	</option>
	<option>
	  <flag>--test-down</flag>
	  <effect>automatic lag order</effect>
	</option>
      </options>
      <examples>
	<example>coint 4 y x1 x2</example>
	<example>coint 0 y x1 x2 --ct --skip-df</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	The <cite key="engle-granger87">Engle&ndash;Granger (1987)</cite>
	cointegration test.  The default procedure is: (1) carry out
	Dickey&ndash;Fuller tests on the null hypothesis that each of the
	variables listed has a unit root; (2) estimate the cointegrating
	regression; and (3) run a DF test on the residuals from the
	cointegrating regression.  If the <opt>--skip-df</opt> flag is
	given, step (1) is omitted.
      </para>
      <para context="cli">
	If the specified lag order is positive all the Dickey&ndash;Fuller
	tests use that order, with this qualification: if the
	<opt>--test-down</opt> option is given, the given value is taken as
	the maximum and the actual lag order used in each case is obtained
	by testing down.  See the <cmdref targ="adf"/> command for
	details of this procedure.
      </para>
      <para context="cli">
	By default, the cointegrating regression contains a constant. If
	you wish to suppress the constant, add the <opt>--nc</opt> flag.
	If you wish to augment the list of deterministic terms in the
	cointegrating regression with a linear or quadratic trend, add
	the <opt>--ct</opt> or <opt>--ctt</opt> flag.  These option
	flags are mutually exclusive.
      </para>

      <para context="gui">
	The Engle&ndash;Granger cointegration test.  The default procedure
	is: (1) carry out Dickey&ndash;Fuller tests on the null
	hypothesis that each of the variables listed has a unit root; (2)
	estimate the cointegrating regression; and (3) run a DF test on
	the residuals from the cointegrating regression.  If the box
	labeled <quote>skip initial DF tests</quote> is checked, however,
	the first of these steps is omitted.
      </para>
      <para context="gui">
	If the lag order, <math>k</math>, is greater than 0, then
	<math>k</math> lags of the dependent variable are included
	on the right-hand side of each test regression, unless the box
	labeled <quote>test down from maximum lag</quote> is checked: in
	that case the selected lag order is taken as a maximum and the
	actual lag order used is obtained by testing down.  See the
	<cmdref targ="adf"/> command for details of this procedure.
      </para>
      <para context="gui">
	By default, the cointegrating regression contains a constant. If
	you wish to suppress the constant, or to add a linear or quadratic
	trend, select the appropriate option from the set of radio buttons
	in the Cointegration dialog box.
      </para>

      <para><emphasis>P-</emphasis>values for this test are based on
      <cite key="mackinnon96">MacKinnon (1996)</cite>.  The
      relevant code is included by kind permission of the author.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/Cointegration test/Engle-Granger</menu-path>
    </gui-access>

  </command>

  <command name="coint2" section="Tests" label="Johansen cointegration test">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>ylist</argument>
	<argblock optional="true" separated="true">
	  <argument>xlist</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>rxlist</argument>
	</argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>no constant</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>restricted constant</effect>
        </option>
        <option>
	  <flag>--uc</flag>
	  <effect>unrestricted constant</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>constant and restricted trend</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>constant and unrestricted trend</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include centered seasonal dummies</effect>
        </option>
        <option>
	  <flag>--asy</flag>
	  <effect>record asymptotic p-values</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>print just the tests</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>don't print anything</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>print details of auxiliary regressions</effect>
        </option>
      </options>
      <examples>
        <example>coint2 2 y x</example>
	<example>coint2 4 y x1 x2 --verbose</example>
	<example>coint2 3 y x1 x2 --rc</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Carries out the Johansen test for cointegration among the
	variables in <repl>ylist</repl> for the given lag order.  For
	details of this test see <guideref targ="chap:vecm"/> or <cite
	key="hamilton94">Hamilton (1994)</cite>, Chapter 20. P-values
	are computed via Doornik's gamma approximation <cite
	key="doornik98" p="true">(Doornik, 1998)</cite>. Two sets of
	p-values are shown for the trace test, straight asymptotic
	values and values adjusted for the sample size. By default the
	<lit>$pvalue</lit> accessor gets the adjusted variant, but the
	<opt>--asy</opt> flag may be used to record the asymptotic
	values instead.
      </para>

      <para context="gui">
	Carries out the Johansen test for cointegration among the
	listed variables for the selected lag order.  For details of
	this test see, for example, Hamilton, <book>Time Series
	Analysis</book> (1994), Chapter 20.  P-values are computed via
	Doornik's (1998) gamma approximation.
      </para>

      <para context="cli">
	The inclusion of deterministic terms in the model is controlled by
	the option flags.  The default if no option is specified is to
	include an <quote>unrestricted constant</quote>, which allows for
	the presence of a non-zero intercept in the cointegrating
	relations as well as a trend in the levels of the endogenous
	variables.  In the literature stemming from the work of Johansen
	(see for example his 1995 book) this is often referred to as
	<quote>case 3</quote>.  The first four options given above, which
	are mutually exclusive, produce cases 1, 2, 4 and 5 respectively.
	The meaning of these cases and the criteria for selecting a case
	are explained in <guideref targ="chap:vecm"/>.
      </para>

      <para context="gui">
	The inclusion of deterministic terms in the model is controlled by
	the drop-down option list.  The default is to include an
	<quote>unrestricted constant</quote>, which allows for the
	presence of a non-zero intercept in the cointegrating relations as
	well as a trend in the levels of the endogenous variables.  In the
	literature stemming from the work of Johansen (see for example his
	1995 book) this is often referred to as <quote>case 3</quote>. The
	other four options produce cases 1, 2, 4 and 5 respectively. The
	meaning of these cases and the criteria for selecting a case are
	explained in <guideref targ="chap:vecm"/>.
      </para>

      <para context="cli">
	The optional lists <repl>xlist</repl> and <repl>rxlist</repl>
	allow you to control for specified exogenous variables: these
	enter the system either unrestrictedly (<repl>xlist</repl>) or
	restricted to the cointegration space (<repl>rxlist</repl>). These
	lists are separated from <repl>ylist</repl> and from each other by
	semicolons.
      </para>

      <para context="gui">
	You may control for exogenous variables by adding them to the
	lower list box.  By default these enter the model in unrestricted
	form (indicated by a <lit>U</lit> next to the name of the
	variable).  If you want a certain exogenous variable to be
	restricted to the cointegrating space, right-click on it and
	select <quote>Restricted</quote> from the pop-up menu.  The symbol
	next to the variable will change to R.
      </para>

      <para context="cli">
	The <opt>--seasonals</opt> option, which may be combined with any of the
	other options, specifies the inclusion of a set of centered seasonal
	dummy variables.  This option is available only for quarterly or monthly
	data.
      </para>

      <para context="gui">
	If the data are quarterly or monthly, a check box is shown that allows
	you to include a set of centered seasonal dummy variables.  In all
	cases, an additional check box (<quote>Show details</quote>) allows
	for the printing of the auxiliary regressions that form the starting
	point of the Johansen maximum likelihood estimation procedure.
      </para>

      <para context="notex">
	The following table is offered as a guide to the
	interpretation of the results shown for the test, for the
	3-variable case.  <lit>H0</lit> denotes the null hypothesis,
	<lit>H1</lit> the alternative hypothesis, and <lit>c</lit> the
	number of cointegrating relations.
      </para>
      <mono context="notex">
         Rank     Trace test         Lmax test
                  H0     H1          H0     H1
         ---------------------------------------
          0      c = 0  c = 3       c = 0  c = 1
          1      c = 1  c = 3       c = 1  c = 2
          2      c = 2  c = 3       c = 2  c = 3
         ---------------------------------------
      </mono>
      <para context="tex">
	The following table is offered as a guide to the
	interpretation of the results shown for the test, for the
	3-variable case.  $H_0$ denotes the null hypothesis,
	$H_1$ the alternative hypothesis, and $c$ the
	number of cointegrating relations.	

	\begin{center}
	\begin{tabular}{cllll}
	&amp; \multicolumn{2}{c}{Trace test} &amp;
	   \multicolumn{2}{c}{$\lambda$-max test} \\
	Rank &amp;  \multicolumn{1}{c}{$H_0$} &amp; 
	       \multicolumn{1}{c}{$H_1$} &amp; 
	       \multicolumn{1}{c}{$H_0$} &amp; 
	       \multicolumn{1}{c}{$H_1$} \\ [4pt]
 	0 &amp; $c$ = 0 &amp; $c$ = 3 &amp; $c$ = 0 &amp; $c$ = 1 \\
	1 &amp; $c$ = 1 &amp; $c$ = 3 &amp; $c$ = 1 &amp; $c$ = 2 \\
	2 &amp; $c$ = 2 &amp; $c$ = 3 &amp; $c$ = 2 &amp; $c$ = 3 
	\end{tabular}
	\end{center}
      </para>

      <para>
	See also the <cmdref targ="vecm"/> command.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Time series/Cointegration test/Johansen</menu-path>
    </gui-access>

  </command>

  <command name="compact" section="Dataset" context="gui"
    label="Compact data">

    <description>

      <para>When you add to a dataset a series that is of higher
	frequency, it is necessary to <quote>compact</quote> the new
	series.  For instance, a monthly series will have to be
	compacted to fit into a quarterly dataset.</para>  

      <para>In addition, you may sometimes want to compact an entire
	dataset to a lower frequency (perhaps, prior to adding a
	lower-frequency variable to the dataset).</para>

      <para>Gretl offers four options for compacting:</para>

      <ilist>
	<li><para>Averaging: The value written to the dataset will be
	    the arithmetic mean of the relevant series values.  For
	    instance the value written for the first quarter of 1990
	    will be the average of the values for January, February
	    and March of 1990.</para>
	</li>
	<li><para>Summing: The value written to the dataset will be
	    the sum of the relevant higher-frequency values.  For
	    example, the first-quarter value will be the sum of the
	    January, February and March values.</para>
	</li>
	<li><para>End-of-period values: The value written to the
	    dataset is the last relevant value from the
	    higher-frequency data.  For example, the first quarter of
	    1990 will get the March 1990 value.</para>
	</li>
	<li><para>Start-of-period values: The value written to the
	    dataset is the first relevant value from the
	    higher-frequency data.  For example, the first quarter of
	    1990 will get the January 1990 value.</para>
	</li>
      </ilist>

      <para>In the case of compacting an entire dataset, the choice
	you make in this dialog box sets the default method.  But if
	you have set a compaction method for an individual variable
	(menu item <quote>Variable/Edit attributes</quote>) that
	method is used rather than the default.  If the compaction
	method is already set for all variables, the choice of a
	default compaction method is not presented.
      </para>

    </description>
  </command>

  <command name="controlled" section="Graphs" context="gui"
    label="Scatterplot with control">

    <description>
      <para>
	This command requires the selection of three variables, one for the X
	axis, one for the Y axis, and one for which you wish to control (call
	it Z).  The plot shows adjusted Y against adjusted X, where the
	adjusted version of the variable is the residual from an OLS
	regression on Z.  
      </para>
      <para>
	Example: You have data on wages, experience and education level
	for a sample of people.  You wish to plot wages against education,
	controlling for experience.  In that case you select wages for
	the Y axis, education for the X axis, and experience as the control.
	The plot shows wages against education, with both variables
	<quote>purged</quote> of the effect of experience.
      </para>
    </description>

  </command>

  <command name="corr" section="Statistics" 
    label="Correlation coefficients">

    <usage>
      <arguments>
        <argument optional="true">varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--uniform</flag>
	  <effect>ensure uniform sample</effect>
	</option>
	<option>
	  <flag>--spearman</flag>
	  <effect>Spearman's rho</effect>
	</option>
	<option>
	  <flag>--kendall</flag>
	  <effect>Kendall's tau</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print rankings</effect>
	</option>
      </options>
      <examples>
        <example>corr y x1 x2 x3</example>
	<example>corr ylist --uniform</example>
	<example>corr x y --spearman</example>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Prints the pairwise correlation coefficients (Pearson's product-moment
	correlation) for the selected variables. The default behavior is to
	use all available observations for computing each pairwise
	coefficient, but if the option box is checked the sample is limited (if
	necessary) so that the same set of observations is used for all the
	coefficients.  This option has an effect only if there are differing
	numbers of missing values for the variables used.
      </para>
    </description>

    <description context="cli">
      <para>
	By default, prints the pairwise correlation coefficients (Pearson's
	product-moment correlation) for the variables in <repl>varlist</repl>,
	or for all variables in the data set if <repl>varlist</repl> is not
	given.  The standard behavior is to use all available observations for
	computing each pairwise coefficient, but if the <flag>--uniform</flag>
	option is given the sample is limited (if necessary) so that the same
	set of observations is used for all the coefficients.  This option
	has an effect only if there are differing numbers of missing values
	for the variables used.
      </para>
      <para>
	The (mutually exclusive) options <opt>--spearman</opt> and
	<opt>--kendall</opt> produce, respectively, Spearman's rank
	correlation rho and Kendall's rank correlation tau in place of the
	default Pearson coefficient.  When either of these options is given,
	<repl>varlist</repl> should contain just two variables.
      </para>
      <para>
	When a rank correlation is computed, the <opt>verbose</opt> option can
	be used to print the original and ranked data (otherwise this option
	is ignored).
      </para>
    </description>

    <gui-access>
      <menu-path>/View/Correlation matrix</menu-path>
      <other-access>Main window pop-up menu (multiple selection)</other-access>
    </gui-access>

  </command>

  <command name="corrgm" section="Statistics" label="Correlogram">

    <usage>
      <arguments>
        <argument>series</argument>
        <argument optional="true">order</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't draw ACF graph</effect>
	</option>
      </options>
      <examples>
        <example>corrgm x 12</example>
      </examples>
    </usage>

    <description>
      <para>
	Prints the values of the autocorrelation function for
	<repl>series</repl>, which may be specified by name or number.  The
	values are defined as 
	<equation status="inline" 
	  tex="$\hat{\rho}(u_t, u_{t-s})$" 
	  ascii="rho(u(t), u(t-s))" 
	  graphic="autocorr"/> where
	<math>u</math><sub>t</sub> is the <math>t</math>th
	observation of the variable <math>u</math> and
	<math>s</math> is the number of lags.
      </para>
      <para>
	The partial autocorrelations (calculated using the
	Durbin&ndash;Levinson algorithm) are also shown: these are net of the
	effects of intervening lags.  In addition the Ljung&ndash;Box
	<math>Q</math> statistic is printed.  This may be used to test the
	null hypothesis that the series is <quote>white noise</quote>; it is
	asymptotically distributed as chi-square with degrees of freedom equal
	to the number of lags used.  Unless the <opt>--quiet</opt> option is
	given, a plot of the correlogram is printed.
      </para>
      <para>
	If a <repl>order</repl> value is specified the length of the
	correlogram is limited to at most that number of lags, otherwise the
	length is determined automatically, as a function of the frequency of
	the data and the number of observations.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Correlogram</menu-path>
      <other-access>Main window pop-up menu (single selection)</other-access>
    </gui-access>

  </command>

  <command name="count-model" section="Estimation" context="gui"
    label="Models for count data">

    <description>
      <para>
	The dependent variable is taken to represent a count of the occurrence
	of events of some sort, and must have only non-negative integer
	values. By default the Poisson distribution is used, but the drop-down
	selector gives the options of using the Negative Binomial
	distribution. (The variant NegBin 2 is commonly used in econometrics,
	but the lesser used NegBin 1 is also available.)
      </para>
      <para>
	Optionally, you may add an <quote>offset</quote> variable to the
	specification.  This is a scale variable, the log of which is added to
	the linear regression function (implicitly, with a coefficient of
	1.0).  This makes sense if you expect the number of occurrences of the
	event in question to be proportional, other things equal, to some
	known factor.  For example, the number of traffic accidents might be
	supposed to be proportional to traffic volume, other things equal, and
	in that case traffic volume could be specified as an
	<quote>offset</quote> in a model of the accident rate. The
	offset variable must be strictly positive.  
      </para>
      <para>
	By default, standard errors are computed using a numerical
	approximation to the Hessian at convergence.  But if the <quote>Robust
	  standard errors</quote> box is checked then QML standard errors are
	calculated, using a <quote>sandwich</quote> of the inverse of the
	Hessian and the outer product of the gradient.
      </para>
    </description>
  </command>

  <command name="curve" section="Graphs" label="Plot a curve"
    context="gui">

    <description>
      <para>
	This dialog box allows you to create a gnuplot graph by specifying a
	formula. This must be an expression acceptable to gnuplot.  Use
	<lit>x</lit> to denote the value of the variable on the x-axis.
	Please note that gnuplot uses <lit>**</lit> for exponentiation
	(raising to a power), and that the decimal character must be given as
	<quote>.</quote>.  Examples:
      </para>
      <code>
	10+0.35*x
	100+5.3*x-0.12*x**2
	sin(x)
	exp(sqrt(pi*x))
      </code>
      <para>
	To put an additional line onto a graph created in this way, click
	on the graph and select <quote>Edit</quote>, select the
	<quote>Lines</quote> tab in the graph editing dialog, and use
	the <quote>Add line</quote> button.
      </para>
    </description>
  </command>

  <command name="cusum" section="Tests" label="CUSUM test">

    <usage>
      <options>
	<option>
	  <flag>--squares</flag>
	  <effect>perform the CUSUMSQ test</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>just print the Harvey&ndash;Collier test</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Must follow the estimation of a model via OLS.  Performs the
	CUSUM test&mdash;or if the <opt>--squares</opt> option is
	given, the CUSUMSQ test&mdash;for parameter stability.  A
	series of one-step ahead forecast errors is obtained by
	running a series of regressions: the first regression uses the
	first <math>k</math> observations and is used to
	generate a prediction of the dependent variable at observation
	<math>k</math> + 1; the second uses the first
	<math>k</math> + 1 observations and generates a
	prediction for observation <math>k</math> + 2, and so on
	(where <math>k</math> is the number of parameters in the
	original model).
      </para>
      <para>
	The cumulated sum of the scaled forecast errors, or the
	squares of these errors, is printed and graphed.  The null
	hypothesis of parameter stability is rejected at the 5 percent
	significance level if the cumulated sum strays outside of the
	95 percent confidence band.
      </para>
      <para>
	In the case of the CUSUM test, the Harvey&ndash;Collier
	<math>t</math>-statistic for testing the null hypothesis of
	parameter stability is also printed.  See Greene's
	<book>Econometric Analysis</book> for details.  For the CUSUMSQ
	test, the 95 percent confidence band is calculated using the
	algorithm given in <cite key="edgerton94">Edgerton and Wells
	(1994)</cite>.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/CUSUM(SQ)</menu-path>
    </gui-access>

  </command>

  <command name="data" section="Dataset" 
    label="Import from database" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't report results except on error</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Reads the variables in <repl>varlist</repl> from a database
	(gretl, RATS 4.0 or PcGive), which must have been opened
	previously using the <cmdref targ="open"/> command.  The
	data frequency and sample range may be established via the
	<cmdref targ="setobs"/> and <cmdref targ="smpl"/> commands prior
	to using this command. Here is a full example:</para>
      <code>
	open macrodat.rat
	setobs 4 1959:1
	smpl ; 1999:4
	data GDP_JP GDP_UK
      </code>
      <para>
	The commands above open a database named
	<filename>macrodat.rat</filename>, establish a quarterly data set
	starting in the first quarter of 1959 and ending in the fourth
	quarter of 1999, and then import the series named
	<lit>GDP_JP</lit> and <lit>GDP_UK</lit>.</para>
      <para>
	If <lit>setobs</lit> and <lit>smpl</lit> are not specified in this
	way, the data frequency and sample range are set using the first
	variable read from the database.
      </para>
      <para>
	If the series to be read are of higher frequency than the working
	data set, you may specify a compaction method as below:</para>
      <code>
	data (compact=average) LHUR PUNEW
      </code>
      <para>
	The four available compaction methods are <quote>average</quote>
	(takes the mean of the high frequency observations),
	<quote>last</quote> (uses the last observation),
	<quote>first</quote> and <quote>sum</quote>.  If no method is
	specified, the default is to use the average.
      </para>

    </description>

    <gui-access>
      <menu-path>/File/Databases</menu-path>
    </gui-access>

  </command>

  <command name="dataset" section="Dataset" 
    label="Manipulate the dataset" context="cli">

    <usage>
      <arguments>
        <argument>keyword</argument>
	<argument>parameters</argument>
      </arguments>
      <examples>
        <example>dataset addobs 24</example>
	<example>dataset insobs 10</example>
        <example>dataset compact 1</example>
        <example>dataset compact 4 last</example>
        <example>dataset expand interp</example>
        <example>dataset transpose</example>
	<example>dataset sortby x1</example>
	<example>dataset resample 500</example>
	<example>dataset renumber x 4</example>
	<example>dataset clear</example>
      </examples>
    </usage>

    <description>
      <para>
	Performs various operations on the data set as a whole,
	depending on the given <repl>keyword</repl>, which must be
	<lit>addobs</lit>, <lit>insobs</lit>, <lit>clear</lit>,
	<lit>compact</lit>, <lit>expand</lit>, <lit>transpose</lit>,
	<lit>sortby</lit>, <lit>dsortby</lit>, <lit>resample</lit> or
	<lit>renumber</lit>. Note: with the exception of
	<lit>clear</lit>, these actions are not available when the
	dataset is currently subsampled by selection of cases on some
	Boolean criterion.
      </para>
      <para>
	<lit>addobs</lit>: Must be followed by a positive integer.  Adds
	the specified number of extra observations to the end of the
	working dataset.  This is primarily intended for forecasting
	purposes.  The values of most variables over the additional range
	will be set to missing, but certain deterministic variables are
	recognized and extended, namely, a simple linear trend and
	periodic dummy variables. 
      </para>
      <para>
	<lit>insobs</lit>: Must be followed by a positive integer no
	greater than the current number of observations. Inserts a
	single observation at the specified position. All subsequent
	data are shifted by one place and the dataset is extended by
	one observation. All variables apart from the constant are
	given missing values at the new observation. This action is
	not available for panel datasets.
      </para>
      <para>
	<lit>clear</lit>: No parameter required.  Clears out the current
	data, returning gretl to its initial <quote>empty</quote> state.
      </para>      
      <para>
	<lit>compact</lit>: Must be followed by a positive integer
	representing a new data frequency, which should be lower than the
	current frequency (for example, a value of 4 when the current
	frequency is 12 indicates compaction from monthly to quarterly).
	This command is available for time series data only; it compacts
	all the series in the data set to the new frequency.  A second
	parameter may be given, namely one of <lit>sum</lit>,
	<lit>first</lit> or <lit>last</lit>, to specify, respectively,
	compaction using the sum of the higher-frequency values,
	start-of-period values or end-of-period values.  The default
	is to compact by averaging.
      </para>
      <para>
	<lit>expand</lit>: This command is only available for annual or
	quarterly time series data: annual data can be expanded to
	quarterly, and quarterly data to monthly frequency. By 
	default all the series in the data set are padded out to the new
	frequency by repeating the existing values, but if the
	modifier <lit>interp</lit> is appended then the series
	are expanded using Chow-Lin interpolation: the regressors are
	a constant and quadratic trend and an AR(1) disturbance process
	is assumed.
      </para>
      <para>
	<lit>transpose</lit>: No additional parameter required.
	Transposes the current data set.  That is, each observation (row)
	in the current data set will be treated as a variable (column),
	and each variable as an observation.  This command may be useful
	if data have been read from some external source in which the rows
	of the data table represent variables.
      </para>
      <para>
	<lit>sortby</lit>: The name of a single series or list is required. If
	one series is given, the observations on all variables in the dataset
	are re-ordered by increasing value of the specified series. If a list
	is given, the sort proceeds hierarchically: if the observations are
	tied in sort order with respect to the first key variable then the
	second key is used to break the tie, and so on until the tie is broken
	or the keys are exhausted. Note that this command is available only
	for undated data.
      </para>
      <para>
	<lit>dsortby</lit>: Works as <lit>sortby</lit> except that
	the re-ordering is by decreasing value of the key series.
      </para>
      <para>
	<lit>resample</lit>: Constructs a new dataset by random
	sampling, with replacement, of the rows of the current dataset.
	One argument is required, namely the number of rows to
	include.  This may be less than, equal to, or greater than
	the number of observations in the original data.  The
	original dataset can be retrieved via the command
	<lit>smpl full</lit>.  
      </para>
      <para>
	<lit>renumber</lit>: Requires the name of an existing series
	followed by an integer between 1 and the number of series in the
	dataset minus one. Moves the specified series to the specified
	position in the dataset, renumbering the other series
	accordingly. (Position 0 is occupied by the constant, which
	cannot be moved.)
      </para>
    </description>

    <gui-access>
      <menu-path>/Data</menu-path>
    </gui-access>

  </command>

  <command name="datasort" section="Dataset" context="gui"
    label="Sorting data">

    <description>
      <para>
	The selected variable is used as a sort key for the entire
	data set.  The observations on all variables are
	re-ordered by increasing value of the key variable, or by
	decreasing value if you select the <quote>Descending</quote>
	option.
      </para>
    </description>
  </command>

  <command name="debug" section="Programming" context="cli"
    label="Debugging">

    <usage>
      <arguments>
        <argument>function</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Experimental debugger for user-defined functions, available in the
	command-line program, gretlcli, and in the GUI console.  The
	<lit>debug</lit> command should be invoked after the function in
	question is defined but before it is called.  The effect is that
	execution pauses when the function is called and a special prompt is
	shown.
      </para>
      <para>
	At the debugging prompt you can type <lit>next</lit> to execute the
	next command in the function, or <lit>continue</lit> to allow
	execution of the function to continue unimpeded. These commands can be
	abbreviated as <lit>n</lit> and <lit>c</lit> respectively.  You can
	also interpolate an instruction at this prompt, for example a
	<lit>print</lit> command to reveal the current value of some variable
	of interest.
      </para>
    </description>
  </command>  

  <command name="delete" section="Dataset" 
    label="Delete variables" context="cli">

    <usage>
      <arguments>
        <argument>varname</argument>
      </arguments>
      <options>
	<option>
	  <flag>--db</flag>
	  <effect>delete series from database</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	This command is an all-purpose destructor for named variables
	(whether series, scalars, matrices, strings or bundles). It
	should be used with caution; no confirmation is asked.
      </para>
      <para>
	In the case of series, <repl>varname</repl> may take the form
	of a named list, in which case all series in the list are
	deleted, or it may take the form of an explicit list of series
	given by name or ID number. Note that when you delete series
	any series with higher ID numbers than those on the deletion
	list will be re-numbered.
      </para>
      <para>
	If the <opt>--db</opt> option is given, this command deletes the
	listed series not from the current dataset but from a gretl
	database, assuming that a database has been opened, and the user
	has write permission for file in question.  See also the
	<cmdref targ="open"/> command.
      </para>
    </description>

    <gui-access>
      <menu-path>Main window pop-up (single selection)</menu-path>
    </gui-access>

  </command>

  <command name="density" section="Statistics" context="gui"
    label="Kernel density estimation">

    <description>

      <para>Kernel density estimation proceeds by defining a set of
	evenly spaced reference points, over a suitable range in
	relation to the range of the data, and attributing a density
	to each reference point based on the actual observations in
	the vicinity.
      </para>
      <para>The formula used to compute the estimated density at each
	reference point, <math>x</math>, is
      <equation status="display"
	tex="\[f(x)=(1/nh) \sum_{t-1}^{n} k\left((x-x_t)/h\right)\]"
	ascii="f(x) = (1/nh) sum(t=1 to n) k((x - x(t)) / h)"
	graphic="kernel1"/>
	where <math>n</math> denotes the number of data
	points, <math>h</math> is a <quote>bandwidth</quote>
	parameter, and <math>k</math>() is the kernel function.
	The larger the value of the bandwidth parameter, the smoother
	the estimated density.
      </para>
      <para>
	You are given the choice of using a Gaussian kernel (the
	standard normal density) or the Epanechnikov kernel.  By
	default, the bandwidth is that suggested as a rule of thumb by
	<cite key="silverman96">Silverman (1986)</cite>, namely
	<equation status="display"
	  tex="\[h=0.9 {\rm min}(s, {\rm IQR}/1.349) n^{1/5}\]"
	  ascii="h = 0.9 min(s, IQR/1.349) n^{1/5}"
	  graphic="kernel2"/>
	where <math>s</math> denotes the standard deviation
	of the data and IQR denotes the inter-quartile range.  You can
	widen or shrink the bandwidth via the <quote>bandwidth
	  adjustment factor</quote>: the actual bandwidth used is
	obtained by multiplying the Silverman value by the adjustment
	factor.
      </para>
      <para>
	For a good introductory discussion of kernel density
	estimation see Chapter 15 of Davidson and MacKinnon's
	<book>Econometric Theory and Methods</book>.
      </para>

    </description>

  </command>  

  <command name="dfgls" section="Tests" context="gui"
    label="The ADF-GLS test">

    <description>
      <para>
	The ADF-GLS test is a variant of the Dickey&ndash;Fuller
	test for a unit root, for the case where the variable
	to be tested is assumed to have a non-zero mean or to
	exhibit a linear trend.  The difference is that 
	the de-meaning or de-trending of the variable is done
	using the GLS procedure suggested by Elliott, Rothenberg
	and Stock (1996).  This gives a test of greater power than
	the standard Dickey&ndash;Fuller approach.
      </para>
      <para>
	See also the <cmdref targ="adf"/> command and the <opt>--gls</opt>
	option.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/ADF-GLS test</menu-path>
    </gui-access>

  </command>

  <command name="dialog" section="Estimation" context="gui"
    label="Model dialog box">

    <description>
      <para>To select the dependent variable, highlight a variable in
	the list on the left and press the <quote>Choose</quote>
	button pointing to the Dependent variable slot.  If you check
	the <quote>Set as default</quote> box, the selected variable
	will be pre-selected as dependent when the model dialog is
	next opened.  Short-cut: double-click on a variable on the
	left to select it as the dependent variable and also set it as
	the default.
      </para>
      <para>To select independent variables, highlight them on the
	left and press the <quote>Add</quote> button (or click the
	right mouse button).  You can highlight several contiguous
	variables by dragging with the mouse.  You can highlight a
	group of non-contiguous variables by clicking on them with the
	<lit>Ctrl</lit> key pressed.
      </para>
    </description>

  </command>

  <command name="diff" section="Transformations" 
    label="First differences" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	The first difference of each variable in <repl>varlist</repl>
	is obtained and the result stored in a new variable with the
	prefix <lit>d_</lit>.  Thus <cmd>diff x y</cmd> creates the
	new variables
      </para>
      <mono>
	d_x = x(t) - x(t-1)
	d_y = y(t) - y(t-1)
      </mono>
    </description>

    <gui-access>
      <menu-path>/Add/First differences of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="difftest" section="Tests" 
    label="Nonparametric tests for differences" context="cli">

    <usage>
      <arguments>
        <argument>var1</argument>
	<argument>var2</argument>
      </arguments>
      <options>
	<option>
	  <flag>--sign</flag>
	  <effect>Sign test, the default</effect>
	</option>
	<option>
	  <flag>--rank-sum</flag>
	  <effect>Wilcoxon rank-sum test</effect>
	</option>
	<option>
	  <flag>--signed-rank</flag>
	  <effect>Wilcoxon signed-rank test</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print extra output</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Carries out a nonparametric test for a difference between two
	populations or groups, the specific test depending on the option
	selected.
      </para>
      <para>
	With the <opt>--sign</opt> option, the Sign test is performed.
	This test is based on the fact that if two samples,
	<math>x</math> and <math>y</math>, are drawn randomly
	from the same distribution, the probability that
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>, for each observation
	<math>i</math>, should equal 0.5.  The test statistic is
	<math>w</math>, the number of observations for which
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>. Under the null hypothesis this
	follows the Binomial distribution with parameters
	(<math>n</math>, 0.5), where <math>n</math> is the
	number of observations.
      </para>
      <para>
	With the <opt>--rank-sum</opt> option, the Wilcoxon rank-sum test
	is performed.  This test proceeds by ranking the observations from
	both samples jointly, from smallest to largest, then finding the
	sum of the ranks of the observations from one of the samples.  The
	two samples do not have to be of the same size, and if they differ
	the smaller sample is used in calculating the rank-sum.  Under the
	null hypothesis that the samples are drawn from populations with
	the same median, the probability distribution of the rank-sum can
	be computed for any given sample sizes; and for reasonably large
	samples a close Normal approximation exists.
      </para>
      <para>
	With the <opt>--signed-rank</opt> option, the Wilcoxon signed-rank
	test is performed.  This is designed for matched data pairs such
	as, for example, the values of a variable for a sample of
	individuals before and after some treatment.  The test proceeds by
	finding the differences between the paired observations,
	<math>x</math><sub>i</sub> &minus;
	<math>y</math><sub>i</sub>, ranking these differences by
	absolute value, then assigning to each pair a signed rank, the
	sign agreeing with the sign of the difference.  One then
	calculates <math>W</math><sub>+</sub>, the sum of the
	positive signed ranks.  As with the rank-sum test, this statistic
	has a well-defined distribution under the null that the median
	difference is zero, which converges to the Normal for samples
	of reasonable size.
      </para>
      <para>
	For the Wilcoxon tests, if the <opt>--verbose</opt> option is
	given then the ranking is printed.  (This option has no effect if
	the Sign test is selected.)
      </para>
    </description>

  </command>

  <command name="discrete" section="Transformations" 
    label="Mark variables as discrete" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--reverse</flag>
	  <effect>mark variables as continuous</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Marks each variable in <repl>varlist</repl> as being discrete. By
	default all variables are treated as continuous; marking a
	variable as discrete affects the way the variable is handled in
	frequency plots, and also allows you to select the variable for
	the command <cmdref targ="dummify"/>.
      </para>
      <para>
	If the <opt>--reverse</opt> flag is given, the operation is reversed;
	that is, the variables in <repl>varlist</repl> are marked as
	being continuous.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Edit attributes</menu-path>
    </gui-access>

  </command>

  <command name="dpanel" section="Estimation" label="Dynamic panel models">

    <usage>
      <arguments>
	<argument>p</argument>
	<argblock separated="true">
	  <argument>depvar</argument>
	  <argument>indepvars</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>instruments</argument>
	</argblock>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't show estimated model</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
        <option>
	  <flag>--two-step</flag>
	  <effect>perform 2-step GMM estimation</effect>
        </option>
        <option>
	  <flag>--system</flag>
	  <effect>add equations in levels</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>add time dummy variables</effect>
        </option>
        <option>
	  <flag>--dpdstyle</flag>
	  <effect>emulate DPD package for Ox</effect>
        </option>
        <option>
	  <flag>--asymptotic</flag>
	  <effect>uncorrected asymptotic standard errors</effect>
        </option>
      </options>
      <examples>
        <example>dpanel 2 ; y x1 x2</example>
	<example>dpanel 2 ; y x1 x2 --system</example>
        <example>dpanel {2 3} ; y x1 x2 ; x1</example>
	<example>dpanel 1 ; y x1 x2 ; x1 GMM(x2,2,3)</example>
	<demos>
	  <demo>bbond98.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Carries out estimation of dynamic panel data models (that is,
	panel models including one or more lags of the dependent
	variable) using either the GMM-DIF or GMM-SYS method.
      </para>
      <para context="cli">
	The parameter <repl>p</repl> represents the order of the
	autoregression for the dependent variable. In the simplest
	case this is a scalar value, but a pre-defined matrix may be
	given for this argument, to specify a set of (possibly
	non-contiguous) lags to be used.
      </para>
      <para>
	The dependent variable and regressors should be given in
	levels form; they will be differenced automatically (since
	this estimator uses differencing to cancel out the individual
	effects).
      </para>
      <para context="cli">
	The last (optional) field in the command is for specifying
	instruments.  If no instruments are given, it is assumed that all
	the independent variables are strictly exogenous.  If you specify
	any instruments, you should include in the list any strictly
	exogenous independent variables.  For predetermined regressors,
	you can use the <lit>GMM</lit> function to include a specified
	range of lags in block-diagonal fashion.  This is illustrated in
	the third example above.  The first argument to <lit>GMM</lit> is
	the name of the variable in question, the second is the minimum
	lag to be used as an instrument, and the third is the maximum lag.
	The same syntax can be used with the <lit>GMMlevel</lit>
	function to specify GMM-type instruments for the equations
	in levels.
      </para>
      <para context="gui">
	As regards the handling of instruments, please see the
	documentation for the script version of this command.  Currently
	you cannot specify instruments explicitly in the GUI: all the
	independent variables are taken to be strictly exogenous.
      </para>
      <para>
	By default the results of 1-step estimation are reported (with
	robust standard errors).  You may select 2-step estimation as an
	option.  In both cases tests for autocorrelation of orders 1 and 2
	are provided, as well as the Sargan overidentification test and a
	Wald test for the joint significance of the regressors.  Note that
	in this differenced model first-order autocorrelation is not a
	threat to the validity of the model, but second-order
	autocorrelation violates the maintained statistical assumptions.
      </para>
      <para context="cli">
	In the case of 2-step estimation, standard errors are by default
	computed using the finite-sample correction suggested by <cite
	key="windmeijer05">Windmeijer (2005)</cite>.  The standard
	asymptotic standard errors associated with the 2-step estimator
	are generally reckoned to be an unreliable guide to inference, but
	if for some reason you want to see them you can use the
	<opt>--asymptotic</opt> option to turn off the Windmeijer
	correction.
      </para>
      <para context="cli">
	If the <opt>--time-dummies</opt> option is given, a set of
	time dummy variables is added to the specified regressors.  
	The number of dummies is one less than the maximum number of
	periods used in estimation, to avoid perfect collinearity with
	the constant.  The dummies are entered in differenced form unless
	the <lit>--dpdstyle</lit> option is given, in which case they
	are entered in levels.
      </para>
      <para>
	For further details and examples, please see <guideref
	targ="chap-dpanel"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Panel/Dynamic panel model</menu-path>
    </gui-access>

  </command>

  <command name="dummify" section="Transformations" 
    label="Create sets of dummies" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--drop-first</flag>
	  <effect>omit lowest value from encoding</effect>
	</option>
	<option>
	  <flag>--drop-last</flag>
	  <effect>omit highest value from encoding</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	For any suitable variables in <repl>varlist</repl>, creates a set
	of dummy variables coding for the distinct values of that
	variable.   Suitable variables are those that have been explicitly
	marked as discrete, or those that take on a fairly small number of
	values all of which are <quote>fairly round</quote> (multiples of
	0.25).
      </para>
      <para>
	By default a dummy variable is added for each distinct value of
	the variable in question.  For example if a discrete variable
	<lit>x</lit> has 5 distinct values, 5 dummy variables will be
	added to the data set, with names <lit>Dx_1</lit>, <lit>Dx_2</lit>
	and so on.  The first dummy variable will have value 1 for
	observations where <lit>x</lit> takes on its smallest value, 0
	otherwise; the next dummy will have value 1 when <lit>x</lit>
	takes on its second-smallest value, and so on.  If one of the
	option flags <opt>--drop-first</opt> or <opt>--drop-last</opt>
	is added, then either the lowest or the highest value of each
	variable is omitted from the encoding (which may be useful for
	avoiding the <quote>dummy variable trap</quote>).
      </para>
      <para>
	This command can also be embedded in the context of a regression
	specification.  For example, the following line specifies a model
	where <lit>y</lit> is regressed on the set of dummy variables
	coding for <lit>x</lit>.  (Option flags cannot be passed to
	<cmd>dummify</cmd> in this context.)
      </para>
      <code>
	ols y dummify(x)
      </code>
    </description>

  </command>

  <command name="duration" section="Estimation" label="Duration models" 
    context="cli">
    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
        <argument separated="true" optional="true">censvar</argument>
      </arguments>
      <options>
        <option>
          <flag>--exponential</flag>
          <effect>use exponential distribution</effect>
        </option>
        <option>
          <flag>--loglogistic</flag>
          <effect>use log-logistic distribution</effect>
        </option>
        <option>
          <flag>--lognormal</flag>
          <effect>use log-normal distribution</effect>
        </option>
        <option>
          <flag>--medians</flag>
          <effect>fitted values are medians</effect>
        </option>
        <option>
          <flag>--robust</flag>
          <effect>robust (QML) standard errors</effect>
        </option>
        <option>
          <flag>--vcv</flag>
          <effect>print covariance matrix</effect>
        </option>
        <option>
          <flag>--verbose</flag>
          <effect>print details of iterations</effect>
        </option>
      </options>      
      <examples>
        <example>duration y 0 x1 x2</example>
	<example>duration y 0 x1 x2 ; cens</example>
      </examples>
    </usage>

    <description>
      <para>
	Estimates a duration model: the dependent variable (which must be
	positive) represents the duration of some state of affairs, for 
	example the length of spells of unemployment for a cross-section
	of respondents. By default the Weibull distribution is used but
	the exponential, log-logistic and log-normal distributions are
	also available.
      </para>
      <para>
	If some of the duration measurements are right-censored (&eg; an
	individual's spell of unemployment has not come to an end within the
	period of observation) then you should supply the trailing argument
	<repl>censvar</repl>, a series in which non-zero values indicate
	right-censored cases.
      </para>
      <para>
	By default the fitted values obtained via the accessor
	<lit>$yhat</lit> are the conditional means of the durations, but if
	the <lit>--medians</lit> option is given then <lit>$yhat</lit>
	provides the conditional medians instead.
      </para>
      <para>
	Please see <guideref targ="chap:discr-models"/> for details.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Duration data...</menu-path>
    </gui-access>

  </command>  

  <command name="elif" section="Programming" label="Flow control" context="cli">
    <description>
      <para>See <cmdref targ="if"/>.
      </para>
    </description>
  </command>

  <command name="else" section="Programming" context="cli">
    <description>
      <para>See <cmdref targ="if"/>. Note that <cmd>else</cmd>
	requires a line to itself, before the following
	conditional command. You can append a comment, as in
      </para>
      <code>
	else # OK, do something different
      </code>
      <para>
	But you cannot append a command, as in
      </para>
      <code>
	else x = 5 # wrong!
      </code>
    </description>
  </command>

  <command name="end" section="Programming" 
    label="End block of commands" context="cli">
    <description>
      <para>
	Ends a block of commands of some sort.  For example, <cmd>end
	  system</cmd> terminates an equation <cmdref targ="system"/>.
      </para>
    </description>
  </command>

  <command name="endif" section="Programming" label="Flow control" context="cli">
    <description><para>See <cmdref targ="if"/>.</para>
    </description>
  </command>

  <command name="endloop" section="Programming" 
    label="End a command loop" context="cli">
    <description>
      <para>
	Marks the end of a command loop.  See <cmdref targ="loop"/>.
      </para>
    </description>
  </command>

  <command name="eqnprint" section="Printing" 
    label="Print model as equation" context="cli">

    <usage>
      <arguments>
        <argument optional="true">-f filename</argument>
      </arguments>
      <options>
        <option>
	  <flag>--complete</flag>
	  <effect>Create a complete document</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Must follow the estimation of a model.  Prints the estimated
	model in the form of a &latex; equation.  If a filename is
	specified using the <lit>-f</lit> flag output goes to that
	file, otherwise it goes to a file with a name of the form
	<filename>equation_N.tex</filename>, where <lit>N</lit> is the
	number of models estimated to date in the current session.
	See also <cmdref targ="tabprint"/>.
      </para>
      <para>
	If the <opt>--complete</opt> flag is given, the &latex; file is
	a complete document, ready for processing; otherwise it must
	be included in a document.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="equation" section="Estimation" 
    label="Define equation within a system" context="cli">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <examples>
        <example>equation y x1 x2 x3 const</example>
      </examples>
    </usage>

    <description>
      <para>
	Specifies an equation within a system of equations (see 
	<cmdref targ="system"/>).  The syntax for specifying an
	equation within an SUR system is the same as that for, &eg;, 
	<cmdref targ="ols"/>.  For an equation within a Three-Stage Least
	Squares system you may either (a) give an OLS-type equation
	specification and provide a common list of instruments using the
	<cmd>instr</cmd> keyword (again, see <cmdref targ="system"/>),
	or (b) use the same equation syntax as for <cmdref targ="tsls"/>.
      </para>
    </description>

  </command>

  <command name="estimate" section="Estimation" 
    label="Estimate system of equations" context="cli">

    <usage>
      <arguments>
        <argument optional="true">systemname</argument>
        <argument optional="true">estimator</argument>
      </arguments>
      <options>
	<option>
	  <flag>--iterate</flag>
	  <effect>iterate to convergence</effect>
	</option>
	<option>
	  <flag>--no-df-corr</flag>
	  <effect>no degrees of freedom correction</effect>
	</option>
	<option>
	  <flag>--geomean</flag>
	  <effect>see below</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't print results</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
      </options>
      <examples>
        <example>estimate "Klein Model 1" method=fiml</example>
	<example>estimate Sys1 method=sur</example>
	<example>estimate Sys1 method=sur --iterate</example>
      </examples>
    </usage>

    <description>
      <para>
	Calls for estimation of a system of equations, which must have
	been previously defined using the <cmdref targ="system"/>
	command.  The name of the system should be given first,
	surrounded by double quotes if the name contains spaces.  The
	estimator, which must be one of <cmd>ols</cmd>,
	<cmd>tsls</cmd>, <cmd>sur</cmd>, <cmd>3sls</cmd>,
	<cmd>fiml</cmd> or <cmd>liml</cmd>, is preceded by the string
	<lit>method=</lit>. These arguments are optional if the
	system in question has already been estimated and occupies the
	place of the <quote>last model</quote>; in that case the
	estimator defaults to the previously used value.
      </para>
      <para>
	If the system in question has had a set of restrictions
	applied (see the <cmdref targ="restrict"/> command),
	estimation will be subject to the specified restrictions.
      </para>
      <para>
	If the estimation method is <cmd>sur</cmd> or <cmd>3sls</cmd>
	and the <opt>--iterate</opt> flag is given, the estimator will
	be iterated.  In the case of SUR, if the procedure converges
	the results are maximum likelihood estimates.  Iteration of
	three-stage least squares, however, does not in general
	converge on the full-information maximum likelihood results.
	The <opt>--iterate</opt> flag is ignored for other methods of
	estimation.  
      </para>
      <para>
	If the equation-by-equation estimators <cmd>ols</cmd> or
	<cmd>tsls</cmd> are chosen, the default is to apply a degrees
	of freedom correction when calculating standard errors. This
	can be suppressed using the <opt>--no-df-corr</opt> flag. This
	flag has no effect with the other estimators; no degrees of
	freedom correction is applied in any case.
      </para>
      <para>
	By default, the formula used in calculating the
	elements of the cross-equation covariance matrix is
	<equation status="display"
	tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{T}\]"
	ascii="sigma(i,j) = u(i)' * u(j) / T"
	graphic="syssigma1"/>
	If the <opt>--geomean</opt> flag is
	given, a degrees of freedom correction is applied: the
	formula is
	<equation status="display"
	tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{\sqrt{(T-k_i)(T-k_j)}}\]"
	ascii="sigma(i,j) = u(i)' * u(j) / sqrt((T - ki) * (T - kj))"
	graphic="syssigma2"/>
	where the <math>k</math>s denote the number of
	independent parameters in each equation.
      </para>
      <para>
	If the <opt>verbose</opt> option is given and an iterative
	method is specified, details of the iterations are printed.
      </para>
    </description>

  </command>

  <command name="expand" section="Dataset" context="gui"
    label="Expand data">

    <description>
      <para>
	If you wish to add to a dataset a series that is of lower
	frequency, it is necessary to <quote>expand</quote> the new
	series.  For instance, a quarterly series will have to be expanded
	to fit into a monthly dataset. In addition, you may sometimes want
	to expand an entire dataset to a higher frequency (perhaps, prior
	to adding a higher-frequency variable to the dataset).
      </para>
      <para>
	Expansion of data should be considered an
	<quote>expert</quote> option; you need to know what you are
	doing. When combining series of differing original frequencies
	within one dataset, you should probably consider compacting
	the higher-frequency data rather than expanding the
	lower-frequency series.
      </para>
      <para>
	That said, gretl offers two options: higher-frequency values
	can be interpolated using the method of Chow and Lin (1971),
	or the values of the lower-frequency series can be repeated as
	many times as required.
      </para>
      <para>
	The Chow-Lin method is regression-based, using a constant and
	quadratic trend and assuming a first-order autoregressive
	process for the disturbances. Four degrees of freedom are used
	up by this procedure. As for the repetition of values, suppose
	we have a quarterly series with the value 35.5 in 1990:1, the
	first quarter of 1990.  On expansion to monthly, the value
	35.5 will be assigned to the observations for January,
	February and March of 1990.  The expanded variable is
	therefore useless for fine-grained time-series analysis,
	outside of the special case where you know that the variable
	in question does in fact remain constant over the sub-periods.
      </para>
    </description>
  </command>

  <command name="export" section="Dataset" context="gui"
    label="Export data">

    <description>
      <para>
	You may export data in Comma-Separated Values (CSV) format: such
	data may be opened in spreadsheets and many other application
	programs. If you select this option you will get some further
	options regarding the specific format of the CSV file.
      </para>
      <para>
	You also have the option of exporting data in the form of a
	<quote>native</quote> gretl datafile, or (if the data are
	suitable) exporting to a gretl database. See
	<url>gretl.sourceforge.net/gretl_data.html</url> for an account of
	gretl databases.
      </para>
      <para>
	You may also export data in a format suitable for use with
	the following programs:
      </para>
      <ilist>
	<li>
	  <para>GNU R (<url>www.r-project.org</url>)</para>
	</li>
	<li>
	  <para>GNU octave (<url>www.gnu.org/software/octave</url>)
	  </para>
	</li>
	<li>
	  <para>JMulTi (<url>www.jmulti.de</url>)</para>
	</li>
	<li>
	  <para>PcGive (<url>www.pcgive.com</url>)</para>
	</li>
      </ilist>
      <para>
	If you wish to export data by copying to the clipboard rather than
	writing to a file on disk, select the series you want to copy in
	the main window, right-click, and select <quote>Copy to
	clibboard</quote>. (Only CSV format is supported in this
	context.) 
      </para>
    </description>
  </command>

  <command name="factorized" section="Graphs" context="gui"
    label="Factorized plot">

    <description>
      <para>
	This command requires the selection of three variables, the last
	of which must be a dummy variable (values 1 or 0). The Y variable
	is plotted against the X variable, with the data points colored
	differently depending on the value of the third.
      </para>
      <para>
	Example: You have data on wages and educational attainment for a
	sample of people; you also have a dummy variable with value 1 for
	men and 0 for women (as in Ramanathan's
	<filename>data7-2</filename>).  A <quote>factorized plot</quote>
	of <lit>WAGE</lit> against <lit>EDUC</lit> using the
	<lit>GENDER</lit> dummy as factor will show the data points for
	men in one color and those for women in another (with a legend to
	identify them).
      </para>
    </description>

  </command>

  <command name="fcast" section="Prediction" 
    label="Generate forecasts">

    <usage>
      <arguments>
        <argument optional="true">startobs endobs</argument>
	<argument optional="true">steps-ahead</argument>
	<argument optional="true">varname</argument>
      </arguments>
      <options>
        <option>
	  <flag>--dynamic</flag>
	  <effect>create dynamic forecast</effect>
        </option>
        <option>
	  <flag>--static</flag>
	  <effect>create static forecast</effect>
        </option>
        <option>
	  <flag>--out-of-sample</flag>
	  <effect>generate post-sample forecast</effect>
        </option>
        <option>
	  <flag>--no-stats</flag>
	  <effect>don't print forecast statistics</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>don't print anything</effect>
        </option>
        <option>
	  <flag>--rolling</flag>
	  <effect>see below</effect>
        </option>
        <option>
	  <flag>--plot</flag>
	  <optparm optional="true">filename</optparm>
	  <effect>see below</effect>
        </option>
      </options>
      <examples>
        <example>fcast 1997:1 2001:4 f1</example>
	<example>fcast fit2</example>
	<example>fcast 2004:1 2008:3 4 rfcast --rolling</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Must follow an estimation command.  Forecasts are generated for
	the specified range of observations. Depending on the nature of
	the model, standard errors may also be generated (see below).
      </para>

      <para context="cli">
	Must follow an estimation command.  Forecasts are generated for a
	certain range of observations: if <repl>startobs</repl> and
	<repl>endobs</repl> are given, for that range (if possible); otherwise
	if the <opt>--out-of-sample</opt> option is given, for observations
	following the range over which the model was estimated; otherwise over
	the currently defined sample range.  If an out-of-sample forecast is
	requested but no relevant observations are available, an error is
	flagged. Depending on the nature of the model, standard errors may
	also be generated; see below.  Also see below for the special effect
	of the <opt>--rolling</opt> option.
      </para>

      <para context="cli">
	If the last model estimated is a single equation, then the
	optional <repl>varname</repl> argument has the following effect:
	the forecast values are not printed, but are saved to the dataset
	under the given name.  If the last model is a system of equations,
	<repl>varname</repl> has a different effect, namely selecting a
	particular endogenous variable for forecasting (the default being
	to produce forecasts for all the endogenous variables). In the
	system case, or if <repl>varname</repl> is not given, the forecast
	values can be retrieved using the accessor <lit>$fcast</lit>, and
	the standard errors, if available, via <lit>$fcerr</lit>.
      </para>

      <para>
	The choice between a static and a dynamic forecast applies
	only in the case of dynamic models, with an autoregressive
	error process or including one or more lagged values of the
	dependent variable as regressors.  Static forecasts are one
	step ahead, based on realized values from the previous period,
	while dynamic forecasts employ the chain rule of forecasting.
	For example, if a forecast for <math>y</math> in 2008
	requires as input a value of <math>y</math> for 2007, a
	static forecast is impossible without actual data for 2007.  A
	dynamic forecast for 2008 is possible if a prior forecast can
	be substituted for <math>y</math> in 2007.
      </para>

      <para>
	The default is to give a static forecast for any portion of
	the forecast range that lies within the sample range over which
	the model was estimated, and a dynamic forecast (if relevant)
	out of sample.  The <lit>dynamic</lit> option requests a
	dynamic forecast from the earliest possible date, and the
	<opt>static</opt> option requests a static forecast even out
	of sample.  
      </para>

      <para context="cli">
	The <opt>rolling</opt> option is presently available only for
	single-equation models estimated via OLS.  When this option is given
	the forecasts are recursive. That is, each forecast is generated from
	an estimate of the given model using data from a fixed starting point
	(namely, the start of the sample range for the original estimation) up
	to the forecast date minus <math>k</math>, where <math>k</math> is the
	number of steps ahead, which must be given in the
	<repl>steps-ahead</repl> argument. The forecasts are always dynamic if
	this is applicable.  Note that the <repl>steps-ahead</repl> argument
	should be given only in conjunction with the <opt>rolling</opt>
	option.
      </para>

      <para context="cli">
	The <opt>--plot</opt> option (available only in the case of
	single-equation estimation) calls for a plot file to be
	produced, containing a graphical representation of the
	forecast.  When no <repl>filename</repl> parameter is given,
	gretl writes a gnuplot command file with a name on the pattern
	<lit>gpttmp01.plt</lit> to the user's gretl working directory
	(with the number incremented for successive plots).  If a
	<repl>filename</repl> is appended, its extension is used to
	determine the type of file to be written (<lit>.eps</lit> for
	EPS, <lit>.pdf</lit> for PDF, or <lit>.png</lit> for PNG; any
	other extension gives a gnuplot command file).  For example,
      </para>
      <code>
	fcast --plot=fc.pdf
      </code>
      <para>
	will generate a graphic in PDF format.  Absolute pathnames are
	respected, otherwise files are written to the gretl working directory.
      </para>

      <para>
	The nature of the forecast standard errors (if available) depends
	on the nature of the model and the forecast.  For static linear
	models standard errors are computed using the method outlined by
	<cite key="davidson-mackinnon04">Davidson and MacKinnon
	(2004)</cite>; they incorporate both uncertainty due to the error
	process and parameter uncertainty (summarized in the covariance
	matrix of the parameter estimates).  For dynamic models, forecast
	standard errors are computed only in the case of a dynamic
	forecast, and they do not incorporate parameter uncertainty.  For
	nonlinear models, forecast standard errors are not presently
	available.
      </para>	

    </description>

    <gui-access>
      <menu-path>Model window, /Analysis/Forecasts</menu-path>
    </gui-access>

  </command>

  <command name="foreign" section="Programming" 
    label="Non-native script" context="cli">

    <usage>
      <syntax><lit>foreign language=</lit><repl>lang</repl></syntax>
      <options>
	<option>
	  <flag>--send-data</flag>
	  <effect>pre-load the current dataset; see below</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress output from foreign program</effect>
	</option>
      </options>
    </usage>

    <description>
     <para>
	This command opens a special mode in which commands to be executed
	by another program are accepted.  You exit this mode with <lit>end
	  foreign</lit>; at this point the stacked commands are executed.
      </para>
      <para>
	At present three <quote>foreign</quote> programs are supported in this
	way, GNU R (<lit>language=R</lit>), Jurgen Doornik's Ox
	(<lit>language=Ox</lit>) and GNU Octave (<lit>language=Octave</lit>).
	Language names are recognized on a case-insensitive basis.
      </para>
      <para>
	The <opt>--send-data</opt> option is valid only in connection with
	R and Octave; it has the effect of making the entire current gretl
	dataset available within the target program, under the name
	<lit>gretldata</lit>.
      </para>
      <para>
	See <guideref targ="chap:gretlR"/> for details and examples.
      </para>
    </description>

  </command>

  <command name="fractint" section="Statistics" label="Fractional integration">
  
    <usage>
      <arguments>
        <argument>series</argument>
	<argument optional="true">order</argument>
      </arguments>
      <options>
        <option>
	  <flag>--gph</flag>
	  <effect>do Geweke and Porter-Hudak test</effect>
        </option>
        <option>
	  <flag>--all</flag>
	  <effect>do both tests</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>don't print results</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Tests the specified series for fractional integration
	(<quote>long memory</quote>). The null hypothesis is that the
	integration order of the series is zero.  By default the local
	Whittle estimator <cite key="robinson95" p="true">(Robinson,
	1995)</cite> is used but if the <opt>--gph</opt> option is given
	the GPH test <cite key="GPH83" p="true">(Geweke and
	Porter-Hudak, 1983)</cite> is performed instead. If the
	<opt>--all</opt> flag is given then the results of both tests
	are printed.
      </para>
      <para>
	For details on this sort of test, see <cite key="phillips04">Phillips 
	and Shimotsu (2004)</cite>. 
      </para>
      <para>
	If the optional <repl>order</repl> argument is not given the order
	for the test(s) is set automatically as the lesser of
	<math>T</math>/2 and <math>T</math><sup>0.6</sup>.
      </para>
      <para>
	The results can be retrieved using the accessors <lit>$test</lit>
	and <lit>$pvalue</lit>. These values are based on the Local
	Whittle Estimator unless the <opt>--gph</opt> option is given.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Unit root tests/Fractional integration</menu-path>
    </gui-access>

  </command>


  <command name="freq" section="Statistics" label="Frequency distribution">

    <usage>
      <arguments>
        <argument>series</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nbins</flag>
	  <optparm>n</optparm>
	  <effect>specify number of bins</effect>
        </option>
        <option>
	  <flag>--min</flag>
	  <optparm>minval</optparm>
	  <effect>specify minimum, see below</effect>
        </option>
        <option>
	  <flag>--binwidth</flag>
	  <optparm>width</optparm>
	  <effect>specify bin width, see below</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of graph</effect>
        </option>
        <option>
	  <flag>--normal</flag>
	  <effect>test for the normal distribution</effect>
        </option>
        <option>
	  <flag>--gamma</flag>
	  <effect>test for gamma distribution</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>don't print anything</effect>
        </option>
        <option>
	  <flag>--show-plot</flag>
	  <effect>see below</effect>
        </option>
      </options>
      <examples>
        <example>freq x</example>
	<example>freq x --normal</example>
	<example>freq x --nbins=5</example>
	<example>freq x --min=0 --binwidth=0.10</example>
      </examples>
    </usage>

    <description context="cli">
      <para>
	With no options given, displays the frequency distribution for
	<repl>series</repl> (given by name or number), with the number
	of bins and their size chosen automatically.
      </para>
      <para>
	To control the presentation of the distribution you may
	specify <emphasis>either</emphasis> the number of bins or
	the minimum value plus the width of the bins, as shown in
	the last two examples above. The <opt>--min</opt> option
	sets the lower limit of the left-most bin.
      </para>
      <para>
	If the <opt>--normal</opt> option is given, the
	Doornik&ndash;Hansen chi-square test for normality is computed. If
	the <opt>--gamma</opt> option is given, the test for normality is
	replaced by Locke's nonparametric test for the null hypothesis
	that the variable follows the gamma distribution; see <cite
	key="locke76">Locke (1976)</cite>, <cite
	key="shapiro-chen01">Shapiro and Chen (2001)</cite>.  Note that
	the parameterization of the gamma distribution used in gretl is
	(shape, scale).
      </para>
      <para>
	In interactive mode a graph of the distribution is displayed by
	default. The <opt>--quiet</opt> flag can be used to suppress
	this. Conversely, the graph is not usually shown when the
	<cmd>freq</cmd> is used in a script, but you can force its
	display by giving the <opt>--show-plot</opt> option. (This does
	not apply when using the command-line program,
	<lit>gretlcli</lit>.)
      </para>
      <para>
	The <opt>--silent</opt> flag suppresses the usual output entirely.
	This makes sense only in conjunction with one or other of the
	distribution test options: the test statistic and its p-value are
	recorded, and can be retrieved using the accessors
	<lit>$test</lit> and <lit>$pvalue</lit>.
      </para>
    </description>

    <description context="gui">
      <para>
	In the frequency plot dialog box you can control the
	characteristics of the plot in either of two ways.
      </para>
      <para>
	First, you may choose the number of bins.  In this case the width
	and placement of the bins are calculated automatically.
      </para>
      <para>
	Alternatively, you may specify the lower limit of the left-most
	bin, and the width of the bins.  In this case the number of bins
	is calculated automatically.
      </para>
      <para>
	If you wish to align the bins on round numbers, here is one way to
	proceed: start by specifying the number of bins you want, and take
	a look at the plot that is produced.  If it's not to your liking,
	take note of the modification that is required (for example, make
	the left-most bin start at 100 and impose a bin width of 200).
	Then make a second pass where you specify the left-hand limit and
	bin width.
      </para>
      <para>
	This dialog also allows you to select a theoretical distribution to be
	plotted against the data: either the normal or the gamma.  If the
	normal option is selected the Doornik&ndash;Hansen test for normality
	is computed.  If the gamma option is selected, gretl computes Locke's
	nonparametric test for the null hypothesis that the variable follows
	the gamma distribution.  Note that the parameterization of the gamma
	distribution used in gretl is (shape, scale).
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Frequency distribution</menu-path>
    </gui-access>

  </command>

  <command name="function" section="Programming" 
    label="Define a function" context="cli">

    <usage>
      <arguments>
        <argument>fnname</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Opens a block of statements in which a function is defined.  This
	block must be closed with <lit>end function</lit>.  Please see
	<guideref targ="chap:functions"/> for details.
      </para>
    </description>

  </command>  

  <command name="garch" section="Estimation" label="GARCH model">

    <usage>
      <arguments>
        <argument>p</argument>
	<argument>q</argument>
	<argument separated="true">depvar</argument>
	<argument optional="true">indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
        <option>
	  <flag>--nc</flag>
	  <effect>do not include a constant</effect>
        </option>
        <option>
	  <flag>--stdresid</flag>
	  <effect>standardize the residuals</effect>
        </option>
        <option>
	  <flag>--fcp</flag>
	  <effect>use Fiorentini, Calzolari, Panattoni algorithm</effect>
        </option>
        <option>
	  <flag>--arma-init</flag>
	  <effect>initial variance parameters from ARMA</effect>
        </option>
      </options>
      <examples>
        <example>garch 1 1 ; y</example>
	<example>garch 1 1 ; y 0 x1 x2 --robust</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Estimates a GARCH model (GARCH = Generalized Autoregressive
	Conditional Heteroskedasticity), either a univariate model or,
	if <repl>indepvars</repl> are specified, including the given
	exogenous variables.  The integer values <repl>p</repl> and
	<repl>q</repl> (which may be given in numerical form or as the
	names of pre-existing scalar variables) represent the lag
	orders in the conditional variance equation:
	<equation status="display"
	  tex="\[h_t = \alpha_0 + \sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} +
	  \sum_{j=1}^p \beta_j h_{t-j}\]"
	  ascii="h(t) = a(0) + sum(i=1 to q) a(i)*u(t-i)^2 + sum(j=1 to p) b(j)*h(t-j)"
	  graphic="garch_h"/>
      </para>
      <para context="cli">
	The parameter <repl>p</repl> therefore represents the Generalized
	(or <quote>AR</quote>) order, while <repl>q</repl> represents the
	regular ARCH (or <quote>MA</quote>) order.  If <repl>p</repl> is
	non-zero, <repl>q</repl> must also be non-zero otherwise the model
	is unidentified.  However, you can estimate a regular ARCH model
	by setting <repl>q</repl> to a positive value and <repl>p</repl>
	to zero.  The sum of <repl>p</repl> and <repl>q</repl> must be no
	greater than 5.  Note that a constant is automatically included in
	the mean equation unless the <opt>--nc</opt> option is given.
      </para>

      <para context="gui">
	Estimates a GARCH model (GARCH = Generalized Autoregressive
	Conditional Heteroskedasticity), either a univariate model or,
	if independent variables are selected, including the given
	exogenous variables.  The conditional variance equation is
	shown below.
	<equation status="display" tex="\[h_t = \alpha_0 + 
	\sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} + \sum_{j=1}^p
	\beta_i h_{t-j}\]" ascii="h(t) = a(0) + sum(i=1 to q) a(i)*u(t-i) +
	sum(j=1 to p) b(j)*h(t-j)" graphic="garch_h"/>
      </para>
      <para context="gui">
	The parameter <repl>p</repl> therefore represents the Generalized
	(or <quote>AR</quote>) order, while <repl>q</repl> represents the
	regular ARCH (or <quote>MA</quote>) order.  If <repl>p</repl> is
	non-zero, <repl>q</repl> must also be non-zero otherwise the model
	is unidentified.  However, you can estimate a regular ARCH model
	by setting <repl>q</repl> to a positive value and <repl>p</repl>
	to zero.  The sum of <repl>p</repl> and <repl>q</repl> must be no
	greater than 5.
      </para>

      <para>
	By default native gretl code is used in estimation of GARCH
	models, but you also have the option of using the algorithm of
	<cite key="fiorentini96">Fiorentini, Calzolari and Panattoni
	(1996)</cite>.  The former uses the BFGS maximizer while the
	latter uses the information matrix to maximize the likelihood,
	with fine-tuning via the Hessian.
      </para>

      <para context="cli">
	Several variant estimators of the covariance matrix are available
	with this command.  By default, the Hessian is used unless the
	<opt>--robust</opt> option is given, in which case the QML (White)
	covariance matrix is used.  Other possibilities (&eg; the
	information matrix, or the Bollerslev&ndash;Wooldridge estimator)
	can be specified using the <cmdref targ="set"/> command.
      </para>

      <para context="gui">
	Several variant estimates of the coefficient covariance matrix are
	available with this command.  By default, the Hessian is used
	unless the <quote>Robust standard errors</quote> box is checked,
	in which case the QML (White) covariance matrix is used.  Other
	possibilities (&eg; the information matrix, or the
	Bollerslev&ndash;Wooldridge estimator) can be specified using the
	<cmdref targ="set"/>
	command.
      </para>

      <para context="gui">
	The estimated conditional variance, along with the residuals and
	various other model statistics, can be accessed and added to the
	dataset using the <quote>Model data</quote> menu in the window where
	the model is displayed.  If the box marked <quote>Standardize the
	residuals</quote> is checked, the residuals are divided by the
	square root of te conditional variance.
      </para>

      <para context="cli">
	By default, the estimates of the variance parameters are
	initialized using the unconditional error variance from
	initial OLS estimation for the constant, and small positive
	values for the coefficients on the past values of the squared
	error and the error variance.  The flag <opt>--arma-init</opt>
	calls for the starting values of these parameters to be
	set using an initial ARMA model, exploiting the relationship
	between GARCH and ARMA set out in Chapter 21 of Hamilton's
	<book>Time Series Analysis</book>.  In some cases this may 
	improve the chances of convergence.
      </para>

      <para context="cli">
	The GARCH residuals and estimated conditional variance can be
	retrieved as <lit>$uhat</lit> and <lit>$h</lit> respectively.  For
	example, to get the conditional variance:  
      </para>
      <code context="cli">
	genr ht = $h
      </code>
      <para context="cli">
	If the <opt>--stdresid</opt> option is given, the <lit>$uhat</lit>
	values are divided by the square root of <math>h</math><sub>t</sub>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Time series/GARCH</menu-path>
    </gui-access>

  </command>

  <command name="genr" section="Dataset"
    label="Generate a new variable">

    <usage>
      <arguments>
        <argument>newvar</argument>
        <argument>= formula</argument>
      </arguments>
    </usage>

    <description>
      <para context="cli">
	In the appropriate context, <lit>series</lit>, <lit>scalar</lit>
	and <lit>matrix</lit> are synonyms for this command.
      </para>

      <para context="cli">
	Creates new variables, often via transformations of existing
	variables. See also <cmdref targ="diff"/>, <cmdref targ="logs"/>,
	<cmdref targ="lags"/>, <cmdref targ="ldiff"/>, 
	<cmdref targ="sdiff"/> and <cmdref targ="square"/>
	for shortcuts. In the context of a <lit>genr</lit> formula, existing
	variables must be referenced by name, not ID number.  The formula should
	be a well-formed combination of variable names, constants, operators and
	functions (described below).  Note that further details on some aspects
	of this command can be found in <guideref targ="chap-genr"/>.
      </para>

      <para context="gui">
	Use this box to define a new variable, on the pattern
	<repl>name</repl> = <repl>formula</repl>.  The formula should be a
	well-formed combination of variable names, constants, operators and
	functions (details below).  To ensure you get the type of variable you
	want, you can prefix the formula with a type-name, &eg;
	<lit>scalar</lit>, <lit>series</lit> or <lit>matrix</lit>.  For
	example, to create a series that has a constant value of 10,
	you can type
      </para>
      <code context="gui">
	series c = 10
      </code>
      <para context="gui">
	(otherwise <lit>c = 10</lit> would create a scalar variable).
      </para>

      <para context="cli">
	A <lit>genr</lit> command may yield either a series or a scalar
	result.  For example, the formula <lit>x2 = x * 2</lit> naturally
	yields a series if the variable <lit>x</lit> is a series and a
	scalar if <lit>x</lit> is a scalar.  The formulae <lit>x = 0</lit>
	and <lit>mx = mean(x)</lit> naturally return scalars. Under some
	circumstances you may want to have a scalar result expanded into a
	series or vector.  You can do this by using <lit>series</lit> as
	an <quote>alias</quote> for the <lit>genr</lit> command.  For
	example, <lit>series x = 0</lit> produces a series all of whose
	values are set to 0.  You can also use <lit>scalar</lit> as an
	alias for <lit>genr</lit>.  It is not possible to coerce a vector
	result into a scalar, but use of this keyword indicates that the
	result <emphasis>should be</emphasis> a scalar: if it is not, an
	error occurs.
      </para>

      <para context="cli">
	When a formula yields a series result, the range over which
	the result is written to the target variable depends on the current
	sample setting.  It is possible, therefore, to define a series piecewise
	using the <lit>smpl</lit> command in conjunction with <lit>genr</lit>.
      </para>

      <para>
	Supported <emphasis>arithmetical operators</emphasis> are, in
	order of precedence: <lit>^</lit> (exponentiation);
	<lit>*</lit>, <lit>/</lit> and <lit>%</lit> (modulus or
	remainder); <lit>+</lit> and <lit>-</lit>. 
      </para>

      <para>
	The available <emphasis>Boolean operators</emphasis> are (again,
	in order of precedence): <lit>!</lit> (negation),
	<lit>&amp;&amp;</lit> (logical AND), <lit>||</lit> (logical OR),
	<lit>&gt;</lit>, <lit>&lt;</lit>, <lit>=</lit>, <lit>&gt;=</lit>
	(greater than or equal), <lit>&lt;=</lit> (less than or equal) and
	<lit>!=</lit> (not equal).  The Boolean operators can be used in
	constructing dummy variables: for instance <lit>(x > 10)</lit>
	returns 1 if <lit>x</lit> &gt; 10, 0 otherwise.
      </para>

      <para>
	Built-in constants are <lit>pi</lit> and <lit>NA</lit>.  The latter
	is the missing value code: you can initialize a variable to the missing
	value with <lit>scalar x = NA</lit>.
      </para>

      <para>
	The <lit>genr</lit> command supports a wide range of mathematical and
	statistical functions, including all the common ones plus several that
	are special to econometrics.  In addition it offers access to numerous
	internal variables that are defined in the course of running
	regressions, doing hypothesis tests, and so on.
	<refnote xref="false"> 
	  For a listing of functions and accessors, type 
	  <quote>help functions</quote>. 
	</refnote> 
	<refnote xref="true">
	  For a listing of functions and accessors, see 
	  <gfr targ="chap:funcref"/>. 
	</refnote>
      </para>

      <para>
	Besides the operators and functions noted above there are
	some special uses of <cmd>genr</cmd>:
      </para>

      <ilist>
	<li>
	  <para>
	    <cmd>genr time</cmd> creates a time trend variable (1,2,3,&hellip;)
	    called <cmd>time</cmd>. <cmd>genr index</cmd> does the same thing
	    except that the variable is called <lit>index</lit>.
	  </para>
	</li>
	<li>
	  <para>
	    <cmd>genr dummy</cmd> creates dummy variables up to the periodicity
	    of the data.  In the case of quarterly data
	    (periodicity 4), the program creates <lit>dq1</lit> = 1 for
	    first quarter and 0 in other quarters, <lit>dq2</lit> = 1 for
	    the second quarter and 0 in other quarters, and so on.  With
	    monthly data the dummies are named <lit>dm1</lit>, <lit>dm2</lit>,
	    and so on.  With other frequencies the names are
	    <lit>dummy_1</lit>, <lit>dummy_2</lit>, etc.
	  </para>
	</li>
	<li>
	  <para>
	    <cmd>genr unitdum</cmd> and <cmd>genr timedum</cmd> create 
	    sets of special dummy variables for use with panel data.
	    The first codes for the cross-sectional units and the second
	    for the time period of the observations.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Note</emphasis>: In the command-line program, <cmd>genr</cmd>
	commands that retrieve model-related data always reference the model
	that was estimated most recently. This is also true in the GUI program,
	if one uses <cmd>genr</cmd> in the <quote>gretl console</quote> or
	enters a formula using the <quote>Define new variable</quote> option
	under the Variable menu in the main window.  With the GUI, however, you
	have the option of retrieving data from any model currently displayed in
	a window (whether or not it's the most recent model).  You do this under
	the <quote>Model data</quote> menu in the model's window.
      </para>

      <para>
	The special variable <lit>obs</lit> serves as an index of the
	observations.  For instance <lit>genr dum = (obs=15)</lit> will
	generate a dummy variable that has value 1 for observation 15, 0
	otherwise.  You can also use this variable to pick out particular
	observations by date or name.  For example, 
	<lit>genr d = (obs&gt;1986:4)</lit>, 
	<lit>genr d = (obs&gt;"2008/04/01")</lit>, or
	<lit>genr d = (obs="CA")</lit>.  If daily dates or observation labels
	are used in this context, they should be enclosed in double quotes.
	Quarterly and monthly dates (with a colon) may be used unquoted. Note
	that in the case of annual time series data, the year is not
	distinguishable syntactically from a plain integer; therefore if you
	wish to compare observations against <lit>obs</lit> by year you must
	use the function <lit>obsnum</lit> to convert the year to a 1-based
	index value, as in <lit>genr d = (obs&gt;obsnum(1986))</lit>.
      </para>

      <para>
	Scalar values can be pulled from a series in the context of a
	<lit>genr</lit> formula, using the syntax
	<repl>varname</repl><lit>[</lit><repl>obs</repl><lit>]</lit>. The
	<repl>obs</repl> value can be given by number or date. Examples:
	<lit>x[5]</lit>, <lit>CPI[1996:01]</lit>.  For daily data, the form
	<repl>YYYY/MM/DD</repl> should be used, &eg; <lit>ibm[1970/01/23]</lit>.
      </para>

      <para>
	An individual observation in a series can be modified via
	<lit>genr</lit>.  To do this, a valid observation number or date, in
	square brackets, must be appended to the name of the variable on the
	left-hand side of the formula.  For example, <lit>genr x[3] = 30</lit>
	or <lit>genr x[1950:04] = 303.7</lit>.
      </para>

      <table id="tab-genr" title="Examples of use of genr command"
	lhead="Formula" rhead="Comment" lwidth="100pt" rwidth="300pt" 
	style="rpara">
	<row>
	  <cell><lit>y = x1^3</lit></cell>
	  <cell><lit>x1</lit> cubed</cell>
	</row>          
	<row>
	  <cell><lit>y = ln((x1+x2)/x3)</lit></cell>
	  <cell></cell>
	</row>
	<row>
	  <cell><lit>z = x&gt;y</lit></cell>
	  <cell><lit>z(t)</lit> = 1 if <lit>x(t) &gt; y(t)</lit>,
	    otherwise 0</cell>
	</row> 
	<row>
	  <cell><lit>y = x(-2)</lit></cell>
	  <cell><lit>x</lit> lagged 2 periods</cell>
	</row>     
	<row>
	  <cell><lit>y = x(+2)</lit></cell>
	  <cell><lit>x</lit> led 2 periods</cell>
	</row>
	<row>
	  <cell><lit>y = diff(x)</lit></cell>
	  <cell><lit>y(t) = x(t) - x(t-1)</lit></cell>
	</row>
	<row>
	  <cell><lit>y = ldiff(x)</lit></cell>
	  <cell><lit>y(t) = log x(t) - log x(t-1)</lit>, the
	    instantaneous rate of growth of <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sort(x)</lit></cell>
	  <cell>sorts <lit>x</lit> in increasing order and stores in
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = dsort(x)</lit></cell>
	  <cell>sort <lit>x</lit> in decreasing order</cell>
	</row>
	<row>
	  <cell><lit>y = int(x)</lit></cell>
	  <cell>truncate <lit>x</lit> and store its integer value as
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = abs(x)</lit></cell>
	  <cell>store the absolute values of <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sum(x)</lit></cell>
	  <cell>sum <lit>x</lit> values excluding missing <lit>NA</lit>
	    entries</cell>
	</row>
	<row>
	  <cell><lit>y = cum(x)</lit></cell>
	  <cell>cumulation: 
		<equation status="inline"
		  tex="$y_t = \sum_{\tau=1}^t x_{\tau}$"
		  ascii="y(t) = the sum from s=1 to s=t of x(s)"
		  graphic="cumulate"/>
	  </cell>
	</row>
	<row>
	  <cell><lit>aa = $ess</lit></cell>
	  <cell>set <lit>aa</lit> equal to the Error Sum of Squares
	    from last regression</cell>
	</row>
	<row>
	  <cell><lit>x = $coeff(sqft)</lit></cell>
	  <cell>grab the estimated coefficient on the variable
	    <lit>sqft</lit> from the last regression</cell>
	</row>
	<row>
	  <cell><lit>rho4 = $rho(4)</lit></cell>
	  <cell>grab the 4th-order autoregressive coefficient from the
	    last model (presumes an <lit>ar</lit> model)</cell>
	</row>
	<row>
	  <cell><lit>cvx1x2 = $vcv(x1, x2)</lit></cell>
	  <cell>grab the estimated coefficient covariance of vars
	    <lit>x1</lit> and <lit>x2</lit> from the last model</cell>
	</row>
	<row>
	  <cell><lit>foo = uniform()</lit></cell>
	  <cell>uniform pseudo-random variable in range
	    0&ndash;1</cell>
	</row>
	<row>
	  <cell><lit>bar = 3 * normal()</lit></cell>
	  <cell>normal pseudo-random variable, &mu; = 0, &sigma; =
	    3</cell>
	</row>
	<row>
	  <cell><lit>samp = ok(x)</lit></cell>
	  <cell>= 1 for observations where <lit>x</lit> is not
	    missing.</cell>
	</row>
      </table>

    </description>

    <gui-access>
      <menu-path>/Add/Define new variable</menu-path>
      <other-access>Main window pop-up menu</other-access>
    </gui-access>

  </command>

  <command name="genrand" section="Programming" context="gui"
    label="Generating random variables">

    <description>
      <para>
	In this dialog you must give a name for the variable to be
	created, plus some additional information depending on the
	distribution.
      </para>

      <ilist>
	<li>
	  <para>
	    Uniform: the lower and upper bounds for the distribution.
	  </para>
	</li>
	<li>
	  <para>
	    Normal: the mean and (positive) standard deviation.
	  </para>
	</li>
	<li>
	  <para>
	    Chi-square and Student's t: the degrees of freedom, which must
	    be positive.
	  </para>
	</li>
	<li>
	  <para>
	    F: both numerator and denominator degrees of freedom.
	  </para>
	</li>
	<li>
	  <para>
	    gamma: shape and scale parameters (both positive).
	  </para>
	</li>
	<li>
	  <para>
	    Binomial: the <quote>success</quote> probability and the
	    integer number of trials.
	  </para>
	</li>
	<li>
	  <para>
	    Poisson: the positive mean (which also equals the variance).
	  </para>
	</li>
      </ilist>

      <para>
	If you want to generate repeatable sequences of pseudo-random
	numbers, you can set the seed, under the Tools menu.
      </para>

    </description>
  </command>

  <command name="genseed" section="Programming" context="gui"
    label="Setting the seed for random numbers">

    <description>
      <para>
	The "seed" controls the starting point for the sequence of
	pseudo-random numbers generated in a given gretl session. By
	default the seed is set when the program is started, using the
	system time.  This ensures that you get a different
	sequence of random numbers each time you run the program.  If
	you want to obtain repeatable sequences, you need to set the
	seed manually (and take note of the value you used).
      </para>
      <para>
	Note that whenever you click "OK" in this dialog box, the
	generator is re-started, using the given seed.  So, for
	example, if you (a) set the seed to (say) 147; (b) generate a
	series from the standard normal distribution; (c) revisit
	this dialog and click "OK" again with the seed still at 147;
	then (d) generate a second series from the standard normal
	distribution, the two generated series will be identical.
      </para>
    </description>
  </command>

  <command name="gmm" section="Estimation" label="GMM estimation">

    <usage>
      <options>
	<option>
	  <flag>--two-step</flag>
	  <effect>two step estimation</effect>
	</option>
	<option>
	  <flag>--iterate</flag>
	  <effect>iterated GMM</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
	<option>
	  <flag>--lbfgs</flag>
	  <effect>use L-BFGS-B instead of regular BFGS</effect>
	</option>
      </options>
    </usage>

    <description>

      <para>
	Performs Generalized Method of Moments (GMM) estimation using the
	BFGS (Broyden, Fletcher, Goldfarb, Shanno) algorithm. You must
	specify one or more commands for updating the relevant quantities
	(typically GMM residuals), one or more sets of orthogonality
	conditions, an initial matrix of weights, and a listing of the
	parameters to be estimated, all enclosed between the tags
	<lit>gmm</lit> and <lit>end gmm</lit>. Any options should be
	appended to the <lit>end gmm</lit> line.
      </para>
      <para>
	Please see <guideref targ="chap:gmm"/> for details on this command.
	Here we just illustrate with a simple example.
      </para>
      <code>
	gmm e = y - X*b
	  orthog e ; W
	  weights V
	  params b
	end gmm
      </code>
      <para>
	In the example above we assume that <lit>y</lit> and <lit>X</lit>
	are data matrices, <lit>b</lit> is an appropriately sized vector
	of parameter values, <lit>W</lit> is a matrix of instruments, and
	<lit>V</lit> is a suitable matrix of weights.  The statement
      </para>
      <code>
	orthog e ; W
      </code>
      <para>
	indicates that the residual vector <lit>e</lit> is in principle
	orthogonal to each of the instruments composing the columns of
	<lit>W</lit>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/GMM</menu-path>
    </gui-access>

  </command>

  <command name="gnuplot" section="Graphs" 
    label="Create a gnuplot graph" context="cli">

    <usage>
      <arguments>
        <argument>yvars</argument>
        <argument>xvar</argument>
	<argument optional="true">dumvar</argument>
      </arguments>
      <options>
        <option>
	  <flag>--with-lines</flag>
	  <effect>use lines, not points</effect>
        </option>
        <option>
	  <flag>--with-impulses</flag>
	  <effect>use vertical lines</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>plot against time</effect>
        </option>
        <option>
	  <flag>--suppress-fitted</flag>
	  <effect>don't show fitted line</effect>
        </option>
        <option>
	  <flag>--single-yaxis</flag>
	  <effect>force use of just one y-axis</effect>
        </option>
        <option>
	  <flag>--linear-fit</flag>
	  <effect>show least squares fit</effect>
        </option>
        <option>
	  <flag>--inverse-fit</flag>
	  <effect>show inverse fit</effect>
        </option>
        <option>
	  <flag>--quadratic-fit</flag>
	  <effect>show quadratic fit</effect>
        </option>
        <option>
	  <flag>--loess-fit</flag>
	  <effect>show loess fit</effect>
        </option>
        <option>
	  <flag>--dummy</flag>
	  <effect>see below</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>name</optparm>
	  <effect>plot columns of named matrix</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>filename</optparm>
	  <effect>send output to specified file</effect>
        </option>
        <option>
	  <flag>--input</flag>
	  <optparm>filename</optparm>
	  <effect>take input from specified file</effect>
        </option>
      </options>
      <examples>
        <example>gnuplot y1 y2 x</example>
        <example>gnuplot x --time-series --with-lines</example>
	<example>gnuplot wages educ gender --dummy</example>
      </examples>
    </usage>

    <description>
      <para>
	The variables in the list <repl>yvars</repl> are graphed against
	<repl>xvar</repl>.  For a time series plot you may either
	give <lit>time</lit> as <repl>xvar</repl> or use the option
	flag <opt>--time-series</opt>.
      </para>

      <para>
	If the <opt>--dummy</opt> option is selected, exactly three
	variables should be given: a single <math>y</math> variable, an
	<math>x</math> variable, and <repl>dvar</repl>, a discrete
	variable.  The effect is to plot <repl>yvar</repl> against
	<repl>xvar</repl> with the points shown in different colors
	depending on the value of <repl>dvar</repl> at the given
	observation.
      </para>

      <para context="cli">
	Generally, <repl>yvars</repl> and <repl>xvar</repl> refer to series in
	the current dataset (given either by name or ID number).  But if a
	named matrix is supplied via the <opt>--matrix</opt> option these
	arguments (which must be given as numerical values) denote
	(1-based) column indices for the given matrix.  So for example
	if you want a scatterplot of column 2 of matrix <lit>M</lit> against
	column 1, you should do:
      </para>
      <code context="cli">
	gnuplot 2 1 --matrix=M
      </code>

      <para context="cli">
	In interactive mode the plot is displayed immediately. In batch mode
	the default behavior is that a gnuplot command file is written in the
	user's working directory, with a name on the pattern
	<filename>gpttmpN.plt</filename>, starting with N = <lit>01</lit>. The
	actual plots may be generated later using <program>gnuplot</program>
	(under MS Windows, <program>wgnuplot</program>).  This behavior can be
	modified by use of the <opt>--output=</opt><repl>filename</repl>
	option.  This option controls the filename used, and at the same time
	allows you to specify a particular output format via the three-letter
	extension of the file name, as follows: <lit>.eps</lit> results in the
	production of an Encapulated PostScript (EPS) file; <lit>.pdf</lit>
	produces PDF; <lit>.png</lit> produces PNG format, <lit>.emf</lit>
	calls for EMF (Enhanced MetaFile), <lit>.fig</lit> calls for an Xfig
	file, and <lit>.svg</lit> for SVG (Scalable Vector Graphics). If the
	dummy filename <quote><lit>display</lit></quote> is given then the
	plot is shown on screen as in interactive mode. If a filename with any
	extension other than those just mentioned is given, a gnuplot command
	file is written.
      </para>

      <para>
	The various <quote>fit</quote> options are applicable only in
	the case of a bivariate scatterplot.  The default behavior
	is to show the OLS fitted line if and only if the slope
	coefficient is significant at the 10 percent level. If the
	<opt>suppress</opt> option is given, no fitted line is shown.
	If the <opt>linear</opt> option is given, the OLS line is
	shown regardless of whether or not it is significant.  The other
	options&mdash;<opt>inverse</opt>, <opt>quadratic</opt> and
	<opt>loess</opt>&mdash;produce respectively an inverse fit
	(regression of <math>y</math> on 1/<math>x</math>), a
	quadratic fit, or a loess fit.  Loess (also sometimes called
	<quote>lowess</quote>) is a robust locally weighted regression.  
      </para>

      <para>
	A further option to this command is available: following
	the specification of the variables to be plotted and the
	option flag (if any), you may add literal gnuplot commands to
	control the appearance of the plot (for example, setting the
	plot title and/or the axis ranges).  These commands should be
	enclosed in braces, and each gnuplot command must be
	terminated with a semi-colon.  A backslash may be used to
	continue a set of gnuplot commands over more than one line.
	Here is an example of the syntax:
      </para>

      <para>
	<lit>{ set title 'My Title'; set yrange [0:1000]; }</lit>
      </para>

    </description>

    <gui-access>
      <menu-path>/View/Graph specified vars</menu-path>
      <other-access>Main window pop-up menu, graph button on toolbar</other-access>
    </gui-access>

  </command>

  <command name="graphing" section="Graphs" context="gui"
    label="Graphing">

    <description>

      <para>Gretl calls a separate program, namely gnuplot, to
	generate graphs.  Gnuplot is a very full-featured graphing
	program with myriad options.  Gretl gives you direct access,
	via a graphical interface, to a subset of these options and it
	tries to choose sensible values for you; it also allows you to
	take complete control over graph details if you wish.</para>

      <para>With a graph displayed, you can click on the graph window
	for a pop-up menu with the following options:</para>

      <ilist>
	<li><para>Save as postscript: save the graph in encapsulated
	    postscript (EPS) format</para>
	</li>
	<li><para>Save as PNG: save in Portable Network Graphics
	    format</para>
	</li>
	<li><para>Save to session as icon: the graph will appear in
	    iconic form when you select <quote>Icon view</quote> from
	    the Session menu</para>
	</li>
	<li><para>Zoom: lets you select an area within the graph for
	    closer inspection</para>
	</li>
	<li><para>Print: (on the Gnome desktop and MS Windows only)
	    lets you print the graph directly</para>
	</li>
	<li><para>Copy to clipboard: (MS Windows only) lets you paste
	    the graph into Windows applications such as MS
	    Word</para>
	</li>
	<li><para>Edit: opens a controller for the plot which lets you
	    adjust various aspects of its appearance</para>
	</li>
	<li><para>Close: closes the graph window</para>
	</li>
      </ilist>

      <para>
	If you know something about gnuplot and wish to get finer
	control over the appearance of a graph than is available via
	the graphical controller (<quote>Edit</quote> option), you
	have two further options:
      </para>

      <ilist>
	<li>
	  <para>
	    Once the graph is saved as a session icon, you can
	    right-click on its icon for a further pop-up menu.  One of the
	    options here is <quote>Edit plot commands</quote>, which opens
	    an editing window with the actual gnuplot commands displayed.
	    You can edit these commands and either save them for future
	    processing or send them to gnuplot (with the execute toolbar
	    icon in the plot commands editing window).
	  </para>
	</li>
	<li>
	  <para>
	    Another way to save the plot commands (or to save
	    the displayed plot in formats other than EPS or PNG) is to
	    use <quote>Edit</quote> item on a graph's pop-up menu to
	    invoke the graphical controller, then click on the
	    <quote>Output to file</quote> tab in the controller.  You
	    are then presented with a drop-down menu of formats in
	    which to save the graph.
	  </para>
	</li>
      </ilist>

      <para>
	To find out more about gnuplot, see http://www.gnuplot.info
      </para>

    </description>

  </command>

  <command name="graphpg" section="Graphs" label="Gretl graph page">

    <description>

      <para>
	The session <quote>graph page</quote> will work only if you have
	the &latex; typesetting system installed, and are able to generate
	and view PDF or PostScript output.
      </para>

      <para>
	In the session icon window, you can drag up to eight graphs onto
	the graph page icon.  When you double-click on the graph page (or
	right-click and select <quote>Display</quote>), a page containing
	the selected graphs will be composed and opened in a suitable
	viewer.  From there you should be able to print the page.
      </para>

      <para>
	To clear the graph page, right-click on its icon and select
	<quote>Clear</quote>.
      </para> 

      <para>
	In script (or console) mode, you can add a graph to the graph page by
	issuing the command <lit>graphpg add</lit> after saving
	a named graph, as in
      </para>
      <code>
	grf1 &lt;- gnuplot Y X
	graphpg add
      </code>

      <para>
	Also in script mode you can call for display of the graph page using
	the command <lit>graphpg show</lit>, and can clear the page via
	<lit>graphpg free</lit>.
      </para>

      <para>
	Note that on systems other than MS Windows, you may have to adjust the
	setting for the program used to view PDF or PostScript files. Find
	that under the <quote>Programs</quote> tab in the gretl Preferences
	dialog box (under the Tools menu in the main window).
      </para>

    </description>

  </command>

  <command name="3-D" section="Graphs" context="gui"
    label="3-dimensional plots">

    <description>
      <para>This feature works best if you have gnuplot 3.8 or higher
	installed.  In that case you can manipulate the 3-D plot with
	the mouse (rotate it, and expand or shrink the axes).</para>

      <para>In composing a 3-D plot, note that the Z-axis will be
	shown as the vertical axis.  Thus if you have some dependent
	variable that you think may be influenced by two independent
	variables, you should put the dependent variable on the
	Z-axis, and the independent variables on the X and Y
	axes.</para>  

      <para>Unlike most other gretl graphs, 3-D plots are controlled
	by gnuplot rather than gretl itself.  The gretl graph-editing
	menu is not available.</para>

    </description>
  </command>

  <command name="gui-htest" section="Tests" context="gui"
    label="Test statistic calculator">

    <description>
      <para>
	Gretl's test calculator computes test statistics and p-values for
	various common hypothesis tests concerning one or two populations.  The
	required input takes the form of sample statistics derived from one or
	two samples, depending on the test chosen.  These statistics can be
	typed in as numerical values.  Alternatively, if you have a data file
	open, you can get gretl to calculate sample statistics for a selected
	variable or variables (in the case of means and variances, but not in
	the case of proportions).
      </para>

      <para>
	If you want to base your test on a variable in the data set, first
	activate this option by checking the box titled "Use variable from
	dataset".  Then the drop-down list of variables will become active and
	you can select a variable.  When you select a variable from the list,
	the relevant statistics are automatically entered in the boxes below.
      </para>

      <para>
	In addition to the simple selection of a variable, you have the option
	of specifying a restriction on the selected variable (that is, defining
	a sub-sample).   For example, suppose you have wage data in a variable
	called "wage" and you also have a dummy variable called "gender" that
	equals 1 for males and 0 for females (or vice versa). Then, in the test
	for the difference of two means, you could select "wage" in both slots,
	but add to the top slot "(gender=0)" and to the bottom "(gender=1)".
	This would then give you a test for the difference between mean male
	income and mean female income.  Note that when you type a restriction in
	this way, you must then press the Enter key to have the sample statistics
	calculated.  
      </para>

      <para>
	The sub-sampling restriction must be placed in parentheses following the
	selected variable, and in general the restriction takes the form "var2
	op value," where var2 is the name of a variable in the current data set,
	val is a numerical value, and op is a comparison operator chosen from =,
	!=, &lt;, &gt;, &lt;= or &gt;= (respectively equality, inequality, less
	than, greater than, less than or equal, and greater than or equal).  The
	spaces around the operator are optional.
      </para>

    </description>
  </command>

  <command name="gui-htest-np" section="Tests" context="gui"
    label="Nonparametric tests">

    <description>
      <para>
	Under the <quote>Difference test</quote> tab you can carry out a
	nonparametric test for a difference between two populations or
	groups, the specific test depending on the option selected.
      </para>
      <para>
	Sign test: This test is based on the fact that if two samples,
	<math>x</math> and <math>y</math>, are drawn randomly
	from the same distribution, the probability that
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>, for each observation
	<math>i</math>, should equal 0.5.  The test statistic is
	<math>w</math>, the number of observations for which
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>. Under the null hypothesis this
	follows the Binomial distribution with parameters
	(<math>n</math>, 0.5), where <math>n</math> is the
	number of observations.
      </para>
      <para>
	Rank sum test: The Wilcoxon rank-sum test is performed.  This test
	proceeds by ranking the observations from both samples jointly,
	from smallest to largest, then finding the sum of the ranks of the
	observations from one of the samples.  The two samples do not have
	to be of the same size, and if they differ the smaller sample is
	used in calculating the rank-sum.  Under the null hypothesis that
	the samples are drawn from populations with the same median, the
	probability distribution of the rank-sum can be computed for any
	given sample sizes; and for reasonably large samples a close
	Normal approximation exists.
      </para>
      <para>
	Signed rank test: The Wilcoxon signed-rank test is performed.
	This is designed for matched data pairs such as, for example, the
	values of a variable for a sample of individuals before and after
	some treatment.  The test proceeds by finding the differences
	between the paired observations, <math>x</math><sub>i</sub>
	&minus; <math>y</math><sub>i</sub>, ranking these
	differences by absolute value, then assigning to each pair a
	signed rank, the sign agreeing with the sign of the difference.
	One then calculates <math>W</math><sub>+</sub>, the sum of
	the positive signed ranks.  As with the rank-sum test, this
	statistic has a well-defined distribution under the null that the
	median difference is zero, which converges to the Normal for
	samples of reasonable size.
      </para>
      <para>
	Under the <quote>Runs test</quote> tab you can carry out a test
	for the randomness of a given variable, based on the number of
	runs of consecutive positive or negative values.  If you select
	the option <quote>Use first difference</quote>, the variable is
	differenced prior to the analysis and hence the runs are
	interpreted as runs of increasing or decreasing values of the
	original variable.  The test statistic is based on a normal
	approximation to the distribution of the number of runs under
	the null of randomness.
      </para>

    </description>
  </command>   
 
  <command name="hausman" section="Tests" label="Panel diagnostics">

    <description>
      <para>
	This test is available only after estimating an OLS model
	using panel data (see also <cmd>setobs</cmd>).  It tests the
	simple pooled model against the principal alternatives, the fixed
	effects and random effects models.
      </para>

      <para>
	The fixed effects model allows the intercept of the regression to
	vary across the cross-sectional units.  An
	<math>F</math>-test is reported for the null hypotheses that
	the intercepts do not differ. The random effects model decomposes
	the residual variance into two parts, one part specific to the
	cross-sectional unit and the other specific to the particular
	observation.  (This estimator can be computed only if the number
	of cross-sectional units in the data set exceeds the number of
	parameters to be estimated.) The Breusch&ndash;Pagan LM statistic
	tests the null hypothesis that the pooled OLS estimator is
	adequate against the random effects alternative.
      </para>

      <para>
	The pooled OLS model may be rejected against both of the
	alternatives, fixed effects and random effects. Provided the
	unit- or group-specific error is uncorrelated with the
	independent variables, the random effects estimator is more
	efficient than the fixed effects estimator; otherwise the
	random effects estimator is inconsistent and the fixed effects
	estimator is to be preferred. The null hypothesis for the
	Hausman test is that the group-specific error is not so
	correlated (and therefore the random effects model is
	preferable).  A low p-value for this test counts against the
	random effects model and in favor of fixed effects.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Panel diagnostics</menu-path>
    </gui-access>

  </command>

  <command name="hccme" section="Estimation" context="gui"
    label="Robust standard errors">

    <description>
      <para>
	You are offered several variant calculations for standard
	errors that are robust in the presence of heteroskedasticity
	(and, in the case of the HAC estimator, autocorrelation).
      </para>
      <para>
	HC0 produces the original <quote>White's standard errors</quote>;
	HC1, HC2, HC3 and HC3a are subsequent variations that are
	generally reckoned to produce superior (more reliable) results.
	For details of the estimators, see <cite
	key="mackinnon-white85">MacKinnon and White (Journal of
	Econometrics, 1985)</cite> or <cite
	key="davidson-mackinnon04">Davidson and MacKinnon, Econometric
	Theory and Methods (Oxford, 2004)</cite>.  The labels given here
	are those used by Davidson and MacKinnon.  Variant
	<quote>HC3a</quote> is the jackknife, as described in MacKinnon
	and White; HC3 is a close approximation to the jackknife.
      </para>
      <para>
	If you use the HAC estimator for OLS on time-series data, you
	are able to fine-tune the lag-length using the <cmd>set</cmd>
	command.  Please see the gretl manual or the script commands
	help file for details.
      </para>
      <para>
	When estimating a model via OLS using panel data, the default
	robust estimator of the covariance matrix is that given by
	Arellano.  The alternative is Beck and Katz's Panel Corrected
	Standard Errors (PCSE).  The latter take into account
	heteroskedasticity but not autocorrelation.  
      </para>
      <para>
	Two robust estimators of the covariance matrix are
	offered for GARCH models: QML is the Quasi-Maximum Likelihood
	Estimator, and BW is the Bollerslev-Wooldridge estimator.
      </para>
    </description>

  </command>

  <command name="heckit" section="Estimation" context="cli"
    label="Heckman selection model">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	<argument separated="true">selection equation</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>QML standard errors</effect>
        </option>
        <option>
	  <flag>--two-step</flag>
	  <effect>perform two-step estimation</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print extra output</effect>
        </option>
      </options>      
      <examples>
        <example>heckit y 0 x1 x2 ; ys 0 x3 x4</example>
	<demos>
	  <demo>heckit.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Heckman-type selection model.  In the specification, the list
	before the semicolon represents the outcome equation, and the
	second list represents the selection equation.  The dependent
	variable in the selection equation (<lit>ys</lit> in the
	example above) must be a binary variable.
      </para>
      <para>
	By default, the parameters are estimated by maximum
	likelihood. The covariance matrix of the parameters is
	computed using the negative inverse of the Hessian. If
	two-step estimation is desired, use the <opt>--two-step</opt>
	option. In this case, the covariance matrix of the parameters
	of the outcome equation is appropriately adjusted as per
	<cite key="heckman79">Heckman (1979)</cite>.
      </para>
      <para>
	Please note that in ML estimation a numerical approximation of
	the Hessian is used; this may lead to inaccuracies in the
	estimated covariance matrix if the scale of the explanatory
	variables is such that some of the estimated coefficients are
	very small in absolute value. This problem will be addressed
	in future versions; in the meantime, rescaling the offending
	explanatory variable(s) can be used as a workaround.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Heckit</menu-path>
    </gui-access>

  </command>

  <command name="help" section="Utilities" 
    label="Help on commands" context="cli">

    <usage>
      <altforms>
        <altform><lit>help</lit></altform>
	<altform><lit>help functions</lit></altform>
        <altform><lit>help</lit> <repl>command</repl></altform>
        <altform><lit>help</lit> <repl>function</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--func</flag>
	  <effect>select functions help</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	If no arguments are given, prints a list of available commands. If the
	single argument <lit quote="true">functions</lit> is given, prints a
	list of available functions (see <cmdref targ="genr"/>).
      </para>
      <para>
	<lit>help</lit> <repl>command</repl> describes <repl>command</repl>
	(&eg; <lit>help smpl</lit>).  <lit>help</lit> <repl>function</repl> 
	describes <repl>function</repl> (&eg; <lit>help ldet</lit>).
	Some functions have the same names as related commands (&eg;
	<lit>diff</lit>): in that case the default is to print help
	for the command, but you can get help on the function by
	using the <opt>--func</opt> option.
      </para> 
    </description>

    <gui-access>
      <menu-path>/Help</menu-path>
    </gui-access>

  </command>

  <command name="hsk" section="Estimation"
    label="Heteroskedasticity-corrected estimates">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	This command is applicable where heteroskedasticity is present in the
	form of an unknown function of the regressors which can be
	approximated by a quadratic relationship.  In that context it offers
	the possibility of consistent standard errors and more efficient
	parameter estimates as compared with OLS.  
      </para>
      <para>
	The procedure involves (a) OLS estimation of the model of interest,
	followed by (b) an auxiliary regression to generate an estimate of the
	error variance, then finally (c) weighted least squares, using as
	weight the reciprocal of the estimated variance.
      </para>
      <para>
	In the auxiliary regression (b) we regress the log of the squared
	residuals from the first OLS on the original regressors and their
	squares.  The log transformation is performed to ensure that the
	estimated variances are non-negative.  Call the fitted values from
	this regression <math>u</math><sup>*</sup>.  The weight series for the
	final WLS is then formed as 1/exp(<math>u</math><sup>*</sup>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Other linear models/Heteroskedasticity corrected</menu-path>
    </gui-access>

  </command>

  <command name="hurst" section="Statistics"
    label="Hurst exponent">

    <usage>
      <arguments>
        <argument>series</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Calculates the Hurst exponent (a measure of persistence or
	long memory) for a time-series variable having at least 128
	observations.
      </para>
      <para>
	The Hurst exponent is discussed by Mandelbrot.  In theoretical
	terms it is the exponent, <math>H</math>, in the
	relationship 
	<equation status="display" 
	  tex="\[\mathrm{RS}(x) = an^H\]" 
	  ascii="RS(x) = an^H" 
	  graphic="hurst"/>where RS is the <quote>rescaled
	  range</quote> of the variable <math>x</math> in
	samples of size <math>n</math> and <math>a</math>
	is a constant. The rescaled range is the range (maximum minus
	minimum) of the cumulated value or partial sum of
	<math>x</math> over the sample period (after subtraction
	of the sample mean), divided by the sample standard deviation.
      </para>
      <para>
	As a reference point, if <math>x</math> is white noise
	(zero mean, zero persistence) then the range of its cumulated
	<quote>wandering</quote> (which forms a random walk), scaled
	by the standard deviation, grows as the square root of the
	sample size, giving an expected Hurst exponent of 0.5.  Values
	of the exponent significantly in excess of 0.5 indicate
	persistence, and values less than 0.5 indicate
	anti-persistence (negative autocorrelation).  In principle the
	exponent is bounded by 0 and 1, although in finite samples it
	is possible to get an estimated exponent greater than 1.  
      </para>
      <para>
	In gretl, the exponent is estimated using binary sub-sampling:
	we start with the entire data range, then the two halves of
	the range, then the four quarters, and so on.  For sample
	sizes smaller than the data range, the RS value is the mean
	across the available samples.  The exponent is then estimated
	as the slope coefficient in a regression of the log of RS on
	the log of sample size.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Hurst exponent</menu-path>
    </gui-access>

  </command>

  <command name="if" section="Programming" label="Flow control" context="cli">

    <description>
      <para>Flow control for command execution.  Three sorts of
	construction are supported, as follows.
      </para>
      <pre>
	<lit># simple form</lit>&par;
	<lit>if</lit> <repl>condition</repl>&par;
	<lit> </lit><lit> </lit> <repl>commands</repl>&par;
	<lit>endif</lit>
      </pre>

      <pre>
	<lit># two branches</lit>&par;
	<lit>if</lit> <repl>condition</repl>&par;
	<lit> </lit><lit> </lit> <repl>commands1</repl>&par;
	<lit>else</lit>&par;
	<lit> </lit><lit> </lit> <repl>commands2</repl>&par;
	<lit>endif</lit>
      </pre>

      <pre>
	<lit># three or more branches</lit>&par;
	<lit>if</lit> <repl>condition1</repl>&par;
	<lit> </lit><lit> </lit> <repl>commands1</repl>&par;
	<lit>elif</lit> <repl>condition2</repl>&par;
	<lit> </lit><lit> </lit> <repl>commands2</repl>&par;
	<lit>else</lit>&par;
	<lit> </lit><lit> </lit> <repl>commands3</repl>&par;
	<lit>endif</lit>
      </pre>

      <para>
	<repl quote="true">condition</repl> must be a Boolean expression, for
	the syntax of which see <cmdref targ="genr"/>.  More than one
	<cmd>elif</cmd> block may be included.  In addition, <lit>if</lit>
	&hellip; <lit>endif</lit> blocks may be nested.
      </para>
    </description>

  </command>

  <command name="include" section="Programming" 
    label="Include function definitions" context="cli">

    <usage>
      <arguments>
        <argument>filename</argument>
      </arguments>
      <examples>
        <example>include myfile.inp</example>
        <example>include sols.gfn</example>
      </examples>
    </usage>

    <description>
      <para>
	Intended for use in a command script, primarily for including
	definitions of functions.  Executes the commands in
	<repl>filename</repl> then returns control to the main script. To
	include a packaged function, be sure to include the filename
	extension.
      </para>
      <para>
	See also <cmdref targ="run"/>.
      </para>
    </description>

  </command>

  <command name="info" section="Dataset" 
    label="Information on data set" context="cli">

    <description>
      <para>
	Prints out any supplementary information stored with the
	current datafile.
      </para>
    </description>

    <gui-access>
      <menu-path>/Data/Dataset info</menu-path>
      <other-access>Data browser windows</other-access>
    </gui-access>

  </command>

  <command name="intreg" section="Estimation" label="Interval regression model">

    <usage>
      <arguments>
        <argument></argument>
        <argument>minvar</argument>
        <argument>maxvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>	
      </options>
      <examples>
	<example>intreg lo hi const x1 x2</example>
	<demos>
	  <demo>wtp.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Estimates an interval regression model.  This model arises when the
	dependent variable is imperfectly observed for some (possibly all)
	observations.  In other words, the data generating process is assumed
	to be 
	<equation status="display"
	tex="\[y^*_t = x_t \beta+\epsilon_t\]" ascii="y* = x b + u"/> but we
	only observe 
	<equation status="inline" tex="\[m_t \le
	y_t \le M_t\]" ascii="m &lt;= y* &lt;= M"/> (the interval may be left-
	or right-unbounded). Note that for some observations <math>m</math>
	may equal <math>M</math>.  The variables <repl>minvar</repl> and
	<repl>maxvar</repl> must contain <lit>NA</lit>s for left- and
	right-unbounded observations, respectively.
      </para>

      <para context="gui">
	In the model specification dialog, <repl>minvar</repl> and
	<repl>maxvar</repl> are indentified as the Lower bound variable and
	the Upper bound variable respectively.
      </para>

      <para>
	The model is estimated by maximum likelihood, assuming normality of
	the disturbance term.
      </para>

      <para context="cli">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the <opt>--robust</opt> flag is given,
	then QML or Huber&ndash;White standard errors are calculated
	instead. In this case the estimated covariance matrix is a
	<quote>sandwich</quote> of the inverse of the estimated Hessian
	and the outer product of the gradient.
      </para>
      <para context="gui">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the "Robust standard errors" box is
	checked, then QML or Huber&ndash;White standard errors are
	calculated instead. In this case the estimated covariance matrix
	is a <quote>sandwich</quote> of the inverse of the estimated
	Hessian and the outer product of the gradient.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Interval regression</menu-path>
    </gui-access>

  </command>

  <command name="irfboot" section="Graphs" context="gui"
    label="Impulse response plots">

    <description>
      <para>
	If you select the bootstrap option when plotting impulse
	responses, gretl computes a confidence interval for the responses
	using the bootstrap method.  The residuals from the original VAR
	(or VECM) are resampled with replacement; an artificial dataset is
	constructed based on the original parameter estimates and the
	resampled residuals; the system is re-estimated and the impulse
	responses are re-evaluated.  This is repeated 999 times and the
	&alpha;/2 and 1 &minus; &alpha;/2 quantiles for the responses are
	found and plotted along with the point estimates. This option is
	not currently available for restricted VECMs.
      </para>
      <para>
	This dialog also supports reordering of the variables for the
	Cholesky decomposition of the cross-equation covariance matrix.
	The default is given by the order in which the variables are
	entered into the model specification, but the up and down arrows
	can be used to promote or demote a selected variable.
      </para>
    </description>

  </command>

  <command name="kalman" section="Estimation" label="Kalman filter">

    <usage>
      <options>
	<option>
	  <flag>--cross</flag>
	  <effect>allow for cross-correlated disturbances</effect>
	</option>
	<option>
	  <flag>--diffuse</flag>
	  <effect>use diffuse initialization</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Opens a block of statements to set up a Kalman filter.  This block
	should end with the line <lit>end kalman</lit>, to which the options
	shown above may be appended.  The intervening lines specify the
	matrices that compose the filter.  For example,
      </para>
      <code>
	kalman 
	  obsy y
	  obsymat H
	  statemat F
	  statevar Q
	end kalman
      </code>
      <para>
	Please see <guideref targ="chap:kalman"/> for details.
      </para>
	<para>
	  <seelist>
	    <fncref targ="kfilter"/>
	    <fncref targ="ksimul"/>
	    <fncref targ="ksmooth"/>
	  </seelist>
	</para>
    </description>

  </command>

  <command name="kpss" section="Tests" label="KPSS stationarity test">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--trend</flag>
	  <effect>include a trend</effect>
	</option>
	<option>
	  <flag>--seasonals</flag>
	  <effect>include seasonal dummies</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print regression results</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>use first difference of variable</effect>
	</option>
      </options>
      <examples>
	<example>kpss 8 y</example>
        <example>kpss 4 x1 --trend</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Computes the KPSS test (Kwiatkowski, Phillips, Schmidt and Shin,
	Journal of Econometrics, 1992) for stationarity of the given
	variable (or its first difference, if the differencing option is
	selected).  The null hypothesis is that the variable in question
	is stationary, either around a level or, if the <quote>include a
	trend</quote> box is checked, around a deterministic linear trend.
      </para>

      <para context="cli">
	For use of this command with panel data please see the final
	section in this entry.
      </para>

      <para context="cli">
	Computes the KPSS test <cite key="KPSS92" p="true">(Kwiatkowski
	et al, Journal of Econometrics, 1992)</cite> for stationarity,
	for each of the specified variables (or their first difference,
	if the <opt>--difference</opt> option is selected). The null
	hypothesis is that the variable in question is stationary,
	either around a level or, if the <opt>--trend</opt> option is
	given, around a deterministic linear trend.
      </para>

      <para context="gui">
	The selected lag order determines the size of the window used
	for Bartlett smoothing.  If the <quote>show regression
	  results</quote> box is checked the results of the auxiliary
	regression are printed, along with the estimated variance of
	the random walk component of the variable.
      </para>

      <para context="cli">
	The order argument determines the size of the window used for
	Bartlett smoothing.  If the <opt>--verbose</opt> option is
	chosen the results of the auxiliary regression are printed,
	along with the estimated variance of the random walk component
	of the variable.
      </para>

      <para>
	The critical values shown for the test statistic are based on the
	response surfaces estimated by <cite key="sephton95">Sephton
	(Economics Letters, 1995)</cite>, which are more accurate for
	small samples than the values given in the original KPSS
	article. When the test statistic lies between the 10 percent and 1
	percent critical values a p-value is shown; this is obtained
	by linear interpolation and should not be taken too literally.
      </para>

      <subhead context="cli">Panel data</subhead>

      <para context="cli">
	When the <lit>kpss</lit> command is used with panel data, to
	produce a panel unit root test, the applicable options and the
	results shown are somewhat different.  While you may give a list
	of variables for testing in the regular time-series case, with
	panel data only one variable may be tested per command. And the
	<opt>--verbose</opt> option has a different meaning: it produces a
	brief account of the test for each individual time series (the
	default being to show only the overall result).
      </para>
      <para context="cli">
	When possible, the overall test (null hypothesis: the series in
	question is stationary for all the panel units) is calculated
	using the method of <cite key="choi01">Choi (Journal of
	International Money and Finance, 2001)</cite>. This is not
	always straightforward, the difficulty being that while the
	Choi test is based on the p-values of the tests on the
	individual series, we do not currently have a means of
	calculating p-values for the KPSS test statistic; we must
	rely on a few critical values.
      </para>
      <para context="cli">
	If the test statistic for a given series falls between the 10
	percent and 1 percent critical values, we are able to interpolate
	a p-value. But if the test falls short of the 10 percent value, or
	exceeds the 1 percent value, we cannot interpolate and can at best
	place a bound on the global Choi test. If the individual test
	statistic falls short of the 10 percent value for some units but
	exceeds the 1 percent value for others, we cannot even compute
	a bound for the global test.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Unit root tests/KPSS test</menu-path>
    </gui-access>

  </command>

  <command name="labels" section="Dataset" 
    label="Print labels for variables" context="cli">

    <usage>
      <altforms>
	<altform><lit>labels [</lit> <repl>varlist</repl> <lit>]</lit></altform>	
	<altform><lit>labels --to-file=</lit><repl>filename</repl></altform>
	<altform><lit>labels --from-file=</lit><repl>filename</repl></altform>
      </altforms>
    </usage>

    <description>
      <para>
	In the first form, prints out the informative labels (if present) for
	the series in <repl>varlist</repl>, or for all series in the dataset
	if <repl>varlist</repl> is not specified.
      </para>
      <para>
	With the option <opt>--to-file</opt>, writes to the named file the
	labels for all series in the dataset, one per line. If no labels are
	present an error is flagged; if some series have labels and others
	do not, a blank line is printed for series with no label.
      </para>
      <para>
	With the option <opt>--from-file</opt>, reads the specified file
	(which should be plain text) and assigns labels to the series in
	the dataset, reading one label per line and taking blank lines
	to indicate blank labels.
      </para>
      <para>
	Via the file writing and reading options it is possible to copy
	series labels from one data file to another.
      </para>
    </description>

  </command>

  <command name="lad" section="Estimation"
    label="Least Absolute Deviation estimation">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calculates a regression that minimizes the sum of the absolute
	deviations of the observed from the fitted values of the
	dependent variable.  Coefficient estimates are derived using
	the Barrodale&ndash;Roberts simplex algorithm; a warning is
	printed if the solution is not unique.
      </para>
      <para>
	Standard errors are derived using the bootstrap procedure with
	500 drawings. The covariance matrix for the parameter
	estimates, printed when the <opt>--vcv</opt> flag is given, is
	based on the same bootstrap.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Robust estimation/Least Absolute Deviation</menu-path>
    </gui-access>

  </command>

  <command name="lags" section="Transformations" 
    label="Create lags" context="cli">

    <usage>
      <altforms>
        <altform><lit>lags</lit> <repl>varlist</repl></altform>
	<altform><lit>lags</lit> <repl>order</repl> <lit>;</lit> <repl>varlist</repl></altform>
      </altforms>
      <examples>
	<example>lags x y</example>
	<example>lags 12 ; x y</example>
      </examples>
    </usage>

    <description>
      <para>
	Creates new series which are lagged values of each of the series in
	<repl>varlist</repl>.  By default the number of lags created equals the
	periodicity of the data. For example, if the periodicity is 4 (quarterly),
	the command <cmd>lags x</cmd> creates
      </para>
      <mono>
	x_1 = x(t-1)
	x_2 = x(t-2)
	x_3 = x(t-3)
	x_4 = x(t-4)
      </mono>
      <para>
	The number of lags created can be controlled by the optional
	first parameter.
      </para>
    </description>

    <gui-access>
      <menu-path>/Add/Lags of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="lags-dialog" section="Estimation" context="gui"
    label="Lag selection box">

    <description>
      <para>
	In this dialog you can select the lag order for the independent
	variables in a time-series model, and in some cases for the dependent
	variable also.  (But note that the common lag order for vector models
	such as VARs and VECMs is handled separately, via a selection spinner in
	the main model dialog box.)
      </para>
      <para>
	The spinners on the left let you select a range of consecutive lags for
	any given variable. To specify non-consecutive lags, click the check box
	next to the entry field titled <quote>specific lags</quote>.  This
	activates the entry box, into which you can type a list of lags,
	separated by spaces.
      </para>
      <para>
	The row marked <quote>default</quote> offers a quick way to set a common
	lag specification for all the independent variables: values set in that
	row are copied to all the others (apart from the dependent variable, if
	present).  
      </para>
      <para>
	The dependent variable is treated specially: the minimum lag must be
	zero, which places the current value of the variable on the left-hand
	side of the model.  Any higher lags appear with the independent
	variables on the right-hand side of the model.
      </para>
      <para>
	Values selected in this dialog are remembered for the duration of your
	session with a given dataset.
      </para>

    </description>

  </command>

  <command name="ldiff" section="Transformations" 
    label="Log-differences" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	The first difference of the natural log of each series in
	<repl>varlist</repl> is obtained and the result stored in a
	new series with the prefix <lit>ld_</lit>.  Thus <cmd>ldiff
	  x y</cmd> creates the new variables
      </para>
      <mono>
	ld_x = log(x) - log(x(-1))
	ld_y = log(y) - log(y(-1))
      </mono>
    </description>

    <gui-access>
      <menu-path>/Add/Log differences of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="leverage" section="Tests" label="Influential observations">

    <usage>
      <options>
        <option>
	  <flag>--save</flag>
	  <effect>save variables</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Must immediately follow an <cmd>ols</cmd> command. Calculates the
	leverage (<math>h</math>, which must lie in the range 0 to 1) for
	each data point in the sample on which the previous model was
	estimated.  Displays the residual (<math>u</math>) for each
	observation along with its leverage and a measure of its influence
	on the estimates, <equation status="inline" tex="$uh/(1 - h)$"
	ascii="u*h/(1-h)" graphic="influence"/>. <quote>Leverage
	points</quote> for which the value of <math>h</math> exceeds
	2<math>k</math>/<math>n</math> (where <math>k</math> is the number
	of parameters being estimated and <math>n</math> is the sample
	size) are flagged with an asterisk.  For details on the concepts
	of leverage and influence see <cite
	key="davidson-mackinnon93">Davidson and MacKinnon (1993)</cite>,
	Chapter 2.
      </para>
      <para>
	DFFITS values are also shown: these are <quote>studentized
	  residuals</quote> (predicted residuals divided by their
	standard errors) multiplied by 
	  <equation status="inline" 
	  tex="$\sqrt{h/(1 - h)}$"
	  ascii="sqrt[h/(1 - h)]"
	  graphic="dffit"/>. 
	  For discussions of studentized residuals and DFFITS see chapter 
	  12 of <cite key="maddala92">Maddala's Introduction to
	  Econometrics</cite> or <cite key="belsley-etal80">Belsley, 
	  Kuh and Welsch (1980)</cite>.
      </para>
      <para>
	Briefly, a <quote>predicted residual</quote> is the difference
	between the observed value of the dependent variable at
	observation <math>t</math>, and the fitted value for
	observation <math>t</math> obtained from a regression in
	which that observation is omitted (or a dummy variable with
	value 1 for observation <math>t</math> alone has been
	added); the studentized residual is obtained by dividing the
	predicted residual by its standard error.
      </para>
      <para context="cli">
	If the <opt>--save</opt> flag is given with this command, then the
	leverage, influence and DFFITS values are added to the current
	data set.
      </para>
      <para context="gui">
	The "+" icon at the top of the leverage test window brings up
	a dialog box that allows you to save one or more of the test
	variables to the current data set.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Influential observations</menu-path>
    </gui-access>

  </command>

  <command name="levinlin" section="Tests" label="Levin-Lin-Chu test">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>series</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>test without a constant</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>with constant and trend</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
	</option>
      </options>
      <examples>
	<example>levinlin 0 y</example>
        <example>levinlin 2 y --ct</example>
        <example>levinlin {2,2,3,3,4,4} y</example>
      </examples>
    </usage>

    <description>
      <para>
	Carries out the panel unit-root test described by <cite
	key="LLC2002">Levin, Lin and Chu (2002)</cite>. The null
	hypothesis is that all of the individual time series exhibit a
	unit root, and the alternative is that none of the series has a
	unit root. (That is, a common AR(1) coefficient is assumed,
	although in other respects the statistical properties of the
	series are allowed to vary across individuals.)
      </para>
	
      <para context="cli">
	By default the test ADF regressions include a constant;
	to suppress the constant use the <lit>--nc</lit> option, or
	to add a linear trend use the <lit>--ct</lit> option.
	(See the <cmdref targ="adf"/> command for explanation of
	ADF regressions.)
      </para>

      <para context="cli">
	The (non-negative) <repl>order</repl> for the test (governing
	the number of lags of the dependent variable to include in the
	ADF regressions) may be given in either of two forms. If a
	scalar value is given, this is applied to all the individuals
	in the panel.  The alternative is to provide a matrix
	containing a specific lag order for each individual; this must
	be a vector with as many elements as there are individuals in
	the current sample range. Such a matrix can be specified by
	name, or constructed using braces as illustrated in the
	last example above.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Unit root tests/Levin-Lin-Chu test</menu-path>
    </gui-access>

  </command>

  <command name="logistic" section="Estimation" label="Logistic regression">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	<argument optional="true" flag="ymax=">value</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
      </options>
      <examples>
        <example>logistic y const x</example>
        <example>logistic y const x ymax=50</example>
      </examples>
    </usage>

    <description>
      <para>
	Logistic regression: carries out an OLS regression using the
	logistic transformation of the dependent variable,
	<equation status="display" 
	  tex="\[\log\left(\frac{y}{y^*-y}\right)\]"
	  ascii="log(y/(y* - y))"
	  graphic="logistic1"/>
      </para>

      <para context="cli">The dependent variable must be strictly
	positive.  If it is a decimal fraction, between 0 and 1, the
	default is to use a <math>y</math><sup>*</sup> value
	(the asymptotic maximum of the dependent variable) of 1. If
	the dependent variable is a percentage, between 0 and 100, the
	default <math>y</math><sup>*</sup> is 100.
      </para>

      <para context="cli">
	If you wish to set a different maximum, use the optional
	<opt>ymax=</opt><repl>value</repl> syntax following the list of
	regressors.  The supplied value must be greater than all of the
	observed values of the dependent variable.
      </para>

      <para context="gui">
	You are presented with a dialog box that allows you to specify a
	different maximum if you wish.  The supplied
	<math>y</math><sup>*</sup> value must be greater than all of
	the observed values of the dependent variable.
      </para>

      <para>The fitted values and residuals from the regression are
	automatically transformed using 	  
	<equation status="display" 
	  tex="\[y=\frac{y^*}{1+e^{-x}}\]"
	  ascii="y = y* / (1 + exp(-x))"
	  graphic="logistic2"/> where <math>x</math> represents
	either a fitted value or a residual from the OLS regression
	using the transformed dependent variable.  The reported values
	are therefore comparable with the original dependent
	variable.
      </para>

      <para>
	Note that if the dependent variable is binary, you should
	use the <cmdref targ="logit"/> command instead.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Logistic</menu-path>
    </gui-access>

  </command>

  <command name="logit" section="Estimation"
    label="Logit regression">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
	</option>
	<option>
	  <flag>--multinomial</flag>
	  <effect>estimate multinomial logit</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>show p-values instead of slopes</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	If the dependent variable is a binary variable (all values are 0
	or 1) maximum likelihood estimates of the coefficients on
	<repl>indepvars</repl> are obtained via the <quote>binary response
	model regression</quote> (BRMR) method outlined by <cite
	key="davidson-mackinnon04">Davidson and MacKinnon
	(2004)</cite>. As the model is nonlinear the slopes depend on the
	values of the independent variables.  By default the slopes with
	respect to each of the independent variables are calculated (at
	the means of those variables) and these slopes replace the usual
	p-values in the regression output.  This behavior can be
	suppressed my giving the <opt>--p-values</opt> option. The
	chi-square statistic tests the null hypothesis that all
	coefficients are zero apart from the constant.
      </para>
      <para context="cli">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the <opt>--robust</opt> flag is given,
	then QML or Huber&ndash;White standard errors are calculated
	instead. In this case the estimated covariance matrix is a
	<quote>sandwich</quote> of the inverse of the estimated Hessian
	and the outer product of the gradient. See chapter 10 of Davidson
	and MacKinnon for details.
      </para>
      <para context="gui">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the "Robust standard errors" box is
	checked, then QML or Huber&ndash;White standard errors are
	calculated instead. In this case the estimated covariance matrix
	is a <quote>sandwich</quote> of the inverse of the estimated
	Hessian and the outer product of the gradient.  See chapter 10 of
	Davidson and MacKinnon for details.
      </para>
      <para>
	If the dependent variable is not binary but is discrete, then by
	default it is interpreted as an ordinal response, and Ordered
	Logit estimates are obtained.  However, if the
	<opt>--multinomial</opt> option is given, the dependent variable
	is interpreted as an unordered response, and Multinomial Logit
	estimates are produced. (In either case, if the variable selected
	as dependent is not discrete an error is flagged.) In the
	multinomial case, the accessor <lit>$mnlprobs</lit> is available
	after estimation, to get a matrix containing the estimated
	probabilities of the outcomes at each observation (observations in
	rows, outcomes in columns).
      </para>
      <para>
	If you want to use logit for analysis of proportions (where
	the dependent variable is the proportion of cases having a
	certain characteristic, at each observation, rather than a 1
	or 0 variable indicating whether the characteristic is present
	or not) you should not use the <cmd>logit</cmd> command, but
	rather construct the logit variable, as in
      </para>
      <code>
	genr lgt_p = log(p/(1 - p))
      </code>
      <para>and use this as the dependent variable in an OLS regression.
      See chapter 12 of <cite key="ramanathan02">Ramanathan (2002)</cite>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Logit</menu-path>
    </gui-access>

  </command>

  <command name="logs" section="Transformations" 
    label="Create logs" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	The natural log of each of the series in <repl>varlist</repl>
	is obtained and the result stored in a new series with the
	prefix <lit>l_</lit> (<quote>el</quote> underscore).  For example,
	<cmd>logs x y</cmd> creates the new variables <lit>l_x</lit> =
	ln(<lit>x</lit>) and <lit>l_y</lit> = ln(<lit>y</lit>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Add/Logs of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="loop" section="Programming" 
    label="Start a command loop" context="cli">

    <usage>
      <arguments>
        <argument>control</argument>
      </arguments>
      <options>
	<option>
	  <flag>--progressive</flag>
	  <effect>enable special forms of certain commands</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>report details of genr commands</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>do not report number of iterations performed</effect>
	</option>
      </options>
      <examples>
        <example>loop 1000</example>
	<example>loop 1000 --progressive</example>
        <example>loop while essdiff > .00001</example>
        <example>loop i=1991..2000</example>
        <example>loop for (r=-.99; r&lt;=.99; r+=.01)</example>
	<example>loop foreach i xlist</example>
      </examples>
    </usage>

    <description>
      <para>
	This command opens a special mode in which the program
	accepts commands to be executed repeatedly.  You exit the mode
	of entering loop commands with <cmd>endloop</cmd>: at this
	point the stacked commands are executed.
      </para>
      <para>
	The parameter <repl quote="true">control</repl> may take any of
	five forms, as shown in the examples: an integer number of times to
	repeat the commands within the loop; <quote><lit>while</lit></quote>
	plus a boolean condition; a range of integer values for index
	variable; <quote><lit>for</lit></quote> plus three expressions in
	parentheses, separated by semicolons (which emulates the
	<lit>for</lit> statement in the C programming language); or
	<quote><lit>foreach</lit></quote> plus an index variable and a list.
      </para>
      <para>
	See <guideref targ="chap:looping"/> for further details and
	examples.  The effect of the <opt>--progressive</opt> option
	(which is designed for use in Monte Carlo simulations) is
	explained there. Not all gretl commands may be used within
	a loop; the commands available in this context are also
	set out there.
      </para>
    </description>

  </command>

  <command name="mahal" section="Statistics" label="Mahalanobis distances">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>don't print anything</effect>
        </option>
	<option>
	  <flag>--save</flag>
	  <effect>add distances to the dataset</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	The Mahalanobis distance is the distance between two points in
	a <math>k</math>-dimensional space, scaled by the
	statistical variation in each dimension of the space.  For
	example, if <math>p</math> and <math>q</math> are
	two observations on a set of <math>k</math> variables
	with covariance matrix <math>C</math>, then the
	Mahalanobis distance between the observations is given by
	<equation status="display"
        tex="\[\sqrt{(p-q)^{\prime}C^{-1}(p-q)}\]"
        ascii="sqrt((p - q)' * C-inverse * (p - q))"
          graphic="mahal"/>
	where (<math>p</math> &minus; <math>q</math>) is a
	<math>k</math>-vector. This reduces to Euclidean
	distance if the covariance matrix is the identity
	matrix.
      </para>
      <para>
	The space for which distances are computed is defined by
	the selected variables.  For each observation in the current
	sample range, the distance is computed between the observation
	and the centroid of the selected variables.  This distance is
	the multidimensional counterpart of a standard
	<math>z</math>-score, and can be used to judge whether a
	given observation <quote>belongs</quote> with a group of other
	observations.
      </para>
      <para context="cli">
	If the <opt>--vcv</opt> option is given, the
	covariance matrix and its inverse are printed.  If the
	<opt>--save</opt> option is given, the distances are saved to
	the dataset under the name <lit>mdist</lit> (or
	<lit>mdist1</lit>, <lit>mdist2</lit> and so on if there is
	already a variable of that name).
      </para>
      <para context="gui">
	If the number of variables selected is 4 or
	less, the covariance matrix and its inverse are printed.
	Clicking the "+" button at the top of the window displaying
	the distances give you the option of adding the distances to
	the dataset as a new variable.
      </para>
    </description>

    <gui-access>
      <menu-path>/View/Mahalanobis distances</menu-path>
    </gui-access>

  </command>  

  <command name="markers" section="Dataset" context="gui"
    label="Add case markers">

    <description>
      <para>
	This command needs the name of a file containing <quote>case
	  markers</quote>, that is, short identifying strings for the
	individual observations in the data set (for example, country
	or city names or codes).  These marker strings should be no
	more than 8 characters long.  The file should contain one
	marker per line, and there should be just as many markers as
	observations in the current dataset. If these conditions are
	met and the specified file is found, the case markers will be
	added; they will be visible when you choose <quote>Display
	  values</quote> under gretl's Data menu.
      </para>
    </description>
  </command>

  <command name="makepkg" section="Programming" context="cli"
    label="Make function package">

    <usage>
      <arguments>
        <argument>filename</argument>
      </arguments>
      <options>
        <option>
	  <flag>--index</flag>
	  <effect>write auxiliary index file</effect>
        </option>
        <option>
	  <flag>--translations</flag>
	  <effect>write auxiliary strings file</effect>
        </option>
      </options>
    </usage>    

    <description>
      <para>
	Supports creation of a gretl function package via the command
	line. The filename argument represents the name of the package
	to be created, and should have the <lit>.gfn</lit>
	extension. Please see <guideref targ="chap:functions"/> for
	details.
      </para>
      <para>
	The option flags support the writing of auxiliary files for
	use with gretl <quote>addons</quote>. The index file is a
	short XML document containing basic information about the
	package; it has the same basename as the package and the
	extension <lit>.xml</lit>. The translations file contains
	strings from the package that may be suitable for translation,
	in C format; for package <lit>foo</lit> this file is named
	<lit>foo-i18n.c</lit>.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Function files/New package</menu-path>
    </gui-access>

  </command>

  <command name="meantest" section="Tests" label="Difference of means">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--unequal-vars</flag>
	  <effect>assume variances are unequal</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Calculates the <math>t</math> statistic for the null
	hypothesis that the population means are equal for the
	variables <repl>var1</repl> and <repl>var2</repl>, and shows
	its p-value.
      </para>
      <para>
	By default the test statistic is calculated on the assumption
	that the variances are equal for the two variables; with the
	<opt>--unequal-vars</opt> option the variances are assumed to
	be different.  This will make a difference to the test
	statistic only if there are different numbers of non-missing
	observations for the two variables.
      </para>
      <para context="gui">
	Calculates the t statistic for the null hypothesis that the
	population means are equal for two selected variables, and
	shows its p-value.  The command may be called with or without
	the assumption that the variances are equal for the two
	variables (although this will make a difference to the test
	statistic only if there are different numbers of non-missing
	observations for the two variables.)
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Bivariate tests/Difference of means</menu-path>
    </gui-access>

  </command>

  <command name="missing" section="Dataset" context="gui"
    label="Missing data values">

    <description>
      <para>
	Set a numerical value that will be interpreted as
	<quote>missing</quote> or <quote>not available</quote>, either for
	a particular data series (under the Variable menu) or globally for
	the entire data set (under the Sample menu).
      </para> 
      <para>
	Gretl has its own internal coding for missing values, but
	sometimes imported data may employ a different code.  For
	example, if a particular series is coded such that a value of
	-1 indicates <quote>not applicable</quote>, you can select
	<quote>Set missing value code</quote> under the Variable menu
	and type in the value <quote>-1</quote> (without the quotes).
	Gretl will then read the -1s as missing observations.
      </para>
    </description>
  </command>

  <command name="mle" section="Estimation"
    label="Maximum likelihood estimation">

    <usage>
      <arguments>
        <argument>log-likelihood function</argument>
	<argument optional="true">derivatives</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't show estimated model</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--hessian</flag>
	  <effect>base covariance matrix on the Hessian</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>QML covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
	<option>
	  <flag>--no-gradient-check</flag>
	  <effect>see below</effect>
	</option>
	<option>
	  <flag>--lbfgs</flag>
	  <effect>use L-BFGS-B instead of regular BFGS</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>weibull.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Performs Maximum Likelihood (ML) estimation using the BFGS
	(Broyden, Fletcher, Goldfarb, Shanno) algorithm. You must
	specify the log-likelihood function; it is recommended that you
	also supply expressions for the derivatives of this function
	with respect to each of the parameters if possible.
      </para>
      <para>
	Simple example: Suppose we have a series <lit>X</lit> with values 0
	or 1 and we wish to obtain the maximum likelihood estimate of the
	probability, <lit>p</lit>, that <lit>X</lit> = 1.  (In this simple case
	we can guess in advance that the ML estimate of <lit>p</lit> will simply
	equal the proportion of Xs equal to 1 in the sample.)
      </para>
      <para>
	The parameter <lit>p</lit> must first be added to the dataset and
	given an initial value.  This can be done using the genr command or via
	menu choices.  Appropriate <quote>genr</quote> lines may be typed into
	the MLE specification window prior to the specification of the
	log-likelihood function.
      </para>
      <para>
	In the MLE window we type the following lines:
      </para>
      <code>
	loglik = X*log(p) + (1-X)*log(1-p)
	deriv p = X/p - (1-X)/(1-p)
      </code>
      <para>
	The first line specifies the log-likelihood function, and the
	next line supplies the derivative of that function with
	respect to the parameter p.  If no "deriv" lines are given, a
	numerical approximation to the derivatives is computed.
      </para>
      <para>
	If the parameter p was not previously declared we could
	preface the above lines with something like the following:
      </para>
      <code>
	genr p = 0.5
      </code>
      <para>
	By default, standard errors are based on the Outer Product of the
	Gradient.  If the robust standard errors box is checked, a QML
	estimator is used (namely, a sandwich of the negative inverse of
	the Hessian and the covariance matrix of the gradient).  The
	Hessian is approximated numerically.
      </para>
    </description>

    <description context="cli">
      <para>
	Performs Maximum Likelihood (ML) estimation using the BFGS
	(Broyden, Fletcher, Goldfarb, Shanno) algorithm. The user must
	specify the log-likelihood function.  The parameters of this
	function must be declared and given starting values (using the
	<cmd>genr</cmd> command) prior to estimation.  Optionally, the
	user may specify the derivatives of the log-likelihood function
	with respect to each of the parameters; if analytical derivatives
	are not supplied, a numerical approximation is computed.
      </para>
      <para>
	Simple example: Suppose we have a series <lit>X</lit> with
	values 0 or 1 and we wish to obtain the maximum likelihood
	estimate of the probability, <lit>p</lit>, that <lit>X</lit> = 1.
	(In this simple case we can guess in advance that the ML estimate
	of <lit>p</lit> will simply equal the proportion of Xs equal to 1
	in the sample.)
      </para>
      <para>
	The parameter <lit>p</lit> must first be added to the dataset and
	given an initial value.  This can be done using the genr
	command.  For example, <lit>genr p = 0.5</lit>.
      </para>
      <para>
	We then construct the MLE command block:
      </para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  deriv p = X/p - (1-X)/(1-p)
	end mle
      </code>
      <para>
	The first line above specifies the log-likelihood function. It
	starts with the keyword <lit>mle</lit>, then a dependent
	variable is specified and an expression for the log-likelihood
	is given (using the same syntax as in the <cmd>genr</cmd>
	command).  The next line (which is optional) starts with the
	keyword <lit>deriv</lit> and supplies the derivative of the
	log-likelihood function with respect to the parameter
	<lit>p</lit>. If no derivatives are given, you should include
	a statement using the keyword <lit>params</lit> which
	identifies the free parameters: these are listed on one line,
	separated by spaces and can be either scalars, or vectors, or
	any combination of the two.  For example, the above could be
	changed to:
      </para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  params p
	end mle
      </code>
      <para>
	in which case numerical derivatives would be used.
      </para>
      <para>
	Note that any option flags should be appended to the ending line
	of the MLE block.
      </para>
      <para>
	By default, estimated standard errors are based on the Outer
	Product of the Gradient.  If the <opt>--hessian</opt> option is
	given, they are instead based on the negative inverse of the
	Hessian (which is approximated numerically).  If the
	<opt>--robust</opt> option is given, a QML estimator is used
	(namely, a sandwich of the negative inverse of the Hessian and the
	covariance matrix of the gradient). 
      </para>
      <para>
	If you supply analytical derivatives, by default gretl runs a
	numerical check on their plausibility.  Occasionally this may
	produce false positives, instances where correct derivatives
	appear to be wrong and estimation is refused. To counter this,
	or to achieve a little extra speed, you can give the option
	<opt>--no-gradient-check</opt>.  Obviously, you should do
	this only if you are quite confident that the gradient you
	have specified is right.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Maximum likelihood</menu-path>
    </gui-access>

  </command>

  <command name="modeltab" section="Utilities" label="The model table">

    <usage>
      <arguments>
        <argument>add</argument>
        <argument alternate="true">show</argument>
        <argument alternate="true">free</argument>
      </arguments>
    </usage>

    <description context="gui"> 
      <para>
	In econometric research it is common to estimate several
	models with a common dependent variable&mdash;the models
	differing in respect of which independent variables are
	included, or perhaps in respect of the estimator used.  In
	this situation it is convenient to present the regression
	results in the form of a table, where each column contains the
	results (coefficient estimates and standard errors) for a
	given model, and each row contains the estimates for a given
	variable across the models.</para>

      <para>Gretl provides a means of constructing such a table (and
	copying it in plain text, &latex; or Rich Text Format).  Here is
	how to do it:</para>

      <nlist>
	<li><para>Estimate a model which you wish to include in the
	    table, and in the model display window, under the File
	    menu, select <quote>Save to session as icon</quote> or
	    <quote>Save as icon and close</quote>.</para>
	</li>
	<li><para>Repeat step 1 for the other models to be included in
	    the table (up to a total of six models).</para>
	</li>
	<li><para>When you are done estimating the models, open the
	    icon view of your gretl session (by selecting <quote>icon
	      view</quote> under the Session menu in the main gretl
	    window, or by clicking the <quote>session icon
	      view</quote> icon on the gretl toolbar).</para>
	</li>
	<li><para>In session icon view, there is an icon labeled
	    <quote>Model table</quote>. Decide which model you wish to
	    appear in the left-most column of the model table and add
	    it to the table, either by dragging its icon onto the
	    Model table icon, or by right-clicking on the model icon
	    and selecting <quote>Add to model table</quote> from the
	    pop-up menu.</para>
	</li>
	<li><para>Repeat step 4 for the other models you wish to
	    include in the table.  The second model selected will
	    appear in the second column from the left, and so
	    on.</para>
	</li>
	<li><para>When you are finished composing the model table,
	    display it by double-clicking on its icon.  Under the Edit
	    menu in the window which appears, you have the option of
	    copying the table to the clipboard in various
	    formats.</para>
	</li>
	<li><para>If the ordering of the models in the table is not
	    what you wanted, right-click on the model table icon and
	    select <quote>Clear table</quote>.  Then go back to step 4
	    above and try again.</para>
	</li>
      </nlist>
    </description>

    <description context="cli">
      <para>
	Manipulates the gretl <quote>model table</quote>. See 
	<guideref targ="modes"/> for details. The sub-commands have
	the following effects: <cmd>add</cmd> adds the last model
	estimated to the model table, if possible; <cmd>show</cmd>
	displays the model table in a window; and <cmd>free</cmd>
	clears the table.
      </para>
    </description>

    <gui-access>
      <menu-path>Session window, Model table icon</menu-path>
    </gui-access>

  </command>

  <command name="modprint" section="Printing"
    label="Print a user-defined model" context="cli">

    <usage>
      <arguments>
        <argument>coeffmat</argument>
        <argument>names</argument>
	<argument optional="true">addstats</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Prints the coefficient table and optional additional statistics for a
	model estimated <quote>by hand</quote>. Mainly useful for user-written
	functions.
      </para>
      <para>
	The argument <repl>coeffmat</repl> should be a <math>k</math>
	by 2 matrix containing <math>k</math> coefficients and
	<math>k</math> associated standard errors, and
	<repl>names</repl> should be a string containing at least
	<math>k</math> names for the coefficients, separated by commas
	or spaces. (The <repl>names</repl> argument may be either the
	name of a string variable or a literal string, enclosed in
	double quotes.)
      </para>
      <para>
	The optional argument <repl>addstats</repl> is a vector containing
	<math>p</math> additional statistics to be printed under the
	coefficient table.  If this argument is given, then <repl>names</repl>
	should contain <math>k + p</math> comma-separated strings, the
	additional <math>p</math> strings to be associated with the additional
	statistics.
      </para>
    </description>

  </command>

  <command name="modtest" section="Tests" label="Model tests"
    context="cli">

    <usage>
      <arguments>
        <argument optional="true">order</argument>
      </arguments>
      <options>
        <option>
	  <flag>--normality</flag>
	  <effect>normality of residual</effect>
        </option>
        <option>
	  <flag>--logs</flag>
	  <effect>non-linearity, logs</effect>
        </option>
        <option>
	  <flag>--autocorr</flag>
	  <effect>serial correlation</effect>
        </option>
        <option>
	  <flag>--arch</flag>
	  <effect>ARCH</effect>
        </option>
        <option>
	  <flag>--squares</flag>
	  <effect>non-linearity, squares</effect>
        </option>
        <option>
	  <flag>--white</flag>
	  <effect>heteroskedasticity, White's test</effect>
        </option>
        <option>
	  <flag>--white-nocross</flag>
	  <effect>White's test, squares only</effect>
        </option>
        <option>
	  <flag>--breusch-pagan</flag>
	  <effect>heteroskedasticity, Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>robust variance estimate for Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--panel</flag>
	  <effect>heteroskedasticity, groupwise</effect>
        </option>
        <option>
	  <flag>--comfac</flag>
	  <effect>common factor restriction, AR1 models only</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>don't print details</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Must immediately follow an estimation command. Depending on the
	option given, this command carries out one of the following: the
	Doornik&ndash;Hansen test for the normality of the error term; a
	Lagrange Multiplier test for nonlinearity (logs or squares);
	White's test (with or without cross-products) or the
	Breusch&ndash;Pagan test for heteroskedasticity; the LMF test for
	serial correlation <cite key="kiviet86" p="true">(Kiviet,
	1986)</cite>; a test for ARCH (Autoregressive Conditional
	Heteroskedasticity; see also the <cmd>arch</cmd> command); or a
	test of the common factor restriction implied by AR(1) estimation.
	With the exception of the normality and common factor test most of
	the options are only available for models estimated via OLS, but
	see below for details regarding two-stage least squares.
      </para>
      <para>
	The optional <lit>order</lit> argument is relevant only in case
	the <opt>--autocorr</opt> or <opt>--arch</opt> options are
	selected.  The default is to run these tests using a lag order
	equal to the periodicity of the data, but this can be adjusted by
	supplying a specific lag order.
      </para>
      <para>
	The <opt>--robust</opt> option applies only when the
	Breusch&ndash;Pagan test is selected; its effect is to use the
	robust variance estimator proposed by <cite
	key="koenker81">Koenker (1981)</cite>, making the test less
	sensitive to the assumption of normality.
      </para>
      <para>
	The <opt>--panel</opt> option is available only when the model
	is estimated on panel data: in this case a test for groupwise
	heteroskedasticity is performed (that is, for a differing
	error variance across the cross-sectional units).
      </para>
      <para>
	The <opt>--comfac</opt> option is available only when the model is
	estimated via an AR(1) method such as Hildreth&ndash;Lu.  The
	auxiliary regression takes the form of a relatively unrestricted
	dynamic model, which is used to test the common factor restriction
	implicit in the AR(1) specification.
      </para>
      <para>
	By default, the program prints the auxiliary regression on which the
	test statistic is based, where applicable.  This may be suppressed by
	using the <opt>--quiet</opt> flag.  The test statistic and its p-value
	may be retrieved using the accessors <lit>$test</lit> and
	<lit>$pvalue</lit> respectively.
      </para>
      <para>
	When a model has been estimated by two-stage least squares (see
	<cmdref targ="tsls"/>), the LM principle breaks down and gretl
	offers some equivalents: the <flag>--autocorr</flag> option
	computes Godfrey's test for autocorrelation <cite key="godfrey94"
	p="true">(Godfrey, 1994)</cite> while the <flag>--white</flag>
	option yields the HET1 heteroskedasticity test <cite
	key="pesaran99" p="true">(Pesaran and Taylor, 1999)</cite>.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests</menu-path>
    </gui-access>

  </command>

  <command name="mpols" section="Estimation" label="Multiple-precision OLS">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
	<option>
	  <flag>--simple-print</flag>
	  <effect>do not print auxiliary statistics</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Computes OLS estimates for the specified model using multiple
	precision floating-point arithmetic.  This command is available
	only if <program>gretl</program> is compiled with support for the
	Gnu Multiple Precision (GMP) library.  By default 256 bits of
	precision are used for the calculations, but this can be increased
	via the environment variable <lit>GRETL_MP_BITS</lit>.  For
	example, when using the bash shell one could issue the following
	command, before starting gretl, to set a precision of 1024 bits.
      </para>
      <code>
	export GRETL_MP_BITS=1024
      </code>

      <para context="cli">
	A rather arcane option is available for this command (primarily
	for testing purposes): if the <repl>indepvars</repl> list is
	followed by a semicolon and a further list of numbers, those
	numbers are taken as powers of <repl>x</repl> to be added to the
	regression, where <repl>x</repl> is the last variable in
	<repl>indepvars</repl>.  These additional terms are computed and
	stored in multiple precision.  In the following example
	<lit>y</lit> is regressed on <lit>x</lit> and the second, third
	and fourth powers of <lit>x</lit>:
      </para>
      <code context="cli">
	mpols y 0 x ; 2 3 4
      </code>
    </description>

    <gui-access>
      <menu-path>/Model/Other linear models/High precision OLS</menu-path>
    </gui-access>

  </command>

  <command name="negbin" section="Estimation"
    label="Negative Binomial regression">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	<argument separated="true" optional="true">offset</argument>
      </arguments>
      <options>
	<option>
	  <flag>--model1</flag>
	  <effect>use NegBin 1 model</effect>
	</option>
	<option>
	  <flag>--opg</flag>
	  <effect>see below</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>QML covariance matrix</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
      </options>
    </usage>  

    <description>
      <para>
	Estimates a Negative Binomial model.  The dependent variable is taken
	to represent a count of the occurrence of events of some sort, and
	must have only non-negative integer values. By default the model
	NegBin 2 is used, in which the conditional variance of the count is
	given by &mu;(1 + &alpha;&mu;), where &mu; denotes the conditional
	mean.  But if the <opt>--model1</opt> option is given the conditional
	variance is &mu;(1 + &alpha;).
      </para>
      <para>
	The optional <lit>offset</lit> series works in the same way as for the
	<cmdref targ="poisson"/> command.  The Poisson model is a restricted
	form of the Negative Binomial in which &alpha; = 0 by construction.
      </para>
      <para>
	By default, standard errors are computed using a numerical
	approximation to the Hessian at convergence.  But if the
	<opt>--opg</opt> option is given the covariance matrix is based on
	the Outer Product of the Gradient (OPG), or if the
	<opt>--robust</opt> option is given QML standard errors are
	calculated, using a <quote>sandwich</quote> of the inverse of the
	Hessian and the OPG.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Count data...</menu-path>
    </gui-access>
  </command>

  <command name="nls" section="Estimation"
    label="Nonlinear Least Squares">

    <usage>
      <arguments>
        <argument>function</argument>
        <argument optional="true">derivatives</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't show estimated model</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>wg_nls.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Performs Nonlinear Least Squares (NLS) estimation using a
	modified version of the Levenberg&ndash;Marquardt
	algorithm. You must supply a function specification; it is
	recommended but not required that you also supply expressions
	for the derivatives of this function with respect to each of
	the parameters if possible.  If you do not supply derivatives
	you should instead give a list of the parameters to be
	estimated (separated by spaces or commas), preceded by the
	keyword <lit>params</lit>; these can be either scalars, or
	vectors, or any combination of the two.
      </para>
      <para>
	Example: Suppose we have a data set with variables
	<math>C</math> and <math>Y</math> (&eg;
	<lit>greene11_3.gdt</lit>) and we wish to estimate a nonlinear
	consumption function of the form
	<equation status="display"
	  tex="\[C = \alpha + \beta Y^{\gamma}\]"
	  ascii="C = alpha + beta * Y^gamma"
	  graphic="greene_Cfunc"/>
      </para>
      <para>
	The parameters alpha, beta and gamma must first be added to the
	dataset and given initial values.  This can be done using the genr
	command or via menu choices. Appropriate <quote>genr</quote> lines
	may be typed into the NLS specification window prior to the
	function specification.
      </para>
      <para>
	In the NLS window we type the following lines:
      </para>
      <code>
	C = alpha + beta * Y^gamma
	deriv alpha = 1
	deriv beta = Y^gamma
	deriv gamma = beta * Y^gamma * log(Y)
      </code>
      <para>
	The first line specifies the regression function, and the next
	three lines supply the derivatives of that function with respect
	to each of the parameters in turn. If the "deriv" lines are not
	given, a numerical approximation to the Jacobian is computed.
      </para>
      <para>
	If the parameters alpha, beta and gamma were not previously
	declared we could preface the above lines with something like the
	following:
      </para>
      <code>
	genr alpha = 1
	genr beta = 1
	genr gamma = 1
      </code>
      <para>For further details on NLS estimation please see 
	<guideref targ="chap-nls"/>.
      </para>
    </description>

    <description context="cli">
      <para>
	Performs Nonlinear Least Squares (NLS) estimation using a modified
	version of the Levenberg&ndash;Marquardt algorithm.  You must
	supply a function specification.  The parameters of this function
	must be declared and given starting values (using the
	<cmd>genr</cmd> command) prior to estimation.  Optionally, you may
	specify the derivatives of the regression function with respect to
	each of the parameters.  If you do not supply derivatives you
	should instead give a list of the parameters to be estimated
	(separated by spaces or commas), preceded by the keyword
	<lit>params</lit>.  In the latter case a numerical approximation
	to the Jacobian is computed.
      </para>
      <para>
	It is easiest to show what is required by example.  The
	following is a complete script to estimate the nonlinear
	consumption function set out in William Greene's
	<book>Econometric Analysis</book> (Chapter 11 of the 4th
	edition, or Chapter 9 of the 5th).  The numbers to the left of
	the lines are for reference and are not part of the commands.
	Note that any option flags, such as <opt>--vcv</opt> for
	printing the covariance matrix of the parameter estimates,
	should be appended to the final command, <lit>end nls</lit>.
      </para>
      <code>
	1   open greene11_3.gdt
	2   ols C 0 Y
	3   genr a = $coeff(0)
	4   genr b = $coeff(Y)
	5   genr g = 1.0
	6   nls C = a + b * Y^g
	7    deriv a = 1
	8    deriv b = Y^g
	9    deriv g = b * Y^g * log(Y)
	10  end nls --vcv
      </code>
      <para>
	It is often convenient to initialize the parameters by
	reference to a related linear model; that is accomplished here
	on lines 2 to 5.  The parameters alpha, beta and gamma could
	be set to any initial values (not necessarily based on a model
	estimated with OLS), although convergence of the NLS procedure
	is not guaranteed for an arbitrary starting point.
      </para>
      <para>
	The actual NLS commands occupy lines 6 to 10. On line 6 the
	<cmd>nls</cmd> command is given: a dependent variable is
	specified, followed by an equals sign, followed by a function
	specification.  The syntax for the expression on the right is
	the same as that for the <cmd>genr</cmd> command.  The next
	three lines specify the derivatives of the regression function
	with respect to each of the parameters in turn.  Each line
	begins with the keyword <cmd>deriv</cmd>, gives the name of a
	parameter, an equals sign, and an expression whereby the
	derivative can be calculated (again, the syntax here is the
	same as for <cmd>genr</cmd>). As an alternative to supplying
	numerical derivatives, you could substitute the following for
	lines 7 to 9:
      </para>
      <code>
	params a b g
      </code>
      <para>
	Line 10, <cmd>end nls</cmd>, completes the command and calls for
	estimation. Any options should be appended to this line.
      </para>
      <para>
	For further details on NLS estimation please see
	<guideref targ="chap-nls"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Nonlinear Least Squares</menu-path>
    </gui-access>

  </command>

  <command name="normtest" section="Tests" label="Normality test">

    <usage>
      <arguments>
        <argument>series</argument>
      </arguments>
      <options>
	<option>
	  <flag>--dhansen</flag>
	  <effect>Doornik&ndash;Hansen test, the default</effect>
        </option>
	<option>
	  <flag>--swilk</flag>
	  <effect>Shapiro&ndash;Wilk test</effect>
        </option>
	<option>
	  <flag>--lillie</flag>
	  <effect>Lilliefors test</effect>
        </option>
	<option>
	  <flag>--jbera</flag>
	  <effect>Jarque&ndash;Bera test</effect>
        </option>
	<option>
	  <flag>--all</flag>
	  <effect>do all tests</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printed output</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Carries out a test for normality for the given
	<repl>series</repl>.  The specific test is controlled by the
	option flags (but if no flag is given, the Doornik&ndash;Hansen
	test is performed).  Note: the Doornik&ndash;Hansen and
	Shapiro&ndash;Wilk tests are recommended over the others, on
	account of their superior small-sample properties.
      </para>
      <para>
	The test statistic and its p-value may be retrieved
	using the accessors <lit>$test</lit> and <lit>$pvalue</lit>.
	Please note that if the <opt>--all</opt> option is given,
	the result recorded is that from the Doornik&ndash;Hansen
	test.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Normality test</menu-path>
    </gui-access>

  </command>

  <command name="nulldata" section="Dataset"
    label="Creating a blank dataset">

    <usage>
      <arguments>
        <argument>series_length</argument>
      </arguments>
      <options>
	<option>
	  <flag>--preserve</flag>
	  <effect>preserve matrices</effect>
        </option>
      </options>
      <examples>
        <example>nulldata 500</example>
      </examples>
    </usage>

    <description>
      <para>
	Establishes a <quote>blank</quote> data set, containing only a
	constant and an index variable, with periodicity 1 and the
	specified number of observations. This may be used for
	simulation purposes: some of the <cmd>genr</cmd> commands
	(&eg; <cmd>genr uniform()</cmd>, <cmd>genr normal()</cmd>)
	will generate dummy data from scratch to fill out the data
	set. This command may be useful in conjunction with
	<cmd>loop</cmd>.  See also the <quote>seed</quote> option to
	the <cmdref targ="set"/> command.
      </para>
      <para>
	By default, this command cleans out all data in gretl's current
	workspace.  If you give the <opt>--preserve</opt> option, however,
	any currently defined matrices are retained.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/New data set</menu-path>
    </gui-access>

  </command>

  <command name="ols" section="Estimation" label="Ordinary Least Squares">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
        <option>
	  <flag>--jackknife</flag>
	  <effect>see below</effect>
        </option>
        <option>
	  <flag>--simple-print</flag>
	  <effect>do not print auxiliary statistics</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
        </option>
        <option>
	  <flag>--anova</flag>
	  <effect>print an ANOVA table</effect>
        </option>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>suppress degrees of freedom correction</effect>
        </option>
        <option>
	  <flag>--print-final</flag>
	  <effect>see below</effect>
        </option>
      </options>
      <examples>
        <example>ols 1 0 2 4 6 7</example>
	<example>ols y 0 x1 x2 x3 --vcv</example>
	<example>ols y 0 x1 x2 x3 --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
        Computes ordinary least squares (OLS) estimates for the
	specified model.
      </para>

      <para context="cli">
        Computes ordinary least squares (OLS) estimates with
	<repl>depvar</repl> as the dependent variable and
	<repl>indepvars</repl> as the list of independent variables.
	Variables may be specified by name or number; use the number
	zero for a constant term. 
      </para>

      <para>Besides coefficient estimates and standard errors, the
	program also prints p-values for <math>t</math>
	(two-tailed) and <math>F</math>-statistics.  A p-value
	below 0.01 indicates statistical significance at the 1 percent
	level and is marked with <lit>***</lit>. <lit>**</lit>
	indicates significance between 1 and 5 percent and
	<lit>*</lit> indicates significance between the 5 and 10
	percent levels. Model selection statistics (the Akaike
	Information Criterion or AIC and Schwarz's Bayesian Information
	Criterion) are also printed.  The formula used for the AIC is
	that given by <cite key="akaike74">Akaike (1974)</cite>, namely 
	minus two times the maximized log-likelihood plus two times the 
	number of parameters estimated.</para>

      <para context="cli">If the option <opt>--no-df-corr</opt> is
	given, the usual degrees of freedom correction is not applied
	when calculating the estimated error variance (and hence also
	the standard errors of the parameter estimates).</para>

      <para context="cli">
	The option <opt>--print-final</opt> is applicable only in the
	context of a <cmdref targ="loop"/>.  It arranges for the
	regression to be run silently on all but the final iteration
	of the loop. See <guideref targ="loop-examples"/> for details.
      </para>

      <para context="cli">Various internal variables may be retrieved
	using the <cmdref targ="genr"/> command, provided
	<cmd>genr</cmd> is invoked directly after estimation.
	For example
      </para>
      <code context="cli">
	genr uh = $uhat
      </code>
      <para>
	saves the residuals under the name <lit>uh</lit>.
	See the <quote>accessors</quote> section of the
	gretl function reference for details.
      </para>

      <para context="cli">The specific formula used for generating
	robust standard errors (when the <opt>--robust</opt> option is
	given) can be adjusted via the <cmdref targ="set"/> command.
	The <opt>--jackknife</opt> option has the effect of
	selecting an <lit>hc_version</lit> of <lit>3a</lit>; it is
	provided to emulate the old <lit>hccm</lit> command.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Ordinary Least Squares</menu-path>
      <other-access>Beta-hat button on toolbar</other-access>
    </gui-access>

  </command>

  <command name="omit" section="Tests" label="Omit variables">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--test-only</flag>
	  <effect>don't replace the current model</effect>
	</option>
	<option>
	  <flag>--chi-square</flag>
	  <effect>give chi-square form of Wald test</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>print only the basic test result</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>don't print anything</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix for reduced model</effect>
	</option>
	<option>
	  <flag>--auto</flag>
	  <optparm optional="true">alpha</optparm>
	  <effect>sequential elimination, see below</effect>
	</option>
      </options>
      <examples>
        <example>omit 5 7 9</example>
        <example>omit seasonals --quiet</example>
        <example>omit --auto</example>
        <example>omit --auto=0.05</example>
      </examples>
    </usage>

    <description context="gui">
      <para>
	This command re-estimates the given model after omitting the specified
	variables, or after sequentially omitting insignificant variables if
	the relevant box is available and is checked.  Besides the usual model
	output, it prints a test for the joint significance of the omitted
	variables. The null hypothesis is that the true coefficients on all
	the omitted variables equal zero.
      </para>
      <para>
	Sequential elimination works as follows: at each step the variable
	with the highest p-value is omitted, until all remaining variables
	have a p-value no greater than some cutoff.  The default cutoff is 10
	percent (two-sided); this can be adjusted via the spin button.  By
	default this process operates on all variables in the model (apart
	from the constant).  If you want to confine it to a subset of the
	variables, check the box labeled <quote>Test only selected
	  variables</quote> and make a selection.
      </para>
    </description>

    <description context="cli">
      <para>
	This command must follow an estimation command.  It calculates
	a Wald test for the joint significance of the variables in
	<repl>varlist</repl>, which should be a subset of the
	independent variables in the model last estimated. The
	results of the test may be retrieved using the accessors
	<lit>$test</lit> and <lit>$pvalue</lit>.
      </para>
      <para>
	By default the restricted model is estimated and it replaces
	the original as the <quote>current model</quote> for the
	purposes of, for example, retrieving the residuals as
	<lit>$uhat</lit> or doing further tests. This behavior may be
	suppressed via the <opt>--test-only</opt> option.
      </para>
      <para>
	By default the <math>F</math>-form of the Wald test is
	recorded; the <opt>--chi-square</opt> option may be used to
	record the chi-square form instead.
      </para>
      <para>
	If the restricted model is both estimated and printed, the
	<opt>--vcv</opt> option has the effect of printing its
	covariance matrix, otherwise this option is ignored.
      </para>
      <para>
	Alternatively, if the <opt>--auto</opt> flag is given,
	sequential elimination is performed: at each step the variable
	with the highest p-value is omitted, until all remaining
	variables have a p-value no greater than some cutoff.  The
	default cutoff is 10 percent (two-sided); this can be adjusted
	by appending <quote><lit>=</lit></quote> and a value between 0
	and 1 (with no spaces), as in the fourth example above.  If
	<repl>varlist</repl> is given this process is confined to the
	listed variables, otherwise all variables are treated as
	candidates for omission. Note that the <opt>--auto</opt>
	and <opt>--test-only</opt> options cannot be combined.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Omit variables</menu-path>
    </gui-access>

  </command>

  <command name="online" section="Dataset" context="gui"
    label="Access online databases">

    <description>
      <para>
	Gretl is able to access databases at Wake Forest University
	(your computer must be connected to the internet for this to
	work).
      </para>
      <para>
	Under the <quote>File, Browse databases</quote> menu,
	select the item <quote>on database server</quote>. A window
	should appear, showing a listing of the gretl databases
	available at Wake Forest. (Depending on your location and the
	speed of your internet connection, this may take a few
	seconds.)  Along with the name of the database and a short
	description, there will appear a <quote>Local status</quote>
	entry: this shows whether you have the database installed
	locally (on the hard drive of your computer) and if so,
	whether or not it is up to date with the version on the
	server.
      </para>
      <para>
	If you have a given database installed locally, and it is
	up to date, there is no advantage in accessing it via the
	server.  But for a database that is not already installed and
	up to date, you may wish to get a listing of the data series:
	click on <quote>Get series listing</quote>.  This brings up a
	further window, from which you can display the values of a
	chosen data series, graph those values, or import them into
	gretl's workspace.  These tasks can be accomplished using the
	<quote>Series</quote> menu, or via the popup menu that appears
	when you click the right mouse button on a given series.  You
	can also search the listing for a variable of interest (the
	<quote>Find</quote> menu item).
      </para>
      <para>
	If you want faster access to the data, or wish to access
	the database offline, then select the line showing the
	database you want, in the initial database window, and press
	the <quote>Install</quote> button.  This will download the
	database in compressed format, then uncompress it and install
	it on your hard drive. Thereafter you should be able to find
	it under the <quote>File, Browse databases, gretl
	  native</quote> menu.
      </para>
    </description>
  </command>

  <command name="open" section="Dataset" 
    label="Open a data file" context="cli">

    <usage>
      <arguments>
        <argument>filename</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't print list of series</effect>
	</option>
	<option>
	  <flag>--preserve</flag>
	  <effect>preserve any matrices and scalars</effect>
	</option>
	<option>
	  <flag>--www</flag>
	  <effect>use a database on the gretl server</effect>
	</option>
	<option>
	  <note>See below for additional specialized options</note>
	</option>
      </options>
      <examples>
        <example>open data4-1</example>
        <example>open voter.dta</example>
	<example>open fedbog --www</example>
      </examples>
    </usage>

    <description>
      <para>
	Opens a data file.  If a data file is already open, it is replaced
	by the newly opened one. To add data to the current dataset, see
	<cmdref targ="append"/>.
      </para>
      <para>
	If a full path is not given, the program will search some relevant
	paths to try to find the file.  If no filename suffix is given (as
	in the first example above), gretl assumes a native datafile with
	suffix <lit>.gdt</lit>.  Based on the name of the file and various
	heuristics, gretl will try to detect the format of the data file
	(native, plain text, CSV, MS Excel, Stata, SPSS, etc.).
      </para>
      <para>
	If the <repl>filename</repl> argument takes the form of a
	URI starting with <lit>http://</lit>, then gretl will attempt
	to download the indicated data file before opening it.
      </para>
      <para>
	By default, opening a new data file clears the current gretl
	session, which includes deletion of any named matrices and
	scalars. If you wish to keep any currently defined matrices
	and scalars, use the <lit>--preserve</lit> option.
      </para>
      <para>
	The <lit>open</lit> command can also be used to open a database
	(gretl, RATS 4.0 or PcGive) for reading.  In that case it should be
	followed by the <cmdref targ="data"/> command to extract particular
	series from the database.  If the <lit>www</lit> option is given, the
	program will try to access a database of the given name on the gretl
	server &mdash; for instance the Federal Reserve interest rates
	database in the third example above.
      </para>
      <para>
	When opening a spreadsheet file (Gnumeric, Open Document or XLS), you
	may give up to three additional parameters following the filename.
	First, you can select a particular worksheet within the file.  This is
	done either by giving its (1-based) number, using the syntax, &eg;,
	<opt>--sheet=2</opt>, or, if you know the name of the sheet, by giving
	the name in double quotes, as in <opt>--sheet="MacroData"</opt>. The
	default is to read the first worksheet. You can also specify a column
	and/or row offset into the worksheet via, &eg;,
      </para>
      <code>
	--coloffset=3 --rowoffset=2
      </code>
      <para>
	which would cause gretl to ignore the first 3 columns and the first 2
	rows.  The default is an offset of 0 in both dimensions, that is, to
	start reading at the top-left cell.
      </para>
      <para>
	With plain text files, gretl generally expects to find the data
	columns delimited in some standard manner.  But there is also a
	special facility for reading <quote>fixed format</quote> files, in
	which there are no delimiters but there is a known specification of the
	form, &eg;, <quote>variable <math>k</math> occupies 8 columns starting
	at column 24</quote>.  To read such files, you should append a string
	<opt>--cols=</opt><repl>colspec</repl>, where <repl>colspec</repl> is
	composed of comma-separated integers.  These integers are interpreted
	as a set of pairs.  The first element of each pair denotes a starting
	column, measured in bytes from the beginning of the line with 1
	indicating the first byte; and the second element indicates how many
	bytes should be read for the given field.  So, for example, if you say
      </para>
      <code>
	open fixed.txt --cols=1,6,20,3
      </code>
      <para>
	then for variable 1 gretl will read 6 bytes starting at column 1; and
	for variable 2, 3 bytes starting at column 20.  Lines that are blank,
	or that begin with <lit>#</lit>, are ignored, but otherwise the
	column-reading template is applied, and if anything other than a valid
	numerical value is found an error is flagged.  If the data are read
	successfully, the variables will be named <lit>v1</lit>,
	<lit>v2</lit>, etc.  It's up to the user to provide meaningful names
	and/or descriptions using the commands <cmdref targ="rename"/> and/or 
	<cmdref targ="setinfo"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Open data</menu-path>
      <other-access>Drag a data file into gretl (MS Windows or Gnome)</other-access>
    </gui-access>

  </command>

  <command name="orthdev" section="Transformations" 
    label="Orthogonal deviations" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Applicable with panel data only. A series of forward orthogonal
	deviations is obtained for each variable in <repl>varlist</repl> and
	stored in a new variable with the prefix <lit>o_</lit>. Thus
	<cmd>orthdev x y</cmd> creates the new variables <lit>o_x</lit> and
	<lit>o_y</lit>.
      </para>
      <para>
	The values are stored one step ahead of their true temporal location
	(that is, <lit>o_x</lit> at observation <math>t</math> holds the
	deviation that, strictly speaking, belongs at <math>t</math> &minus;
	1).  This is for compatibility with first differences: one loses the
	first observation in each time series, not the last.
      </para>
    </description>

  </command>

  <command name="outfile" section="Printing" 
    label="Direct printing to file" context="cli">

    <usage>
      <arguments>
        <argument>filename</argument>
        <argument>option</argument>
      </arguments>
      <options>
        <option>
	  <flag>--append</flag>
	  <effect>append to file</effect>
        </option>
        <option>
	  <flag>--close</flag>
	  <effect>close file</effect>
        </option>
        <option>
	  <flag>--write</flag>
	  <effect>overwrite file</effect>
        </option>
      </options>
      <examples>
        <example>outfile --write regress.txt</example>
        <example>outfile --close</example>
      </examples>
    </usage>

    <description>
      <para>
	Diverts output to <repl>filename</repl>, until further
	notice.  Use the flag <opt>--append</opt> to append output to
	an existing file or <opt>--write</opt> to start a new file
	(or overwrite an existing one).  Only one file can be opened
	in this way at any given time.
      </para>
      <para>
	The <opt>--close</opt> flag is used to close an output
	file that was previously opened as above.  Output will then
	revert to the default stream.
      </para>
      <para>
	In the first example command above, the file
	<filename>regress.txt</filename> is opened for writing, and in the
	second it is closed.  This would make sense as a sequence only if
	some commands were issued before the <opt>--close</opt>.  For
	example if an <cmd>ols</cmd> command intervened, its output would
	go to <filename>regress.txt</filename> rather than the screen.
      </para>
      <para>
	Three special variants on the above are available. If you give the
	keyword <lit>null</lit> in place of a real filename along with the
	<opt>--write</opt> option, the effect is to suppress all printed
	output until the next <lit>outfile --close</lit>. In addition if
	the keywords <lit>stdout</lit> or <lit>stderr</lit> are given in
	place of a regular filename the effect is to redirect output to
	standard output or standard error output respectively.
      </para>
    </description>

  </command>

  <command name="panel" section="Estimation" label="Panel models">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
        <option>
	  <flag>--fixed-effects</flag>
	  <effect>estimate with group fixed effects</effect>
        </option>
        <option>
	  <flag>--random-effects</flag>
	  <effect>random effects or GLS model</effect>
        </option>
        <option>
	  <flag>--between</flag>
	  <effect>estimate the between-groups model</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>robust standard errors; see below</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>include time dummy variables</effect>
        </option>
        <option>
	  <flag>--unit-weights</flag>
	  <effect>weighted least squares</effect>
        </option>
        <option>
	  <flag>--iterate</flag>
	  <effect>iterative estimation</effect>
        </option>
        <option>
	  <flag>--matrix-diff</flag>
	  <effect>use matrix-difference method for Hausman test</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>less verbose output</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>more verbose output</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Estimates a panel model.  By default the fixed effects estimator is
	used; this is implemented by subtracting the group or unit means from
	the original data.
      </para>
      <para context="cli">
	If the <opt>--random-effects</opt> flag is given, random effects
	estimates are computed, using the method of Swamy and Arora. In this
	case (only) the option <opt>--matrix-diff</opt> forces use of the
	matrix-difference method (as opposed to the regression method) for
	carrying out the Hausman test for the consistency of the random
	effects estimator.
      </para>
      <para context="cli">
	Alternatively, if the <opt>--unit-weights</opt> flag is given, the
	model is estimated via weighted least squares, with the weights
	based on the residual variance for the respective cross-sectional
	units in the sample.  In this case (only) the <opt>--iterate</opt>
	flag may be added to produce iterative estimates: if the
	iteration converges, the resulting estimates are Maximum
	Likelihood.
      </para>
      <para context="cli">
	As a further alternative, if the <opt>--between</opt> flag is
	given, the between-groups model is estimated (that is, an OLS
	regression using the group means).
      </para>
      <para context="cli">
	The <opt>--robust</opt> option is available only for fixed
	effects models. The default variant is the Arellano HAC
	estimator, but Beck&ndash;Katz <quote>Panel Corrected Standard
	  Errors</quote> can be selected via the command
	<lit>set pcse on</lit>.
      </para>
      <para context="gui">
	If the "Random effects" button is checked, random effects
	GLS estimates are computed, using the method of Swamy and Arora.
      </para>
      <para>
	For more details on panel estimation, please see <guideref
	  targ="chap-panel"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Panel</menu-path>
    </gui-access>

  </command>

  <command name="panel-between" section="Estimation" context="gui"
    label="Between groups model">

    <description>
      <para>
	This dialog allows you to enter a specification for the
	<quote>between model</quote> in the context of panel data.  This
	regression uses the group-means of the data, thereby ignoring the
	variation within the groups.  This model is rarely of great
	interest in its own right, but may be useful for purposes of
	comparison (for example, with the fixed effects model).
      </para>
    </description>

  </command>    

  <command name="panel-mode" section="Dataset" context="gui"
    label="Panel data organization">

    <description>
      <para>
	This dialog offers up to three options with regard to defining a
	data set as a panel.  The first two options require that the data
	set is already organized in a panel format (although this may not
	yet be recognized by gretl).  The third option requires that the
	data set contains variables that represent the panel structure.
      </para>
      <para>
	<emphasis>Stacked time series</emphasis>: Let there be <repl>N</repl>
	cross-sectional units in the data set, and let <repl>T</repl> = the
	number of time-series observations per unit.  By selecting this option
	you are telling gretl that the data set is currently composed of
	<repl>N</repl> consecutive blocks of <repl>T</repl> time-series
	observations, one for each cross-sectional unit.  The next step will
	be to specify the value of <repl>N</repl>.
      </para>
      <para>
	<emphasis>Stacked cross sections</emphasis>: You are telling gretl
	that the data set is currently composed of <repl>T</repl> consecutive
	blocks of <repl>N</repl> cross-sectional observations, one for each
	time period. The next step, again, will be to specify the value of
	<repl>N</repl>.
      </para>
      <para>
	If the total number of observations in the current dataset is
	prime, the above options are not available.
      </para>
      <para>
	<emphasis>Use index variables</emphasis>: You are saying that the data
	set is currently organized any old way (it doesn't matter how), but
	that it contains two variables that index the cross-sectional units
	and the time periods respectively.  The next step will be to select
	those two variables.  Panel index variables must have nothing but
	non-negative integer values, with no missing values.  If there are no
	such variables in the dataset this option is not available.
      </para>
    </description>

  </command>

  <command name="panel-wls" section="Estimation" context="gui"
    label="Groupwise weighted least squares">

    <description>
      <para>
	Groupwise weighted least squares for panel data.  Computes
	weighted least squares (WLS) estimates, with the weights based on
	the estimated error variances for the respective cross-sectional
	units in the sample.
      </para>
      <para>
	If the iteration option is selected, the procedure is iterated: at
	each round the residuals are re-computed using the current WLS
	parameter estimates, which gives rise to a new set of estimates of
	the error variances, and a hence a new set of weights. Iteration
	stops when the maximum difference in the parameter estimates from
	one round to the next falls below 0.0001 or the number of
	iterations reaches 20.  If the iteration converges, the resulting
	estimates are Maximum Likelihood.
      </para>
    </description>

  </command>

  <command name="pca" section="Statistics"
    label="Principal Components Analysis">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--covariance</flag>
	  <effect>use the covariance matrix</effect>
        </option>	
        <option>
	  <flag>--save</flag>
	  <effect>save major components</effect>
        </option>	
        <option>
	  <flag>--save-all</flag>
	  <effect>save all components</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
	Principal Components Analysis.  Prints the eigenvalues of the
	correlation matrix (or the covariance matrix if the option box is
	checked) for the variables in <repl>varlist</repl>, along with the
	proportion of the joint variance accounted for by each component.
	Also prints the corresponding eigenvectors (or <quote>component
	  loadings</quote>).
      </para>
      <para>
	In the window displaying the results, you have the option of
	saving the principal components to the dataset as series.
      </para> 
    </description>

    <description context="cli">
      <para>
	Principal Components Analysis.  Prints the eigenvalues of the
	correlation matrix (or the covariance matrix if the
	<flag>--covariance</flag> option is given) for the variables in
	<repl>varlist</repl>, along with the proportion of the joint variance
	accounted for by each component.  Also prints the corresponding
	eigenvectors (or <quote>component loadings</quote>).
      </para>
      <para>
	If the <opt>--save</opt> flag is given, components with eigenvalues
	greater than the mean (which means greater than 1.0 if the analysis is
	based on the correlation matrix) are saved to the dataset as
	series, with names <lit>PC1</lit>, <lit>PC2</lit> and so on.  These
	artificial variables are formed as the sum of (component loading)
	times (standardized <lit>Xi</lit>), where <lit>Xi</lit> denotes the
	<math>i</math>th variable in <repl>varlist</repl>.
      </para>
      <para>
	If the <opt>--save-all</opt> flag is given, all of the components are
	saved as described above.
      </para> 
    </description>

    <gui-access>
      <menu-path>/View/Principal components</menu-path>
      <other-access>Main window pop-up (multiple selection)</other-access>
    </gui-access>

  </command>

  <command name="pergm" section="Statistics" label="Periodogram">

    <usage>
      <arguments>
        <argument>series</argument>
        <argument optional="true">bandwidth</argument>
      </arguments>
      <options>
        <option>
	  <flag>--bartlett</flag>
	  <effect>use Bartlett lag window</effect>
        </option>
        <option>
	  <flag>--log</flag>
	  <effect>use log scale</effect>
        </option>
        <option>
	  <flag>--radians</flag>
	  <effect>show frequency in radians</effect>
        </option>
        <option>
	  <flag>--degrees</flag>
	  <effect>show frequency in degrees</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Computes and displays (and if not in batch mode, graphs) the
	spectrum of the specified series.  By default the sample
	periodogram is given, but optionally a Bartlett lag window is used
	in estimating the spectrum (see, for example, Greene's
	<book>Econometric Analysis</book> for a discussion of this).  The
	default width of the Bartlett window is twice the square root of
	the sample size but this can be set manually using the
	<repl>bandwidth</repl> parameter, up to a maximum of half the
	sample size.
      </para>
      <para>
	If the <opt>--log</opt> option is given the spectrum is
	represented on a logarithmic scale.
      </para>
      <para>
	The (mutually exclusive) options <opt>--radians</opt> and
	<opt>--degrees</opt> influence the appearance of the frequency
	axis when the periodogram is graphed. By default the frequency
	is scaled by the number of periods in the sample, but these
	options cause the axis to be labeled from 0 to &pi; radians
	or from 0 to 180&deg;, respectively.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Periodogram</menu-path>
      <other-access>Main window pop-up menu (single selection)</other-access>
    </gui-access>

  </command>

  <command name="polyweights" section="Transformations" context="gui"
    label="Polynomial trend fitting">

    <description>
      <para>
	In fitting a polynomial trend to a time series it may be
	desirable to give extra weight to the observations at the
	start and end of the sample. (Points in the middle of the
	sample range have neighbours on both sides that are likely to
	be pulling the fit in the same general direction.)
      </para>
      <para>
	The weighting schemes offered here (quadratic, cosine-bell and
	steps) can be used to this effect. If you select one of these
	schemes two additional settings must be chosen: first, what
	maximum weight should be used (the minimum, baseline weight is
	1.0)?  Second, what central fraction of the sample should be
	given a uniform (minimal) weighting?
      </para>
      <para>
	Suppose, for example, you select a maximum weight of 3.0 and a
	central fraction of 0.4. This means that the middle 40 percent
	of the data get a weight of 1.0. If the steps shape is
	selected the first and last 30 percent of the observations get
	a weight of 3.0; otherwise, for the first 30 percent of
	observations the weights decline gradually from 3.0 to 1.0; and
	for the last 30 percent the weights increase from 1.0 to 3.0.
      </para>
    </description>

  </command>

  <command name="poisson" section="Estimation" 
    label="Poisson estimation">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
        <argument separated="true" optional="true">offset</argument>
      </arguments>
      <options>
        <option>
          <flag>--robust</flag>
          <effect>robust standard errors</effect>
        </option>	
        <option>
          <flag>--vcv</flag>
          <effect>print covariance matrix</effect>
        </option>
        <option>
          <flag>--verbose</flag>
          <effect>print details of iterations</effect>
        </option>
      </options>      
      <examples>
        <example>poisson y 0 x1 x2</example>
	<example>poisson y 0 x1 x2 ; S</example>
      </examples>
    </usage>

    <description>
      <para>
	Estimates a poisson regression.  The dependent variable is taken to
	represent the occurrence of events of some sort, and must take on only
	non-negative integer values.
      </para>
      <para>
	If a discrete random variable <math>Y</math> follows
	the Poisson distribution, then
        <equation status="display" 
          tex="\[\mathrm{Pr}(Y = y) = \frac{e^{-v} v^y}{y!}\]"
          ascii="Pr(Y = y) = exp(-v) * v^y / y!"
          graphic="poisson1"/>
	for <math>y</math> = 0, 1,
      2,&hellip;.  The mean and variance of the distribution are both
      equal to <math>v</math>.  In the Poisson regression model,
      the parameter <math>v</math> is represented as a function
      of one or more independent variables.  The most common version
      (and the only one supported by gretl) has
        <equation status="display" 
          tex="\[v = \mathrm{exp}(\beta_0+\beta_1 x_1+\beta_2 x_2 + \cdots)\]"
          ascii="v = exp(b0 + b1*x1 + b2*x2 + ...)"
          graphic="poisson2"/>
	or in other words the log of
      <math>v</math> is a linear function of the independent
      variables.
      </para>
      <para>
	Optionally, you may add an <quote>offset</quote> variable to the
	specification.  This is a scale variable, the log of which is added to
	the linear regression function (implicitly, with a coefficient of
	1.0).  This makes sense if you expect the number of occurrences of the
	event in question to be proportional, other things equal, to some
	known factor.  For example, the number of traffic accidents might be
	supposed to be proportional to traffic volume, other things equal, and
	in that case traffic volume could be specified as an
	<quote>offset</quote> in a Poisson model of the accident rate. The
	offset variable must be strictly positive.  
      </para>
      <para>
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the <opt>--robust</opt> flag is given,
	then QML or Huber&ndash;White standard errors are calculated
	instead. In this case the estimated covariance matrix is a
	<quote>sandwich</quote> of the inverse of the estimated Hessian
	and the outer product of the gradient.
      </para>
      <para>
	See also <cmdref targ="negbin"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Count data...</menu-path>
    </gui-access>

  </command>

  <command name="print" section="Printing" 
    label="Print data or strings" context="cli">

    <usage>
      <altforms>
        <altform><lit>print</lit> <repl>varlist</repl></altform>
	<altform><lit>print</lit></altform>
	<altform><lit>print</lit> <repl>object_name</repl></altform>
        <altform><lit>print</lit> <repl>string_literal</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--byobs</flag>
	  <effect>by observations</effect>
	</option>
	<option>
	  <flag>--no-dates</flag>
	  <effect>use simple observation numbers</effect>
	</option>
      </options>
      <examples>
	<example>print x1 x2 --byobs</example>
	<example>print my_matrix</example>
	<example>print "This is a string"</example>
      </examples>
    </usage>

    <description>
      <para>
	If <repl>varlist</repl> is given, prints the values of the specified
	series, or if no argument is given, prints the values of all series in
	the current dataset. If the <opt>--byobs</opt> flag is added the data
	are printed by observation, otherwise they are printed by variable.
	When printing by observation, the default is to show the date (with
	time-series data) or the observation marker string (if any) at the
	start of each line. The <opt>--no-dates</opt> option suppresses the
	printing of dates or markers; a simple observation number is shown
	instead.
      </para>
      <para>
	Besides printing series, you may give the name of a (single) matrix or
	scalar variable for printing. Or you may give a literal string
	argument, enclosed in double quotes, to be printed as is. In these
	case the option flags are not applicable.
      </para>
      <para>
	Note that you can gain greater control over the printing format (and
	so, for example, expose a greater number of digits than are shown by
	default) by using <cmdref targ="printf"/>.
      </para>	
    </description>

    <gui-access>
      <menu-path>/Data/Display values</menu-path>
    </gui-access>

  </command>

  <command name="printf" section="Printing" 
    label="Formatted printing" context="cli">

    <usage>
      <arguments>
        <argument>format</argument>
	<argpunct>, </argpunct>
        <argument>args</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Prints scalar values, series, matrices, or strings under the control
	of a format string (providing a subset of the <lit>printf()</lit>
	statement in the C programming language).  Recognized numeric formats
	are <lit>%e</lit>, <lit>%E</lit>, <lit>%f</lit>, <lit>%g</lit>,
	<lit>%G</lit> and <lit>%d</lit>, in each case with the various
	modifiers available in C.  Examples: the format <lit>%.10g</lit>
	prints a value to 10 significant figures; <lit>%12.6f</lit> prints a
	value to 6 decimal places, with a width of 12 characters.  The format
	<lit>%s</lit> should be used for strings.
      </para>
      <para>
	The format string itself must be enclosed in double quotes.  The
	values to be printed must follow the format string, separated by
	commas.  These values should take the form of either (a) the names of
	variables, (b) expressions that are valid for the <cmd>genr</cmd>
	command, or (c) the special functions <lit>varname()</lit> or
	<lit>date()</lit>.  The following example prints the values of two
	variables plus that of a calculated expression:
      </para>
      <code>
	ols 1 0 2 3
	genr b = $coeff(2)
	genr se_b = $stderr(2)
	printf "b = %.8g, standard error %.8g, t = %.4f\n", b, se_b, b/se_b
      </code>
      <para>
	The next lines illustrate the use of the varname and date functions,
	which respectively print the name of a variable, given its ID number,
	and a date string, given a 1-based observation number.
      </para>
      <code>
	printf "The name of variable %d is %s\n", i, varname(i)
	printf "The date of observation %d is %s\n", j, date(j)
      </code>
      <para>
	If a matrix argument is given in association with a numeric
	format, the entire matrix is printed using the specified
	format for each element.  The same applies to series, except
	that the range of values printed is governed by the current
	sample setting.
      </para>
      <para>
	The maximum length of a format string is 127 characters.  The
	escape sequences <lit>\n</lit> (newline), <lit>\t</lit> (tab),
	<lit>\v</lit> (vertical tab) and <lit>\\</lit> (literal
	backslash) are recognized.  To print a literal percent sign,
	use <lit>%%</lit>.
      </para>
      <para>
	As in C, numerical values that form part of the format (width and or
	precision) may be given directly as numbers, as in <lit>%10.4f</lit>,
	or they may be given as variables.  In the latter case, one puts
	asterisks into the format string and supplies corresponding arguments
	in order.  For example,
      </para>
      <code>
	scalar width = 12
	scalar precision = 6
	printf "x = %*.*f\n", width, precision, x
      </code>
    </description>

  </command>

  <command name="probit" section="Estimation"
    label="Probit model">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>show p-values instead of slopes</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	If the dependent variable is a binary variable (all values are 0
	or 1) maximum likelihood estimates of the coefficients on
	<repl>indepvars</repl> are obtained via the <quote>binary response
	model regression</quote> (BRMR) method outlined by <cite
	key="davidson-mackinnon04">Davidson and MacKinnon
	(2004)</cite>. As the model is nonlinear the slopes depend on the
	values of the independent variables.  By default the slopes with
	respect to each of the independent variables are calculated (at
	the means of those variables) and these slopes replace the usual
	p-values in the regression output.  This behavior can be
	suppressed my giving the <opt>--p-values</opt> option. The
	chi-square statistic tests the null hypothesis that all
	coefficients are zero apart from the constant.
      </para>
      <para context="cli">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the <opt>--robust</opt> flag is given,
	then QML or Huber&ndash;White standard errors are calculated
	instead. In this case the estimated covariance matrix is a
	<quote>sandwich</quote> of the inverse of the estimated Hessian
	and the outer product of the gradient. See chapter 10 of Davidson
	and MacKinnon for details.
      </para>
      <para context="gui">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the "Robust standard errors" box is
	checked, then QML or Huber&ndash;White standard errors are
	calculated instead. In this case the estimated covariance matrix
	is a <quote>sandwich</quote> of the inverse of the estimated
	Hessian and the outer product of the gradient.  See chapter 10 of
	Davidson and MacKinnon for details.
      </para>
      <para>
	If the dependent variable is not binary but is discrete, then Ordered
	Probit estimates are obtained.  (If the variable selected as dependent
	is not discrete, an error is flagged.)
      </para>
      <para>
	Probit for analysis of proportions is not implemented in
	<program>gretl</program> at this point.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Probit</menu-path>
    </gui-access>

  </command>

  <command name="pvalue" section="Utilities" 
    label="Compute p-values" context="cli">

    <usage>
      <arguments>
        <argument>dist</argument>
        <argument optional="true">params</argument>
	<argument>xval</argument>
      </arguments>
      <examples>
        <example>pvalue z zscore</example>
	<example>pvalue t 25 3.0</example>
	<example>pvalue X 3 5.6</example>
	<example>pvalue F 4 58 fval</example>
	<example>pvalue G shape scale x</example>
	<example>pvalue B bprob 10 6</example>
	<example>pvalue P lambda x</example>
	<example>pvalue W shape scale x</example>
      </examples>
    </usage>

    <description>
      <para>
	Computes the area to the right of <repl>xval</repl> in the
	specified distribution (<lit>z</lit> for Gaussian, <lit>t</lit>
	for Student's <math>t</math>, <lit>X</lit> for chi-square,
	<lit>F</lit> for <math>F</math>, <lit>G</lit> for gamma,
	<lit>B</lit> for binomial, <lit>P</lit> for Poisson, or
	<lit>W</lit> for Weibull).  
      </para>
      <para>
	Depending on the distribution, the following information must be
	given, before the <repl>xval</repl>: for the <math>t</math>
	and chi-square distributions, the degrees of freedom; for
	<math>F</math>, the numerator and denominator degrees of
	freedom; for gamma, the shape and scale parameters; for the
	binomial distribution, the <quote>success</quote> probability and
	the number of trials; for the Poisson distribution, the
	parameter &lgr; (which is both the mean and the variance); and
	for the Weibull distribution, shape and scale parameters. As
	shown in the examples above, the numerical parameters may be given
	in numeric form or as the names of variables.
      </para>
      <para>
	The parameters for the gamma distribution are sometimes given as
	mean and variance rather than shape and scale. The mean is the
	product of the shape and the scale; the variance is the product of
	the shape and the square of the scale.  So the scale may be found
	as the variance divided by the mean, and the shape as the mean
	divided by the scale.  
      </para>
    </description>

    <gui-access>
      <menu-path>/Tools/P-value finder</menu-path>
    </gui-access>

  </command>

  <command name="qlrtest" section="Tests" 
    label="Quandt likelihood ratio test">

    <description>
      <para>
	For a model estimated on time-series data via OLS, performs the
	Quandt likelihood ratio (QLR) test for a structural break at an
	unknown point in time, with 15 percent trimming at the beginning
	and end of the sample period.
      </para>
      <para>
	For each potential break point within the central 70 percent of
	the observations, a Chow test is performed (see <cmdref
	targ="chow"/>). The QLR test statistic is the maximum of the
	<math>F</math> values from these tests.  It follows a non-standard
	distribution, the critical values of which are taken from <cite
	key="stock-watson03">Stock and Watson's <book>Introduction to
	Econometrics</book> (2003)</cite>. If the QLR statistic exceeds
	the critical value at the chosen level of significance, one can
	infer that the parameters of the model are not constant.  This
	statistic can be used to detect forms of instability other than a
	single discrete break (such as multiple breaks or a slow drifting
	of the parameters).
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/QLR test</menu-path>
    </gui-access>

  </command>

  <command name="qqplot" section="Graphs" label="Q-Q plot">

    <usage>
      <altforms>
	<altform><lit>qqplot</lit> <repl>y</repl></altform>
	<altform><lit>qqplot</lit> <repl>y</repl> <repl>x</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--z-scores</flag>
	  <effect>see below</effect>
        </option>
        <option>
	  <flag>--raw</flag>
	  <effect>see below</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="gui">
	With just one series selected, displays a plot of the empirical
	quantiles of the given series against the quantiles of the normal
	distribution. The series must include at least 20 valid observations
	in the current sample range. By default the empirical quantiles are
	plotted against quantiles of the normal distribution having the same
	mean and variance as the sample data, but two alternatives are
	available: the data may be standardized (converted to z-scores) before
	plotting, or the <quote>raw</quote> empirical quantiles may be plotted
	against the quantiles of the standard normal distribution.
      </para>
      <para context="cli">
	Given just one series argument, displays a plot of the empirical
	quantiles of the selected series (given by name or ID number)
	against the quantiles of the normal distribution. The series must
	include at least 20 valid observations in the current sample
	range. By default the empirical quantiles are plotted against
	quantiles of the normal distribution having the same mean and
	variance as the sample data, but two alternatives are available:
	if the <opt>--z-scores</opt> option is given the data are
	standardized, while if the <opt>--raw</opt> option is given the
	<quote>raw</quote> empirical quantiles are plotted against the
	quantiles of the standard normal distribution. 
      </para>
      <para>
	Given two series arguments, <repl>y</repl> and <repl>x</repl>,
	displays a plot of the empirical quantiles of <repl>y</repl> against
	those of <repl>x</repl>. The data values are not standardized.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Normal Q-Q plot</menu-path>
      <menu-path>/View/Graph specified vars/Q-Q plot</menu-path>
    </gui-access>

  </command>

  <command name="quantreg" section="Estimation" 
    label="Quantile regression">

    <usage>
      <arguments>
	<argument>tau</argument>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
        <option>
	  <flag>--intervals</flag>
	  <optparm optional="true">level</optparm>
	  <effect>compute confidence intervals</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
        </option>
      </options>
      <examples>
	<example>quantreg 0.25 y 0 xlist</example>
	<example>quantreg 0.5 y 0 xlist --intervals</example>
	<example>quantreg 0.5 y 0 xlist --intervals=.95</example>
	<example>quantreg tauvec y 0 xlist --robust</example>
	<demos>
	  <demo>mrw_qr.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Quantile regression.  By default standard errors are computed
	according to the asymptotic formula given by <cite
	key="koenker-bassett78">Koenker and Bassett
	(<book>Econometrica</book>, 1978)</cite>, but if the
	<quote>robust</quote> box is checked we use the
	heteroskedasticity-robust variant from <cite
	key="koenker-zhao94">Koenker and Zhao (<book>Journal of
	Nonparametric Statistics</book>, 1994)</cite>.
      </para>
      <para>
	If the <quote>Compute confidence intervals</quote> option is
	checked gretl will calculate confidence intervals for the
	coefficients, in place of standard errors. The
	<quote>robust</quote> check-box still has an effect: if it is not
	checked, the intervals are computed on the assumption of IID
	errors; with it, gretl uses the robust estimator developed by
	<cite key="koenker-machado99">Koenker and Machado (<book>Journal
	of the American Statistical Association</book>, 1999)</cite>.
	Note that these intervals are not just <quote>plus or minus so
	many standard errors</quote>; in general, they are asymmetrical
	about the point estimates of the coefficients.
      </para>	
      <para>
	You may give a list of quantiles (see the drop-down list for some
	pre-defined possibilities).  In that case gretl will calculate
	quantile estimates and either standard errors or confidence intervals
	for each of the specified values.
      </para>
      <para>
	To Follow up on the references given above, please see
	<guideref targ="chap:quantreg"/>.
      </para>
    </description>

    <description context="cli">
      <para>
	Quantile regression.  The first argument, <repl>tau</repl>, is the
	conditional quantile for which estimates are wanted.  It may be given
	either as a numerical value or as the name of a pre-defined scalar
	variable; the value must be in the range 0.01 to 0.99. (Alternatively,
	a vector of values may be given for <repl>tau</repl>; see below for
	details.) The second and subsequent arguments compose a regression
	list on the same pattern as <cmdref targ="ols"/>.
      </para>
      <para>
	Without the <opt>--intervals</opt> option, standard errors are
	printed for the quantile estimates.  By default, these are
	computed according to the asymptotic formula given by <cite
	key="koenker-bassett78">Koenker and Bassett (1978)</cite>, but if
	the <opt>--robust</opt> option is given, standard errors that are
	robust with respect to heteroskedasticity are calculated using the
	method of <cite key="koenker-zhao94">Koenker and Zhao
	(1994)</cite>.
      </para>
      <para>
	When the <opt>--intervals</opt> option is chosen, confidence
	intervals are given for the parameter estimates instead of
	standard errors.  These intervals are computed using the rank
	inversion method, and in general they are asymmetrical about the
	point estimates.  The specifics of the calculation are inflected
	by the <opt>--robust</opt> option: without this, the intervals are
	computed on the assumption of IID errors <cite key="koenker94"
	p="true">(Koenker, 1994)</cite>; with it, they use the robust
	estimator developed by <cite key="koenker-machado99">Koenker and
	Machado (1999)</cite>.
      </para>
      <para>
	By default, 90 percent confidence intervals are produced.  You can
	change this by appending a confidence level (expressed as a decimal
	fraction) to the intervals option, as in <opt>--intervals=0.95</opt>.
      </para>
      <para>
	Vector-valued <repl>tau</repl>:  instead of supplying a scalar, you
	may give the name of a pre-defined matrix.  In this case estimates are
	computed for all the given <repl>tau</repl> values and the results are
	printed in a special format, showing the sequence of quantile
	estimates for each regressor in turn.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Robust estimation/Quantile regression</menu-path>
    </gui-access>

  </command>

  <command name="quit" section="Utilities" 
    label="Exit the program" context="cli">

    <description>
      <para>
	Exits from the program, giving you the option of saving the
	output from the session on the way out.  
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Exit</menu-path>
    </gui-access>

  </command>

  <command name="rename" section="Dataset" 
    label="Rename variables" context="cli">

    <usage>
      <arguments>
	<argument>series</argument>
	<argument>newname</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Changes the name of <repl>series</repl> (identified by name or ID
	number) to <repl>newname</repl>.  The new name must be of 15
	characters maximum, must start with a letter, and must be composed of
	only letters, digits, and the underscore character.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Edit attributes</menu-path>
      <other-access>Main window pop-up menu (single selection)</other-access>
    </gui-access>

  </command>

  <command name="reset" section="Tests" label="Ramsey's RESET">

    <usage>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't print the auxiliary regression</effect>
	</option>
	<option>
	  <flag>--squares-only</flag>
	  <effect>compute the test using only the squares</effect>
	</option>
	<option>
	  <flag>--cubes-only</flag>
	  <effect>compute the test using only the cubes</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Must follow the estimation of a model via OLS. Carries out
	Ramsey's RESET test for model specification (non-linearity) by
	adding the square and/or the cube of the fitted values to the
	regression and calculating the <math>F</math> statistic for the
	null hypothesis that the parameters on the added terms are zero.
      </para>
      <para context="cli">
	Both the square and the cube are added, unless one of the options
	<opt>--squares-only</opt> or <opt>--cubes-only</opt> is given.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Ramsey's RESET</menu-path>
    </gui-access>

  </command>

  <command name="restrict" section="Tests" context="cli"
    label="Testing restrictions">

    <usage>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't print restricted estimates</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>don't print anything</effect>
	</option>
	<option>
	  <flag>--wald</flag>
	  <effect>system estimators only &ndash; see below</effect>
	</option>
	<option>
	  <flag>--bootstrap</flag>
	  <effect>bootstrap the test if possible</effect>
	</option>
	<option>
	  <flag>--full</flag>
	  <effect>OLS and VECMs only, see below</effect>
	</option>
      </options>
    </usage>    

    <description>
      <para>
	Imposes a set of (usually linear) restrictions on either (a)
	the model last estimated or (b) a system of equations
	previously defined and named. In all cases the set of
	restrictions should be started with the keyword
	<quote>restrict</quote> and terminated with <quote>end
	restrict</quote>.
      </para>
      <para>
	In the single equation case the restrictions are always
	implicitly to be applied to the last model, and they are
	evaluated as soon as the <lit>restrict</lit> block is closed.
      </para>
      <para>
	In the case of a system of equations (defined via the <cmdref
	targ="system"/> command), the initial <quote>restrict</quote>
	may be followed by the name of a previously defined system of
	equations. If this is omitted and the last model was a system
	then the restrictions are applied to the last model. By
	default the restrictions are evaluated when the system is next
	estimated, using the <cmdref targ="estimate"/> command. But if
	the <opt>--wald</opt> option is given the restriction is
	tested right away, via a Wald chi-square test on the
	covariance matrix. Note that this option will produce an error
	if a system has been defined but not yet estimated.
      </para>
      <para>
	Depending on the context, the restrictions to be tested may be
	expressed in various ways.  The simplest form is as follows: each
	restriction is given as an equation, with a linear combination of
	parameters on the left and a scalar value to the right of the equals
	sign (either a numerical constant or the name of a scalar variable).
      </para>
      <para>
	In the single-equation case, parameters may be referenced in the form
	<lit>b[</lit><repl>i</repl><lit>]</lit>, where <repl>i</repl>
	represents the position in the list of regressors (starting at 1), or
	<lit>b[</lit><repl>varname</repl><lit>]</lit>, where
	<repl>varname</repl> is the name of the regressor in question. In the
	system case, parameters are referenced using <lit>b</lit> plus two
	numbers in square brackets. The leading number represents the position
	of the equation within the system and the second number indicates
	position in the list of regressors.  For example <lit>b[2,1]</lit>
	denotes the first parameter in the second equation, and
	<lit>b[3,2]</lit> the second parameter in the third equation.
	The <lit>b</lit> terms in the equation representing a restriction may
	be prefixed with a numeric multiplier, for example
	<lit>3.5*b[4]</lit>.
      </para>
      <para>
	Here is an example of a set of restrictions for a previously estimated
	model:
      </para>
      <code>
	restrict
	 b[1] = 0
	 b[2] - b[3] = 0
	 b[4] + 2*b[5] = 1
	end restrict
      </code>
      <para>
	And here is an example of a set of restrictions to be applied to a
	named system.  (If the name of the system does not contain spaces, the
	surrounding quotes are not required.)
      </para>
      <code>
	restrict "System 1"
	 b[1,1] = 0
	 b[1,2] - b[2,2] = 0
	 b[3,4] + 2*b[3,5] = 1
	end restrict
      </code>
      <para>
	In the single-equation case the restrictions are by default evaluated
	via a Wald test, using the covariance matrix of the model in question.
	If the original model was estimated via OLS then the restricted
	coefficient estimates are printed; to suppress this, append the
	<opt>--quiet</opt> option flag to the initial <lit>restrict</lit>
	command.  As an alternative to the Wald test, for models estimated via
	OLS or WLS only, you can give the <opt>--bootstrap</opt> option to
	perform a bootstrapped test of the restriction.
      </para>
      <para>
	In the system case, the test statistic depends on the estimator
	chosen: a Likelihood Ratio test if the system is estimated using a
	Maximum Likelihood method, or an asymptotic <math>F</math>-test
	otherwise.
      </para>
      <para>
	There are two alternatives to the method of expressing restrictions
	discussed above.  First, a set of <math>g</math> linear restrictions
	on a <math>k</math>-vector of parameters, &bgr;, may be written
	compactly as <math>R</math>&bgr; &minus; <math>q</math> = 0, where
	<math>R</math> is an <by r="g" c="k"/> matrix and <math>q</math> is a
	<math>g</math>-vector.  You can specify a restriction by giving the
	names of pre-defined, conformable matrices to be used as
	<math>R</math> and <math>q</math>, as in
      </para>
      <code>
	restrict 
	  R = Rmat
	  q = qvec
	end restrict
      </code>
      <para>
	Secondly, if you wish to test a nonlinear restriction (this is
	currently available for single-equation models only) you should give
	the restriction as the name of a function, preceded by
	<quote><lit>rfunc = </lit></quote>, as in
      </para>
      <code>
	restrict
	  rfunc = myfunction
	end restrict
      </code>
      <para>
	The constraint function should take a single <lit>const matrix</lit>
	argument; this will be automatically filled out with the parameter
	vector.  And it should return a vector which is zero under the null
	hypothesis, non-zero otherwise.  The length of the vector is the
	number of restrictions. This function is used as a
	<quote>callback</quote> by gretl's numerical Jacobian routine, which
	calculates a Wald test statistic via the delta method.
      </para>
      <para>
	Here is a simple example of a function suitable for testing one
	nonlinear restriction, namely that two pairs of parameter values have
	a common ratio. 
      </para>
      <code>
	function matrix restr (const matrix b)
	  matrix v = b[1]/b[2] - b[4]/b[5]
	  return v
	end function
      </code>
      <para>
	On successful completion of the <lit>restrict</lit> command
	the accessors <lit>$test</lit> and <lit>$pvalue</lit> give the
	test statistic and its p-value.
      </para>
      <para>
	When testing restrictions on a single-equation model estimated
	via OLS, or on a VECM, the <opt>--full</opt> option can be
	used to set the restricted estimates as the <quote>last
	model</quote> for the purposes of further testing or the use
	of accessors such as <lit>$coeff</lit> and <lit>$vcv</lit>.
	Note that some special considerations apply in the case of
	testing restrictions on Vector Error Correction Models. Please
	see <guideref targ="chap:vecm"/> for details.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Linear restrictions</menu-path>
    </gui-access>

  </command>

  <command name="restrict-model" section="Tests" context="gui"
    label="Restrictions on a model">

    <description>
      <para>
	Each restriction in the set should be expressed as an equation, with a
	linear combination of parameters on the left and a numeric value to
	the right of the equals sign. Parameters may be referenced in the form
	<lit>b[</lit><repl>i</repl><lit>]</lit>, where <repl>i</repl>
	represents the position in the list of regressors (starting at 1), or
	<lit>b[</lit><repl>varname</repl><lit>]</lit>, where
	<repl>varname</repl> is the name of the regressor in question.
      </para>
      <para>
	The <lit>b</lit> terms in the equation representing a restriction may
	be prefixed with a numeric multiplier, using <lit>*</lit> to represent
	multiplication, for example <lit>3.5*b[4]</lit>.
      </para>
      <para>
	Here is an example of a set of restrictions:
      </para>
      <code>
	b[1] = 0
	b[2] - b[3] = 0
	b[4] + 2*b[5] = 1
      </code>
    </description>

  </command>

  <command name="restrict-system" section="Tests" context="gui"
    label="Restrictions on a system of equations">

    <description>
      <para>
	Each restriction in the set should be expressed as an equation, with a
	linear combination of parameters on the left and a numeric value to
	the right of the equals sign.  Parameters are referenced using
	<lit>b</lit> plus two numbers in square brackets. The leading number
	represents the position of the equation within the system and the
	second number indicates position in the list of regressors, starting
	at 1 in both cases.  For example <lit>b[2,1]</lit> denotes the first
	parameter in the second equation, and <lit>b[3,2]</lit> the second
	parameter in the third equation.
      </para>
      <para>
	The <lit>b</lit> terms in the equation representing a restriction may
	be prefixed with a numeric multiplier, using <lit>*</lit> to represent
	multiplication, for example <lit>3.5*b[1,4]</lit>.
      </para>
      <para>Here is an example of a set of restrictions:
      </para>
      <code>
	b[1,1] = 0
	b[1,2] - b[2,2] = 0
	b[3,4] + 2*b[3,5] = 1
      </code>
    </description>

  </command>

  <command name="restrict-vecm" section="Tests" context="gui"
    label="Restrictions on a VECM">

    <description>
      <para>
	Use this command to place linear restrictions on the cointegrating
	relations (beta) and/or adjustment coefficients (alpha) in a vector
	error-correction model (VECM).
      </para>
      <para>
	Each restriction should be expressed as an equation, with a linear
	combination of parameters to the left of the equals sign and a
	numerical value on the right.  Restrictions on beta may be
	non-homogeneous (non-zero on the right), but alpha restrictions must
	be homogeneous (zero on the right).  
      </para>
      <para>
	If the VECM is of rank 1, the elements of beta are referenced in the
	form <lit>b[</lit><repl>i</repl><lit>]</lit>, where <repl>i</repl>
	represents position in the cointegrating vector, starting at 1. For
	example, <lit>b[2]</lit> denotes the second element in beta. If the
	rank is greater than 1, use <lit>b</lit> plus two numbers in square
	brackets.  For example, <lit>b[2,1]</lit> denotes the first element in
	the second cointegrating vector.
      </para>
      <para>
	To reference elements of alpha, use <lit>a</lit> instead of
	<lit>b</lit>.
      </para>
      <para>
	The parameter identifiers in the equation representing a restriction
	may be prefixed with a numeric multiplier, using <lit>*</lit> to
	represent multiplication, for example <lit>3.5*b[4]</lit>.
      </para>
      <para>Here is an example of a set of restrictions on a VECM of rank 1.
      </para>
      <code>
	b[1] + b[2] = 0
	b[1] + b[3] = 0
      </code>
      <para>
	See also <guideref targ="chap:vecm"/>.
      </para>
    </description>

  </command>

  <command name="rmplot" section="Graphs" label="Range-mean plot">

    <usage>
      <arguments>
        <argument>series</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printed output</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Range&ndash;mean plot: this command creates a simple graph to help in
	deciding whether a time series, <math>y</math>(t), has constant
	variance or not.  We take the full sample t=1,...,T and divide it into
	small subsamples of arbitrary size <math>k</math>. The first subsample
	is formed by <math>y</math>(1),...,<math>y</math>(k), the second is
	<math>y</math>(k+1), ..., <math>y</math>(2k), and so on.  For each
	subsample we calculate the sample mean and range (= maximum minus
	minimum), and we construct a graph with the means on the horizontal
	axis and the ranges on the vertical. So each subsample is represented
	by a point in this plane.  If the variance of the series is constant
	we would expect the subsample range to be independent of the subsample
	mean; if we see the points approximate an upward-sloping line this
	suggests the variance of the series is increasing in its mean; and if
	the points approximate a downward sloping line this suggests the
	variance is decreasing in the mean.
      </para>
      <para>
	Besides the graph, gretl displays the means and ranges for each
	subsample, along with the slope coefficient for an OLS regression of
	the range on the mean and the p-value for the null hypothesis that
	this slope is zero.  If the slope coefficient is significant at the 10
	percent significance level then the fitted line from the regression of
	range on mean is shown on the graph.  The <math>t</math>-statistic for
	the null, and the corresponding p-value, are recorded and may be
	retrieved using the accessors <lit>$test</lit> and <lit>$pvalue</lit>
	respectively.
      </para>
      <para context="cli">
	If the <opt>--quiet</opt> option is given, no graph is shown and no
	output is printed; only the <math>t</math>-statistic and p-value
	are recorded.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Range-mean graph</menu-path>
    </gui-access>

  </command>

  <command name="run" section="Programming" 
    label="Execute a script" context="cli">

    <usage>
      <arguments>
        <argument>filename</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Execute the commands in <repl>filename</repl> then return
	control to the interactive prompt.  This command is intended
	for use with the command-line program gretlcli, or at the
	<quote>gretl console</quote> in the GUI program.
      </para>
      <para>
	See also <cmdref targ="include"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Run icon in script window</menu-path>
    </gui-access>

  </command>

  <command name="runs" section="Tests" label="Runs test">

    <usage>
      <arguments>
        <argument>series</argument>
      </arguments>
      <options>
	<option>
	  <flag>--difference</flag>
	  <effect>use first difference of variable</effect>
	</option>
	<option>
	  <flag>--equal</flag>
	  <effect>positive and negative values are equiprobable</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Carries out the nonparametric <quote>runs</quote> test for
	randomness of the specified <repl>series</repl>, where runs are
	defined as sequences of consecutive positive or negative values.
	If you want to test for randomness of deviations from the median,
	for a variable named <lit>x1</lit> with a non-zero median, you can
	do the following:
      </para>
      <code>
	genr signx1 = x1 - median(x1)
	runs signx1
      </code>
      <para>
	If the <opt>--difference</opt> option is given, the variable is
	differenced prior to the analysis, hence the runs are interpreted
	as sequences of consecutive increases or decreases in the
	value of the variable.
      </para>
      <para>
	If the <opt>--equal</opt> option is given, the null hypothesis
	incorporates the assumption that positive and negative values
	are equiprobable, otherwise the test statistic is invariant
	with respect to the <quote>fairness</quote> of the process
	generating the sequence, and the test focuses on independence
	alone.  
      </para>
    </description>

    <gui-access>
      <menu-path>/Tools/Nonparametric tests</menu-path>
    </gui-access>

  </command>

  <command name="sampling" section="Dataset" context="gui"
    label="Setting the sample">

    <description>
      <para>
	The Sample menu offers several ways of selecting a sub-sample from the
	current dataset.
      </para>
      <para>
	If you choose <quote>Sample/Restrict based on criterion...</quote> you
	need to supply a Boolean (logical) expression, of the same sort that
	you would use to define a dummy variable.  For example the expression
	<quote>sqft > 1400</quote> will select only cases for which the
	variable sqft has a value greater than 1400. Conditions may be
	concatenated using the logical operators <quote>&amp;&amp;</quote>
	(AND) and <quote>||</quote> (OR), and may be negated using
	<quote>!</quote> (NOT). If the dataset already contains dummy
	variables, you are also given the option of selecting one of these to
	define the sample (observations with a value of 1 for the selected
	dummy will be included, and others excluded).
      </para>
      <para>
	The menu item <quote>Sample/Drop all obs with missing values</quote>
	redefines the sample to exclude all observations for which values of
	one or more variables are missing (leaving only complete cases).
      </para>  
      <para>
	To select observations for which a particular variable has no missing
	values, use <quote>Restrict based on criterion...</quote> and
	supply the Boolean condition <quote>!missing(varname)</quote> (replace
	<quote>varname</quote> with the name of the variable you want to use).
      </para>  
      <para>
	If the observations are labeled, you can exclude particular
	observations using, for example, <lit>obs!="France"</lit> as the
	Boolean criterion.  The observation name must be enclosed in double
	quotes.
      </para>
      <para>
	One point should be noted about defining a sample based on a dummy
	variable, a Boolean expression, or on the missing values criterion:
	Any <quote>structural</quote> information in the data header file
	(regarding the time series or panel nature of the data) is lost.  You
	may reimpose structure with <quote>Sample/Set frequency,
	  startobs...</quote>.
      </para>
      <para>
	Please see <guideref targ="sampling"/> for further details.
      </para>
    </description>
  </command>

  <command name="save-labels" section="Utilities" 
    label="Save or remove series labels" context="gui">
    <description>
      <para>
	If you choose Export here, gretl will write a file containing 
	the descriptive labels of any series in the current dataset
	that have such labels. This is a plain text file with one
	line per variable. The line will be empty for variables that
	have no descriptive label.
      </para>
      <para>
	If you choose Remove, the descriptive labels will be removed
	for all series that have such labels. This would be
	appropriate only if the current labels have somehow been
	added in error.
      </para>
    </description>
  </command>

  <command name="add-labels" section="Utilities" 
    label="Add series labels" context="gui">
    <description>
      <para>
	If you choose Yes here, you are offered a file-open dialog box to
	select a plain text file containing descriptive labels for the
	series in the current dataset. The file should contain one label
	per line; a blank line means no label. Gretl will attempt to read
	as many labels as there are series in the dataset, excluding the
	constant.
      </para>
    </description>
  </command>

  <command name="save-script" section="Utilities" 
    label="Save commands?" context="gui">
    <description>
      <para>
	If you choose Yes here, gretl will write a file containing a
	record of the commands you executed in the current session.  Most
	commands that you execute via <quote>point and click</quote> have
	a <quote>script</quote> counterpart, and it is these script
	commands that will be saved.  You could take the file as the basis
	for writing a gretl command script.
      </para>
      <para>
	If you don't care to be prompted to save a record of commands
	on exit, uncheck the tick box in the save commands dialog.
      </para>
    </description>
  </command>

  <command name="save-session" section="Utilities" 
    label="Save this gretl session?" context="gui">
    <description>
      <para>
	If you choose Yes here, gretl will write a file containing a
	<quote>snapshot</quote> of the current session, including a copy of
	the working dataset along with any models, graphs or other objects
	that you have saved <quote>as icons</quote>.  You can re-open this
	file later to recreate the state of gretl as of the time you quit the
	session (see the <quote>File/Session files</quote> menu).
      </para>
      <para>
	If you mostly work with gretl using command scripts (which we
	recommend for <quote>serious</quote> econometric work) you
	probably don't need to save the session, but you should be
	sure to save any changes to your script that you wish to keep.
	You may also want to save any changes to your dataset, unless
	these are of a sort that can easily be recreated by running
	a script.
      </para>
      <para>
	If you work with scripts and don't care to be prompted to
	save your session on exit, uncheck the tick box in the
	save session dialog.
      </para>
    </description>
  </command>

  <command name="scatters" section="Graphs"
    label="Multiple pairwise graphs">

    <usage>
      <arguments>
        <argument>yvar</argument>
        <argument separated="true">xvars</argument>
	<argument alternate="true">yvars ; xvar</argument>
      </arguments>
      <options>
	<option>
	  <flag>--with-lines</flag>
	  <effect>create line graphs</effect>
	</option>
        <option>
	  <flag>--output</flag>
	  <optparm>filename</optparm>
	  <effect>send output to specified file</effect>
        </option>
      </options>
      <examples>
        <example>scatters 1 ; 2 3 4 5</example>
        <example>scatters 1 2 3 4 5 6 ; 7</example>
	<example>scatters y1 y2 y3 ; x --with-lines</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Generates pairwise graphs of <repl>yvar</repl> against all the
	variables in <repl>xvars</repl>, or of all the variables in
	<repl>yvars</repl> against <repl>xvar</repl>.  The first
	example above puts variable 1 on the <math>y</math>-axis
	and draws four graphs, the first having variable 2 on the
	<math>x</math>-axis, the second variable 3 on the
	<math>x</math>-axis, and so on.  The second example
	plots each of variables 1 through 6 against variable 7 on the
	<math>x</math>-axis. Scanning a set of such plots can be
	a useful step in exploratory data analysis.  The maximum
	number of plots is six; any extra variable in the list will be
	ignored.
      </para>
      <para context="cli">
	By default the graphs are scatterplots, but if you give the
	<opt>--with-lines</opt> flag they will be line graphs.
      </para>
      <para context="cli">
	For details on usage of the <opt>--output</opt> option, please see
	the <cmdref targ="gnuplot"/> command.
      </para>
      <para context="gui">
	Generates pairwise graphs of the selected <quote>Y-axis
	  variable</quote> against each of the selected <quote>X-axis
	  variables</quote> in turn.  (Or you can select several variables
	for the Y-axis and one for the X-axis.)  Scanning a set of such
	plots can be a useful step in exploratory data analysis.  The
	maximum number of plots is six; any extra variables will be
	ignored.
      </para>
    </description>

    <gui-access>
      <menu-path>/View/Multiple graphs</menu-path>
    </gui-access>

  </command>

  <command name="sdiff" section="Transformations" 
    label="Seasonal differencing" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	The seasonal difference of each variable in <repl>varlist</repl> is
	obtained and the result stored in a new variable with the prefix
	<lit>sd_</lit>.  This command is available only for seasonal time
	series.  
      </para>
    </description>

    <gui-access>
      <menu-path>/Add/Seasonal differences of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="set" section="Programming" 
    label="Set program parameters" context="cli">

    <usage>
      <altforms>
	<altform><lit>set</lit> <repl>variable</repl> <repl>value</repl></altform>
	<altform><lit>set --to-file=</lit><repl>filename</repl></altform>
	<altform><lit>set --from-file=</lit><repl>filename</repl></altform>
	<altform><lit>set stopwatch</lit></altform>
	<altform><lit>set</lit></altform>
      </altforms>
      <examples>
        <example>set svd on</example>
        <example>set csv_delim tab</example>
	<example>set horizon 10</example>
	<example>set --to-file=mysettings.inp</example>
      </examples>    
    </usage>

    <description>
      <para>
	The most common use of this command is the first variant shown above,
	where it is used to set the value of a selected program parameter.
	This is discussed in detail below.  The other uses are: with
	<opt>--to-file</opt>, to write a script file containing all the
	current parameter settings; with <opt>--from-file</opt> to read a
	script file containing parameter settings and apply them to the
	current session; with <lit>stopwatch</lit> to zero the gretl
	<quote>stopwatch</quote> which can be used to measure CPU time (see
	the entry for the <lit>$stopwatch</lit> accessor in the gretl function
	reference); or, if the word <lit>set</lit> is given alone, to print
	the current settings.
      </para>
      <para>
	Values set via this comand remain in force for the duration of
	the gretl session unless they are changed by a further call to
	<cmd>set</cmd>.  The parameters that can be set in this way are
	enumerated below. Note that the settings of <lit>hc_version</lit>,
	<lit>hac_lag</lit> and <lit>hac_kernel</lit> are used when the
	<opt>--robust</opt> option is given to an estimation command. 
      </para>
      <para>
	The available settings are grouped under the following categories:
	program interaction and behavior, numerical methods, random number
	generation, robust estimation, filtering, time series 
	estimation, and interaction with GNU R.
      </para>

      <para>
	<emphasis>Program interaction and behavior</emphasis>
      </para>
      <para>
	These settings are used for controlling various aspects of the way
	gretl interacts with the user.
      </para>
      <ilist>
	<li>
	  <para><lit>csv_delim</lit>: either <lit>comma</lit> (the default),
	    <lit>space</lit>, <lit>tab</lit> or <lit>semicolon</lit>.  Sets
	    the column delimiter used when saving data to file in CSV format.
	  </para>
	</li>
	<li>
	  <para><lit>csv_na</lit>: string to represent missing values when
	    writing data to file in CSV format.  Maximum 7 characters; the
	    default is <lit>NA</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>echo</lit>: <lit>off</lit> or <lit>on</lit> (the
	  default). Suppress or resume the echoing of commands in gretl's
	    output.</para>
	</li>
	<li>
	  <para><lit>force_decpoint</lit>: <lit>on</lit> or <lit>off</lit>
	    (the default).  Force gretl to use the decimal point
	    character, in a locale where another character (most likely
	    the comma) is the standard decimal separator.
	  </para>
	</li>
	<li>
	  <para><lit>halt_on_error</lit>: <lit>off</lit> or <lit>on</lit> (the
	    default). By default, when an error is encountered in the course
	    of executing a script, execution is halted (and if the
	    command-line program is operating in batch mode, it exits with a
	    non-zero return status).  You can force gretl to continue on error
	    by setting <lit>halt_on_error</lit> to <lit>off</lit> (or by
	    setting the environment variable <lit>GRETL_KEEP_GOING</lit> to
	    1). If an error occurs while <quote>compiling</quote> a loop or
	    user-defined function, however, execution is halted regardless.
	  </para>
	</li>
	<li>	  
	  <para><lit>loop_maxiter</lit>: one positive integer value.
	  Sets the maximum number of iterations that a
	  <lit>while</lit> loop is allowed before halting (see <cmdref
	  targ="loop"/>). Note that this setting only affects the
	  <lit>while</lit> variant, as its purpose is to forcibly
	  break potentially infinite loops.
	  </para>
	</li>
	<li>
	  <para><lit>max_verbose</lit>: <lit>on</lit> or
	  <lit>off</lit> (the default). Toggles verbose output for the
	  <lit>BFGSmax</lit> function (see the User's Guide for
	  details).
	</para>
	</li>
	<li>
	  <para><lit>messages</lit>: <lit>off</lit> or <lit>on</lit> (the
	  default). Suppress or resume the printing of non-error messages
	  associated with various commands, for example when a new variable is
	  generated or when the sample range is changed.
         </para>
	</li>
	<li>
	  <para><lit>warnings</lit>: <lit>off</lit> or <lit>on</lit> (the
	  default). Suppress or resume the printing of warning messages
	  issued when arithmetical operations produce non-finite values. 
         </para>
	</li>
	<li>
	  <para><lit>debug</lit>: <lit>1</lit>, <lit>2</lit> or <lit>0</lit>
	    (the default).  This is for use with user-defined functions.
	    Setting <lit>debug</lit> to 1 is equivalent to turning
	    <lit>messages</lit> on within all such functions; setting this
	    variable to <lit>2</lit> has the additional effect of turning on
	    <lit>max_verbose</lit> within all functions.
	  </para>
	</li>
	<li>
	  <para><lit>shell_ok</lit>: <lit>on</lit> or <lit>off</lit>
	  (the default). Enable launching external programs from
	  gretl via the system shell. This is disabled by default for
	  security reasons, and can only be enabled via the graphical
	  user interface (Tools/Preferences/General). However, once
	  set to on, this setting will remain active for future
	  sessions until explicitly disabled.
	  </para>
	</li>
	<li>
	  <para><lit>shelldir</lit>: <repl>path</repl>.  Sets the current
	  working directory for shell commands.
	  </para>
	</li>
	<li>
	  <para><lit>use_cwd</lit>: <lit>on</lit> or <lit>off</lit>
	  (the default). This setting affects the behavior of the
	  <cmdref targ="outfile"/> and <cmdref targ="store"/>
	  commands, which write external files. Normally, the file
	  will be written in the user's default data directory; if
	  <lit>use_cwd</lit> is <lit>on</lit>, on the contrary, the
	  file will be created in the working directory when gretl was
	  started.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_verbskip</lit>: one integer. This setting
	  affects the behavior of the <opt>--verbose</opt> option to
	  those commands that use BFGS as an optimization algorithm and
	  is used to compact output. if <lit>bfgs_verbskip</lit> is
	  set to, say, 3, then the <opt>--verbose</opt> switch will
	  only print iterations 3, 6, 9 and so on.
	  </para>
	</li>
	<li>
	  <para><lit>skip_missing</lit>: <lit>on</lit> (the default)
	  or <lit>off</lit>. Controls gretl's behavior when
	  contructing a matrix from data series: the default is to
	  skip data rows that contain one or more missing values but
	  if <lit>skip_missing</lit> is set <lit>off</lit> missing
	  values are converted to NaNs.
	  </para>
	</li>
	<li>
	  <para><lit>matrix_mask</lit>: the name of a series, or the
	  keyword <lit>null</lit>. Offers greater control than 
	  <lit>skip_missing</lit> when constructing matrices from
	  series: the data rows selected for matrices are those
	  with non-zero (and non-missing) values in the specified
	  series. The selected mask remains in force until it is 
	  replaced, or removed via the <lit>null</lit> keyword.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Numerical methods</emphasis>
      </para>
      <para>
	These settings are used for controlling the numerical
	algorithms that gretl uses for estimation.
      </para>
      <ilist>
	<li>	
	  <para><lit>optimizer</lit>: either <lit>auto</lit> (the
	  default), <lit>BFGS</lit> or <lit>newton</lit>. Sets the
	  optimization algorithm used for various ML estimators, in
	  cases where both BFGS and Newton&ndash;Raphson are
	  applicable. The default is to use Newton&ndash;Raphson
	  where an analytical Hessian is available, otherwise BFGS.
	  </para>
	</li>
	<li>	
	  <para><lit>bhhh_maxiter</lit>: one integer, the maximum number of
	    iterations for gretl's internal BHHH routine, which is used in
	    the <cmd>arma</cmd> command for conditional ML estimation. If
	    convergence is not achieved after <lit>bhhh_maxiter</lit>, the
	    program returns an error. The default is set at 500.
	  </para>
	</li>	  
	<li>	  
	  <para><lit>bhhh_toler</lit>: one floating point value, or the
	    string <lit>default</lit>.  This is used in gretl's internal
	    BHHH routine to check if convergence has occurred. The
	    algorithm stops iterating as soon as the increment in the
	    log-likelihood between iterations is smaller than
	    <lit>bhhh_toler</lit>.  The default value is 1.0E&minus;06;
	    this value may be re-established by typing <lit>default</lit>
	    in place of a numeric value.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_maxiter</lit>: one integer, the maximum number of
	    iterations for gretl's BFGS routine, which is used for
	    <cmd>mle</cmd>, <cmd>gmm</cmd> and several specific
	    estimators. If convergence is not achieved in the specified
	    number of iterations, the program returns an error. The
	    default value depends on the context, but is typically
	    of the order of 500.
	  </para>
	</li>	  
	<li>	  
	  <para><lit>bfgs_toler</lit>: one floating point value, or the
	    string <lit>default</lit>.  This is used in gretl's BFGS
	    routine to check if convergence has occurred. The algorithm
	    stops as soon as the relative improvement in the objective
	    function between iterations is smaller than
	    <lit>bfgs_toler</lit>.  The default value is the machine
	    precision to the power 3/4; this value may be re-established
	    by typing <lit>default</lit> in place of a numeric value.
	  </para>
	</li>
	<li>	  
	  <para><lit>bfgs_maxgrad</lit>: one floating point value. This is
	    used in gretl's BFGS routine to check if the norm of the gradient
	    is reasonably close to zero when the <lit>bfgs_toler</lit>
	    criterion is met.  A warning is printed if the norm of the
	    gradient exceeds 1; an error is flagged if the norm exceeds
	    <lit>bfgs_maxgrad</lit>. At present the default is the 
	    permissive value of 5.0.
	  </para>
	</li>
	<li>	  
	  <para><lit>initvals</lit>: a pre-specified matrix. Allows manual
	    setting of the initial parameter estimates for numerical
	    optimization problems (such as ARMA estimation). For details see
	    <guideref targ="arma-estimation"/>.
	  </para>
	</li>
	<li>
	  <para><lit>lbfgs</lit>: <lit>on</lit> or <lit>off</lit> (the
	    default). Use the limited-memory version of BFGS (L-BFGS-B)
	    instead of the ordinary algorithm. This may be advantageous when
	    the function to be maximized is not globally concave.
	  </para>
	</li>
	<li>
	  <para><lit>lbfgs_mem</lit>: an integer value in the range 3 to 20
	    (with a default value of 8).  This determines the number of
	    corrections used in the limited memory matrix when L-BFGS-B
	    is employed.  
	  </para>
	</li>
	<li>
	<para>
	  <lit>nls_toler</lit>: a floating-point value (the default is the
	  machine precision to the power 3/4).  Sets the tolerance used in
	  judging whether or not convergence has occurred in nonlinear least
	  squares estimation using the <cmdref targ="nls"/> command.
	</para>
	</li>
	<li>
	  <para>
	    <lit>svd</lit>: <lit>on</lit> or <lit>off</lit> (the default). Use
	    SVD rather than Cholesky or QR decomposition in least squares
	    calculations.  This option applies to the <lit>mols</lit> function
	    as well as various internal calculations, but not to the regular
	    <cmdref targ="ols"/> command.
	  </para>
	</li>
	<li>
	  <para><lit>fcp</lit>: <lit>on</lit> or <lit>off</lit> (the
	    default). Use the algorithm of Fiorentini, Calzolari and
	    Panattoni rather than native gretl code when computing
	    GARCH estimates.</para>
	</li>
	<li>
	  <para><lit>gmm_maxiter</lit>: one integer, the maximum number of
	    iterations for gretl's <lit>gmm</lit> command when in iterated
	    mode (as opposed to one- or two-step).  The default value is
	    250.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Random number generation</emphasis>
      </para>

      <ilist>
	<li>
	  <para><lit>seed</lit>: an unsigned integer.  Sets the seed for
	    the pseudo-random number generator.  By default this is set from the
	    system time; if you want to generate repeatable sequences of random
	    numbers you must set the seed manually.
	  </para>
	</li>
	<li>
	  <para><lit>RNG</lit>: either <lit>MT</lit> or
	  <lit>SFMT</lit> (the default). Switches between the default
	  random number generator, namely the SIMD-oriented Fast
	  Mersenne Twister (SFMT), and the Mersenne Twister of 2002 as
	  implemented in GLib (MT). SFMT is faster and has better
	  distributional properties but MT was gretl's RNG up to
	  version 1.9.3.
	  </para>
	</li>
	<li>
	  <para><lit>normal_rand</lit>: <lit>ziggurat</lit> (the default) or
	    <lit>box-muller</lit>.  Sets the method for generating random
	    normal samples based on uniform input.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Robust estimation</emphasis>
      </para>

      <ilist>
	<li>
	  <para><lit>bootrep</lit>: an integer. Sets the number of
	  replications for the <cmdref targ="restrict"/> command with
	  the <opt>--bootstrap</opt> option.</para>
	</li>
	<li>
	  <para><lit>garch_vcv</lit>: <lit>unset</lit>,
	    <lit>hessian</lit>, <lit>im</lit> (information matrix) ,
	    <lit>op</lit> (outer product matrix), <lit>qml</lit> (QML
	    estimator), <lit>bw</lit> (Bollerslev&ndash;Wooldridge). Specifies
	    the variant that will be used for estimating the coefficient
	    covariance matrix, for GARCH models.  If <lit>unset</lit> is given
	    (the default) then the Hessian is used unless the
	    <quote>robust</quote> option is given for the garch command, in
	    which case QML is used.
	  </para>
	</li>
	<li>
	  <para><lit>arma_vcv</lit>: <lit>hessian</lit> (the default) or
	    <lit>op</lit> (outer product matrix). Specifies the variant
	    to be used when computing the covariance matrix for ARIMA
	    models.
	  </para>
	</li>
	<li>
	  <para><lit>force_hc</lit>: <lit>off</lit> (the default) or
	  <lit>on</lit>.  By default, with time-series data and when
	  the <lit>--robust</lit> option is given with <lit>ols</lit>,
	  the HAC estimator is used.  If you set <lit>force_hc</lit>
	  to <quote>on</quote>, this forces calculation of the regular
	  Heteroskedasticity Consistent Covariance Matrix (HCCM),
	  which does not take autocorrelation into account. Note that
	  when a VAR is estimated with the <lit>--robust</lit> option,
	  the default is regular HCCM, but the <lit>--robust-hac</lit>
	  option is available to produce a HAC estimator.
	  </para>
	</li>
	<li>
	  <para><lit>hac_lag</lit>: <lit>nw1</lit> (the default),
	    <lit>nw2</lit>, <lit>nw3</lit> or an integer.  Sets the
	    maximum lag value or bandwidth, <math>p</math>, used when
	    calculating HAC (Heteroskedasticity and Autocorrelation
	    Consistent) standard errors using the Newey-West approach, for
	    time series data.  <lit>nw1</lit> and <lit>nw2</lit> represent
	    two variant automatic calculations based on the sample size,
	    <math>T</math>: for nw1, 
	    <equation status="inline"
	      tex="$p = 0.75 \times T^{1/3}$" 
	      ascii="p = 0.75 * T^(1/3)"
	      graphic="nw1"/>, and for nw2, 
	    <equation status="inline"
	      tex="$p = 4 \times (T/100)^{2/9}$" 
	      ascii="p = 4 * (T/100)^(2/9)" 
	      graphic="nw2"/>. <lit>nw3</lit> calls for data-based
	    bandwidth selection.  See also <lit>qs_bandwidth</lit> and
	    <lit>hac_prewhiten</lit> below.
	  </para>
	</li>
	<li>
	  <para><lit>hac_kernel</lit>: <lit>bartlett</lit> (the default),
	    <lit>parzen</lit>, or <lit>qs</lit> (Quadratic Spectral). Sets
	    the kernel, or pattern of weights, used when calculating HAC
	    standard errors.
	  </para>
	</li>
	<li>
	  <para><lit>hac_prewhiten</lit>: <lit>on</lit> or <lit>off</lit>
	    (the default). Use Andrews-Monahan prewhitening and
	    re-coloring when computing HAC standard errors.  This also
	    implies use of data-based bandwidth selection.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>hc_version</lit>: 0 (the default), 1, 2, 3 or 3a. Sets the
	    variant used when calculating Heteroskedasticity Consistent
	    standard errors with cross-sectional data.  The first four options
	    correspond to the HC0, HC1, HC2 and HC3 discussed by
	    Davidson and MacKinnon in <book>Econometric Theory and
	      Methods</book>, chapter 5.  HC0 produces what are usually called
	    <quote>White's standard errors</quote>.  Variant 3a is
	    the MacKinnon&ndash;White <quote>jackknife</quote> procedure.
	  </para>
	</li>
	<li>
	  <para><lit>pcse</lit>: <lit>off</lit> (the default) or
	    <lit>on</lit>.  By default, when estimating a model using
	    pooled OLS on panel data with the <opt>--robust</opt> option,
	    the Arellano estimator is used for the covariance matrix.  If
	    you set <lit>pcse</lit> to <quote>on</quote>, this forces use
	    of the Beck and Katz Panel Corrected Standard Errors (which do
	    not take autocorrelation into account).
	  </para>
	</li>
	<li>
	  <para><lit>qs_bandwidth</lit>: Bandwidth for HAC estimation in
	    the case where the Quadratic Spectral kernel is selected.
	    (Unlike the Bartlett and Parzen kernels, the QS bandwidth need
	    not be an integer.)
	  </para>
	</li> 
      </ilist>

      <para>
	<emphasis>Time series</emphasis>
      </para>

      <ilist>
	<li>
	  <para>
	    <lit>horizon</lit>: one integer (the default is based on the
	    frequency of the data).  Sets the horizon for impulse responses
	    and forecast variance decompositions in the context of vector
	    autoregressions.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>vecm_norm</lit>: <lit>phillips</lit> (the default),
	    <lit>diag</lit>, <lit>first</lit> or <lit>none</lit>. Used in the
	    context of VECM estimation via the <cmdref targ="vecm"/> command
	    for identifying the cointegration
	    vectors. See the <guideref targ="chap:vecm"/> for
	    details.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Interaction with R</emphasis>
      </para>

      <ilist>
	<li>
	  <para><lit>R_lib</lit>: <lit>on </lit>(the default) or
	    <lit>off</lit>.  When sending instructions to be executed by R,
	    use the R shared library by preference to the R executable, if the
	    library is available.
	  </para>
	</li>
	<li>
	  <para><lit>R_functions</lit>: <lit>off</lit> (the default) or
	    <lit>on</lit>. Recognize functions defined in R as if they were
	    native functions (the namespace prefix
	    <quote><lit>R.</lit></quote> is required). See <guideref
	      targ="chap:gretlR"/> for details on this and the
	    previous item.
	  </para>
	</li>
      </ilist>

    </description>
  </command>

  <command name="setinfo" section="Dataset" label="Edit attributes of variable">

    <usage>
      <arguments>
        <argument>series</argument>
        <argument flag="-d ">description</argument>
        <argument flag="-n ">displayname</argument>
      </arguments>
      <options>
	<option>
	  <flag>--discrete</flag>
	  <effect>mark series as discrete</effect>
	</option>
	<option>
	  <flag>--continuous</flag>
	  <effect>mark series as continuous</effect>
	</option>
      </options>
      <examples>
        <example>setinfo x1 -d "Description of x1" -n "Graph name"</example>
	<example>setinfo z --discrete</example>
      </examples>
    </usage>

    <description context="cli">
      <para>
	Sets up to three attributes of <repl>series</repl>, given by name
	or ID number, as follows.
      </para>

      <para>
	If the <lit>-d</lit> flag is given followed by a string in double
	quotes, that string is used to set the variable's descriptive
	label. This label is shown in response to the <cmdref
	  targ="labels"/> command, and is also shown in the main window of
	the GUI program.
      </para>

      <para>
	If the <lit>-n</lit> flag is given followed by a quoted string,
	that string is used to set the variable's <quote>display
	  name</quote>, which is then used in place of the variable's name
	in graphs.
      </para>

      <para>
	If one or other of the <opt>--discrete</opt> or
	<opt>--continuous</opt> option flags is given, the variable's
	numerical character is set accordingly.  The default is to treat
	all series as continuous; setting a series as discrete
	affects the way the variable is handled in frequency plots.
      </para>

    </description>

    <description context="gui">

      <para>
	In this dialog box you can:</para>

      <para>* Rename a (series) variable.</para>

      <para>* Add or edit a description of the variable: this appears
	next to the variable name in the gretl main window.</para>

      <para>* Add or edit the "display name" for the variable (if the
	variable is a series, not a scalar).  This string (maximum 19
	characters) is shown in place of the variable name when the
	variable is displayed in a graph.  Thus for instance you can
	associate a more comprehensible string such as "T-bill rate" with
	a cryptically named variable such as "tb3".</para>

      <para>* (For time-series data) set the compaction method for the
	variable.  This method will be used if you decide to reduce the
	frequency of the dataset, or if you update the variable by
	importing from a database where the variable is at a higher
	frequency than in the working dataset.
      </para>

      <para>* Mark a variable as discrete (for series with integer values
	only).  This affects the way the variable is handled when you ask
	for a frequency plot.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Edit attributes</menu-path>
      <other-access>Main window pop-up menu</other-access>
    </gui-access>

  </command>

  <command name="setobs" section="Dataset" context="cli"
    label="Set frequency and starting observation">

    <usage>
      <altforms>
        <altform><lit>setobs</lit> <repl>periodicity</repl> <repl>startobs</repl></altform>
	<altform><lit>setobs</lit> <repl>unitvar</repl> <repl>timevar</repl></altform>
	<altform><lit>setobs --labels=</lit><repl>filename</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--cross-section</flag>
	  <effect>interpret as cross section</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>interpret as time series</effect>
        </option>
        <option>
	  <flag>--stacked-cross-section</flag>
	  <effect>interpret as panel data</effect>
        </option>
        <option>
	  <flag>--stacked-time-series</flag>
	  <effect>interpret as panel data</effect>
        </option>
        <option>
	  <flag>--panel-vars</flag>
	  <effect>use index variables, see below</effect>
        </option>
      </options>
      <examples>
        <example>setobs 4 1990:1 --time-series</example>
        <example>setobs 12 1978:03</example>
	<example>setobs 1 1 --cross-section</example>
        <example>setobs 20 1:1 --stacked-time-series</example>
	<example>setobs unit year --panel-vars</example>
      </examples>
    </usage>

    <description>
      <para>
	In its primary use, this command forces the program to
	interpret the current data set as having a specified
	structure. A secondary use, with the <opt>--labels</opt> flag,
	is to add observation labels to a dataset.
      </para>
      <para>
	In the first form of the command the <repl>periodicity</repl>,
	which must be an integer, represents frequency in the case of
	time-series data (1 = annual; 4 = quarterly; 12 = monthly; 52 =
	weekly; 5, 6, or 7 = daily; 24 = hourly).  In the case of panel
	data the periodicity means the number of lines per data block:
	this corresponds to the number of cross-sectional units in the
	case of stacked cross-sections, or the number of time periods in
	the case of stacked time series.  In the case of simple
	cross-sectional data the periodicity should be set to 1.
      </para>
      <para>
	The starting observation represents the starting date in the
	case of time series data.  Years may be given with two or four
	digits; subperiods (for example, quarters or months) should be
	separated from the year with a colon.  In the case of panel
	data the starting observation should be given as 1:1; and in
	the case of cross-sectional data, as 1.  Starting observations
	for daily or weekly data should be given in the form YY/MM/DD
	or YYYY/MM/DD (or simply as 1 for undated data).  
      </para>
      <para>
	The second form of the command (which requires the
	<opt>--panel-vars</opt> flag) may be used to impose a panel
	interpretation when the data set contains variables that uniquely
	identify the cross-sectional units and the time periods.  The data
	set will be sorted as stacked time series, by ascending values of
	the units variable, <repl>unitvar</repl>.
      </para>
      <para>
	If no explicit option flag is given to indicate the structure
	of the data the program will attempt to guess the structure
	from the information given.
      </para>
      <para>
	In the third form of the comman, with the <opt>--labels</opt>
	flag, the effect is not to set the interpretation of the data
	structure, but rather to add labels for the observations. The
	required <repl>filename</repl> parameter must give the name of
	a plain text file that contains one label per line, with
	enough lines to label all the observations.
      </para>
    </description> 

    <gui-access>
      <menu-path>/Data/Dataset structure</menu-path>
      <menu-path>/Data/Observation markers</menu-path>
    </gui-access>
      
  </command>

  <command name="setmiss" section="Dataset"
    label="Missing value code">

    <usage>
      <arguments>
        <argument>value</argument>
        <argument optional="true">varlist</argument>
      </arguments>
      <examples>
        <example>setmiss -1</example>
        <example>setmiss 100 x2</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Get the program to interpret some specific numerical data
	value (the first parameter to the command) as a code for
	<quote>missing</quote>, in the case of imported data.  If this
	value is the only parameter, as in the first example above,
	the interpretation will be applied to all series in the data
	set.  If <repl quote="true">value</repl> is followed by a list
	of variables, by name or number, the interpretation is
	confined to the specified variable(s). Thus in the second
	example the data value 100 is interpreted as a code for
	<quote>missing</quote>, but only for the variable
	<lit>x2</lit>.
      </para>
      
      <para context="gui">
	Set a numerical value that will be interpreted as "missing" or
	"not applicable", either for a particular data series (under
	the Variable menu) or globally for the entire data set (under
	the Sample menu).</para> 
      
      <para context="gui">
	Gretl has its own internal coding for missing values, but
	sometimes imported data may employ a different code.  For
	example, if a particular series is coded such that a value of
	-1 indicates "not applicable", you can select "Set missing
	value code" under the Variable menu and type in the value "-1"
	(without the quotes).  Gretl will then read the -1s as missing
	observations.</para>

    </description>

    <gui-access>
      <menu-path>/Data/Set missing value code</menu-path>
    </gui-access>

  </command>

  <command name="shell" section="Utilities" 
    label="Execute shell commands" context="cli">

    <usage>
      <arguments>
        <argument>shellcommand</argument>
      </arguments>
      <examples>
        <example>! ls -al</example>
	<example>! notepad</example>
	<example>launch notepad</example>
      </examples>
    </usage>

    <description>
      <para>
	A <cmd>!</cmd>, or the keyword <cmd>launch</cmd>, at the beginning
	of a command line is interpreted as an escape to the user's shell.
	Thus arbitrary shell commands can be executed from within
	<program>gretl</program>.  When <cmd>!</cmd> is used, the external
	command is executed synchronously.  That is,
	<program>gretl</program> waits for it to complete before
	proceeding.  If you want to start another program from within
	<program>gretl</program> and not wait for its completion
	(asynchronous operation), use <cmd>launch</cmd> instead.
      </para>
      <para>
	For reasons of security this facility is not enabled by default.
	To activate it, check the box titled <quote>Allow shell
	commands</quote> under the File, Preferences menu in the GUI
	program.  This also makes shell commands available in the
	command-line program (and is the only way to do so).
      </para>
    </description>

  </command>

  <command name="smpl" section="Dataset" 
    label="Set the sample range" context="cli">

    <!-- don't break the lines below or the text version will get messed
    up -->

    <usage>
      <altforms>
	<altform><lit>smpl</lit> <repl>startobs endobs</repl></altform>
	<altform><lit>smpl</lit> <repl>+i -j</repl></altform>
	<altform><lit>smpl</lit> <repl>dumvar</repl> <lit>--dummy</lit></altform>
	<altform><lit>smpl</lit> <repl>condition</repl> <lit>--restrict</lit></altform>
	<altform><lit>smpl</lit> <lit>--no-missing [ </lit><repl>varlist</repl> <lit>]</lit></altform>
	<altform><lit>smpl</lit> <lit>--contiguous [ </lit><repl>varlist</repl> <lit>]</lit></altform>
	<altform><lit>smpl</lit> <repl>n</repl> <lit>--random</lit></altform>
	<altform><lit>smpl full</lit></altform>
      </altforms>
      <options>
        <option>
	  <flag>--dummy</flag>
	  <effect>argument is a dummy variable</effect>
        </option>
        <option>
	  <flag>--restrict</flag>
	  <effect>apply boolean restriction</effect>
        </option>
        <option>
	  <flag>--replace</flag>
	  <effect>replace any existing boolean restriction</effect>
        </option>
        <option>
	  <flag>--no-missing</flag>
	  <effect>restrict to valid observations</effect>
        </option>
        <option>
	  <flag>--contiguous</flag>
	  <effect>see below</effect>
        </option>
        <option>
	  <flag>--random</flag>
	  <effect>form random sub-sample</effect>
        </option>
        <option>
	  <flag>--balanced</flag>
	  <effect>panel data: try to retain balanced panel</effect>
        </option>
      </options>	
      <examples>
        <example>smpl 3 10</example>
	<example>smpl 1960:2 1982:4</example>
	<example>smpl +1 -1</example>
	<example>smpl x > 3000 --restrict</example>
	<example>smpl y > 3000 --restrict --replace</example>
	<example>smpl 100 --random</example>
      </examples>
    </usage>

    <description>
      <para>
	Resets the sample range.  The new range can be defined in several
	ways.  In the first alternate form (and the first two examples) above,
	<repl>startobs</repl> and <repl>endobs</repl> must be consistent with
	the periodicity of the data.  Either one may be replaced by a
	semicolon to leave the value unchanged.  In the second form, the
	integers <repl>i</repl> and <repl>j</repl> (which may be positive or
	negative, and should be signed) are taken as offsets relative to the
	existing sample range. In the third form <repl>dummyvar</repl> must be
	an indicator variable with values 0 or 1 at each observation; the
	sample will be restricted to observations where the value is 1. The
	fourth form, using <opt>--restrict</opt>, restricts the sample to
	observations that satisfy the given Boolean condition (which is
	specified according to the syntax of the <cmdref targ="genr"/>
	command).
      </para>

      <para>
	With the <opt>--no-missing</opt> form, if <repl>varlist</repl> is
	specified observations are selected on condition that all variables in
	<repl>varlist</repl> have valid values at that observation; otherwise,
	if no <repl>varlist</repl> is given, observations are selected on
	condition that <emphasis>all</emphasis> variables have valid
	(non-missing) values.
      </para>

      <para>
	The <opt>--contiguous</opt> form of <lit>smpl</lit> is intended for
	use with time series data.  The effect is to trim any observations
	at the start and end of the current sample range that contain
	missing values (either for the variables in <repl>varlist</repl>, or
	for all data series if no <repl>varlist</repl> is given).  Then a
	check is performed to see if there are any missing values in the
	remaining range; if so, an error is flagged.
      </para>

      <para>
	With the <opt>--random</opt> flag, the specified number of cases
	are selected from the current dataset at random (without
	replacement).  If you wish to be able to replicate this selection
	you should set the seed for the random number generator first (see
	the <cmdref targ="set"/> command).
      </para>

      <para>
	The final form, <lit>smpl full</lit>, restores the full data range.
      </para>

      <para>
	Note that sample restrictions are, by default, cumulative: the
	baseline for any <lit>smpl</lit> command is the current sample. If you
	wish the command to act so as to replace any existing restriction you
	can add the option flag <opt>--replace</opt> to the end of the
	command. (But this option is not compatible with the
	<opt>--contiguous</opt> option.)
      </para>

      <para>
	The internal variable <lit>obs</lit> may be used with the
	<opt>--restrict</opt> form of <lit>smpl</lit> to exclude particular
	observations from the sample.  For example
      </para>
      <code>
	smpl obs!=4 --restrict
      </code> 
      <para>
	will drop just the fourth observation. If the data points are
	identified by labels,
      </para>
      <code>
	smpl obs!="USA" --restrict
      </code>
      <para>will drop the observation with label <quote>USA</quote>.
      </para>

      <para>
	One point should be noted about the <opt>--dummy</opt>,
	<opt>--restrict</opt> and <opt>--no-missing</opt> forms of
	<lit>smpl</lit>: <quote>structural</quote> information in the data
	file (regarding the time series or panel nature of the data) is likely
	to be lost when this command is issued.  You may reimpose structure
	with the <cmdref targ="setobs"/> command.  A related option, for use
	with panel data, is the <opt>--balanced</opt> flag: this requests that
	a balanced panel is reconstituted after sub-sampling, via the
	insertion of <quote>missing rows</quote> if need be.  But note that it
	is not always possible to comply with this request.  
      </para>

      <para>
	Please see <guideref targ="sampling"/> for further details.
      </para>

    </description>

    <gui-access>
      <menu-path>/Sample</menu-path>
    </gui-access>

  </command>

  <command name="spearman" section="Statistics"
    label="Spearmans's rank correlation">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--verbose</flag>
	  <effect>print ranked data</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Prints Spearman's rank correlation coefficient for the
	series <repl>var1</repl> and <repl>var2</repl>. The
	variables do not have to be ranked manually in advance; the
	function takes care of this.
      </para>
      <para context="gui">
	Prints Spearman's rank correlation coefficient for a specified
	pair of variables.  The variables do not have to be ranked
	manually in advance; the function takes care of this.
      </para>
      <para>
	The automatic ranking is from largest to smallest (&ie; the
	largest data value gets rank 1).  If you need to invert this
	ranking, create a new variable which is the negative of the
	original.  For example:
      </para>
      <code>
	genr altx = -x
	spearman altx y
      </code>
    </description>

    <gui-access>
      <menu-path>/Model/Robust estimation/Rank correlation</menu-path>
    </gui-access>

  </command>

  <command name="sprintf" section="Printing" 
    label="Printing to a string" context="cli">

    <usage>
      <arguments>
	<argument>stringvar</argument>
        <argument>format</argument>
	<argpunct>, </argpunct>
        <argument>args</argument>
      </arguments>
    </usage>

    <description>
      <para>
	This command works exactly like the <cmdref targ="printf"/>
	command, printing the given arguments under the control of the
	format string, except that the result is written into the named
	string, <repl>stringvar</repl>.
      </para>
      <para>
	To print the string variable, give its name preceded by
	<lit>@</lit>, as in
      </para>
      <code>
	sprintf myvar "%g", x
	print "myvar has value @myvar"
      </code>
    </description>

  </command>

  <command name="square" section="Transformations" 
    label="Create squares of variables" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--cross</flag>
	  <effect>generate cross-products as well as squares</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Generates new series which are squares of the series in
	<repl>varlist</repl> (plus cross-products if the
	<opt>--cross</opt> option is given).  For example, <cmd>square
	  x y</cmd> will generate <lit>sq_x</lit> = <lit>x</lit>
	squared, <lit>sq_y</lit> = <lit>y</lit> squared and
	(optionally) <lit>x_y</lit> = <lit>x</lit> times <lit>y</lit>.
	If a particular variable is a dummy variable it is not squared
	because we will get the same variable.  
      </para>
    </description>

    <gui-access>
      <menu-path>/Add/Squares of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="sscanf" section="Programming" 
    label="Scanning a string" context="cli">

    <usage>
      <arguments>
	<argument>source</argument>
	<argpunct>, </argpunct>
        <argument>format</argument>
	<argpunct>, </argpunct>
        <argument>args</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Deprecated command-style version of the <fncref targ="sscanf"/>
	function. 
      </para>
    </description>
  </command>

  <command name="store" section="Dataset" label="Save data">

    <usage>
      <arguments>
        <argument>filename</argument>
        <argument optional="true">varlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--csv</flag>
	  <effect>use CSV format</effect>
        </option>
        <option>
	  <flag>--omit-obs</flag>
	  <effect>see below, on CSV format</effect>
        </option>
        <option>
	  <flag>--no-header</flag>
	  <effect>see below, on CSV format</effect>
        </option>
        <option>
	  <flag>--gnu-octave</flag>
	  <effect>use GNU Octave format</effect>
        </option>
        <option>
	  <flag>--gnu-R</flag>
	  <effect>use GNU R format</effect>
        </option>
        <option>
	  <flag>--traditional</flag>
	  <effect>use traditional ESL format</effect>
        </option>
        <option>
	  <flag>--gzipped</flag>
	  <effect>apply gzip compression</effect>
        </option>
        <option>
	  <flag>--jmulti</flag>
	  <effect>use JMulti ASCII format</effect>
        </option>
        <option>
	  <flag>--dat</flag>
	  <effect>use PcGive ASCII format</effect>
        </option>
        <option>
	  <flag>--database</flag>
	  <effect>use gretl database format</effect>
        </option>
        <option>
	  <flag>--overwrite</flag>
	  <effect>see below, on database format</effect>
        </option>
        <option>
	  <flag>--comment</flag>
	  <optparm>string</optparm>
	  <effect>see below</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Saves either the entire dataset or, if a <repl>varlist</repl> is
	supplied, a specified subset of the series in the current dataset,
	to the file given by <repl>filename</repl>.
      </para>
      <para>
	By default the data are saved in <quote>native</quote> gretl
	format, but the option flags permit saving in several
	alternative formats.  CSV (Comma-Separated Values) data may be
	read into spreadsheet programs, and can also be manipulated
	using a text editor.  The formats of
	<program>Octave</program>, <program>R</program> and
	<program>PcGive</program> are designed for use with the
	respective programs.  Gzip compression may be useful for large
	datasets.  See <guideref targ="datafiles"/> for details on the
	various formats.
      </para>
      <para>
	The option flags <opt>--omit-obs</opt> and <opt>--no-header</opt>
	are applicable only when saving data in CSV format.  By default,
	if the data are time series or panel, or if the dataset includes
	specific observation markers, the CSV file includes a first column
	identifying the observations (&eg; by date).  If the
	<opt>--omit-obs</opt> flag is given this column is omitted. The
	<opt>--no-header</opt> flag suppresses the usual printing of the
	names of the variables at the top of the columns.
      </para>
      <para>
	The option of saving in gretl database format is intended to help
	with the construction of large sets of series, possibly having
	mixed frequencies and ranges of observations.  At present this
	option is available only for annual, quarterly or monthly
	time-series data. If you save to a file that already exists, the
	default action is to append the newly saved series to the existing
	content of the database.  In this context it is an error if one or
	more of the variables to be saved has the same name as a variable
	that is already present in the database. The
	<opt>--overwrite</opt> flag has the effect that, if there are
	variable names in common, the newly saved variable replaces the
	variable of the same name in the original dataset. 
      </para>
      <para>
	The <opt>--comment</opt> option is available when saving data
	as a database or in CSV format. The required parameter is a
	double-quoted one-line string, attached to the option flag
	with an equals sign. The string is inserted as a comment into
	the database index file or at the top of the CSV output.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Save data; /File/Export data</menu-path>
    </gui-access>

  </command>

  <command name="summary" section="Statistics" 
    label="Descriptive statistics" context="cli">

    <usage>
      <altforms>
	<altform><lit>summary [</lit> <repl>varlist</repl> ]</altform>
	<altform><lit>summary --matrix=</lit><repl>matname</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--simple</flag>
	  <effect>basic statistics only</effect>
        </option>
        <option>
	  <flag>--by</flag>
	  <optparm>byvar</optparm>
	  <effect>see below</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	In its first form, this command prints summary statistics for
	the variables in <repl>varlist</repl>, or for all the
	variables in the data set if <repl>varlist</repl> is omitted.
	By default, output consists of the mean, standard deviation
	(sd), coefficient of variation (= sd/mean), median, minimum,
	maximum, skewness coefficient, and excess kurtosis.  If the
	<opt>--simple</opt> option is given, output is restricted to
	the mean, minimum, maximum and standard deviation.
      </para>
      <para>
	If the <opt>--by</opt> option is given (in which case the parameter
	<repl>byvar</repl> should be the name of a discrete variable), then
	statistics are printed for sub-samples corresponding to the distinct
	values taken on by <repl>byvar</repl>.  For example, if
	<repl>byvar</repl> is a (binary) dummy variable, statistics are
	given for the cases <lit>byvar = 0</lit> and <lit>byvar = 1</lit>.
      </para>
      <para>
	If the alternative form is given, using a named matrix, then
	summary statistics are printed for each column of the matrix.
	The <opt>--by</opt> option is not available in this case.
      </para>      
    </description>

    <gui-access>
      <menu-path>/View/Summary statistics</menu-path>
      <other-access>Main window pop-up menu</other-access>
    </gui-access>

  </command>

  <command name="system" section="Estimation" label="Systems of equations">

    <usage>
      <altforms>
	<altform><lit>system method=</lit><repl>estimator</repl></altform>
	<altform><repl>sysname</repl><lit> &lt;- system</lit></altform>
      </altforms>
      <examples>
	<example>"Klein Model 1" &lt;- system</example>
        <example>system method=sur</example>
	<example>system method=3sls</example>
	<demos>
	  <demo>klein.inp</demo>
	  <demo>kmenta.inp</demo>
	  <demo>greene14_2.inp</demo>
	</demos>	  
      </examples>
    </usage>

    <description>

      <para context="gui">
	In this window you can define a system of equations and choose an
	estimator for the system.  Four sorts of statement may be given here, as
	follows:
      </para>

      <para context="cli">
	Starts a system of equations.  Either of two forms of the
	command may be given, depending on whether you wish to save
	the system for estimation in more than one way or just
	estimate the system once.</para>

      <para context="cli">
	To save the system you should assign it a name, as in the first
	example (if the name contains spaces it must be surrounded by
	double quotes).  In this case you estimate the system using
	the <cmdref targ="estimate"/> command.  With a saved system of
	equations, you are able to impose restrictions (including
	cross-equation restrictions) using the <cmdref
	targ="restrict"/> command.
      </para>

      <para context="cli">
	Alternatively you can specify an estimator for the system
	using <lit>method=</lit> followed by a string identifying one
	of the supported estimators: <cmd>ols</cmd> (Ordinary Least
	Squares), <cmd>tsls</cmd> (Two-Stage Least Squares)
	<cmd>sur</cmd> (Seemingly Unrelated Regressions),
	<cmd>3sls</cmd> (Three-Stage Least Squares), <cmd>fiml</cmd>
	(Full Information Maximum Likelihood) or <cmd>liml</cmd>
	(Limited Information Maximum Likelihood).  In this case the
	system is estimated once its definition is complete.  
      </para>

      <para context="cli">
	An equation system is terminated by the line <cmd>end system</cmd>.
	Within the system four sorts of statement may be given, as follows.
      </para>

      <ilist>
	<li><para><cmdref targ="equation"/>: specify an equation
	    within the system.  At least two such statements must be
	    provided.</para>
	</li>
	<li><para><cmd>instr</cmd>: for a system to be estimated via
	    Three-Stage Least Squares, a list of instruments (by
	    variable name or number). Alternatively, you can put this
	    information into the <cmd>equation</cmd> line using the
	    same syntax as in the <cmdref targ="tsls"/>
	    command.</para>
	</li>
	<li><para><cmd>endog</cmd>: for a system of simultaneous
	    equations, a list of endogenous variables.  This is
	    primarily intended for use with FIML estimation, but with
	    Three-Stage Least Squares this approach may be used
	    instead of giving an <cmd>instr</cmd> list; then all the
	    variables not identified as endogenous will be used as
	    instruments.</para>
	</li>
	<li><para><cmd>identity</cmd>: for use with FIML, an identity
	    linking two or more of the variables in the system.  This
	    sort of statement is ignored when an estimator other than
	    FIML is used.
	  </para>
	</li>
      </ilist>
	
      <para context="cli">
	After estimation using the <cmd>system</cmd> or
	<cmd>estimate</cmd> commands the following accessors can be used to
	retrieve additional information:
      </para>

      <ilist context="cli">
	<li><para><lit>$uhat</lit>: the matrix of residuals, one column
	    per equation.
	  </para>
	</li>
	<li><para><lit>$yhat</lit>: matrix of fitted values, one column
	    per equation.
	  </para>
	</li>
	<li><para><lit>$coeff</lit>: column vector of coefficients (all
	    the coefficients from the first equation, followed by those
	    from the second equation, and so on).
	  </para>
	</li>
	<li><para><lit>$vcv</lit>: covariance matrix of the coefficients.
	    If there are <math>k</math> elements in the
	    <lit>$coeff</lit> vector, this matrix is <math>k</math>
	    by <math>k</math>.
	  </para>
	</li>
	<li><para><lit>$sigma</lit>: cross-equation residual covariance
	    matrix.
	  </para>
	</li>
	<li><para><lit>$sysGamma</lit>, <lit>$sysA</lit> and <lit>$sysB</lit>: 
	    structural-form coefficient matrices (see below).
	  </para>
	</li>
      </ilist>

      <para context="cli">
	If you want to retrieve the residuals or fitted values for a
	specific equation as a data series, select a column from the
	<lit>$uhat</lit> or <lit>$yhat</lit> matrix and assign it to
	a series, as in
      </para>
      <code context="cli">
	series uh1 = $uhat[,1]
      </code>

      <para context="cli">
	The structural-form matrices correspond to the following
	representation of a simultaneous equations model:
	<equation status="display"
	  tex="\[\Gamma y_t=Ay_{t-1}+Bx_t+\epsilon_t\]"
	  ascii="Gamma y(t) = A y(t-1) + B x(t) + e(t)"
	  graphic="structural"/> 
	If there are <math>n</math> endogenous variables and
	<math>k</math> exogenous variables, 
	&Gamma; is an <by r="n" c="n"/> matrix and <math>B</math>
	is <by r="n" c="k"/>. If the system contains no lags of the endogenous
	variables then the <math>A</math> matrix is not present.  If the
	maximum lag of an endogenous regressor is <math>p</math>,
	the <math>A</math> matrix is <by r="n" c="np"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Simultaneous equations</menu-path>
    </gui-access>

  </command>

  <command name="tabprint" section="Printing" 
    label="Print model in tabular form" context="cli">

    <usage>
      <arguments>
        <argument optional="true">-f filename</argument>
      </arguments>
      <options>
        <option>
	  <flag>--rtf</flag>
	  <effect>Produce RTF instead of &latex;</effect>
        </option>
        <option>
	  <flag>--complete</flag>
	  <effect>Create a complete document</effect>
        </option>
        <option>
	  <flag>--format="f1|f2|f3|f4"</flag>
	  <effect>Specify a custom format</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Must follow the estimation of a model.  Prints the estimated model in
	tabular form &mdash; by default as &latex;, but as RTF if the
	<opt>--rtf</opt> flag is given.  If a filename is specified using the
	<lit>-f</lit> flag output goes to that file, otherwise it goes to a
	file with a name of the form <filename>model_N.tex</filename> (or
	<filename>model_N.rtf</filename>), where <lit>N</lit> is the number of
	models estimated to date in the current session.
      </para>
      <para>
	The further options discussed below are available only when printing
	the model as &latex;.
      </para>
      <para>
	If the <opt>--complete</opt> flag is given the &latex; file is
	a complete document, ready for processing; otherwise it must
	be included in a document.
      </para>
      <para>
	If you wish alter the appearance of the tabular output, you can
	specify a custom row format using the <opt>--format</opt> flag.
	The format string must be enclosed in double quotes and must be
	tied to the flag with an equals sign.  The pattern for the format
	string is as follows.  There are four fields, representing the
	coefficient, standard error, <math>t</math>-ratio and
	p-value respectively.  These fields should be separated by
	vertical bars; they may contain a <lit>printf</lit>-type
	specification for the formatting of the numeric value in question,
	or may be left blank to suppress the printing of that column
	(subject to the constraint that you can't leave all the columns
	blank).  Here are a few examples:
      </para>
      <code>
	--format="%.4f|%.4f|%.4f|%.4f"
	--format="%.4f|%.4f|%.3f|"
	--format="%.5f|%.4f||%.4f"
	--format="%.8g|%.8g||%.4f"
      </code>
      <para>
	The first of these specifications prints the values in all columns
	using 4 decimal places.  The second suppresses the p-value and
	prints the <math>t</math>-ratio to 3 places.  The third
	omits the <math>t</math>-ratio.  The last one again omits
	the <math>t</math>, and prints both coefficient and standard
	error to 8 significant figures.
      </para>
      <para>
	Once you set a custom format in this way, it is remembered and
	used for the duration of the gretl session.  To revert to
	the default format you can use the special variant
	<opt>--format=default</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="textplot" section="Graphs" 
    label="ASCII plot" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--time-series</flag>
	  <effect>plot by observation</effect>
        </option>
        <option>
	  <flag>--one-scale</flag>
	  <effect>force a single scale</effect>
        </option>
        <option>
	  <flag>--tall</flag>
	  <effect>use 40 rows</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Quick and simple ASCII graphics.  Without the <opt>--time-series</opt>
	flag, <repl>varlist</repl> must contain at least two series, the last
	of which is taken as the variable for the <math>x</math> axis, and a
	scatter plot is produced. In this case the <opt>--tall</opt> option
	may be used to produce a graph in which the <math>y</math> axis is
	represented by 40 rows of characters (the default is 20 rows).
      </para>
      <para>
	With the <opt>--time-series</opt>, a plot by observation is produced.
	In this case the option <opt>--one-scale</opt> may be used to force
	the use of a single scale; otherwise if <repl>varlist</repl> contains
	more than one series the data may be scaled. Each line represents an
	observation, with the data values plotted horizontally.  
      </para>
      <para>
	See also <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>


  <command name="tobit" section="Estimation" label="Tobit model">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--llimit</flag>
	  <optparm>lval</optparm>
	  <effect>specify left bound</effect>
        </option>
        <option>
	  <flag>--rlimit</flag>
	  <optparm>rval</optparm>
	  <effect>specify right bound</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Estimates a Tobit model, which may be appropriate when the
	dependent variable is <quote>censored</quote>.  For example,
	positive and zero values of purchases of durable goods on the part
	of individual households are observed, and no negative values, yet
	decisions on such purchases may be thought of as outcomes of an
	underlying, unobserved disposition to purchase that may be
	negative in some cases. 
      </para>
      <para context="cli">
	By default it is assumed that the dependent variable is
	censored at zero on the left and is uncensored on the
	right. However you can use the options <opt>--llimit</opt>
	and <opt>--rlimit</opt> to specify a different pattern
	of censoring. Note that if you specify a right bound only,
	the assumption is then that the dependent variable is
	uncensored on the left.
      </para>
      <para context="gui">
	By default it is assumed that the dependent variable is
	censored at zero on the left and is uncensored on the
	right. However you can use the entry boxes marked <quote>left
	bound</quote> and <quote>right bound</quote> to specify a
	different pattern of censoring. Enter either a numerical value
	or <lit>NA</lit> for no censoring.
      </para>
      <para>
	The Tobit model is a special case of interval regression, which
	is supported via the <cmdref targ="intreg"/> command.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Tobit</menu-path>
    </gui-access>

  </command>

  <command name="transpos" section="Dataset" label="Transpose data"
    context="gui">

    <description>
      <para>
	Transposes the current data set.  That is, each observation
	(row) in the current data set will be treated as a variable
	(column), and each variable as an observation.  This command
	may be useful if data have been read from some external source 
	in which the rows of the data table represent variables.
      </para>
      <para>
	See also <cmdref targ="dataset"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Data/Transpose data</menu-path>
    </gui-access>

  </command>

  <command name="tsls" section="Estimation"
    label="Instrumental variables regression">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	<argument separated="true">instruments</argument>
      </arguments>
      <options>
        <option>
	  <flag>--no-tests</flag>
	  <effect>don't do diagnostic tests</effect>
        </option>	
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
	<option>
	  <flag>--liml</flag>
	  <effect>use Limited Information Maximum Likelihood</effect>
        </option>
	<option>
	  <flag>--gmm</flag>
	  <effect>use the Generalized Method of Moments</effect>
        </option>
      </options>      
      <examples>
        <example>tsls y1 0 y2 y3 x1 x2 ; 0 x1 x2 x3 x4 x5 x6</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Computes Instrumental Variables (IV) estimates, by default using
	two-stage least squares (TSLS) but see below for further options.  The
	dependent variable is <repl>depvar</repl>, <repl>indepvars</repl> is
	the list of regressors (which is presumed to include at least one
	endogenous variable); and <repl>instruments</repl> is the list of
	instruments (exogenous and/or predetermined variables). If the
	<repl>instruments</repl> list is not at least as long as
	<repl>indepvars</repl>, the model is not identified.
      </para>

      <para context="cli">
	In the above example, the <lit>y</lit>s are endogenous and the
	<lit>x</lit>s are the exogenous variables. Note that exogenous
	regressors should appear in both lists.
      </para>

      <para context="gui">
	This command requires the selection of two lists of variables: the
	independent variables to appear in the given model and a set of
	instruments.  Note that any exogenous regressors should appear in both
	lists.
      </para>

      <para>
	Output for two-stage least squares estimates includes the Hausman
	test and, if the model is over-identified, the Sargan
	over-identification test.  In the Hausman test, the null
	hypothesis is that OLS estimates are consistent, or in other words
	estimation by means of instrumental variables is not really
	required.  A model of this sort is over-identified if there are
	more instruments than are strictly required.  The Sargan test is
	based on an auxiliary regression of the residuals from the
	two-stage least squares model on the full list of instruments.
	The null hypothesis is that all the instruments are valid, and
	suspicion is thrown on this hypothesis if the auxiliary regression
	has a significant degree of explanatory power. For a good
	explanation of both tests see chapter 8 of <cite
	key="davidson-mackinnon04">Davidson and MacKinnon (2004)</cite>.
      </para>

      <para>
	For both TSLS and LIML estimation, an additional test result is
	shown provided that the model is estimated under the assumption of
	i.i.d.  errors (that is, the <opt>--robust</opt> option is not
	selected). This is a test for weakness of the instruments.  Weak
	instruments can lead to serious problems in IV regression: biased
	estimates and/or incorrect size of hypothesis tests based on the
	covariance matrix, with rejection rates well in excess of the
	nominal significance level <cite key="stock-wright-yogo02"
	p="true">(Stock, Wright and Yogo, 2002)</cite>.  The test
	statistic is the first-stage <math>F</math>-test if the model
	contains just one endogenous regressor, otherwise it is the
	smallest eigenvalue of the matrix counterpart of the first stage
	<math>F</math>. Critical values based on the Monte Carlo analysis
	of <cite key="stock-yogo03">Stock and Yogo (2003)</cite> are shown
	when available.
      </para>

      <para>
	The R-squared value printed for models estimated via two-stage least
	squares is the square of the correlation between the dependent
	variable and the fitted values.
      </para>

      <para context="cli">
	As alternatives to TSLS, the model may be estimated via Limited
	Information Maximum Likelihood (the <opt>--liml</opt> option) or via
	the Generalized Method of Moments (<opt>--gmm</opt> option). Note that
	if the model is just identified these methods should produce the same
	results as TSLS, but if it is over-identified the results will differ
	in general.
      </para>

      <para context="cli">
	If GMM estimation is selected, the following additional options become
	available:
      </para>

      <ilist context="cli">
	<li>
	  <para>
	    <opt>--two-step</opt>: perform two-step GMM rather than the
	    default of one-step.
	  </para>
	</li>
	<li>
	  <para>
	    <opt>--iterate</opt>: Iterate GMM to convergence.
	  </para>
	</li>
	<li>
	  <para>
	    <opt>--weights=</opt><repl>Wmat</repl>: specify a square matrix of
	    weights to be used when computing the GMM criterion function. The
	    dimension of this matrix must equal the number of instruments. The
	    default is an appropriately sized identity matrix.
	  </para>
	</li>	
      </ilist>

    </description>

    <gui-access>
      <menu-path>/Model/Other linear models/Two-Stage Least Squares</menu-path>
    </gui-access>

  </command>

  <command name="var" section="Estimation"
    label="Vector Autoregression">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>ylist</argument>
	<argument separated="true" optional="true">xlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>do not include a constant</effect>
        </option>
        <option>
	  <flag>--trend</flag>
	  <effect>include a linear trend</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include seasonal dummy variables</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
        <option>
	  <flag>--robust-hac</flag>
	  <effect>HAC standard errors</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>print impulse responses</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>print variance decompositions</effect>
        </option>
        <option>
	  <flag>--lagselect</flag>
	  <effect>show information criteria for lag selection</effect>
        </option>
      </options>
      <examples>
        <example>var 4 x1 x2 x3 ; time mydum</example>
	<example>var 4 x1 x2 x3 --seasonals</example>
	<example>var 12 x1 x2 x3 --lagselect</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	This command requires specification of:
      </para>
      <ilist context="gui">
	<li><para context="gui">- the lag order, that is, the number of
	    lags of each variable that should be included in the
	    system;</para>
	</li>
	<li><para context="gui">- any exogenous variables (but note that a
	    constant is included automatically unless you specify otherwise, a
	    trend can be added using the trend checkbox, and seasonal dummy
	    variables can be added using the seasonals checkbox); and
	  </para>
	</li>
	<li><para context="gui">- a list of endogenous variables, lags
	    of which will be included on the right-hand side of each
	    equation (note: do not include lagged variables in this
	    list -- they will be added automatically).</para>
	</li>
      </ilist>
      <para context="gui">
	A separate regression will be run for each variable in the system.
	Output for each equation includes F-tests for zero restrictions on
	all lags of each of the variables and an F-test for the maximum
	lag, along with (optionally) forecast variance decompositions and
	impulse response functions.
      </para>

      <para context="cli">
	Sets up and estimates (using OLS) a vector autoregression (VAR).
	The first argument specifies the lag order &mdash; or the maximum
	lag order in case the <opt>--lagselect</opt> option is given (see
	below).  The order may be given numerically, or as the name of a
	pre-existing scalar variable. Then follows the setup for the first
	equation.  Don't include lags among the elements of
	<repl>ylist</repl> &mdash; they will be added automatically.
	The semi-colon separates the stochastic variables, for which
	<repl>order</repl> lags will be included, from any exogenous
	variables in <repl>xlist</repl>.  Note that a constant is
	included automatically unless you give the <opt>--nc</opt> flag, a
	trend can be added with the <opt>--trend</opt> flag, and seasonal
	dummy variables may be added using the <opt>--seasonals</opt>
	flag.
      </para>

      <para context="cli">
	A separate regression is reported for each variable in
	<repl>ylist</repl>.  Output for each equation includes
	<math>F</math>-tests for zero restrictions on all lags of each
	of the variables, an <math>F</math>-test for the significance
	of the maximum lag, and, if the <opt>--impulse-responses</opt>
	flag is given, forecast variance decompositions and impulse
	responses.
      </para>

      <para>
	Forecast variance decompositions and impulse responses are based on the
	Cholesky decomposition of the contemporaneous covariance matrix, and in
	this context the order in which the (stochastic) variables are given
	matters.  The first variable in the list is assumed to be <quote>most
	  exogenous</quote> within-period. The horizon for variance
	decompositions and impulse responses can be set using the <cmdref
	  targ="set"/> command.
      </para>

      <para context="cli">
	If the <opt>--robust</opt> option is given, standard errors
	are corrected for heteroskedasticity. Alternatively, the
	<opt>--robust-hac</opt> option can be given to produce
	standard errors that are robust with respect to both
	heteroskedasticity and autocorrelation (HAC). In general
	the latter correction should not be needed if the VAR
	includes sufficient lags.
      </para>

      <para context="cli">
	If the <opt>--lagselect</opt> option is given, the first parameter to
	the <lit>var</lit> command is taken as the maximum lag order.  Output
	consists of a table showing the values of the Akaike (AIC), Schwartz
	(BIC) and Hannan&ndash;Quinn (HQC) information criteria computed from
	VARs of order 1 to the given maximum.  This is intended to help
	with the selection of the optimal lag order.  The usual VAR output is
	not presented. The table of information criteria may be retrieved
	as a matrix via the <lit>$test</lit> accessor.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Time series/Vector autoregression</menu-path>
    </gui-access>

  </command>

  <command name="VAR-lagselect" section="Tests" context="gui"
    label="VAR lag-length selection">

    <description>
      <para>
	In this dialog box you specify a VAR as usual, but use the lag order
	spin button to set the maximum number of lags to test.
      </para>
      <para>
	Output will consist of a table showing the values of the Akaike (AIC),
	Schwartz (BIC) and Hannan&ndash;Quinn (HQC) information criteria computed
	from VARs of order 1 to the chosen maximum.  This is intended to help with
	the selection of the optimal lag order.  
      </para>
    </description>

  </command>

  <command name="VAR-omit" section="Tests" context="gui"
    label="Test exogenous variables in VAR">

    <description>
      <para>
	Use this dialog box to specify a subset of exogenous variables in a VAR.
	These variables will be omitted from the original VAR, and the system
	re-estimated.
      </para>
      <para>
	A Likelihood Ratio test is reported, where the null hypothesis is that
	the true parameter values are zero, in all equations of the VAR, for the
	omitted variables.  The test is based on the difference between the
	log-determinant of the variance matrix for the unrestricted system, and
	that for the restricted system with the selected variables omitted.
      </para>
    </description>

  </command>

  <command name="varlist" section="Dataset" 
    label="Listing of variables" context="cli">

    <usage>
      <options>
	<option>
	  <flag>--scalars</flag>
	  <effect>list scalars</effect>
	</option>
	<option>
	  <flag>--accessors</flag>
	  <effect>list accessor variables</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	By default, prints a listing of the (series) variables currently
	available.  <cmd>list</cmd> and <cmd>ls</cmd> are synonyms.
      </para>
      <para>
	If the <opt>--scalars</opt> option is given, prints a listing
	of any currently defined scalar variables and their
	values. Otherwise, if the <opt>--accessors</opt> option is
	given, prints a list of the internal variables currently
	available via accessors such as <fncref targ="$nobs"/> and
	<fncref targ="$uhat"/>.
      </para>
    </description>

  </command>

  <command name="vartest" section="Tests"
    label="Difference of variances">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
      </arguments>
    </usage>

    <description>
      <para context="cli">
	Calculates the <math>F</math> statistic for the null
	hypothesis that the population variances for the variables
	<repl>var1</repl> and <repl>var2</repl> are equal, and shows
	its p-value.
      </para>
      <para context="gui">
	Calculates the <math>F</math> statistic for the null
	hypothesis that the population variances are equal for the
	two selected variables, and shows its p-value.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Bivariate tests/Difference of variances</menu-path>
    </gui-access>

  </command>

  <command name="vecm" section="Estimation"
    label="Vector Error Correction Model">

    <usage>
      <arguments>
        <argument>order</argument>
	<argument>rank</argument>
        <argument>ylist</argument>
	<argblock optional="true" separated="true">
	  <argument>xlist</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>rxlist</argument>
	</argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>no constant</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>restricted constant</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>constant and restricted trend</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>constant and unrestricted trend</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include centered seasonal dummies</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>print impulse responses</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>print variance decompositions</effect>
        </option>
      </options>
      <examples>
        <example>vecm 4 1 Y1 Y2 Y3</example>
        <example>vecm 3 2 Y1 Y2 Y3 --rc</example>
	<example>vecm 3 2 Y1 Y2 Y3 ; X1 --rc</example>
	<demos>
	  <demo>denmark.inp</demo>
	  <demo>hamilton.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	A VECM is a form of vector autoregression or VAR (see <cmdref
	  targ="var"/>), applicable where the variables in the model are
	individually integrated of order 1 (that is, are random walks, with or
	without drift), but exhibit cointegration.  This command is closely
	related to the Johansen test for cointegration (see <cmdref
	  targ="coint2"/>).
      </para>

      <para context="cli">
	The <repl>order</repl> parameter to this command represents the lag
	order of the VAR system.  The number of lags in the VECM itself (where
	the dependent variable is given as a first difference) is one less than
	<repl>order</repl>.
      </para>

      <para context="gui">
	The lag order selected in the VECM dialog box is that of the VAR system.
	The number of lags in the VECM itself (where the dependent variable is
	given as a first difference) is one less than this number.
      </para>

      <para context="cli">
	The <repl>rank</repl> parameter represents the cointegration rank, or in
	other words the number of cointegrating vectors.  This must be greater
	than zero and less than or equal to (generally, less than) the number of
	endogenous variables given in <repl>ylist</repl>.
      </para>

      <para context="gui">
	The <quote>cointegration rank</quote> represents the number of
	cointegrating vectors.  This must be greater than zero and less than or
	equal to (generally, less than) the number of endogenous variables 
	selected.
      </para>

      <para context="cli">
	<repl>ylist</repl> supplies the list of endogenous variables, in
	levels. The inclusion of deterministic terms in the model is controlled
	by the option flags.  The default if no option is specified is to
	include an <quote>unrestricted constant</quote>, which allows for the
	presence of a non-zero intercept in the cointegrating relations as well
	as a trend in the levels of the endogenous variables.  In the literature
	stemming from the work of Johansen (see for example his 1995 book) this
	is often referred to as <quote>case 3</quote>.  The first four options
	given above, which are mutually exclusive, produce cases 1, 2, 4 and 5
	respectively.  The meaning of these cases and the criteria for selecting
	a case are explained in <guideref targ="chap:vecm"/>.
      </para>

      <para context="cli">
	The optional lists <repl>xlist</repl> and <repl>rxlist</repl>
	allow you to specify sets of exogenous variables which enter the
	model either unrestrictedly (<repl>xlist</repl>) or restricted to
	the cointegration space (<repl>rxlist</repl>). These lists are
	separated from <repl>ylist</repl> and from each other by
	semicolons.
      </para>

      <para context="gui">
	In the <quote>Endogenous variables</quote> box you select the
	vector of endogenous variables, in levels. The inclusion of
	deterministic terms in the model is controlled by the option
	buttons.  The default is to include an <quote>unrestricted
	constant</quote>, which allows for the presence of a non-zero
	intercept in the cointegrating relations as well as a trend in the
	levels of the endogenous variables.  In the literature stemming
	from the work of Johansen (see for example his 1995 book) this is
	often referred to as <quote>case 3</quote>.  The other four
	options produce cases 1, 2, 4 and 5 respectively.  The meaning of
	these cases and the criteria for selecting a case are explained in
	<guideref targ="chap:vecm"/>.
      </para>

      <para context="gui">
	In the <quote>Exogenous variables</quote> box you may add specific
	exogenous variables.  By default these enter the model in
	unrestricted form (indicated by a <lit>U</lit> next to the name of
	the variable).  If you want a certain exogenous variable to be
	restricted to the cointegrating space, right-click on it and
	select <quote>Restricted</quote> from the pop-up menu.  The symbol
	next to the variable will change to R.
      </para>

      <para context="cli">
	The <opt>--seasonals</opt> option, which may be combined with any of the
	other options, specifies the inclusion of a set of centered seasonal
	dummy variables.  This option is available only for quarterly or monthly
	data.
      </para>

      <para context="gui">
	If the data are quarterly or monthly, a check box is shown that allows
	you to include a set of centered seasonal dummy variables.  In all
	cases, an additional check box (<quote>Show details</quote>) allows
	for the printing of the auxiliary regressions that form the starting
	point of the Johansen maximum likelihood estimation procedure.
      </para>

      <para context="cli">
	The first example above specifies a VECM with lag order 4 and a single
	cointegrating vector.  The endogenous variables are <lit>Y1</lit>,
	<lit>Y2</lit> and <lit>Y3</lit>.  The second example uses the same
	variables but specifies a lag order of 3 and two cointegrating vectors;
	it also specifies a <quote>restricted constant</quote>, which is
	appropriate if the cointegrating vectors may have a non-zero intercept
	but the <lit>Y</lit> variables have no trend.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/VECM</menu-path>
    </gui-access>

  </command>

  <command name="vif" section="Tests" context="cli"
    label="Variance Inflation Factors">

    <description>
      <para>
	Must follow the estimation of a model which includes at least
	two independent variables. Calculates and displays the
	Variance Inflation Factors (VIFs) for the regressors.  The VIF
	for regressor <math>j</math> is defined as
	<equation status="display" 
	  tex="\[\frac{1}{1-R_j^2}\]"
	  ascii="1/(1 - Rj^2)"
	  graphic="vif"/> where <math>R</math><sub>j</sub> is
	the coefficient of multiple correlation between regressor
	<math>j</math> and the other regressors. The factor has
	a minimum value of 1.0 when the variable in question is
	orthogonal to the other independent variables.  
	<cite key="neter-etal90">Neter,	Wasserman, and Kutner (1990)</cite> 
	suggest inspecting the largest VIF as a diagnostic for collinearity; 
	a value greater than 10 is sometimes taken as indicating a 
	problematic degree of collinearity.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Collinearity</menu-path>
    </gui-access>

  </command>

  <command name="wls" section="Estimation"
    label="Weighted Least Squares">

    <usage>
      <arguments>
        <argument>wtvar</argument>
        <argument>depvar</argument>
	<argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
        </option>
      </options> 
    </usage>

    <description>
      <para context="cli">
	Computes weighted least squares (WLS) estimates using
	<repl>wtvar</repl> as the weight, <repl>depvar</repl> as the
	dependent variable, and <repl>indepvars</repl> as the list of
	independent variables.  Let <repl>w</repl> denote the positive
	square root of <lit>wtvar</lit>; then WLS is basically equivalent
	to an OLS regression of <repl>w</repl> <lit>*</lit>
	<repl>depvar</repl> on <repl>w</repl> <lit>*</lit>
	<repl>indepvars</repl>.  The <emphasis>R</emphasis>-squared,
	however, is calculated in a special manner, namely as
	<equation status="display"
	  tex="\[R^2 = 1 - \frac{\rm ESS}{\rm WTSS}\]"
	  ascii="R^2 = 1 - ESS / WTSS"
	  graphic="wlsr2"/> where ESS is the error sum of squares (sum of
	squared residuals) from the weighted regression and WTSS denotes
	the <quote>weighted total sum of squares</quote>, which equals the
	sum of squared residuals from a regression of the weighted
	dependent variable on the weighted constant alone.
      </para>

      <para context="cli">
	If <repl>wtvar</repl> is a dummy variable, WLS estimation is
	equivalent to eliminating all observations with value zero for
	<repl>wtvar</repl>.
      </para>

      <para context="gui">
	Let "wtvar" denote the variable selected in the "Weight variable"
	box.  An OLS regression is run, where the dependent variable is
	the product of the positive square root of wtvar and the selected
	dependent variable, and the independent variables are also
	multiplied by the square root of wtvar. Statistics such as
	<emphasis>R</emphasis>-squared are based on the weighted
	data.  If wtvar is a dummy variable, weighted least squares
	estimation is equivalent to eliminating all observations with
	value zero for wtvar.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Other linear models/Weighted Least Squares</menu-path>
    </gui-access>

  </command>

  <command name="working-dir" section="Utilities" label="Working directory"
    context="gui">

    <description>
      <para>
	The <quote>working directory</quote> is where gretl looks
	by default when reading or writing data files or scripts
	via the file Open and Save dialogs.
      </para>
      <para>
	In addition the working directory is the default location for
      </para>
      <ilist>
	<li>
	  <para>
	    reading files via the script commands <lit>append</lit>,
	    <lit>open</lit>, <lit>run</lit> and <lit>include</lit>; and
	  </para>
	</li>
	<li>
	  <para>
	    writing files via the commands <lit>eqnprint</lit>,
	    <lit>tabprint</lit>, <lit>gnuplot</lit>, <lit>outfile</lit>
	    and <lit>store</lit>.
	  </para>
	</li>
      </ilist>
      <para>
	The option of having gretl use the current directory (as
	determined via the shell) at start-up may be useful to people who
	are in the habit of launching gretl from a command prompt rather
	than a menu or icon.
      </para>
      <para>
	This dialog also allows you to set the behavior of the GUI file
	selector: when you open or save a file in a given folder, should the
	selector remember and return to the same folder on the next
	invocation?  Or should the selector always visit the chosen working
	directory?
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Working directory</menu-path>
    </gui-access>

  </command>

  <command name="x12a" section="Utilities" context="gui"
    label="X-12-ARIMA">

    <description>
      <para>
	There are two procedural options here, controlled by the 
	lower set of radio-buttons.
      </para>
      <para>
	If you select <quote>Execute X-12-ARIMA directly</quote> then
	gretl writes a command file for X-12-ARIMA and calls the
	x12a program to execute the commands. In this case you have the
	option of producing a graph and/or saving selected output series
	to the gretl dataset.
      </para>
      <para>
	If you select <quote>Make X-12-ARIMA command file</quote>
	gretl writes a command file for X-12-ARIMA, as above, but then
	opens this file in an editor window. In that window you are
	able to make changes and to save the file under a chosen
	name. You are also able to send the file for execution by x12a
	(by clicking the <quote>Run</quote> button on the editor
	window toolbar) and view the output. But in this case you do
	not have the option of saving data as gretl series or
	producing a gretl graph.
      </para>
    </description>

  </command>

  <command name="xcorrgm" section="Statistics" label="Cross-correlogram">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
        <argument optional="true">order</argument>
      </arguments>
      <examples>
        <example>xcorrgm x y 12</example>
      </examples>
    </usage>

    <description>
      <para>
	Prints and graphs the cross-correlogram for variables
	<repl>var1</repl> and <repl>var2</repl>, which may be specified by
	name or number.  The values are the sample correlation coefficients
	between the current value of <repl>var1</repl> and successive leads
	and lags of <repl>var2</repl>.
      </para>
      <para>
	If an <repl>order</repl> value is specified the length of the
	cross-correlogram is limited to at most that number of leads and
	lags, otherwise the length is determined automatically, as a
	function of the frequency of the data and the number of
	observations.
      </para>
    </description>

    <gui-access>
      <menu-path>/View/Cross-correlogram</menu-path>
      <other-access>Main window pop-up menu (multiple selection)</other-access>
    </gui-access>

  </command>

  <command name="xtab" section="Statistics" 
    label="Cross-tabulate variables">

    <usage>
      <arguments>
        <argument>ylist</argument>
	<argument optional="true" separated="true">xlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--row</flag>
	  <effect>display row percentages</effect>
        </option>
        <option>
	  <flag>--column</flag>
	  <effect>display column percentages</effect>
        </option>
        <option>
	  <flag>--zeros</flag>
	  <effect>display zero entries</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>matname</optparm>
	  <effect>use frequencies from named matrix</effect>
        </option>
      </options>
    </usage>

    <description context="cli">
      <para>
        Displays a contingency table or cross-tabulation for each
	combination of the variables included in <repl>ylist</repl>; if a
	second list <repl>xlist</repl> is given, each variable in
	<repl>ylist</repl> is cross-tabulated by row against each variable
	in <repl>xlist</repl> (by column).  Variables in these lists can
	be referenced by name or by number.  Note that all the variables
	must have been marked as discrete.  Alternatively, if the 
	<opt>--matrix</opt> option is given, treat the named matrix as
	a precomputed set of frequencies and display this as a 
	cross-tabulation.
      </para>
      <para>
	By default the cell entries are given as frequency counts. The
	<opt>--row</opt> and <opt>--column</opt> options (which are
	mutually exclusive), replace the counts with the percentages for
	each row or column, respectively.  By default, cells with a zero
	count are left blank; the <opt>--zeros</opt> option, which has the
	effect of showing zero counts explicitly, may be useful for
	importing the table into another program, such as a spreadsheet.
      </para>
      <para>
        Pearson's chi-square test for independence is displayed if the
        expected frequency under independence is at least 1.0e-7 for all
        cells.  A common rule of thumb for the validity of this statistic is
        that at least 80 percent of cells should have expected frequencies
        of 5 or greater; if this criterion is not met a warning is printed.
      </para>
      <para>
	If the contingency table is 2 by 2, Fisher's Exact Test for
	independence is computed.  Note that this test is based on the
	assumption that the row and column totals are fixed, which may or
	may not be appropriate depending on how the data were generated.
	The left p-value should be used when the alternative to
	independence is negative association (values tend to cluster in
	the lower left and upper right cells); the right p-value should be
	used if the alternative is positive association.  The two-tailed
	p-value for this test is calculated by method (b) in section 2.1
	of <cite key="agresti92">Agresti (1992)</cite>: it is the sum of
	the probabilities of all possible tables having the given row and
	column totals and having a probability less than or equal to that
	of the observed table.
      </para>
    </description>

    <description context="gui">
      <para>
        Displays a contingency table or cross-tabulation for each
	combination of the selected variables.  Note that all the
	variables must be discrete.
      </para>
      <para>
	By default, frequency count values are shown in the cells and on
	the margins of the table.  However, you can choose to display
	either row or column percentages instead.
      </para>
      <para>
	By default, cells with a zero count are shown as empty, but you
	can choose to show zero values explicitly.
      </para>
      <para>
        Pearson's chi-square test for independence is displayed if the
        expected frequency under independence is at least 1.0e-7 for all
        cells.  A common rule of thumb for the validity of this statistic is
        that at least 80 percent of cells should have expected frequencies
        of 5 or greater; if this criterion is not met a warning is printed.
      </para>
      <para>
	If the contingency table is 2 by 2, Fisher's Exact Test for
	independence is computed.  Note that this test is based on the
	assumption that the row and column totals are fixed, which may or
	may not be approriate depending on how the data were generated.
	The left p-value should be used when the alternative to
	independence is negative association (values tend to cluster in
	the lower left and upper right cells); the right p-value should be
	used if the alternative is positive association.  The two-tailed
	p-value for this test is calculated by method (b) in section 2.1
	of <cite key="agresti92">Agresti (1992)</cite>: it is the sum of
	the probabilities of all possible tables having the given row and
	column totals and having a probability less than or equal to that
	of the observed table.
      </para>
    </description>

  </command>

</commandlist>

