<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE funcref SYSTEM "gretl_functions.dtd">

<funcref language="galego">

  <funclist name="Accessors" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
	  Debe de executarse logo de que o último modelo se estimase con datos de
	  panel de efectos fixos ou de efectos aleatorios. Devolve unha serie que
	  contén as estimacións dos efectos individuais.
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do Criterio de
	  Información de Akaike (AIC) do último modelo estimado. Máis detalles
	  sobre o cálculo no <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$allprobs" section="access" output="matrix">
      <description>
	<para>
	  Debe ir despois dunha estimación con probit ou logit ordenados,
	  ou con logit multinomial; e devolverá unha matriz de orde
	  <by r="n" c="j"/>, onde <math>n</math> é o número de observacións
	  utilizadas e <math>j</math> indica o número de resultados posibles,
	  que contén a probabilidade estimada de cada resultado para cada
	  observación.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do Criterio de
	  Información Baiesiano (BIC) de Schwarz do último modelo estimado.
	  Máis detalles sobre o cálculo no <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do estatístico khi-cadrado
	  global da proba de Razón de Verosimilitudes do último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen argumentos <lit>$coeff</lit> devolve un vector columna que contén
	  os coeficientes do último modelo estimado. Co argumento opcional de
	  texto <lit>(nome dun regresor)</lit> a función devolve un escalar co
	  valor do parámetro estimado dese regresor.
	  <seelist>
            <fncref targ="$stderr"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg
	  b = $coeff               # Devolve un vector
	  macoef = $coeff(theta_1) # Devolve un escalar
	</code>
	<para>
	  Se o <quote>modelo</quote> en cuestión é un sistema de ecuacións,
	  o resultado depende das características deste; para VARs e VECMs
	  o resultado devolto é una matriz con unha columna por cada ecuación;
	  noutro caso, é un vector columna que contén os coeficientes da primeira
	  ecuación seguidos polos coeficientes da segunda ecuación e así de
	  maneira sucesiva.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Debe de executarse tras estimar un modelo, e devolve a cadea cos caracteres
	  da instrución utilizada (exemplo: <lit>ols</lit> ou <lit>probit</lit>).
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da estimación dun VAR ou dun VECM, e devolve a
	  matriz compañeira.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar enteiro que representa o tipo de datos que se están
	  utilizando nese momento: 0 = sen datos; 1 = datos de corte transversal;
	  2 = datos de series temporais; 3 = datos de panel.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Debe de executarse logo da estimación dun modelo con unha única ecuación,
	  e devolve unha cadea de texto co nome da variable dependente.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cos graos de liberdade do último modelo estimado.
	  Se este consiste nun sistema de ecuacións, o valor devolto é o número de graos
	  de liberdade por cada ecuación. Se os graos de liberdade das diferentes
	  ecuacións non son os mesmos en todas elas, entón o valor devolto se
	  calcula restando o número de observacións menos a media do número de
	  coeficientes das ecuacións (esta media arredóndase ao valor enteiro
	  inmediatamente superior).
	</para>
      </description>
    </function>

    <function name="$diagpval" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo da estimación dun sistema de ecuacións, e devolve
	  un escalar coa probabilidade asociada ao valor do estatístico
	  <fncref targ="$diagtest"/>.
	</para>
      </description>
    </function>

    <function name="$diagtest" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo da estimación dun sistema de ecuacións. Devolve
	  un escalar co valor do estatístico utilizado para probar a hipótese nula
	  de que a matriz de varianzas-covarianzas das perturbacións das ecuacións
	  do sistema, é diagonal. Esta é a proba de Breusch-Pagan, agás cando
	  o estimador é o dun SUR reiterado (sen restricións), pois nese caso é
	  unha proba de Razón de Verosimilitudes. Para obter máis detalles, véxase
	  o <guideref targ="chap:system"/> (tamén <fncref targ="$diagpval"/>).
	</para>
      </description>
    </function>

    <function name="$dotdir" section="access" output="string">
      <description>
	<para>
	  Este accesorio devolve unha cadea de texto coa ruta onde GRETL
	  garda ficheiros temporalmente, por exemplo cando usa a función
	  <fncref targ="mwrite"/> cun terceiro argumento distinto de cero.
	</para>
      </description>
    </function>

    <function name="$dw" section="access" output="scalar">
      <description>
	<para>
	  Devolve (se é posible) un escalar co valor do estatístico de Durbin&ndash;Watson
	  para probar autocorrelación de primeiro nivel no derradeiro modelo estimado.
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor da función de distribución
	  acumulada (CDF) de Durbin&ndash;Watson, avaliada no valor do estatístico
	  de DW para o derradeiro modelo estimado; para isto úsase o procedemento
	  de cálculo <cite key="imhof61">Imhof</cite>. Este é o valor p (probabilidade
	  asociada) para unha proba dunha cola na que a hipótese alternativa
	  é que existe autocorrelación positiva de primeiro nivel. Se queres o
	  valor p para unha proba de dúas colas, colle 2<math>P</math> cando
	  DW &lt; 2, ou 2(1 &minus; <math>P</math>) cando DW &gt; 2, onde
	  <math>P</math> é o valor que devolve este accesorio.
	</para>
	<para>
	  Debido á limitada precisión da aritmética dixital, o resultado do
	  cálculo da integral do método Imhof pode volverse negativo cando
	  o estatístico de Durbin-Watson está próximo ao seu límite inferior;
	  por iso este accesorio devolve <lit>NA</lit> nesa situación. Dado que
	  calquera outra modalidade de fallo ten como resultado un erro que se
	  sinaliza, posiblemente sexa seguro asumir que un resultado NA indica que
	  a verdadeira probabilidade asociada é <quote>moi pequena</quote>,
	  aínda que non sexa posible cuantificala.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da estimación dun VECM, e devolve unha matriz que
	  contén os termos de Corrección de Erros. O número de filas é igual ao
	  número de observacións utilizadas, e o número de columnas é igual á orde
	  de cointegración do sistema.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cun dos códigos internos de fallo do programa. Ese
	  código é un valor non nulo cando ocorre un fallo pero é capturado usando
	  a función <cmdref targ="catch"/>. Cae na conta de que, ao utilizar este
	  accesorio, o código interno de fallo vólvese novamente cero. Se desexas
	  obter a mensaxe de fallo asociada a un <lit>$error</lit> en concreto,
	  é preciso gardar o seu valor nunha variable provisional, por exemplo
	  utilizando o código:
	</para>
	<code>
	  err = $error
	  if (err)
	      printf "Obtívose o fallo %d (%s)\n", err, errmsg(err)
	  endif
	</code>
	<para>
	  <seelist>
            <cmdref targ="catch"/>
            <fncref targ="errmsg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar coa suma dos erros cadrados do
	  último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da estimación dun VECM, e devolve un vector que
	  contén os autovalores que se utilizan no cálculo da proba da traza para
	  verificar se existe cointegración.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da instrución de predición <cmdref targ="fcast"/>,
	  e devolve unha matriz cos valores previstos. Se o modelo que se utiliza
	  para facer as predicións é un sistema de ecuacións, a matriz está
	  formada por unha columna para cada ecuación; noutro caso, é un vector
	  columna.
	</para>
      </description>
    </function>

    <function name="$fcse" section="access" output="matrix">
      <description>
	<para>
	  Se pode calcularse, debe de executarse logo de procesar a instrución
	  <cmdref targ="fcast"/> e devolve unha matriz cos desvíos padrón
	  das predicións. Se o modelo que se utiliza para facer as predicións é
	  un sistema de ecuacións, a matriz está formada por unha columna para
	  cada ecuación; noutro caso, é un vector columna.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da estimación dun VAR, e devolve unha matriz que
	  contén a descomposición da varianza dos erros de predición (FEVD, na
	  sigla en inglés). Esa matriz ten <math>h</math> filas que indican o
	  número de períodos do horizonte de predición, o cal pode escollerse
	  de forma manual por medio de <lit>set horizon</lit> ou de forma
	  automática en base á frecuencia dos datos.
	</para>
	<para>
	  Para un VAR con <math>p</math> variables, a matriz ten <math>p</math>
	  <sup>2</sup> columnas: as primeiras <math>p</math> columnas conteñen
	  a FEVD para a primeira variable do VAR; as <math>p</math> columnas
	  seguintes conteñen a FEVD para a segunda variable do VAR e así de
	  maneira sucesiva. A fracción (decimal) do erro de predición da variable
	  <math>i</math> causada por unha innovación na variable <math>j</math>
	  vai atoparse entón inspeccionando a columna (<math>i</math> &minus; 1)
	  <math>p</math> + <math>j</math>.
	</para>
	<para>
	  Para unha variante máis flexible desta funcionalidade, consulta a
	  función <fncref targ="fevd"/>.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co estatístico F da proba de
	  validez global do último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo dun bloque <lit>gmm</lit> (do Método Xeneralizado
	  dos Momentos), e devolve un escalar co mínimo da función obxectivo.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Debe de executarse logo da instrución <lit>garch</lit>, e devolve unha
	  serie coas varianzas condicionais estimadas.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Debe de executarse logo de estimar un modelo por medio de <lit>tsls</lit>
	  ou <lit>panel</lit> coa opción de efectos aleatorios, e devolve un
	  vector fila <by r="1" c="3"/> que contén nesta orde: o valor do
	  estatístico da proba de Hausman, os graos de liberdade que
	  corresponden e a probabilidade asociada ao valor do estatístico.
	</para>
     </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do Criterio de
	  Información de Hannan-Quinn para o último modelo estimado. Para
	  detalles sobre o cálculo, consulta o <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cun número positivo moi grande. Por defecto é igual
	  a 1.0E100, pero pode cambiarse coa instrución <cmdref targ="set"/>.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VECM, e devolve a matriz de carga.
	  O número de filas desa matriz é igual ao número de variables do VECM,
	  e o número de columnas é igual ao rango de cointegración.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VECM, e devolve a matriz de
	  cointegración. O seu número de filas é igual ao número de variables do
	  VECM (máis o número de variables esóxenas que se restrinxen ao espazo
	  de cointegración, se hai algunha); e o seu número de columnas é igual
	  ao rango de cointegración.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VECM, e devolve a matriz estimada de
	  varianzas-covarianzas dos elementos dos vectores de cointegración.
	</para>
	<para>
	  No caso de tratarse dunha estimación sen restricións, o número de filas
	  desa matriz é igual ao número de elementos non restrinxidos do espazo
	  de cointegración, logo da normalización de Phillips. Polo contrario, de
	  tratarse da estimación dun sistema restrinxido por medio da instrución
	  <lit>restrict</lit> coa opción <lit>--full</lit>, obtense unha matriz
	  singular con <math>(n+m)r</math> filas (onde <math>n</math> é o número
	  de variables endóxenas, <math>m</math> o número de variables esóxenas
	  restrinxidas ao espazo de cointegración e <math>r</math> o rango de
	  cointegración).
	</para>
	<para>
	  Exemplo: o código...
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	    b[1,1] = 1
	    b[1,2] = -1
	    b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  ... orixina o seguinte resultado:
	</para>
	<code>
	  s0 (4 x 4)

          0,019751     0,029816  -0,00044837   -0,12227
          0,029816     0,31005   -0,45823      -0,18526
         -0,00044837  -0,45823    1,2169       -0,035437
         -0,12227     -0,18526   -0,035437      0,76062

	  s1 (5 x 5)

	  0,0000       0,0000       0,0000       0,0000       0,0000
	  0,0000       0,0000       0,0000       0,0000       0,0000
	  0,0000       0,0000      0,27398     -0,27398    -0,019059
	  0,0000       0,0000     -0,27398      0,27398     0,019059
	  0,0000       0,0000    -0,019059     0,019059    0,0014180
	</code>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  Para unha selección de modelos que se estiman polo método de Máxima
	  Verosimilitude, a función devolve unha serie cos valores do logaritmo
	  da verosimilitude para cada observación. Polo momento esa función só
	  está dispoñible para logit e probit binarios, tobit e heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co logaritmo da verosimilitude do último modelo
	  estimado (se fose aplicable).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co valor do <quote>épsilon da máquina</quote>,
	  o cal proporciona un límite superior para o erro relativo debido ao
	  arredondamento na aritmética de punto flotante con dobre precisión.
	</para>
      </description>
    </function>

    <function name="$mapfile" section="access" output="string">
      <description>
	<para>
	  Devolve unha cadea de texto co nome do ficheiro que se debe abrir
	  para obter os polígonos do mapa, cando antes se cargaron datos dun
	  ficheiro GeoJSON ou dun ficheiro ESRI de forma; noutro caso,
	  devolve unha cadea baleira. Isto está deseñado para utilizarse coa
	  función <fncref targ="geoplot"/>.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse tras estimar un modelo logit multinomial (unicamente),
	  e devolve unha matriz coas probabilidades estimadas de cada resultado
	  posible, en cada observación da mostra utilizada na estimación do
	  modelo. Cada liña representa unha observación e cada columna un
	  resultado. Dado que desde GRETL 2023a, este accesorio é obsoleto:
	  por favor, utiliza en troques <fncref targ="$allprobs"/>.
	</para>
      </description>
    </function>

    <function name="$model" section="access" output="bundle">
      <description>
	<para>
	  Debe de executarse logo de estimar modelos cunha única ecuación, e
	  devolve un feixe (<quote>bundle</quote>) que contén varias unidades de
	  datos pertencentes ao modelo. Inclúense todos os accesorios habituais
	  dos modelos, que son designados mediante claves iguais aos nomes
	  deses accesorios habituais, sen o signo dólar inicial. Por exemplo,
	  os erros aparecen baixo a clave <lit>uhat</lit> e a suma de erros
	  cadrados baixo <lit>ess</lit>.
	</para>
	<para>
	  Dependendo do estimador, podes dispoñer de información adicional. As
	  claves para tal información é de agardar que sexan explicativas por si
	  mesmas. Para ver o que está dispoñible, podes gardar unha copia do
	  feixe e mostrar o seu contido, como por exemplo co código:
	</para>
	<code>
	  ols y 0 x
	  bundle b = $model
	  print b
	</code>
      </description>
    </function>

    <function name="$mpirank" section="access" output="int">
      <description>
	<para>
	  Cando se prepara GRETL con soporte MPI, e o programa está
	  funcionando en modo MPI, devolve a <quote>xerarquía</quote>
	  en base 0 ou número ID do proceso vixente. Doutro xeito, devolve
	  &minus;1.
	</para>
      </description>
    </function>

    <function name="$mpisize" section="access" output="int">
      <description>
	<para>
	  Cando se prepara GRETL con soporte MPI, e o programa está
	  funcionando en modo MPI, devolve o número de procesos MPI
	  que están funcionando nese momento. Doutro xeito, devolve 0.
	</para>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa cantidade de coeficientes estimados
	  no último modelo.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa cantidade total de observacións que están
	  seleccionadas na mostra vixente. Relacionado: <fncref targ="$tmax"/>.
	</para>
	<para>
	  No caso de datos de panel, o valor que se devolve é o número de
	  observacións combinadas (o número de unidades de sección cruzada
	  multiplicado polo número de períodos de tempo). Se queres saber o
	  número de unidades tempo dun panel, utiliza <fncref targ="$pd"/>.
	  E o número de unidades de sección cruzada incluídas pode obterse
	  mediante <lit>$nobs</lit> dividido por <lit>$pd</lit>.
	</para>
      </description>
    </function>

    <function name="$now" section="access" output="vector">
      <description>
	<para>
	  Devolve un vector con 2 elementos: o primeiro indica o número
	  de segundos transcorridos dende o 01-01-1970 00:00:00 +0000
	  (UTC, ou Tempo Universal Coordinado), o que se utiliza amplamente
	  no mundo da informática para representar o tempo vixente;
	  e o segundo indica a data vixente en formato <quote>básico</quote>
	  ISO 8601, <lit>YYYYMMDD</lit>. Podes utilizar a función 
	  <fncref targ="strftime"/> para procesar o primeiro elemento, e a función
	  <fncref targ="epochday"/> para procesar o segundo elemento.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro co número de series incluídas no conxunto
	  vixente de datos (contando coa constante). Posto que <lit>const</lit>
	  está sempre presente en calquera conxunto de datos, a obtención do
	  valor 0 indica que non hai conxunto de datos. Cae na conta de que ao
	  usar este accesorio dentro dunha función, o número vixente de series
	  accesibles ben pode caer por debaixo do indicado por <lit>$nvars</lit>.
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando o conxunto vixente de datos está formado por
	  series temporais con frecuencia decenal, anual, trimestral, mensual,
	  datadas semanalmente ou datadas diariamente. Tamén pode utilizarse con
	  datos de panel se a información temporal está axustada correctamente
	  (consulta a instrución <cmdref targ="setobs"/>). Devolve unha serie
	  formada por números con 8 díxitos co padrón <lit>YYYYMMDD</lit> (o
	  formato de datos <quote>básico</quote> do ISO 8601), que corresponden
	  ao día da observación, ou ao primeiro día da observación no caso dunha
	  frecuencia temporal menor que a diaria.
	</para>
	<para>
	  Estas series poden resultar de utilidade cando se emprega a instrución
	  <cmdref targ="join"/>.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  Devolve unha serie que contén a compoñente maior (de menor
	  frecuencia) de cada observación. Isto quere dicir o ano para series
	  de tempo anuais, trimestrais, mensuais, semanais ou diarias; o día
	  para datos horarios; ou o individuo no caso dos datos de panel.
	  Se os datos son de sección cruzada, a serie que se devolve é
	  simplemente o índice enteiro das observacións.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsminor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando as observacións do conxunto de vixente datos
	  teñen unha estrutura maior:menor:micro, como nas series temporais
	  datadas diariamente (ano:mes:día). Devolve unha serie que contén a
	  compoñente micro (de maior frecuencia) de cada observación (por
	  exemplo, o día).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando as observacións do conxunto vixente de datos
	  teñen unha estrutura maior:menor, como en series temporais trimestrais
	  (ano:trimestre), series temporais mensuais (ano:mes), datos de horas
	  (día:hora) e datos de panel (individuo:período). Devolve unha serie
	  que contén a compoñente menor (de maior frecuencia) de cada
	  observación (por exemplo, o mes).
	</para>
	<para>
	  No caso de datos datados diariamente, <lit>$obsminor</lit> devolve
	  unha serie co mes de cada observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>
    
    <function name="$panelpd" section="access" output="int">
      <description>
	<para>
	  Específico para datos de panel, devolve un enteiro coa periodicidade
	  temporal (por exemplo: 4 para datos trimestrais). Cando non estableces
	  a periodicidade no conxunto de datos de panel activo, devolve 1 de
	  xeito similar a <fncref targ="$pd"/> para datos de tipo atemporal ou
	  sen data. Se o conxunto de datos non é de panel, devólvese NA.
	</para>
	<para>
	  <seelist>
            <fncref targ="$pd"/>
            <fncref targ="$datatype"/>
            <cmdref targ="setobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$parnames" section="access" output="strings">
      <description>
	<para>
	  Logo da estimación dun modelo uniecuacional, devolve un arranxo
	  de cadeas de texto que conteñen os nomes dos parámetros do modelo.
	  O número de nomes coincide co número de elementos que ten o vector
	  <fncref targ="$coeff"/>.
	</para>
	<para>
	  Para os modelos especificados mediante unha lista de regresores,
	  o resultado vai ser o mesmo que o de
	</para>
	<code>
	  varnames($xlist)
	</code>
	<para>
	  (consulta a función<fncref targ="varnames"/>) pero a función
	  <lit>$parnames</lit> é máis xeral; pois tamén funciona para os modelos que
	  non teñen unha lista de regresores
	  (<cmdref targ="nls"/>, <cmdref targ="mle"/>, <cmdref targ="gmm"/>).
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa frecuencia ou periodicidade dos datos
	  (por exemplo: 4 para datos trimestrais). No caso de datos de panel, o
	  valor devolto é a cantidade de períodos de tempo do conxunto de datos.
	</para>
	<para>
	  <seelist>
            <fncref targ="$panelpd"/>
	  </seelist>
	  </para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co valor de &pi; con dobre precisión.
	</para>
      </description>
    </function>

    <function name="$pkgdir" section="access" output="string">
      <description>
	<para>
	  Utilidade especial para que utilicen os autores de paquetes de función.
	  Devolve unha cadea de texto baleira agás que se estea executando
	  unha función empaquetada, en cuxo caso devolve a ruta completa
	  (dependendo da plataforma) a onde está instalado o paquete. Por
	  exemplo, o valor devolto podería ser...
	</para>
	<code>
	  /usr/share/gretl/functions/foo
	</code>
	<para>
	  no caso de que este sexa o cartafol no que estea localizado
	  <lit>foo.gfn</lit>. Isto permite que o autor dun paquete de función
	  poda acceder a recursos tales como ficheiros de matrices, que teña
	  incluídos no seu paquete.
	</para>
      </description>
    </function>

    <function name="$pmanteau" section="access" output="matrix">
      <description>
	<para>
	  Dispoñible despois da estimación dunha autorregresión de vectores.
	  Devolve un vector fila que contén os resultados da proba portmanteau
	  multivariante de autocorrelación dos erros, como se discute nas
	  páxinas 21&ndash;22 en <cite key="johansen95">Johansen (1995)</cite>.
	  Os elementos son, nesta orde, o estatístico de Ljung&ndash;Box,
	  o retardo máximo que se considera, os graos de liberdade para a
	  proba (khi-cadrado), e a probabilidade asociada (valor p) ao valor
	  que toma o estatístico de proba.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Devolve a probabilidade asociada ao valor do estatístico de proba que
	  foi xerado pola última instrución explícita de proba de hipóteses (por
	  exemplo: <lit>chow</lit>). Consulta o <guideref targ="chap:genr"/>
	  para obter máis detalles.
	</para>
	<para>
	  Xeralmente devolve un escalar, mais nalgúns casos devolve unha
	  matriz (por exemplo, isto ocorre coas probabilidades asociadas aos
	  valores dos estatísticos da traza e do máximo-lambda da proba de
	  cointegración de Johansen). Neste caso, os valores están dispostos na
	  matriz do mesmo xeito que nos resultados presentados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$qlrbreak" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo da instrución <cmdref targ="qlrtest"/> (que
	  permite facer a proba QLR para o cambio estrutural nun punto
	  descoñecido). Devolve un escalar co número enteiro positivo que indexa
	  a observación na que se maximiza o valor do estatístico de proba.
	</para>
      </description>
    </function>

    <function name="$result" section="access" output="matrix-or-bundle">
      <description>
	<para>
	  Proporciona información reservada, a continuación dalgunhas
	  instrucións que non teñen accesorios específicos. As instrucións
	  en cuestión inclúen <cmdref targ="bds"/>, <cmdref targ="bkw"/>
    <cmdref targ="corr"/>, <cmdref targ="fractint"/>,
	  <cmdref targ="freq"/>, <cmdref targ="hurst"/>, <cmdref targ="leverage"/>,
	  <cmdref targ="summary"/>, <cmdref targ="vif"/> e <cmdref targ="xtab"/>
	  (en cuxos casos, o resultado é unha matriz), ademais de
	  <cmdref targ="pkg"/> (en cuxo caso, gárdase opcionalmente un feixe).
	</para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen argumentos, este accesorio devolve o coeficiente de autocorrelación
	  de primeiro nivel para os erros do último modelo estimado. Agora ben,
	  coa sintaxe <lit>$rho(n)</lit> logo da estimación dun modelo por medio
	  da instrución <lit>ar</lit>, devolve o valor estimado correspondente
	  ao coeficiente &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rlnl" section="access" output="scalar">
      <description>
	<para>
	  Despois da estimación dun VECM restrinxido, devolve un escalar
	  co logaritmo da verosimilitude do modelo restrinxido. Consulta
	  tamén <fncref targ="$lnl"/>, e o <guideref targ="chap:vecm"/> para
	  ver exemplos do seu uso.
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do coeficiente
	  <math>R</math><sup>2</sup> non corrixido do último modelo estimado.
	  En xeral, este será o <math>R</math><sup>2</sup> habitual (centrado),
	  pero se a especificación do modelo non contén a constante (nin un
	  conxunto de regresores cuxa <quote>suma</quote> resulte ser constante),
	  entón será a versión non centrada. Nese caso, podes acadar a versión
	  centrada por medio de <lit>$model.centered_R2</lit>.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Debe de executarse logo de estimar un modelo dunha soa ecuación. Devolve
	  unha serie con unha variable ficticia que ten valores iguais a: 1 nas
	  observacións utilizadas na estimación, 0 nas observacións da mostra
	  vixente non utilizadas na estimación (posiblemente debido a valores
	  ausentes), e NA nas observacións fóra da mostra vixente seleccionada.
	</para>
	<para>
	  Se desexas calcular estatísticos baseados na mostra que se utiliza
	  para un modelo dado, pode facerse, por exemplo co código:
	</para>
	<code>
	  ols y 0 xlist
	  series sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Debe de executarse logo da instrución <lit>tsls</lit>. Devolve un vector
	  fila <by r="1" c="3"/> que contén, nesta orde: o valor do estatístico
	  da proba de Sobreidentificación de Sargan, os correspondentes graos
	  de liberdade e a probabilidade asociada ao valor do estatístico. Se o
	  modelo está exactamente identificado, o estatístico non se pode
	  calcular e tratar de facelo provoca un fallo.
	</para>
      </description>
    </function>

    <function name="$seed" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co valor da semente do xerador de números
	  aleatorios de GRETL. Se estableces a semente por ti mesmo, non
	  tes necesidade deste accesorio; pero pode resultar interesante
	  cando a semente se establece automaticamente (baseándose no
	  momento no que comezou a execución do programa).
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Se o último modelo estimado foi uniecuacional, devolve un escalar coa
	  Desviación Padrón da regresión (S, ou noutras palabras, o desvío
	  padrón dos erros do modelo coa oportuna corrección dos graos de
	  liberdade). Se o último modelo estimado foi un sistema de ecuacións,
	  devolve unha matriz coas varianzas-covarianzas dos erros das ecuacións
	  do sistema.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se utiliza sen argumentos, <lit>$stderr</lit> devolve un vector
	  columna que contén os desvíos padrón dos coeficientes do último
	  modelo estimado. Co argumento opcional <lit>(nome dun regresor)</lit>
	  devolve un escalar co valor do parámetro estimado dese regresor
	  <argname>s</argname>.
	</para>
	<para>
	  Se o <quote>modelo</quote> é un sistema de ecuacións, o resultado
	  depende das características deste: para VARs e VECMs, o valor devolto
	  é unha matriz que contén unha columna por cada ecuación; noutro caso,
	  é un vector columna que contén os coeficientes da primeira ecuación
	  seguidos polos coeficientes da segunda ecuación e así de maneira
	  sucesiva.
	</para>
	<para>
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo da instrución <lit>set stopwatch</lit> que activa
	  a medición de tempo da CPU. Ao usar este accesorio por primeira vez
	  obtense un escalar coa cantidade de segundos de CPU que pasaron dende
	  a instrución <lit>set stopwatch</lit>. Con cada acceso, reiníciase o
	  reloxo, polo que as sucesivas utilizacións de <lit>$stopwatch</lit>
	  xeran cada vez un escalar indicativo dos segundos de CPU dende o acceso previo.
	</para>
	<para>
	  Cando unha función definida polo usuario está en execución, ao usar a
	  instrución <lit>set stopwatch</lit> e o accesorio <lit>$stopwatch</lit>,
	  estes resultan específicos para esa función &mdash;é dicir, a medición
	  do tempo dentro dunha función non interrompe calquera medición
	  <quote>global</quote> que poda estarse facendo nun guión principal.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un sistema de ecuacións simultáneas.
	  Devolve a matriz cos coeficientes das variables endóxenas retardadas
	  (no caso de que existan), na forma estrutural do sistema. Consulta
	  tamén a instrución <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un sistema de ecuacións simultáneas.
	  Devolve unha matriz cos coeficientes das variables esóxenas, na forma
	  estrutural do sistema. Consulta a instrución
	  <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un sistema de ecuacións simultáneas.
	  Devolve unha matriz cos coeficientes das variables endóxenas
	  contemporáneas, na forma estrutural do sistema. Consulta a instrución
	  <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
	<para>
	  Devolve un feixe (<quote>bundle</quote>) que contén información das
	  capacidades do GRETL e do sistema operativo no que está executándose.
	  Os elementos do feixe indícanse deseguido:
	</para>
	<ilist>
	  <li>
	          <para>
	            <lit>gui_mode</lit>: número enteiro igual a 1 se libgretl
	            está sendo invocado polo programa GUI, e 0 noutro caso.
	          </para>
	  </li>
	  <li>
            <para>
              <lit>mpi</lit>: número enteiro igual a 1 se o sistema admite
              MPI (Interface de Paso de Mensaxes), e 0 noutro caso.
            </para>
	  </li>
	  <li>
            <para>
              <lit>omp</lit>: número enteiro igual a 1 se GRETL compilouse
              con soporte para Open MP, e 0 noutro caso.
            </para>
	  </li>
	  <li>
            <para>
              <lit>ncores</lit>: número enteiro que indica o número de
              núcleos físicos de procesador dispoñibles.
            </para>
	  </li>
	  <li>
            <para>
              <lit>nproc</lit>: número enteiro que indica o número
              de procesadores dispoñibles, e que será maior que
              <lit>ncores</lit> se está habilitado o Hyper-threading.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mpimax</lit>: número enteiro que indica o máximo número
              de procesos MPI que poden executarse en paralelo. É igual a
              cero se non se admite MPI; noutro caso, é igual ao valor de
              <lit>nproc</lit> local, agás que se especifique un ficheiro
              de hosts MPI, caso no que é igual á suma do número de
              procesadores ou <quote>slots</quote> ao longo de todas as
              máquinas ás que se fai referencia no ficheiro.
            </para>
	  </li>
	  <li>
            <para>
              <lit>wordlen</lit>: número enteiro igual a 32 ou a 64 en
              sistemas de 32 bit e 64 bit, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              <lit>os</lit>: cadea de texto que representa o sistema
              operativo, ben <lit>linux</lit>, <lit>macos</lit>,
              <lit>windows</lit> ou <lit>outro</lit>. Cae na conta de
              que as versións de GRETL previas á '2021e' proporcionan
              a cadea <lit>osx</lit> para o sistema operativo de Mac;
              polo tanto, unha expresión de comprobación para Mac
              independente da versión é <lit>instring($sysinfo.os, "os")</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>hostname</lit>: cadea de texto co nome da máquina (ou
              <quote>host</quote>) na que está executándose o proceso vixente
              de GRETL. Se non é posible determinar o nome, prodúcese
              unha volta atrás do <lit>localhost</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mem</lit>: un vector bidimensional que contén a memoria
              física total, e a memoria libre ou dispoñible, expresadas en
              MB. Esta información pode que non estea dispoñible en todos
              os sistemas, pero debera estalo en Windows, macOS e Linux.
            </para>
	  </li>
	  <li>
	          <para>
              <lit>blas</lit>: cadea de texto que identifica o provedor da
              biblioteca BLAS (Subprogramas Básicos de Álxebra Linear)
              que utiliza GRETL.
            </para>
	  </li>
	  <li>
	          <para>
              <lit>blas_version</lit>: cadea de texto que identifica o número
              da versión da biblioteca BLAS que se utiliza.
            </para>
	  </li>
	  <li>
	          <para>
              <lit>blascore</lit>: (se é aplicable) unha cadea de texto que
              identifica o tipo de CPU para o que está optimizada a
              biblioteca BLAS vixente.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>compiler</lit>: unha cadea de texto que identifica o
              compilador utilizado ao xerar libgretl.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>cpuid</lit>: unha cadea de texto que identifica o vendedor
              e o modelo da CPU na que está executándose libgretl.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>gnuplot</lit>: unha cadea de texto que identifica a
              versión dispoñible de Gnuplot para que GRETL faga gráficas,
              no formato de 3 números separados por puntos que indican
              a versión principal, a versión secundaria e o nivel de parche.
            </para>
	  </li>
	  <li>
            <para>
              <lit>foreign</lit>: un sub-feixe que contén indicadores 0/1
              para amosar a presencia no sistema, de cada un dos
              programas <quote>externos</quote> que admite GRETL
              baixo as claves <lit>julia</lit>, <lit>octave</lit>,
              <lit>ox</lit>, <lit>python</lit>, <lit>Rbin</lit>,
              <lit>Rlib</lit> e <lit>stata</lit>. As dúas claves que
              corresponden a R representan respectivamente, o
              executable de R e a biblioteca compartida.
            </para>
	  </li>
	</ilist>
	<para>
	  Fíxate en que podes acceder a elementos individuais do feixe
	  mediante a notación do <quote>punto</quote>, sen necesidade de copiar o
	  feixe enteiro cun nome de usuario específico. Por exemplo co código:
	</para>
	<code>
	  if $sysinfo.os == "linux"
	      # Faga algo que sexa propio do Linux
	  endif
	</code>
      </description>
    </function>

    <function name="$system" section="access" output="bundle">
      <description>
	<para>
	  Debe de seguir á estimación dun sistema de ecuacións, feita
	  coa instrución <cmdref targ="system"/>, con <cmdref targ="var"/> ou
	  con <cmdref targ="vecm"/>; e devolve un feixe que contén moitos
	  apartados de datos que se refiren ao sistema. Inclúense todos
	  os accesorios importantes e habituais do sistema, que se nomean
	  mediante símbolos chave que son idénticos aos nomes habituais
	  dos accesorios, menos o símbolo de dólar inicial. Así, por exemplo,
	  os erros aparecen baixo a chave <lit>uhat</lit> e os coeficientes
	  baixo <lit>coeff</lit>. (Como excepcións están as chaves <lit>A</lit>,
	  <lit>B</lit>, e <lit>Gamma</lit>, que se corresponden cos accesorios
	  habituales <fncref targ="sysA"/>, <fncref targ="sysB"/>, e
	  <fncref targ="sysGamma"/>.) As chaves para obter información
	  adicional agárdase que deberan explicarse suficientemente
	  por si mesmas. Para comprobar o que tes á túa disposición,
	  podes obter unha copia do feixe e representar o seu contido,
	  como en
	</para>
	<code>
	  var 4 y1 y2 y2
	  bundle b = $system
	  print b
	</code>
	<para>
	  Podes pasar un feixe obtido deste xeito como argumento
	  final (opcional) das funcións <fncref targ="fevd"/> e
	  <fncref targ="irf"/>.
	</para>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro co número de observacións utilizadas na
	  estimación do último modelo.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Devolve un enteiro positivo co número que indexa a primeira
	  observación da mostra vixente seleccionada.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Devolve un enteiro positivo co número que indexa a derradeira
	  observación da mostra vixente seleccionada.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Devolve o valor do estatístico de proba que foi xerado pola última
	  instrución explícita para unha proba de hipóteses (por exemplo:
	  <lit>chow</lit>). Consulta o <guideref targ="chap:genr"/> para
	  obter máis detalles.
	</para>
	<para>
	  Xeralmente devolve un escalar, mais nalgúns casos devolve unha
	  matriz (por exemplo, iso ocorre cos estatísticos da traza e do
	  máximo-lambda da proba de cointegración de Johansen). Neste caso,
	  os valores están dispostos na matriz do mesmo xeito que nos
	  resultados presentados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$time" section="access" output="series">
      <description>
	<para>
	  Para datos de series temporais ou de panel, xera un índice con
	  enteiros positivos do período temporal. No caso do panel, a secuencia
	  de valores repítese para cada unidade de sección cruzada.
	</para>
	<para>
	  A instrución <quote><lit>genr time</lit></quote> é unha alternativa,
	  coa diferenza de que a variante <lit>genr</lit> xera automaticamente
	  unha serie nomeada <lit>time</lit>, mentres que o nomeamento da
	  serie corresponde ao solicitante cando se utiliza <lit>$time</lit>,
	  como en
	</para>
	<code>
	  series trend = $time
	</code>
	<para>
	  Este accesorio non está dispoñible para datos de sección cruzada.
	</para>
      </description>
    </function>

    <function name="$tmax" section="access" output="int">
      <description>
	<para>
	  Devolve un enteiro co máximo valor válido establecido para indicar o
	  final do rango da mostra mediante a instrución <cmdref targ="smpl"/>.
	  Na maioría dos casos, isto vai ser igual ao número de observacións do
	  conxunto de datos; pero nunha función de HANSL, o valor <lit>$tmax</lit>
	  podería ser menor, posto que o acceso habitual aos datos dentro das
	  funcións, limítase ao rango mostral establecido polo solicitante.
	</para>
	<para>
	  Ten en conta que, en xeral, <lit>$tmax</lit> non é igual a
	  <fncref targ="$nobs"/>, que proporciona o número de
	  observacións do rango da mostra vixente.
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Devolve o escalar <math>TR</math><sup>2</sup> (o tamaño da mostra
	  multiplicado polo R-cadrado do último modelo), se está dispoñible.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Devolve unha serie cos erros do último modelo estimado. Isto pode ter
	  diferentes significados dependendo dos estimadores utilizados. Por
	  exemplo, logo da estimación dun modelo ARMA, <lit>$uhat</lit> contén
	  os erros da predición adiantados 1 paso; logo da estimación dun
	  probit, contén os erros xeneralizados.
	</para>
	<para>
	  Cando o <quote>modelo</quote> vixente en cuestión é un sistema de
	  ecuacións (un VAR, un VECM ou un sistema de ecuacións simultáneas),
	  o <lit>$uhat</lit> xera unha matriz cos erros de estimación de cada
	  ecuación, ordenados por columnas.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Só e válido para datos de panel. Devolve unha serie con valor igual a
	  1 en todas as observacións na primeira unidade ou grupo, 2 en todas as
	  observacións na segunda unidade ou grupo, e así de forma sucesiva.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">nome1</fnarg>
	<fnarg optional="true" type="coeffname">nome2</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se utiliza sen argumentos, <lit>$vcv</lit> devolve unha matriz
	  cadrada que contén as varianzas-covarianzas estimadas dos coeficientes
	  do último modelo estimado. Se este último era uniecuacional, pódense
	  indicar os nomes de dous regresores entre parénteses, para así obter
	  un escalar coa covarianza estimada entre <argname>nome1</argname> e
	  <argname>nome2</argname>.
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  Este accesorio non está dispoñible para VARs ou VECMs. Para modelos
	  dese tipo <fncref targ="$sigma"/> e <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VECM e devolve unha matriz na que
	  as matrices Gamma (cos coeficientes das diferenzas retardadas das
	  variables cointegradas) se agrupan unhas ao lado das outras. Cada fila
	  indica unha ecuación; para un VECM con nivel de retardo <math>p</math>
	  existen <math>p</math> &minus; 1 submatrices.
	</para>
      </description>
    </function>

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cun valor enteiro que designa a versión de GRETL.
	  A versión actual de GRETL está formada por unha cadea de texto que
	  indica o ano con formato de 4 díxitos seguido dunha letra desde a ata
	  j, que representa as sucesivas actualizacións dentro de cada ano (por
	  exemplo, 2015d). O valor devolto por este accesorio está calculado
	  multiplicando o ano por 10, e sumándolle un número que representa á
	  letra, na orde léxica en base cero. Así, 2015d represéntase mediante
	  20153.
	</para>
	<para>
	  En versións anteriores ao GRETL 2015d, o identificador tiña o seguinte
	  formato: x.y.z (tres números enteiros separados por puntos); nese caso,
	  o valor da función calculábase con <lit>10000*x + 100*y + z</lit>. Por
	  exemplo, a última versión co formato antigo (1.10.2) transcribíase
	  mediante 11002. Deste xeito a orde numérica de <lit>$version</lit> foi
	  preservada aínda despois de mudar o esquema das versións.
	</para>
      </description>
    </function>

    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VAR ou un VECM, e devolve unha
	  matriz que contén a representación VMA ata a orde especificada por
	  medio da instrución <lit>set horizon</lit>. Para ter máis detalles,
	  consulta o <guideref targ="chap:var"/>.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro co valor 1 se GRETL está executándose en Windows,
	  e 0 noutro caso. Poñendo como condición un destes valores, podes escribir instrucións
	  <quote>shell </quote> que podan executarse en diferentes sistemas operativos.
	</para>
	<para>
	  Consulta tamén a instrución <cmdref targ="shell"/>.
	</para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado era uniecuacional, este accesorio vai
	  devolver unha lista cos seus regresores. Se o último modelo era un
	  sistema de ecuacións, devolve unha lista <quote>global</quote> coas
	  variables esóxenas (na mesma orde na que aparecen co accesorio
	  <fncref targ="$sysB"/>). Se o último modelo era un VAR, devolve
	  unha lista cos regresores esóxenos (se hai algún), excepción feita
	  dos termos determinísticos habituais (a constante, a tendencia e
	  os elementos estacionais).
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse unicamente logo da estimación dun VAR ou VECM, e
	  devolve a matriz <math>X'X</math><sup>-1</sup>, onde <math>X</math>
	  é a matriz habitual cos regresores utilizados en cada ecuación. Pese
	  a que este accesorio está dispoñible para un VECM estimado con
	  unha restrición imposta en &agr; (a matriz de <quote>cargas</quote>),
	  debe de terse en conta que nese caso non todos os coeficientes dos
	  regresores varían libremente.
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Devolve unha serie cos valores estimados da variable explicada da última regresión.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado foi un VAR, un VECM ou un sistema
	  de ecuacións simultáneas, o accesorio devolve unha lista coas
	  variables endóxenas. Se o último modelo estimado foi uniecuacional,
	  o accesorio devolve unha lista cun único elemento, a variable dependente.
	  No caso especial do modelo biprobit, a lista contén dous
	  elementos.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Built-in strings" ref="string_constants">

    <function name="$dotdir" section="straccess" output="string">
      <description>
        <para>
          Proporciona unha cadea de texto coa ruta completa ao directorio que usa
          GRETL para os ficheiros temporais. Para usala en modo de substitución
          para cadeas de texto, antepón o símbolo arroba (<lit>@dotdir</lit>).
        </para>
        </description>
    </function>

    <function name="$gnuplot" section="straccess" output="string">
        <description>
        <para>
          Proporciona unha cadea de texto coa ruta ata o executable
          <lit>gnuplot</lit>. Para usala en modo de substitución para
          cadeas de texto, antepón o símbolo arroba (<lit>@gnuplot</lit>).
        </para>
        </description>
    </function>

    <function name="$gretldir" section="straccess" output="string">
        <description>
        <para>
          Proporciona unha cadea de texto coa ruta completa ao directorio
          de instalación de GRETL. Para usala en modo de substitución para
          cadeas de texto, antepón o símbolo arroba (<lit>@gretldir</lit>).
        </para>
        </description>
    </function>

    <function name="$lang" section="access" output="string">
      <description>
	<para>
	  Devolve unha cadea de texto que representa o idioma que se está usando
	  (se este pode determinarse). A cadea de texto está composta por dúas
	  letras do código de linguaxe ISO 639-1 (por exemplo, <lit>en</lit>
	  para o idioma inglés, <lit>jp</lit> para o xaponés, <lit>el</lit> para
	  o grego) seguidas dun guión baixo máis outras dúas letras do código de
	  país ISO 3166-1. Así, por exemplo, o idioma portugués de Portugal
	  represéntase por <lit>pt_PT</lit> ao tempo que o idioma portugués do
	  Brasil represéntase por <lit>pt_BR</lit>.
	</para>
	<para>
	  Se non é posible determinar o idioma vixente, se devolve o texto
	  <quote><lit>unknown</lit></quote>.
	</para>
      </description>
    </function>

    <function name="$seats" section="straccess" output="string">
        <description>
        <para>
          Proporciona unha cadea de texto coa ruta ata o executable
          <lit>seats</lit>, que acompaña a <lit>tramo</lit>. Para usala
          en modo de substitución para cadeas de texto, antepón o
          símbolo arroba (<lit>@seats</lit>).
        </para>
        </description>
    </function>

    <function name="$tramo" section="straccess" output="string">
        <description>
        <para>
          Proporciona unha cadea de texto coa ruta ata o executable
          <lit>tramo</lit>. Para usala en modo de substitución para cadeas
          de texto, antepón o símbolo arroba (<lit>@tramo</lit>).
        </para>
        </description>
    </function>

    <function name="$tramodir" section="straccess" output="string">
        <description>
        <para>
          Proporciona unha cadea de texto coa ruta ata o directorio de datos
          de <lit>tramo</lit>. Para usala en modo de substitución para
          cadeas de texto, antepón o símbolo arroba (<lit>@tramodir</lit>).
        </para>
        </description>
    </function>

    <function name="$workdir" section="straccess" output="string">
        <description>
        <para>
	  Este accesorio devolve unha cadea de texto coa ruta desde a que le e
	  na que escribe GRETL por defecto. Ofrécese unha discusión máis cumprida
	  no manual de Instrucións, na referencia <cmdref targ="workdir"/>. Cae
	  na conta de que o usuario pode determinar esta cadea por medio da
	  instrución <cmdref targ="set"/>. Para usala en modo de substitución
	  para cadeas de texto, antepón o símbolo arroba (<lit>@workdir</lit>).
        </para>
        </description>
    </function>

    <function name="$x12a" section="straccess" output="string">
        <description>
        <para>
          Proporciona unha cadea de texto coa ruta ata o executable
          <lit>x-12-arima</lit> (ou <lit>x-13arima</lit>). Para usala en
          modo de substitución para cadeas de texto, antepón o símbolo
          arroba (<lit>@x12a</lit>).
        </para>
        </description>
    </function>

    <function name="$x12adir" section="straccess" output="string">
        <description>
        <para>
          Proporciona unha cadea de texto coa ruta ata o directorio de
          datos de <lit>x-12-arima</lit> (ou <lit>x-13arima</lit>). Para
          usala en modo de substitución para cadeas de texto, antepón
          o símbolo arroba (<lit>@x12adir</lit>).
        </para>
        </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor absoluto de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos radiáns do arco
	  coseno de <argname>x</argname>; é dicir, proporciona o arco cuxo coseno é
	  <argname>x</argname> (o argumento debe de estar entre &minus;1 e 1).
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coseno hiperbólico
	  inverso de <argname>x</argname> (solución positiva). Este último
	  debe de ser maior ca 1, pois pola contra a función devolverá NA.
	  <seelist>
            <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-list-or-mat">x</fnarg>
	<fnarg type="series-list-or-mat">segunvar</fnarg>
	<fnarg type="string" optional="true">nomefunc</fnarg>
      </fnargs>
      <description>
	<para>
	  A maior parte do que segue asume que os dous primeiros argumentos desta
	  función toman a forma de series ou listas, pero consulta a sección
	  <quote>Entrada matricial</quote> de abaixo para un uso alternativo.
	</para>
	<para>
	  Na forma máis simple de uso desta función, <argname>x</argname>
	  establécese igual a <lit>null</lit>, <argname>segunvar</argname> é unha
	  serie individual e o terceiro argumento omítese (ou establécese igual
	  a cero). O valor que se devolve entón e unha matriz con dúas columnas
	  que contén: os distintos valores de <argname>segunvar</argname>
	  ordenados de forma crecente na primeira columna, e o número de
	  observacións nas que <argname>segunvar</argname> toma cada un
	  deses valores. Por exemplo...
	</para>
	<code>
	  open data4-1
	  eval aggregate(null, bedrms)
	</code>
	<para>
	  ... amosará que a serie <lit>bedrms</lit> ten os valores
	  3 (en total 5 veces) e 4 (en total 9 veces).
	</para>
	<para>
	  De xeito máis xeral, se <argname>segunvar</argname> é unha lista
	  con <math>n</math> elementos, entón as primeiras <math>n</math>
	  columnas da matriz que se devolve conteñen as combinacións dos
	  distintos valores de cada unha das <math>n</math> series, e a
	  columna de reconto contén o número de observacións nas que se
	  produce cada combinación. (A columna de reconto sempre se pode
	  atopar na posición <lit>nelem(segunvar)+1</lit>).
	</para>
	<subhead>Especificar unha función de agregación</subhead>
	<para>
	  Cando indicas o terceiro argumento, entón <argname>x</argname>
	  non debe ser <lit>null</lit>, e as <math>m</math> columnas máis
	  á dereita van conter os valores do estatístico especificado por
	  <argname>nomefunc</argname> para cada unha das variables en
	  <argname>x</argname>. (Deste xeito, <math>m</math> iguálase a 1
	  cando <argname>x</argname> é unha única serie, e iguálase a
	  <lit>nelem(x)</lit> cando <argname>x</argname> é unha lista.)
	  O estatístico indicado calcúlase nas submostras que estean definidas
	  mediante as combinacións indicadas en <argname>segunvar</argname>
	  (en orde ascendente); estas combinacións amósanse na(s) primeira(s)
	  <math>n</math> columna(s) da matriz que se
	  devolve.
	</para>
	<para>
	  Deste xeito, se tanto <argname>x</argname> como
	  <argname>segunvar</argname> son series individuais, o valor que se
	  devolve é unha matriz con tres columnas que vai conter: os distintos
	  valores de <argname>segunvar</argname> ordenados de forma crecente,
	  o número de observacións nas que <argname>segunvar</argname>
	  toma cada un deses valores, e os valores do estatístico que
	  especifica a función <argname>nomefunc</argname>, calculado
	  para a serie <argname>x</argname>, pero usando xusto aquelas
	  observacións nas que <argname>segunvar</argname> toma o mesmo
	  valor que se especifica na primeira columna da
	  matriz.
	</para>
	<para>
	  As seguintes opcións de <argname>nomefunc</argname> mantéñense
	  de forma <quote>orixinal</quote>: <fncref targ="sum"/>,
	  <fncref targ="sumall"/>, <fncref targ="mean"/>, <fncref targ="sd"/>,
	  <fncref targ="var"/>, <fncref targ="sst"/>, <fncref targ="skewness"/>,
	  <fncref targ="kurtosis"/>, <fncref targ="min"/>, <fncref targ="max"/>,
	  <fncref targ="median"/>, <fncref targ="nobs"/>, <fncref targ="gini"/>,
	  <fncref targ="isconst"/> e <fncref targ="isdummy"/>.
	  Cada unha destas funcións utiliza unha serie como argumento e
	  devolve un valor escalar; por iso, neste sentido, pode dicirse
	  que dalgún xeito <quote>agregan</quote> a serie. Se non hai ningunha
	  destas funcións orixinais que faga o que necesitas, podes utilizar
	  unha función definida polo usuario como <quote>agregador</quote>.
	  Nese caso, da mesma forma que as funcións orixinais, esa función
	  debe de ter como argumento unicamente unha serie, e devolver un
	  valor escalar.
	</para>
	<para>
	  Cae na conta de que, a pesar de que <lit>aggregate</lit> fai o
	  reconto de casos de forma automática, a opción <lit>nobs</lit>,
	  non é redundante como función <quote>agregadora</quote>, posto que
	  proporciona o número de observacións válidas (non ausentes) de
	  <argname>x</argname> en cada combinación de <argname>segunvar</argname>.
	</para>
        <subhead>Algúns exemplos</subhead>
	<para>
	  Primeiro, supón que con <lit>rexion</lit> se definen uns códigos para
	  representar unha distribución xeográfica por rexións, utilizándose
	  para iso enteiros desde 1 ata <math>n</math>, e que con <lit>renda</lit>
	  se representa a renda dos fogares. Entón o código indicado deseguido
	  debe producir unha matriz de orde <by r="n" c="3"/> que contén os
	  códigos das rexións, o reconto de observacións de cada unha, e a
	  renda media dos fogares en cada unha:
	</para>
	<code>
	  matrix m = aggregate(renda, rexion, mean)
	</code>
	<para>
	  Como exemplo de utilización con listas de variables, sexa
	  <lit>xenero</lit> unha variable binaria home/muller, sexa
	  <lit>raza</lit> unha variable categórica con tres valores, e
	  considera o seguinte código:
	</para>
	<code>
	  list BY = xenero raza
	  list X = renda idade
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  Invocar a función <lit>aggregate</lit> producirá unha matriz de
	  orde <by r="6" c="5"/>. Nas dúas primeiras columnas exprésanse as
	  6 distintas combinacións dos valores de 'xenero' e 'raza'; a columna
	  do medio contén o reconto do número de casos para cada unha desas
	  combinacións; e as dúas columnas máis á dereita conteñen os
	  desvíos padrón mostrais de <lit>renda</lit> e <lit>idade</lit>.
	</para>
	<para>
	  Se <argname>segunvar</argname> é unha lista de variables, algunhas
	  combinacións dos valores de <argname>segunvar</argname> poden non
	  estar presentes nos datos (producíndose un reconto igual a cero). Nese
	  caso, os valores dos estatísticos para <argname>x</argname> se rexistran
	  como <lit>NaN</lit> (é dicir, non son números). Para cortar eses casos,
	  podes usar a función <fncref targ="selifr"/> para escoller só aquelas
	  filas que non teñan reconto igual a cero. A columna a comprobar estará
	  unha posición á dereita da indicada polo número de variables de
	  <argname>segunvar</argname>, polo que pode usarse o código:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
	<subhead>Entrada matricial</subhead>
	<para>
	  En troques de indicar <argname>x</argname> e
	  <argname>segunvar</argname> como series ou listas, podes indicalas
	  en formato matricial. Porén, se indicas os dous argumentos, deben
	  coincidir no mesmo tipo (non podes indicar unha serie ou unha
	  lista para un dos argumentos, e unha matriz para o outro); ademais,
	  dous argumentos de tipo matricial deberán ter o mesmo número de
	  filas. Neste contexto, se trata ás columnas das matrices como se
	  fosen series, por iso a función de agregación debe seguir o mesmo
	  padrón descrito máis arriba, collendo un argumento de tipo serie
	  e devolvendo un escalar.
	</para>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string" optional="true">pordefecto</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é o nome dun parámetro cara a unha función
	  definida previamente polo usuario, devolve unha cadea de texto co nome
	  do argumento correspondente (se este ten un nome a nivel da chamada).
	  Cando o argumento é anónimo, devólvese unha cadea baleira agás que
	  indiques o argumento opcional <argname>pordefecto</argname>, en cuxo
	  caso utilízase o seu valor como alternativa.
	</para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é a función <quote>xeradora</quote> básica dunha nova variable
	  de tipo arranxo (<quote>array</quote>). Ao usar esta función é
	  necesario que especifiques un tipo (en forma plural) para o arranxo:
	  <lit>strings</lit>, <lit>matrices</lit>, <lit>bundles</lit>,
	  <lit>lists</lit> ou <lit>arrays</lit>. Devolve un arranxo do tipo
	  especificado con <argname>n</argname> elementos <quote>baleiros</quote>
	  (por exemplo, unha cadea de texto (<quote>string</quote>) baleira ou
	  unha matriz nula). Exemplos de utilización:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  Consulta tamén <fncref targ="defarray"/>.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos radiáns do arco
	  seno de <argname>x</argname>; é dicir, proporciona o arco cuxo seno é
	  <argname>x</argname> (o argumento debe de estar entre &minus;1 e 1).
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co seno hiperbólico inverso de <argname>x</argname>.
	  <seelist>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="asort" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="array">a</fnarg>
	<fnarg type="string">nomefun</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza unha reordenación inmediata dos elementos do argumento
	  <argname>a</argname>, usando unha función de comparación especificada
	  polo solicitante baixo o control da rutina de ordenación rápida.
	</para>
	<para>
	  O argumento <argname>a</argname> pode ser de calquera dos tipos que se
	  admiten para un arranxo de GRETL; en concreto <lit>strings</lit>
	  (cadeas), <lit>matrices</lit>, <lit>bundles</lit> (paquetes),
	  <lit>lists</lit> (listas) ou <lit>arrays</lit> (arranxos). O argumento
	  <argname>nomefun</argname> debe ser o nome dunha función que tome
	  dous argumentos <lit>const</lit>, cuxo tipo coincida co tipo dos
	  elementos de <argname>a</argname>. Esta función debe devolver un
	  valor enteiro co seguinte padrón de comportamento: 0 cando os dous
	  argumentos teñan a mesma orde de clasificación, negativo cando o primeiro
	  argumento clasifique antes que o segundo, ou positivo cando o segundo
	  clasifique antes que o primeiro. (Os valores exactos non importan.)
	</para>
	<para>
	  Por exemplo, supón que queres ordenar un arranxo de paquetes, nos que
	  cada un deles contén un escalar denominado <lit>crit</lit>, en función
	  do valor crecente de <lit>crit</lit>. Entón, a seguinte función sería
	  axeitada para usala con <lit>asort</lit>:
	</para>
	<code>
	  function scalar my_bsort (const bundle b1, const bundle b2)
	     return sgn(b1.crit - b2.crit)
	  end function
	</code>
	<para>
	  Se desexas preservar o arranxo sen ordenar, fai unha copia del antes
	  de usalo con <lit>asort</lit>. O valor que devolve esta función cando
	  ten éxito, é un 0.
	</para>
	<para>
	  Consulta tamén a función <fncref targ="sort"/> para unha ordenación
	  sinxela dun arranxo de cadeas de texto.
	</para>
      </description>
    </function>

    <function name="assert" section="programming" output="scalar">
      <fnargs>
	<fnarg type="scalar">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función está dirixida a comprobar e depurar código HANSL.
	  O seu argumento deberá ser unha expresión cuxo valor sexa un
	  escalar. O valor que devolve esta función é ou ben 1 cando o
	  valor do argumento <argname>expr</argname> non é cero
	  (<quote>verdadeiro</quote> booleano ou <quote>éxito</quote>),
	  ou ben 0 se o valor do argumento é cero (<quote>falso</quote>
	  booleano ou <quote>fallo</quote>).
	</para>
	<para>
	  Por defecto, non hai outras consecuencias de que falle unha
	  chamada a <lit>assert</lit>, máis que o feito de que o valor
	  que se devolve é cero. Porén, podes utilizar a instrución
	  <cmdref targ="set"/> para facer que o fallo dunha afirmación
	  teña máis consecuencias. Hai tres niveis:
	</para>
	<code>
	  # Amosar unha mensaxe de aviso, mais continuar coa execución
	  set assert warn
	  # Amosar unha mensaxe de aviso e deter a execución dun guión
	  set assert stop
	  # Amosar unha mensaxe a 'stderr' e deter o programa
	  set assert fatal
	</code>
	<para>
	  Na maioría dos casos <lit>stop</lit> é suficiente para deter a
	  execución dun guión, pero en certos casos especiais (como dentro
	  dunha función invocada desde un bloque de instrucións tal como
	  en <cmdref targ="mle"/>), pode resultar necesario utilizar a opción
	  <lit>fatal</lit> para acadar unha indicación clara da afirmación
	  que falla. Porén, observa que neste caso a mensaxe vai dirixirse
	  á saída de resultados do erro padrón.
	</para>
	<para>
	  Podes restablecer o funcionamento por defecto mediante
	</para>
	<code>
	  set assert off
	</code>
	<para>
	  A xeito de exemplo sinxelo:
	  Se en certo punto dun guión HANSL, un escalar <lit>x</lit> debera ser
	  non negativo, o seguinte código amosará un erro se este non é o caso:
	</para>
	<code>
	  set assert stop
	  assert(x >= 0)
	</code>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos radiáns do arco tanxente de
	  <argname>x</argname>; é dicir, devolve o arco cuxa tanxente é <argname>x</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="tan"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor principal
	  da arco tanxente de <argname>y</argname>/<argname>x</argname>,
	  utilizando os signos dos dous argumentos indicados para determinar
	  o cuadrante do resultado. O valor que se devolve está en radiáns,
	  dentro do rango [&minus;&pi;, &pi;].
	</para>
	<para>
	  Se os dous argumentos son de tipos difirentes, o tipo do resultado
	  é o mesmo que o do <quote>maior</quote> dos dous, donde a xerarquía
	  é matriz &gt; serie &gt; escalar. Por exemplo, se <argname>y</argname>
	  é un escalar, e <argname>x</argname> é un vector de dimensión
	  <math>n</math> (ou viceversa), o resultado é un vector de dimensión
	  <math>n</math>. Cae na conta de que os argumentos dunha matriz deben
	  de ser vectores; e de que, se ningún argumento é un escalar, os dous
	  argumentos deben de ser da mesma longura.
	</para>
	<para>
	  <seelist>
            <fncref targ="tan"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa tanxente hiperbólica inversa de <argname>x</argname>.
	  <seelist>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Función moi relacionada coa da linguaxe de programación C co mesmo nome.
	  Devolve un escalar co resultado de converter a cadea de texto
	  <argname>s</argname> (ou o seu anaco relevante logo de descartar
	  calquera espazo inicial en branco) nun número de punto flotante.
	  A diferenza do que ocorre na linguaxe C, a función <lit>atof</lit>
	  sempre asume que o carácter decimal é o <quote><lit>.</lit></quote>
	  (por cuestións de transportabilidade). Ignóranse todos os caracteres
	  que seguen logo da parte de <argname>s</argname> que se converte en
	  número de punto flotante.
	</para>
	<para>
	  Se, baixo o suposto establecido, non puidera converterse ningún dos
	  caracteres de <argname>s</argname> que queden logo de descartar
	  os espazos en branco, a función devolve <lit>NA</lit>.
	</para>
	<code>
	  # Exemplos:
	  x = atof("1.234") # Devolve x = 1,234
	  x = atof("1,234") # Devolve x = 1
	  x = atof("1.2y")  # Devolve x = 1,2
	  x = atof("y")     # Devolve x = NA
	  x = atof(",234")  # Devolve x = NA
	</code>
	<para>
	  Consulta tamén <fncref targ="sscanf"/> se queres ter maior
	  flexibilidade nas conversións de cadeas de texto en números.
	</para>
      </description>
    </function>

    <function name="bcheck" section="programming" output="scalar">
      <fnargs>
	<fnarg type="bundleref">obxectivo</fnarg>
	<fnarg type="bundle" optional="true">entrada</fnarg>
	<fnarg type="strings" optional="true">teclas-requiridas</fnarg>
      </fnargs>
      <description>
	<para>
	  Principalmente pensada para que a utilicen os autores de paquetes de
	  funcións. Este é o contexto no que <lit>bcheck</lit> pode ser útil:
	  tes unha función que admite un argumento de tipo feixe mediante o que
	  o solicitante pode facer varias eleccións. Algúns elementos do feixe
	  poden ter valores predeterminados &mdash;polo que o solicitante
	  non está obrigado a facer unha elección explícita&mdash; anque
	  poden necesitarse outros elementos. O que queres é determinar
	  se o argumento que obtés é correcto. O texto principal de abaixo
	  asume que o solicitante da túa función proporciona un paquete
	  (bundle) de <argname>entrada</argname>, pero consulta a sección
	  titulada <quote>Sen paquete de entrada</quote>, en caso
	  contrario.
	</para>
	<para>
	  Para utilizar <lit>bcheck</lit>, constrúes un modelo de feixe que
	  conteña tódalas chaves admitidas, con valores que exemplifiquen
	  o tipo asociado a cada chave, e pásalo en forma de punteiro como
	  <argname>obxectivo</argname>. Para o segundo argumento,
	  <argname>entrada</argname>, pasas o feixe que obtés do solicitante.
	  Entón, esta función comproba o seguinte:
	</para>
	<ilist>
	  <li>
	    <para>
	      Contén a <argname>entrada</argname> algunha chave que non
	      estea presente no <argname>obxectivo</argname>? En tal caso,
	      <lit>bcheck</lit> devolve un valor non nulo, indicando que a
	      <argname>entrada</argname> é incorrecta. (Moi probablemente,
	      a chave en cuestión está escrita incorrectamente).
	    </para>
	  </li>
	  <li>
	    <para>
	      Contén a <argname>entrada</argname>, baixo algunha das
	      chaves indicadas, un obxecto cuxo tipo non coincida co do
	      <argname>obxectivo</argname>? En tal caso, devólvese un valor
	      non nulo.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se algúns elementos do <argname>obxectivo</argname> requiren
	      unha entrada do solicitante (polo que o valor que indicas non é
	      un valor predeterminado, senón só un marcador de posición
	      para indicar o tipo requirido), debes de indicar un terceiro
	      argumento a <lit>bcheck</lit>: un arranxo de cadeas de texto
	      que conteña as chaves para as que non é opcional a entrada. Entón,
	      o valor devolto será non nulo se falta algún dos elementos
	      requiridos de <argname>entrada</argname>.
	    </para>
	  </li>
	</ilist>
	<para>
	  Ademais do anterior, poderías estar interesado en impoñer límites
	  inferiores e/ou superiores ao valor de un ou máis dos elementos
	  escalares do argumento de feixe. En tal caso, engade un feixe co
	  nome <lit>bounds</lit> ao teu modelo de feixe. Cada elemento deste
	  feixe secundario deberá ter unha <i>chave</i> que identifique un
	  elemento do modelo de feixe; o seu <i>valor</i> deberá ser un
	  vector 'dobre' que conteña os límites inferiores e superiores. Coloca
	  un <lit>NA</lit> no lugar dun dos límites, se non hai límite dese
	  lado. Así, por exemplo, cando se indica <lit>x1</lit> na entrada
	  do solicitante, o seguinte código vai comprobar que está entre
	  1 e 5; e cando se indica <lit>x2</lit>, que este non é
	  negativo:
	</para>
	<code>
	  template.bounds = _(x1={1,5}, x2={0,NA})
	</code>
	<para>
	  Cando non se detectan fallos en ningún deses puntos, os valores
	  indicados en <argname>entrada</argname> cópianse a
	  <argname>obxectivo</argname> (substituíndose os predeterminados
	  por eleccións correctas na parte do solicitante). Cando se detecten
	  fallos, vaise presentar unha mensaxe que vai indicar qué é o que
	  está mal na <argname>entrada</argname>.
	</para>
	<para>
	  Para ofrecer un exemplo sinxelo, supón que o teu feixe de argumentos
	  da función admite unha matriz <lit>X</lit> (requirida), un escalar
	  non negativo <lit>z</lit> con valor 0 por defecto, e unha cadea
	  <lit>s</lit> co valor predeterminado <quote><lit>display</lit></quote>.
	  Entón, o seguinte fragmento de código sería axeitado para comprobar
	  un feixe de nome <lit>uservals</lit> proporcionado polo
	  solicitante:
	</para>
	<code>
	  bundle target = _(X={}, z=0, s="display")
	  target.bounds = _(z={0,NA})
	  strings req = defarray("X")
	  err = bcheck(&amp;target, uservals, req)
	  if err
	     # Reaccionar adecuadamente
	  else
	     # Continuar utilizando os valores no obxectivo
	  endif
	</code>
	<subhead>Sen paquete de entrada</subhead>
	<para>
	  Se non se proporciona o paquete (bundle) de <argname>entrada</argname>
	  a <lit>bcheck</lit>, se comporta do seguinte xeito. Se o argumento
    <argname>teclas-requiridas</argname> non se indica, devolve o cero
    (posto que non pode acontecer ningunha das condicións de fallo que se
    mencionan máis arriba), e <argname>obxectivo</argname> non se modifica.
    Noutro caso, devolve un valor non nulo posto que está claro que unha ou
    máis especificacións deben estar ausentes. Isto significa que é seguro pasar unha
    <argname>entrada</argname> nula a <lit>bcheck</lit>.
        </para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">tipo</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite calcular unha das variantes da función de Bessel de clase
	  <argname>v</argname> con argumento <argname>x</argname>. O valor que
	  devolve é do mesmo tipo que este <argname>x</argname>. A clase da
	  función escóllese co primeiro argumento que debe ser <lit>J</lit>,
	  <lit>Y</lit>, <lit>I</lit> ou <lit>K</lit>. Unha boa discusión sobre
	  as funcións de Bessel pode atoparse na Wikipedia, mais aquí
	  ofrécense uns breves comentarios.
	</para>
	<para>
	  Caso <lit>J</lit>: función de Bessel de primeira clase que se asemella
	  a unha onda sinusoidal amortecida. Defínese para <argname>v</argname>
	  real e <argname>x</argname>; pero se <argname>x</argname> fose
	  negativo, entón <argname>v</argname> debe de ser un número enteiro.
	</para>
	<para>
	  Caso <lit>Y</lit>: función de Bessel de segunda clase. Defínese para
	  <argname>v</argname> real e <argname>x</argname>, pero con unha
	  singularidade en <argname>x</argname> = 0.
	</para>
	<para>
	  Caso <lit>I</lit>: función de Bessel modificada de primeira clase que
	  presenta un crecemento exponencial. Os argumentos que poden usarse con
	  ela son os mesmos que no caso <lit>J</lit>.
	</para>
	<para>
	  Caso <lit>K</lit>: función de Bessel modificada de segunda clase que
	  presenta un decrecemento exponencial. Diverxe en <argname>x</argname>
	  = 0, non está definida para valores negativos de <argname>x</argname>,
	  e é simétrica arredor de <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización numérica feita co
	  método de Broyden, Fletcher, Goldfarb e Shanno. O argumento vectorial
	  <argname>b</argname> debe de conter os valores iniciais dun conxunto
	  de parámetros, e o argumento <argname>f</argname> debe de especificar
	  unha chamada á función que vai calcular o criterio obxectivo (escalar)
	  que se quere maximizar, dados os valores vixentes dos parámetros, así
	  como calquera outros datos que sexan relevantes. Se o que pretendes
	  é en realidade minimizar o criterio obxectivo, esta función devolve o
	  valor negativo dese criterio obxectivo. Cando se completa con éxito a
	  súa execución, <lit>BFGSmax</lit> devolve o valor maximizado do
	  criterio obxectivo, e <argname>b</argname> contén finalmente os
	  valores dos parámetros que proporcionan o máximo dese criterio.
	</para>
	<para>
	  O terceiro argumento (opcional) establece unha maneira de proporcionar
	  derivadas analíticas (noutro caso, o gradiente compútase numericamente).
	  A chamada <argname>g</argname> á función gradiente debe de ter como
	  primeiro argumento a unha matriz definida previamente que teña o
	  tamaño axeitado para poder almacenar o gradiente, indicado en forma de
	  punteiro. Así mesmo, tamén precisa ter como argumento (en forma de
	  punteiro ou non) ao vector de parámetros. Outros argumentos son
	  opcionais.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
	          <fncref targ="BFGScmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="BFGSmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="BFGScmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="matrix">limites</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización con restricións por
	  medio do método L-BFGS-B (BFGS con memoria limitada, consulta
	  <cite key="byrd-etal95">Byrd, Lu, Nocedal e Zhu, 1995</cite>). O argumento 
	  vectorial <argname>b</argname> debe de conter os valores iniciais dun
	  conxunto de parámetros, o argumento <argname>limites</argname> debe de
	  conter as restricións aplicadas aos valores dos parámetros (consulta
	  máis abaixo), e o argumento <argname>f</argname> debe de especificar
	  unha chamada á función que vai calcular o criterio obxectivo (escalar)
	  que se quere maximizar, dados os valores vixentes dos parámetros así
	  como calquera outros datos que sexan relevantes. Se o que pretendes
	  realmente é minimizar o criterio obxectivo, esta función debe devolver
	  o valor negativo dese criterio. Ao completar con éxito a súa execución,
	  <lit>BFGScmax</lit> devolve o valor máximo do criterio obxectivo, dadas
	  as restricións de <argname>limites</argname>, e <argname>b</argname>
	  contén finalmente os valores dos parámetros que maximizan o criterio.
	</para>
        <subhead>Límites dos parámetros</subhead>
	<para>
	  A matriz <argname>limites</argname> debe de ter 3 columnas, e un
	  número de filas igual ao número de elementos restrinxidos no vector de
	  parámetros. O primeiro elemento dunha fila dada é o enteiro positivo
	  que indexa o parámetro restrinxido; o segundo e o terceiro elementos
	  son os límites inferior e superior, respectivamente. Os valores
	  <lit>-$huge</lit> e <lit>$huge</lit> deben usarse para indicar que
	  o parámetro non posúe restricións inferiores ou superiores,
	  respectivamente. Por exemplo, a seguinte expresión é a forma de
	  especificar que o segundo elemento do vector de parámetros debe
	  de ser non negativo:
	</para>
	<code>
	  matrix limites = {2, 0, $huge}
	</code>
        <subhead>Derivadas analíticas</subhead>
	<para>
	  O cuarto argumento (opcional) establece unha maneira de proporcionar
	  derivadas analíticas (noutro caso, o gradiente calcúlase numericamente).
	  A chamada <argname>g</argname> á función gradiente debe de ter como
	  primeiro argumento a unha matriz definida previamente que teña o
	  tamaño axeitado para poder almacenar o gradiente, indicado en forma de
	  punteiro. Así mesmo, tamén precisa ter como argumento (en forma de
	  punteiro ou non) ao vector de parámetros. Outros argumentos son
	  opcionais.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
	          <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGScmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="BFGScmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="bin2dec" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha matriz <argname>B</argname> que conteña unicamente ceros
	  e uns, esta función interpreta cada fila da matriz como se fose unha
	  representación binaria dun enteiro de 32 bits sen signo; e devolve
	  un vector columna coas representacións decimais deses enteiros. A
	  matriz do argumento non pode ter máis de 32 columnas; doutro xeito,
	  vaise amosar un fallo.
	</para>
	<para>
	  Cae na conta de que se considera que o derradeiro bit significativo
	  está na primeira columna. Así, a columna 1 vaise corresponder con
	  <math>2</math><sup>0</sup>, a columna 2 con <math>2</math><sup>1</sup>,
	  e así no sucesivo. Por exemplo, a
	  expresión
	</para>
	<code>
	  scalar x = bin2dec({1,0,1})
	</code>
	<para>
	  garda o valor 5 en <math>x</math>.
	</para>
	<para>
	  A función <fncref targ="dec2bin"/> realiza a transformación
	  inversa.
	</para>
      </description>
    </function>

    <function name="bincoeff" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">n</fnarg>
	<fnarg type="anyfloat">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coeficiente binomial.
	  Este indica o número de xeitos nos que <argname>k</argname> elementos
	  se poden escoller (sen repetición) de entre <argname>n</argname>
	  elementos, independentemente de como estean ordenados. Isto tamén
	  equivale ao coeficiente do elemento (<math>k</math>+1)-ésimo
	  na expansión polinómica da potencia dun binomio
	  <equation status="inline" ascii="(1+x)^n" tex="$(1+x)^n$"/>.
	</para>
	<para context="tex">
	  Para argumentos enteiros o resultado é $n!/(k!(n-k)!)$.
	  Pero a función tamén acepta argumentos non enteiros, e
	  a fórmula de arriba xeneralízase como
	  $\frac{\Gamma(n+1)}{\Gamma(k+1) \Gamma(n-k+1)}$.
	</para>
	<para context="notex">
	  Para argumentos enteiros o resultado é <math>n!/(k!(n-k)!)</math>.
	  Pero esta función tamén acepta argumentos non enteiros,
	  e nese caso a fórmula de arriba
	  se xeneraliza como
	   Γ(<math>n</math>+1)/(Γ(<math>k</math>+1) &times; Γ(<math>n-k</math>+1)).
	</para>
	<para>
	  Cando <argname>k</argname> &gt; <argname>n</argname> ou
	  <argname>k</argname> &lt; 0, non hai unha resposta válida
	  polo que se amosa un fallo.
	</para>
	<para>
	  Se os dous argumentos son de diferente tipo, o resultado será
	  do tipo do <quote>maior</quote> dos dous (sendo o criterio de
	  ordenación matriz &gt; serie &gt; escalar). Por exemplo, se
	  <argname>n</argname> é un escalar, e <argname>k</argname> é un
	  vector de dimensión <math>r</math> (ou viceversa), o resultado
	  é un vector de dimensión <math>r</math>. Ten en conta que os
	  argumentos matriciais deberán ser vectores. Tamén que, se ningún
	  argumento é un escalar, os dous deberán ser da mesma longura.
	</para>
	<para>
	  Consulta tamén <fncref targ="gammafun"/> e <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="binperms" section="math" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Permutacións binarias: devolve unha matriz <by r="p" c="n"/>,
	  na que cada unha das súas filas contén unha ordenación diferente
	  de <math>k</math> uns e <math>n</math> &minus; <math>k</math>
	  ceros (en orde lexicográfica). O valor máximo admitido para
	  <math>n</math> é 64; tanto <math>n</math> como <math>k</math>
	  deben ser non negativos; e <math>k</math> non debe ser maior que
	  <math>n</math>; doutro xeito, vaise amosar un fallo. No caso de
	  que <math>n</math> = <math>k</math> = 0 devólvese unha matriz
	  baleira.
	</para>
	<para>
	  Por exemplo, con <math>n</math> = 4 e <math>k</math> = 2,
	  o resultado é
	</para>
	<code>
	  0   0   1   1
	  0   1   0   1
	  0   1   1   0
	  1   0   0   1
	  1   0   1   0
	  1   1   0   0
	</code>
	<para>
	  <emphasis>Advertencia</emphasis>: O número <math>p</math> de
	  permutacións medra rapidamente en función de <math>n</math>; e
	  resulta maior cando <math>k</math> é aproximadamente a metade de
	  <math>n</math>. Entón, podería interesarte comprobar con antelación
	  a dimensión da matriz que a función <lit>binperms</lit> vai tratar de
	  asignar. Como a función <fncref targ="bincoeff"/> devolve o valor de
	  <math>p</math>, pódese calcular o tamaño en megabytes da matriz
	  resultante mediante
	</para>
	<code>
	  MB = 8 * n * bincoeff(n, k) / 10^6
	</code>
	<para>
	  Para <math>n</math> = 30, isto da como resultado preto de 34 Mb
	  cando <math>k</math> = 25, en torno a 7.211 Mb se <math>k</math> = 20,
	  e 20.758 Mb aproximadamente se <math>k</math> = 18.
	</para>
      </description>
    </function>

    <function name="bkfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie co resultado da aplicación do filtro paso-banda
	  de Baxter&ndash;King a unha serie <argname>y</argname>. Os
	  parámetros opcionais <argname>f1</argname> e <argname>f2</argname>
	  representan, de maneira respectiva, os límites inferior e superior
	  do rango de frecuencias que se vai extraer, namentres que
	  <argname>k</argname> representa a orde de aproximación que se vai
	  utilizar.
	</para>
	<para>
	  Se non se proporcionan eses argumentos, entón os valores por defecto
	  van depender da periodicidade do conxunto de datos. Para datos
	  anuais os valores por defecto para <argname>f1</argname>,
	  <argname>f2</argname> e <argname>k</argname> son 2, 8 e 3
	  respectivamente; para datos trimestrais son 6, 32 e 12; e para
	  datos mensuais son 18, 96 e 36. Eses valores escóllense para
	  coincidir coa elección máis común entre os usuarios, que consiste
	  na utilización deste filtro para extraer a compoñente de frecuencia
	  do <quote>ciclo de negocios</quote>. Isto, á súa vez, defínese
	  habitualmente comprendido entre 18 meses e 8 anos. O filtro abarca
	  3 anos de datos, na elección por defecto.
	</para>
	<para>
	  Se <argname>f2</argname> é maior ou igual ao número de observacións
	  dispoñibles, entón execútase a versión <quote>paso-baixo</quote>
	  do filtro, e a serie resultante debe de considerarse como unha
	  estimación da compoñente de tendencia, máis ca da compoñente do
	  ciclo.
	  <seelist>
            <fncref targ="bwfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bkw" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">V</fnarg>
	<fnarg optional="true" type="strings">nomespar</fnarg>
	<fnarg optional="true" type="bool">detallado</fnarg>
      </fnargs>
      <description>
	<para>
	  Executa probas BKW de diagnose de multicolinearidade (consulta
	  <cite key="belsley-etal80">Belsley, Kuh e Welsch (1980)</cite>)
	  dada unha matriz de covarianzas das estimacións dos parámetros,
	  <argname>V</argname>. O segundo argumento (opcional), pode ser
	  un arranxo de cadeas de texto ou unha cadea que conteña nomes
	  separados por comas, e se usa para etiquetar as columnas que
	  amosan as proporcións de varianza; o número de nomes debe de
	  coincidir coa dimensión de <argname>V</argname>. Despois de
	  estimar un modelo en GRETL, podes obter argumentos adecuados para
	  indicar nesta función mediante os accesorios <fncref targ="$vcv"/>
	  e <fncref targ="$parnames"/>.
	</para>
	<para>
	  Por defecto, esta función traballa silandeiramente, devolvendo tan
	  só a táboa BKW en forma de matriz, pero se indicas como terceiro
	  argumento un valor non nulo, a táboa preséntase xunto con algunhas
	  análises.
	</para>
	<para>
	  Tamén dispós desta funcionalidade con formato de instrución mediante
	  <cmdref targ="bkw"/>, e vaise referir automaticamente ao derradeiro
	  modelo, sen requirir ningún argumento.
	</para>
      </description>
    </function>

    <function name="boxcox" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o resultado da transformación de Box&ndash;Cox con
	  parámetro <argname>d</argname> dunha serie positiva
	  <argname>y</argname> (ou das columnas dunha matriz
	  <argname>y</argname>).
	</para>
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  O resultado é (<math>y</math><sup>d</sup> - 1)/<math>d</math>
	  para <math>d</math> distinto de cero, ou log(<math>y</math>) para
	  <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg optional="true" type="bool">importar</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a lectura dun feixe (bundle) desde un ficheiro especificado
	  polo argumento <argname>nomeficheiro</argname>. Por defecto, asúmese
	  que o feixe está representado en XML; e que se lle aplicou a compresión
	  gzip se <argname>nomeficheiro</argname> ten extensión <lit>.gz</lit>.
	  Pero se a extensión é <lit>.json</lit> ou <lit>.geojson</lit>, asúmese
	  que o contido é de tipo JSON.
	</para>
	<para>
	  No caso XML, o ficheiro debe de conter un elemento
	  <lit>gretl-bundle</lit>, que se use para almacenar cero ou
	  máis elementos <lit>bundled-item</lit>. Por exemplo:
	</para>
	<code>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;gretl-bundle name="temp"&gt;
          &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
          &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
	  &lt;/gretl-bundle&gt;
	</code>
	<para>
	  Como cabería agardar, os ficheiros que se len axeitadamente por
	  medio de <lit>bread</lit> xéranse mediante a función asociada
	  <fncref targ="bwrite"/>.
	</para>
	<para>
	  Se o nome do ficheiro non contén a especificación completa do camiño
	  ao cartafol onde está, entón vai procurarse en varias localizacións
	  <quote>probables</quote>, comezando no <cmdref targ="workdir"/> vixente.
	  Porén, cando se proporciona un valor non nulo para o argumento
	  opcional <argname>importar</argname>, o ficheiro vai procurarse no
	  cartafol <quote>punto</quote> do usuario. Neste caso, o argumento
	  <argname>nomeficheiro</argname> deberá ser un nome simple de ficheiro,
	  sen a inclusión do camiño ao cartafol.
	</para>
	<para>
	  Se ocorre algún fallo (por exemplo, se o ficheiro está mal formatado
	  ou é inaccesible), devólvese o fallo por medio do accesorio
	  <fncref targ="$error"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
            <fncref targ="bwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="brename" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">vellachave</fnarg>
	<fnarg type="string">novachave</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o feixe <argname>B</argname> contén un elemento que teña
	  a chave <argname>vellachave</argname>, esa súa chave trócase
	  a <argname>novachave</argname>; doutro xeito, amósase un fallo.
	  A función devolve un 0 cando se fai correctamente o cambio de nome.
	</para>
	<para>
	  Trocar a chave dun elemento dun feixe non é unha tarefa habitual,
	  mais pode xurdirte esa necesidade no contexto de funcións que
	  operan con feixes, e <lit>brename</lit> resulta ser unha ferramenta
	  eficiente para ese traballo. Exemplo:
	</para>
	<code>
	  # Establecer un feixe que contén unha matriz grande
	  bundle b
	  b.X = mnormal(1000, 1000)
	  if 0
	      # 'Trocar a chave manualmente'
	      Xcopy = b.X
	      delete b.X
	      b.Y = Xcopy
	      delete Xcopy
	  else
	      # fronte a 'Trocala de forma eficiente'
	      brename(b, "X", "Y")
	  endif
	</code>
	<para>
	  O primeiro método esixe que se copie esa gran matriz dúas veces:
	  primeiro fóra do feixe, e logo de novo dentro del baixo unha chave
	  diferente. O método eficiente troca a chave directamente.
	</para>
      </description>
    </function>

    <function name="bwfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie co que resulta ao aplicar un filtro paso-baixo
	  de Butterworth de orde <argname>n</argname> e frecuencia de
	  corte <argname>omega</argname>, na serie <argname>y</argname>.
	  O corte exprésase en graos e debe de ser maior ou igual a cero,
	  e menor ca 180. Os valores de corte máis pequenos van restrinxir o
	  paso-banda a menores frecuencias, e así producen unha tendencia
	  máis suave. Os valores maiores de <argname>n</argname> producen
	  un corte máis agudo, mais co custo de poder ter inestabilidade
	  numérica.
	</para>
	<para>
	  A inspección preliminar do periodograma da serie de interese é moi
	  útil cando se desexa aplicar esta función. Para obter máis detalles,
	  consulta o <guideref targ="chap:tsfilter"/>.
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg optional="true" type="bool">exportar</fnarg>
      </fnargs>
      <description>
	<para>
	  Escribe o feixe (bundle) <argname>B</argname> nun ficheiro, serializado
	  en XML; ou como JSON, se <argname>nomeficheiro</argname> ten extensión
	  <lit>.json</lit> ou <lit>.geojson</lit>. Consulta <fncref targ="bread"/>
	  para ter unha descrición do formato cando se usa XML. Se xa existe un
	  ficheiro denominado <argname>nomeficheiro</argname>, vaise sobrescribir.
	  Esta función devolve o valor nominal 0 no caso de que conclúa con éxito;
	  se fracasa a escritura se amosa un fallo.
	</para>
	<para>
	  O ficheiro de saída gárdase no cartafol <cmdref targ="workdir"/>
	  vixente, agás que <argname>nomeficheiro</argname> conteña o camiño
	  completo co cartafol no que vai ser gardado. Agora ben, cando se indica
	  un valor non nulo para o argumento <argname>exportar</argname>,
	  o ficheiro vaise gardar no cartafol <quote>punto</quote> do usuario.
	  Neste caso, o argumento <argname>nomeficheiro</argname> deberá
	  de ser un nome simple de ficheiro, sen a inclusión do camiño ao cartafol.
	</para>
	<para>
	  Dispós da opción de compresión gzip, pero unicamente no caso
	  de que o resultado sexa de tipo XML. Isto vaise aplicar se
	  <argname>nomeficheiro</argname> ten a extensión <lit>.gz</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="carg" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz real de dimensión <by r="m" c="n"/> que contén o
	  <quote>argumento</quote> complexo de cada elemento da matriz complexa
	  <argname>C</argname> de dimensión <by r="m" c="n"/>. O argumento do
	  número complexo <math>z</math> = <math>x</math> + <math>yi</math>
	  tamén pode calcularse mediante <lit>atan2(y, x)</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="abs"/>
	    <fncref targ="cmod"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">tipificar</fnarg>
	<fnarg type="bool" optional="true">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Centra as columnas da matriz <argname>X</argname> a respecto
	  das súas medias. Se o segundo argumento (opcional) ten un valor
	  non nulo, entón os valores centrados divídense ademais polos
	  desvíos padrón de cada columna (que se caculan utilizando
	  <math>n</math> &minus; 1 como divisor, no que <math>n</math>
	  é o número de filas de <argname>X</argname>).
	</para>
	<para>
	  Se indicas un valor non nulo para <argname>obviar_na</argname>
	  vanse ignorar os valores ausentes; doutro xeito, se unha columna
	  da matriz <argname>X</argname> contén algún valor ausente, a
	  columna correspondente da saída vai ter todos
	  ausentes.
	</para>
	<para>
	  Cae na conta de que <fncref targ="stdize"/> proporciona unha
	  funcionalidade máis flexible.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Calcula o valor da función de distribución acumulativa, e devolve
	  un resultado (do mesmo tipo ca o argumento) coa probabilidade
	  <equation status="inline" ascii="P(X &le; x)" tex="$P(X \le x)$"/>,
	  onde a distribución de <math>X</math> se especifica por medio da letra
	  <argname>d</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>x</argname> pode necesitarse algún argumento adicional
	  escalar para especificar os parámetros da distribución, tal e como
	  se indica a continuación (mais observa que a distribución Normal
	  ten a súa propia función, por conveniencia, <fncref targ="cnorm"/>):
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (d = z, n ou N): sen argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Normal bivariante (D): coeficiente de correlación
            </para>
	  </li>
	  <li>
            <para>
              Loxística (lgt ou s): sen máis argumentos
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): 2 parámetros de forma
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Exponencial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media; escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Khi-cadrado non central (ncX): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F non central (ncF): graos de liberdade (num.), graos de liberdade (den.),
	      parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t non central (nct): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribución} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Normal bivariante &amp; \texttt{D} &amp;
	  $\rho$ &amp; -- &amp; --\\
	  Loxística &amp; \texttt{lgt} &amp;
	  -- &amp; -- &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  gl &amp; -- &amp; --\\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  gl &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  gl (num.) &amp; gl (den.) &amp; --\\
	  Gamma &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  probabilidade &amp; ensaios &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  media &amp; -- &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp;
	  escala &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp;
	  forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
	  media &amp; escala &amp; --\\
	  Erro Xeneralizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ non central &amp; \texttt{ncX} &amp;
	  gl &amp; non centralidade &amp; --\\
	  $F$ non central &amp; \texttt{ncF} &amp;
	  gl (num.) &amp; gl (den.) &amp; non centralidade\\
	  $t$ non central &amp; \texttt{nct} &amp;
	  gl &amp; non centralidade &amp; --\\
	</tabular>
	<para>
	  Cae na conta de que, na maioría dos casos, existen alcumes para axudar
	  a memorizar os códigos. O caso da normal bivariante é especial: a
	  sintaxe é <lit>x = cdf(D, rho, z1, z2)</lit> onde <lit>rho</lit>
	  é o coeficiente de correlación entre as variables <lit>z1</lit>
	  e <lit>z2</lit>.
	</para>
	<para context="tex">
	  A disposición de parámetros que usa o GRETL para a variable
	  aleatoria Gamma implica que a súa función de densidade pode escribirse
	  \[
	  f(x; k, \theta) = \frac{x^{k-1}}{\theta^k} \frac{e^{-x/\theta}}{\Gamma(k)}
	  \]
	  onde $k&gt;0$ é o parámetro de forma, e $\theta&gt;0$ é o parámetro
	  de escala.
	</para>
	<para>
	  <seelist>
            <fncref targ="pdf"/>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é unha función herdada, anterior ao soporte
	  orixinal de GRETL para matrices complexas.
	</para>
	<para>
	  Devolve unha matriz co resultado de dividir números complexos. Os dous
	  argumentos deben comporse do mesmo número de filas, <math>n</math>, e
	  dunha ou dúas columnas. A primeira columna contén a parte real, e a
	  segunda (se existe) contén a parte imaxinaria. O resultado que se
	  devolve é unha matriz de orde <by r="n" c="2"/> ou, no caso de non
	  existir a parte imaxinaria, un vector con <math>n</math> filas.
	  <seelist>
            <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función devolve unha lista na que cada serie do argumento
	  <argname>L</argname> que teña o atributo <quote>codificado</quote>,
	  substitúese por un conxunto de variables ficticias que representan
	  cada un dos seus valores codificados, pero omitindo o valor
	  máis pequeno. Se o argumento <argname>L</argname> non contén
	  ningunha serie codificada, o valor que se devolve vai ser idéntico
	  a <argname>L</argname>.
	</para>
	<para>
	  No caso de que se xeren, as variables ficticias noméanse co
	  padrón <lit>D</lit><repl>varname</repl><lit>_</lit><repl>vi</repl>,
	  no que <repl>vi</repl> indica o <repl>i</repl><sup>-ésimo</sup>
	  valor representado da variable que se codifica. No caso de que
	  algúns dos valores sexan negativos, vaise inserir <quote>m</quote>
	  antes do valor (absoluto) de
	  <repl>vi</repl>.
	</para>
	<para>
	  Por exemplo, supón que <argname>L</argname> contén unha serie
	  codificada chamada <lit>C1</lit> cos valores &minus;9, &minus;7,
	  0, 1 e 2. Entón, as variables ficticias xeradas van ser
	  <lit>DC1_m7</lit> (que codifica cando C1 = &minus;7),
	  <lit>DC1_0</lit> (que codifica cando C1 = 0), etcétera.
	</para>
	<para>
	  <seelist>
            <fncref targ="dummify"/>
	    <fncref targ="getinfo"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Función tope: devolve un resultado (do tipo do argumento) co menor
	  enteiro que sexa maior ou igual a <argname>x</argname>.
	  <seelist>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a descomposición de Cholesky de <argname>A</argname>.
	  Cando <argname>A</argname> sexa unha matriz real, deberá ser
	  simétrica e definida positiva; nese caso, o resultado será
	  unha matriz triangular inferior <math>L</math> que verificará
	  <equation status="inline" ascii="A = LL'" tex="$A = LL'$"/>.
	  Cando <argname>A</argname> sexa complexa, deberá ser
	  Hermitiana e definida positiva; e o resultado será unha matriz
	  complexa triangular inferior de xeito que
	  <equation status="inline" ascii="A = LL^H" tex="$A = LL^{\mathrm H}$"/>.
	  En caso contrario, a función devolverá un fallo.
	</para>
	<para>
	  Para o caso real, consulta tamén <fncref targ="psdroot"/> e
	  <fncref targ="Lsolve"/>.
	</para>
      </description>
    </function>

    <function name="chowlin" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">factorx</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Non se recomenda seguir utilizando esta función; en troques,
	  utiliza <fncref targ="tdisagg"/>.
	</para>
	<para>
	  Devolve unha matriz como resultado de expandir os datos de
	  entrada, <argname>Y</argname>, a unha frecuencia maior, co método
	  de <cite key="chowlin71">Chow e Lin (1971)</cite>. Asúmese que as
	  columnas de <argname>Y</argname> representan series de datos.
	  A matriz que se devolve ten o mesmo número de columnas que
	  <argname>Y</argname> e <argname>factorx</argname> veces o seu
	  número de filas. Tamén se asume que cada valor de baixa frecuencia
	  debe tratarse como a media de <argname>factorx</argname> valores
	  de alta frecuencia.
	</para>
	<para>
	  O valor de <argname>factorx</argname> debe ser igual a 3 para expandir
	  datos trimestrais a mensuais, 4 para facelo de anuais a trimestrais, ou
	  12 de anuais a mensuais. Podes usar o terceiro argumento (opcional)
	  para prover unha matriz de covariables cun obxectivo de maior frecuencia.
	</para>
	<para>
	  Os regresores que se utilizan por defecto son unha constante e
	  unha tendencia. Cando se proporciona <argname>X</argname>, as
	  súas columnas utilízanse como regresores adicionais. A función
	  devolve un fallo se o número de filas de <argname>X</argname> non
	  é igual a <argname>factorx</argname> veces o número de filas de
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmod" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz real de dimensión <by r="m" c="n"/>
	  que contén o módulo complexo de cada elemento da matriz
	  complexa <argname>C</argname> de dimensión
	  <by r="m" c="n"/>. O módulo do número complexo
	  <math>z</math> = <math>x</math> + <math>yi</math> é igual á raíz
	  cadrada de <math>x</math><sup>2</sup> + <math>y</math><sup>2</sup>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="abs"/>
	    <fncref targ="carg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cmult" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é unha función herdada, anterior ao soporte
	  orixinal de GRETL para matrices complexas.
	</para>
	<para>
	  Devolve unha matriz co resultado de multiplicar números complexos. Os dous
	  argumentos deben comporse do mesmo número de filas, <math>n</math>, e
	  dunha ou dúas columnas. A primeira columna contén a parte real e a
	  segunda (se existe) contén a parte imaxinaria. O resultado que se
	  devolve é unha matriz de orde <by r="n" c="2"/> ou, no caso de non
	  existir a parte imaxinaria, un vector con <math>n</math> filas.
	  <seelist>
            <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a función de distribución acumulativa para unha Normal
	  estándar.
	  <seelist>
            <fncref targ="dnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnumber" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co número de condición dunha matriz
	  <argname>X</argname> de orde <by r="n" c="k"/>, conforme se define
	  en <cite key="belsley-etal80"> Belsley, Kuh e Welsch (1980)</cite>.
	  Se as columnas de <argname>X</argname> son mutuamente ortogonais,
	  o número de condición de <argname>X</argname> é a unidade. Pola
	  contra, un valor grande do número de condición enténdese como un
	  indicio de alto grao de multicolinearidade; habitualmente considérase
	  que o valor é <quote>grande</quote> se é maior ou igual a 50 (ou,
	  algunhas veces, a 30).
	</para>
	<para>
	  Os pasos para facer os cálculos son: (1) conformar unha matriz
	  <math>Z</math> cuxas columnas sexan o resultado de dividir cada
	  columna de <argname>X</argname> pola súa respectiva norma
	  euclidiana; (2) construír a matriz <math>Z'Z</math> e obter os seus
	  autovalores; e (3) calcular a raíz cadrada da razón entre o maior
	  e o menor autovalor.
	</para>
	
	<para>
	  <seelist>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Se indicas o argumento <argname>col</argname>, devolve unha cadea
	  de texto co nome da columna <argname>col</argname> da matriz
	  <argname>M</argname>. Se as columnas de <argname>M</argname>
	  non teñen nome, entón devólvese unha cadea baleira; e se
	  <argname>col</argname> está fóra dos límites do número de columnas
	  desta matriz, amósase un fallo.
	</para>
	<para>
	  Se non indicas o segundo argumento, devolve un arranxo de cadeas
	  de texto que contén os nomes das columnas de <argname>M</argname>,
	  ou un arranxo baleiro se <argname>M</argname> non ten asignados
	  nomes de columnas.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  cnameset(A, "Col_A Col_B Col_C")
	  string name = cnameget(A, 3)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="cnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameset" section="matrix" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Engade nomes ás columnas da matriz de orde <by r="T" c="k"/>,
	  <argname>M</argname>. Cando <argname>S</argname> é unha lista,
	  os nomes son os das series listadas (é preciso que esa lista teña
	  <math>k</math>elementos). Cando <argname>S</argname> é un arranxo
	  de cadeas de texto, deberá de ter <math>k</math> elementos. Como
	  segundo argumento tamén se acepta unha única cadea de texto; nese
	  caso, esta cadea precisa ter <math>k</math> subcadeas separadas
	  por espazos. Como caso especial, o feito de indicar unha cadea de
	  texto baleira como segundo argumento, ten como efecto a eliminación
	  de calquera nome de columna existente.
	</para>
	<para>
	  Devolve o valor nominal 0 se as columnas son nomeadas con éxito;
	  no caso de que non funcione, amósase un fallo. Consulta tamén
	  <fncref targ="rnameset"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(2)
	  S[1] = "Col1"
	  S[2] = "Col2"
	  cnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co número de columnas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="commute" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
	<fnarg optional="true" type="int">post</fnarg>
	<fnarg optional="true" type="int">add_id</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o resultado de premultiplicar a matriz <argname>A</argname>
	  pola matriz <math>K</math><sub>m,n</sub> de conmutación (utilizando
	  un algoritmo que é máis eficiente que a propia multiplicación
	  explícita). Asúmese que cada columna de <argname>A</argname>
	  procede dunha operación de vectorización sobre unha matriz
	  <math>m x n</math>. En particular,
	</para>
	<code>
	  commute(vec(B), rows(B), cols(B))
	</code>
	<para>
	  proporciona vec(<math>B'</math>). Co obxecto de calcular a matriz
	  de conmutación apropiada, aplica simplemente a función a unha matriz
	  identidade co tamaño axeitado. Por exemplo:
	</para>
	<code>
	  K_32 = commute(I(6), 3, 2)
	</code>
	<para>
	  Por defecto, o argumento opcional <argname>n</argname> está
	  establecido que sexa igual a <argname>m</argname>. Cando
	  o argumento opcional <argname>post</argname> non é cero,
	  lévase a cabo a multiplicación posterior en troques da multiplicación
	  anterior; e a opción Booleana <argname>add_id</argname> vai
	  premultiplicar a matriz <argname>A</argname> por
	  <math>I + K</math><sub>m,n</sub> en troques de
	  <math>K</math><sub>m,n</sub>.
	</para>
      </description>
    </function>

    <function name="complex" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="scalar-or-matrix">A</fnarg>
	<fnarg optional="true" type="scalar-or-matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz complexa, na que tómase <argname>A</argname>
	  para ofrecer a parte real e <argname>B</argname> para a parte
	  imaxinaria. Se <argname>A</argname> é de dimensión <by r="m" c="n"/>
	  e <argname>B</argname> é un escalar, o resultado é unha matriz
	  <by r="m" c="n"/> cunha parte imaxinaria constante (e de xeito
	  similar no caso recíproco, mais cunha parte real constante). Se
	  ambos argumentos son matrices, deben de ter as mesmas dimensións.
	  Se omites o segundo argumento, a parte imaxinaria establécese por
	  defecto como cero.
	  <seelist><fncref targ="cswitch"/></seelist>
	</para>
      </description>
    </function>

    <function name="conj" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz complexa de dimensión <by r="m" c="n"/>
	  que contén o conxugado complexo de cada elemento da matriz
	  complexa <argname>C</argname> de dimensión <by r="m" c="n"/>.
	  O conxugado dun número complexo
	  <math>z</math> = <math>x</math> + <math>yi</math> é igual a
	  <math>x</math> &minus; <math>yi</math>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="carg"/>
	    <fncref targ="abs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="contains" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
	<fnarg type="matrix">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciona un medio de determinar se un obxecto numérico
	  <argname>x</argname> está contido nalgún dos elementos dunha
	  matriz <argname>S</argname> (que cumpre o papel dun
	  conxunto).
	</para>
	<para>
	  O valor que se devolve é un obxecto do mesmo tamaño que
	  <argname>x</argname> que contén valores de 1 nas posicións
	  onde o valor <argname>x</argname> coincide con algún elemento
	  de <argname>S</argname>, e ceros nas demais.
	  Por exemplo, o código
	</para>
	<code>
	  matrix A = mshape(seq(1,9), 3, 3)
	  matrix C = contains(A, {1, 5, 9})
	</code>
	<para>
	  produce
	</para>
	<code>
	  A (3 x 3)

	  1   4   7
	  2   5   8
	  3   6   9

	  C (3 x 3)

	  1   0   0
	  0   1   0
	  0   0   1
	</code>
	<para>
	  Esta función pode ser particularmente útil cando <argname>x</argname>
	  é unha serie que contén unha codificación moi refinada para unha
	  característica cualitativa, e queres reducir isto a un número de
	  categorías menor. Podes meter en <argname>S</argname> un conxunto
	  de valores a consolidar, e obter unha variable ficticia co valor 1
	  para as observacións que coinciden con este conxunto, e o valor 0
	  para as demais.
	</para>
	<para>
	  Posto que <argname>S</argname> funciona como un conxunto, debera
	  ser un vector sen valores repetidos para ter unha maior eficiencia;
	  porén, acéptase unha matriz calquera.
	</para>
      </description>
    </function>

    <function name="conv2d" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co cálculo da convolución bidimensional (2D)
	  de dúas matrices <argname>A</argname> e <argname>B</argname>.
	  Se <argname>A</argname> é de orde <by r="r" c="c"/>, e
	  <argname>B</argname> é de orde <by r="m" c="n"/>, entón
	  a matriz que se devolve vai ter <math>r+m-1</math> filas
	  e <math>c+n-1</math> columnas.
	</para>
	<para context="tex">
	    A convolución 2D de <argname>A</argname> e
	    <argname>B</argname> defínese como
	    \[
	    C_{i,j} =
	    \sum_{k=1}^r\sum_{l=1}^c A_{k,l} B_{i-k+1,j-l+1},
	    \]
	    onde as sumas admiten só aqueles valores de $k$ e de $l$ para
	    os que os subíndices de $B$ están dentro dos límites definidos.
	</para>
	<para>
	  <seelist>
            <fncref targ="fft"/>
            <fncref targ="filter"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cquad" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">Z</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha matriz complexa <argname>Z</argname> de orde
	  <by r="m" c="n"/>, esta instrución devolve unha matriz real de
	  orde <by r="m" c="n"/> que contén as "cuadranzas" de cada un dos
	  elementos de <argname>Z</argname>. A cuadranza dun número complexo
	  <math>z</math> = <math>a</math> + <math>bi</math> se define
	  como <math>a</math><sup>2</sup> + <math>b</math><sup>2</sup>.
	  Polo tanto, é igual ao cadrado do módulo de <math>z</math>, e
	  tamén é igual a <math>z</math> multiplicado polo seu conxugado
	  complexo; pero o cálculo directo que realiza <lit>cquad</lit> é
	  considerablemente máis rápido que calquera das outras propostas
	  alternativas.
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor do coeficiente de correlación entre
	  <argname>y1</argname> e <argname>y2</argname>. Os argumentos deben
	  de ser dúas series ou dous vectores do mesmo tamaño.
	  <seelist>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
            <fncref targ="npcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corresp" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">a</fnarg>
	<fnarg type="series-or-vec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  En base a unha tabulación cruzada de <argname>a</argname> e
	  <argname>b</argname>, devolve un código de tipo enteiro que indica
	  a clase de correspondencia entre as dúas variables, do seguinte
	  xeito.
	</para>
	<ilist>
	  <li>
	    <para>
	      Código = 2: hai unha relación de tipo 1 a 1.
	    </para>
	  </li>
	  <li>
	    <para>
	      Código = 1: hai unha relación de tipo 1 a n
	      (<argname>a</argname> <quote>aniña</quote>
	      <argname>b</argname>, pode interpretarse como unha función de
	      <argname>b</argname> en senso matemático).
	    </para>
	  </li>
	  <li>
	    <para>
	      Código = &minus;1: hai unha relación de tipo n a 1
	      (<argname>b</argname> <quote>aniña</quote>
	      <argname>a</argname>, pode interpretarse como unha función de
	      <argname>a</argname>).
	    </para>
	  </li>
	  <li>
	    <para>
	    Code = 0: non hai ningunha relación.
	    </para>
	  </li>
	</ilist>
	<para>
	  Cae na conta de que estes códigos baséanse exclusivamente nos valores
	  mostrais dos dous argumentos. No caso de que <argname>b</argname>
	  sexa o cadrado de <argname>a</argname>, por exemplo, o resultado
	  vai diferir dependendo de se <argname>a</argname> contén algúns
	  pares de valores que unicamente se diferencien no signo
	  (código = &minus;1), ou non (código = 2).
	</para>
	<para>
	  Un caso de posible utilización consiste en comprobar se dúas series
	  discretas codifican a mesma información. Por exemplo, as seguintes
	  expresións
	</para>
	<code>
	  open grunfeld.gdt
	  c = corresp($unit, firm)
	</code>
	<para>
	  proporcionan <lit>c</lit> = 2, indicando que a serie <lit>firm</lit>
	  é de feito un único identificador para as unidades de sección
	  cruzada nese conxunto de datos de panel.
	</para>
	<para>
	  Consulta tamén <fncref targ="mxtab"/>.
	</para>
      </description>
    </function>

    <function name="corrgm" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se proporcionan só os dous primeiros argumentos, a función
	  devolve unha matriz co correlograma de <argname>x</argname> para
	  os retardos dende 1 ata <argname>p</argname>. Se <math>k</math> é o
	  número de elementos de <argname>x</argname> (igual a 1 se
	  <argname>x</argname> é unha serie, igual ao número de columnas se
	  <argname>x</argname> é unha matriz, ou igual ao número de elementos
	  se <argname>x</argname> é unha lista), o valor que se devolve é unha
	  matriz con <argname>p</argname> filas e 2<math>k</math> columnas,
	  na que as <math>k</math> primeiras columnas conteñen as respectivas
	  autocorrelacións, e as restantes conteñen as respectivas autocorrelacións
	  parciais.
	</para>
	<para>
	  Cando se indica o terceiro argumento, esta función calcula o
	  correlograma cruzado dende <math>+</math><argname>p</argname>
	  ata <math>-</math><argname>p</argname> para cada un dos <math>k</math>
	  elementos de <argname>x</argname> e <argname>y</argname>. A matriz
	  que se devolve componse de 2<math>p</math> + 1 filas e <math>k</math>
	  columnas. Se <argname>x</argname> é unha serie ou unha lista, e
	  <argname>y</argname> é un vector, este último é preciso que teña
	  tantas filas coma o número total de observacións que hai na mostra
	  seleccionada en vigor.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coseno de <argname>x</argname>.
	  <seelist>
            <fncref targ="sin"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coseno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="acosh"/>
            <fncref targ="sinh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa covarianza entre <argname>y1</argname> e
	  <argname>y2</argname>. Os argumentos deben de ser dúas series,
	  ou ben dous vectores da mesma longura.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Permite calcular valores críticos, e devolve un resultado do mesmo tipo
	  que o introducido. O valor <math>x</math> que se devolve vai cumprir
	  <equation status="inline" ascii="P(X &gt; x) = p" tex="$P(X &gt; x) = p$"/>,
	  onde a distribución de <math>X</math> determínase pola letra
	  <argname>c</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>x</argname>, pode necesitarse algún outro adicional (escalar)
	  para indicar os parámetros da distribución. Isto faise deste xeito:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (c = z, n ou N): sen argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media; escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	</ilist>
	<tabular colspec="llll">
	  \textit{Distribución} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- \\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  graos de liberdade &amp; -- \\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  graos de liberdade &amp; -- \\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  graos de liberdade (num.) &amp; graos de liberdade (den.) \\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$ \\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  $\lambda$ &amp; -- \\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
	  media &amp; escala \\
	  Erro Xeneralizado &amp; \texttt{E} &amp;
	  forma &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cswitch" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="scalar">xeito</fnarg>
      </fnargs>
      <description>
	<para>
	  Reinterpreta unha matriz real como se contivese valores complexos,
	  ou viceversa. A acción concreta depende de <argname>xeito</argname>
	  (que deberá ter un valor de 1, 2, 3 ou 4), como se explica deseguido:
	</para>
	<para>
	  Xeito 1: O argumento <argname>A</argname> debe ser unha matriz
	  real cun número par de columnas. A función devolve unha matriz coa
	  metade das columnas, con valores complexos formados utilizando as
	  columnas impares de <argname>A</argname> para as partes reais, e
	  as columnas pares para as partes imaxinarias.
	</para>
	<para>
	  Xeito 2: Permite facer a operación inversa á do xeito 1. O argumento
	  <argname>A</argname> debe ser unha matriz complexa, e o resultado
	  que se devolve é unha matriz real que terá o dobre de columnas que
	  as de <argname>A</argname>.
	</para>
	<para>
	  Xeito 3: O argumento <argname>A</argname> debe ser unha matriz
	  real cun número par de filas. A función devolve unha matriz coa
	  metade das filas, con valores complexos formados utilizando as
	  filas impares de <argname>A</argname> para as partes reais, e
	  as filas pares para as partes imaxinarias.
	</para>
	<para>
	  Xeito 4: Permite facer a operación inversa á do xeito 3. O argumento
	  <argname>A</argname> debe ser unha matriz complexa, e o resultado
	  que se devolve é unha matriz real que terá o dobre de filas que as de
	  <argname>A</argname>.
	</para>
	<para>
	  <seelist><fncref targ="complex"/></seelist>
	</para>
      </description>
    </function>

    <function name="ctrans" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz complexa de dimensión <by r="n" c="m"/> que
	  contén a trasposta conxugada da matriz complexa <argname>C</argname>
	  de dimensión <by r="m" c="n"/>. O operador <lit>&apos;</lit> (traspoñer)
	  fai tamén a transposición conxugada de matrices complexas. Podes
	  utilizar a función <fncref targ="transp"/> con matrices complexas,
	  pero iso vai realizar a transposición <quote>directa</quote>
	  (non a conxugada).
	</para>
      </description>
    </function>

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Acumula <argname>x</argname> (isto é, crea unha suma móbil). Cando
	  <argname>x</argname> é unha serie, produce unha serie <math>y</math>
	  na que cada un dos seus elementos é igual á suma dos valores de
	  <argname>x</argname> ata a observación correspondente. O punto
	  de partida para a acumulación é a primeira observación non ausente
	  da mostra vixente seleccionada. Cando se atopa algún valor ausente
	  en <math>x</math>, vanse establecer como ausentes os valores
	  conseguintes de <math>y</math>. Cando <argname>x</argname> é
	  unha matriz, os seus elementos acumúlanse por
	  columnas.
	</para>
	<para context="tex">
	  Acumula <argname>x</argname>. Cando <math>x</math> é unha serie,
	  produce unha serie $y_t = \sum_{s=m}^t x_s$, na que o punto de partida
	  <math>m</math> para a acumulación, é a primeira observación
	  non ausente da mostra provisionalmente seleccionada. Ao atopar valores
	  ausentes en <math>x</math>, os valores subseguintes de <math>y</math>
	  defínense como valores ausentes. Cando <argname>x</argname> é unha
	  matriz, os elementos acumúlanse por columnas.
	</para>
	<para>
	  No caso de datos de panel, a acumulación prodúcese na dimensión
	  temporal, comezando novamente para cada unidade do panel.
	</para>
	<para>
	  Se queres que a acumulación ignore os valores ausentes (é dicir,
	  para tratalos como se fosen ceros), podes aplicar a función
	  <fncref targ="misszero"/> ao argumento, como en
	</para>
	<code>
	  series cx = cum(misszero(x))
	</code>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Ofrece un medio bastante flexible de obter un <quote>buffer</quote> de
	  texto que contén datos dun servidor de internet, utilizando a biblioteca
	  'libcurl'. Ao escribila, o argumento de tipo feixe <argname>b</argname>,
	  debe de conter unha cadea de texto chamada <lit>URL</lit> que indica
	  o enderezo completo do recurso no 'host' de destino. Outros elementos
	  opcionais preséntanse deseguido:
	</para>
	<ilist>
	  <li>
	    <para>
	      <quote><lit>header</lit></quote>: Unha cadea de texto que
	      especifica un encabezamento HTTP que vai enviarse ao 'host'.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>include</lit></quote>: Un escalar: se non é cero,
	      o encabezamento que se recibe do 'host' inclúese no corpo do
	      resultado.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>nobody</lit></quote>: Un escalar: se non é cero,
	      a función <i>non</i> vai descargar o corpo da URL que se
	      require.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>postdata</lit></quote>: Unha cadea de texto que
	      contén os datos que van enviarse ao 'host'.
	    </para>
	  </li>
	</ilist>
	<para>
	  Os campos <lit>header</lit> e <lit>postdata</lit> destínanse
	  para usarse cunha solicitude HTTP do tipo <lit>POST</lit>. Se
	  está presente <lit>postdata</lit>, vai implícito o método
	  <lit>POST</lit>. Noutro caso, os métodos <lit>GET</lit> ou
	  <lit>HEAD</lit> van implícitos, dependendo do valor da chave
	  <lit>nobody</lit>. (Mais observa que para solicitudes <lit>GET</lit>
	  sinxelas, a función <fncref targ="readfile"/> ofrece unha interface
	  máis simple.)
	</para>
	<para>
	  Ao completarse a solicitude, o texto recibido do servidor
	  engádese ao feixe coa chave <quote><lit>output</lit></quote>,
	  e o código de status de HTTP gárdase baixo a chave
	  <quote><lit>http_code</lit></quote>.
	</para>
	<para>
	  A función vai fallar se hai unha equivocación ao formular a solicitude
	  (por exemplo, se non existe unha <lit>URL</lit> na entrada); noutro
	  caso, vai devolver o valor 0 se a solicitude prospera, ou un valor non
	  nulo se non o fai. Neste último caso, engádese ao feixe a mensaxe de
	  fallo de libcurl, co identificador <quote><lit>errmsg</lit></quote>.
	  Cae na conta de que <quote>éxito</quote> neste senso non significa
	  necesariamente que obtés os datos que desexabas; en realidade
	  significa tan só que se recibiu algunha resposta do servidor.
	  Un xeito rápido de comprobación é inspeccionar o código de status
	  de HTTP: os utilizados máis habitualmente son 200 (éxito) ou
	  404 (páxina non atopada).
	  Consulta
	  <url>https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</url>
	  para obter a lista completa. Como alternativa, tamén podes comprobar
	  o contido do 'buffer' de saída (que de feito pode ser unha mensaxe
	  tal como <quote>Páxina non atopada</quote>).
	</para>
	<para>
	  Aquí temos un exemplo de como utilizar esta función: para baixar
	  algúns datos da web da US Bureau of Labor Statistics, que require
	  o envío dunha consulta JSON. Observa o uso de <fcnref targ="sprintf"/>
	  para inserir comiñas nos datos <lit>POST</lit>.
	</para>
    <code>
	 bundle req
	 req.URL = "https://api.bls.gov/publicAPI/v1/timeseries/data/"
	 req.include = 1
	 eq.header = "Content-Type: application/json"
	 string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	 req.postdata = s
	 err = curl(&amp;req)
	 if err == 0
	    s = req.output
	    string line
	    loop while getline(s, &amp;line)
	       printf "%s\n", line
	    endloop
	 endif
    </code>
  <para>
	 Como segundo exemplo, o código de abaixo comproba se está dispoñible
	 unha versión concreta do conxunto de datos
	 <quote>Global Macro Database</quote>, e a descarga nese caso.
  </para>
    <code>
	 string base_URL = "https://www.globalmacrodata.com"
	 string filename = "GMD_2025_03.csv"

	 bundle req
	 req.URL = base_URL ~ "/" ~ filename
	 req.nobody = 1
	 err = curl(&amp;req)

	 if err || (req.http_code != 200)
	    printf "Oh, oh. It seems %s is unavailable\n", filename
	 else
	    # actual request
	    bundle req = empty
	    req.URL = base_URL ~ "/" ~ filename
	    err = curl(&amp;req)
	    print req
	 endif
    </code>
	<para>
	  Consulta tamén as funcións <fncref targ="jsonget"/> e
	  <fncref targ="xmlget"/> para ver xeitos de procesamento
	  de datos recibidos no formato JSON e XML, respectivamente.
	</para>
      </description>
    </function>

    <function name="dayspan" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">d1</fnarg>
	<fnarg type="int">d2</fnarg>
	<fnarg type="int">duracsemana</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un número enteiro co número de días (relevantes) entre os
	  días de época <argname>d1</argname> e <argname>d2</argname>, ambos
	  incluídos, considerando a duración de semana indicada polo argumento
	  <argname>duracsemana</argname>. Este debe de ser igual a 5, 6 ou 7
	  (indicando o valor 6 que non se contan os domingos, e o 5 que non se
	  contan nin os sábados nin os domingos).
	</para>
	<para>
	  Para obter os días de época no formato máis familiar das datas,
	  consulta <fncref targ="epochday"/>. Relacionado con isto, consulta
	  <fncref targ="smplspan"/>.
	</para>
      </description>
    </function>

    <function name="dec2bin" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función devolve a representación binaria dos números contidos
	  no vector columna <argname>x</argname>, gardando cada díxito
	  binario nunha columna da matriz que se devolve, e que sempre
	  ten 32 columnas. Cada elemento de <argname>x</argname> debe ser
	  un enteiro entre 0 e <math>2</math><sup>32</sup><math>-1</math>.
	  Noutro caso, vaise amosar un
	  fallo.
	</para>
	<para>
	  Cae na conta de que se considera que o derradeiro bit significativo
	  está na primeira columna. Así, a columna 1 vaise corresponder con
	  <math>2</math><sup>0</sup>, a columna 2 con <math>2</math><sup>1</sup>,
	  e así no sucesivo. Por exemplo, a
	  expresión
	</para>
	<code>
	  matrix B = dec2bin(5)
	</code>
	<para>
	  produce un vector fila cheo de ceros, agás nas posicións 1
	  e 3.
	</para>
	<para>
	  A función <fncref targ="bin2dec"/> realiza a transformación
	  inversa.
	</para>
      </description>
    </function>

    <function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permite definir <emphasis>cumpridamente</emphasis> unha variable
	  de tipo arranxo (<quote>array</quote>), proporcionando un ou máis
	  elementos. Ao utilizar esta función debes especificar o tipo de
	  arranxo (en forma plural): <lit>strings</lit>, <lit>matrices</lit>,
	  <lit>bundles</lit> ou <lit>lists</lit>. Cada un dos argumentos debe
	  de ser un obxecto do mesmo tipo que o tipo especificado na definición
	  do arranxo. No caso de completarse con éxito, a función devolve como
	  resultado un arranxo con <math>n</math> elementos, onde <math>n</math>
	  é igual ao número de argumentos.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  Consulta tamén <fncref targ="array"/>.
	</para>
      </description>
    </function>

    <function name="defbundle" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Te permite a carga inicial dunha variable de tipo feixe
	  <emphasis>extensamente</emphasis>, proporcionando cero ou
	  máis parellas co formato <repl>chave</repl>, <repl>elemento</repl>.
	  Se contamos os argumentos desde 1, cada argumento numerado
	  impar debe de avaliar unha cadea de texto (chave), e cada
	  argumento numerado par debe de avaliar un obxecto dun tipo
	  que poida incluírse nun feixe.
	</para>
	<para>
	  Un par de exemplos sinxelos:
	</para>
	<code>
	  bundle b1 = defbundle("s", "Sample string", "m", I(3))
	  bundle b2 = defbundle("yn", normal(), "x", 5)
	</code>
	<para>
	  O primeiro exemplo xera un feixe cuxos elementos son unha cadea
	  de texto e unha matriz; o segundo, un feixe cun elemento que é
	  unha serie e outro que é escalar. Ten en conta que non podes
	  especificar un tipo para cada argumento cando utilizas esta función,
	  entón debes de aceptar o tipo <quote>natural</quote> de argumento
	  en cuestión. Se queres engadir unha serie cun valor constante de 5
	  a un feixe chamado <lit>b1</lit> sería necesario facer algo como
	  o seguinte (despois de definir <lit>b1</lit>):
	</para>
	<code>
	  series b1.s5 = 5
	</code>
	<para>
	  Se non indicas ningún argumento para esta función, iso
	  equivale a xerar un feixe baleiro (ou a baleirar un
	  feixe existente do seu contido), como poderías facer
	  mediante
	</para>
	<code>
	  bundle b = null
	</code>
	<subhead>Variantes de sintaxe</subhead>
	<para>
	  Dispós de dúas formas alternativas de sintaxe para definir feixes.
	  En ambos casos, a palabra chave <lit>defbundle</lit> substitúese
	  por un carácter de barra baixa. Na primeira variante, os elementos
	  separados por comas teñen a forma <lit>chave=valor</lit>, onde a
	  chave se entende que debe ser unha cadea de texto literal e non
	  require que a poñas entre comiñas. Este é un exemplo:
	</para>
	<code>
	  bundle b = _(x=5, strval="Algunha cadea", m=I(3))
	</code>
	<para>
	  Esta forma resulta particularmente conveniente para producir un feixe
	  anónimo improvisadamente como argumento dunha función, como en
	</para>
	<code>
	  b = regls(ys, LX, _(lfrac=0.35, stdize=0))
	</code>
	<para>
	  onde a función <lit>regls</lit> ten un argumento opcional de tipo
	  feixe que contén varios parámetros.
	</para>
	<para>
	  A segunda variante está pensada para o caso no que queiras empaquetar
	  varios obxectos xa existentes nun feixe: simplemente indica os seus
	  nomes sen comiñas:
	</para>
	<code>
	  bundle b = _(x, y, z)
	</code>
	<para>
	  Neste caso, o obxecto <lit>x</lit> se copia nun feixe coa chave
	  <quote><lit>x</lit></quote>. De xeito similar faise tanto para
	  <lit>y</lit> como para <lit>z</lit>.
	</para>
	<para>
	  Estas formas alternativas implican teclear menos que na versión
	  cumprida de <lit>defbundle()</lit>, e probablemente moitas veces
	  son máis convenientes, pero ten en conta que son menos flexibles.
	  Só na versión cumprida podes manexar as chaves indicándoas como
	  variables de cadea de texto en troques de cadeas literais.
	</para>
      </description>
    </function>

    <function name="deflist" section="data-utils" output="list">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Xera unha lista (de series xa definidas) dados un ou máis argumentos
	  apropiados. Cada argumento debe de ser, unha serie xa definida
	  (indicada polo seu nome ou o número enteiro ID), unha lista xa definida,
	  ou unha expresión que se corresponda cunha lista (incluíndo un vector que
	  poda interpretarse como un conxunto de números ID de series).
	</para>
	<para>
	  Un aspecto a ter en conta é que esta función simplemente encadea
	  os seus argumentos para producir a lista que devolve. Cando se
	  pretende que o valor que devolva non conteña duplicados (que non
	  se refira a ningunha serie máis dunha vez), depende do solicitante
	  asegurarse de que se satisfaga ese requirimento.
	</para>
      </description>
    </function>

    <function name="deseas" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="bundle">opcions</fnarg>
      </fnargs>
      <description>
	<para>
	  A intención principal desta función é xerar unha versión desestacionalizada
	  da serie <argname>x</argname> (mensual ou trimestral) de entrada,
	  utilizando para elo X-13ARIMA-SEATS; isto estará dispoñible unicamente
	  se está instalado X-13ARIMA-SEATS. Cando omites o feixe necesario para
	  o segundo argumento (opcional), o axuste estacional faise incluíndo
	  tódalas opcións de X-13ARIMA establecidas nos seus valores por defecto
	  (procedemento completamente automático). Cando indicas o feixe de
	  <argname>opcions</argname>, se podería incluír calquera das seguintes
	  especificacións para as opcións.
	</para>
	<ilist>
	  <li>
	    <para>
	      <lit>verbose</lit>: Que presentar? 0 = nada (por defecto);
	      1 = confirmación das opcións que están seleccionadas;
	      2 = confirmación das opcións máis o resultado de
	      X-13ARIMA.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>seats</lit>: 1 para utilizar o algoritmo SEATS en troques
	      do algoritmo predeterminado X11 para o axuste estacional, ou
	      0.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>airline</lit>: 1 para utilizar a especificación <quote>airline</quote>
	      (0,1,1)(0,1,1) de modelos ARIMA en troques da selección de modelos
	      automática predeterminada, ou 0.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>arima</lit>: Pode utilizarse para impoñer unha especificación
	      ARIMA escollida, en formato dun vector de 6 elementos que conteña
	      números enteiros baixos e non negativos. Estes se indican coa
	      simboloxía (p,d,q,P,D,Q) da notación tradicional das series de
	      tempo: os primeiros tres termos representan as ordes AR, de
	      Integración e MA non estacionais; e os tres derradeiros indican
	      as contrapartidas estacionais. Cando se indican tanto a opción
	      <lit>airline</lit> como a <lit>arima</lit>, ten prioridade a
	      <lit>arima</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>outliers</lit>: Permite a detección e corrección de valores
	      atípicos (eleccións de 1 ata 7), ou 0 (o predeterminado) para
	      omitir esta característica. Os tres tipos de valores atípicos
	      dispoñibles cos seus códigos numéricos son: 1 = valor atípico
	      aditivo (ao), 2 = paso de nivel (ls), 4 = cambio temporal (tc).
	      Para combinar as opcións podes engadir códigos, por exemplo:
	      1 + 2 + 4 = 7 para activar as tres a un tempo. Cae na conta de
	      que a elección 3 = 1 + 2 (ao con ls) é a predeterminada en
	      X-13ARIMA-SEATS, e se selecciona mediante o cadriño de valores
	      atípicos na xanela de diálogo de GRETL para o axuste estacional
	      por medio de X13.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>critical</lit>: Un escalar positivo co valor crítico para
	      definir os valores atípicos, sendo automático o predeterminado
	      que se fai en función do tamaño da mostra. Relevante só cando
	      indicas a opción <lit>outliers</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>logtrans</lit>: Debería pasarse a serie de entrada a
	      logaritmos? 0 = non, 1 = si, 2 = selección automática (por
	      defecto). Cae na conta de que non se recomenda que indiques
	      unha serie de entrada xa en logaritmos; se queres que se utilice o
	      logaritmo, indica o nivel <quote>de base</quote> pero especificando
	      despois <lit>logtrans=1</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>trading_days</lit>: Deberían incluírse os días de operación?
	      0 = no, 1 = si, 2 = automático (o predeterminado).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>working_days</lit>: Unha versión máis simple de
	      <lit>trading_days</lit> cunha única distinción entre días da
	      semana e fins de semana, en vez dos efectos dos días particulares.
	      0 = no (o predeterminado), 1 = si, 2 = automático. Utiliza só
	      unha das dúas opcións, <lit>trading_days</lit> ou
	      <lit>working_days</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>easter</lit>: 1 para permitir o efecto da Pascua, como
	      complemento a <lit>trading_days</lit> ou a <lit>working_days</lit>,
	      ou 0 (o predeterminado).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>output</lit>: Unha cadea de texto para escoller o tipo de serie
	      do resultado: <lit>"sa"</lit> para desestacionalizado (o
	      predeterminado), <lit>"trend"</lit> para a tendencia estimada,
	      ou <lit>"irreg"</lit> para a compoñente irregular.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>save_spc</lit>: Indicador booleano, 0 por defecto; mira abaixo.
	    </para>
	  </li>
	</ilist>
	<subhead>Resultados ampliados</subhead>
	<para>
	  Nalgúns casos poderías querer obter os tres resultados dispoñibles
	  do X-13ARIMA mediante unha única chamada a <lit>deseas</lit>. Isto
	  se admite do seguinte xeito. Pasa o feixe <argname>opcions</argname>
	  en formato de punteiro, e indica a cadea de texto <lit>"all"</lit>
	  baixo a chave <lit>output</lit>. O valor directo que se devolve entón
	  é a serie axustada estacionalmente, mais cando se completa con
	  éxito <argname>opcions</argname> vai conter unha matriz denominada
	  <lit>results</lit> con tres columnas: axustada estacionalmente,
	  tendencia e irregular. A continuación tes un exemplo (no que se
	  descarta o valor do resultado directo).
	</para>
	<code>
	  bundle b = _(output="all")
	  deseas(y, &amp;b)
	  series y_dseas = b.results[,1]
	  series y_trend = b.results[,2]
	  series y_irreg = b.results[,3]
	</code>
	<subhead>Gardando a especificación de X-13ARIMA</subhead>
	<para>
	  Podes utilizar o indicador <lit>save_spc</lit> para gardar o contido
	  do ficheiro de entrada X-13ARIMA que escribe GRETL. O feixe coas
	  opcións debe pasarse en formato de punteiro, e a especificación
	  (como cadea de texto) pode atoparse baixo a chave <lit>x13a_spc</lit>.
	  O seguinte código ilustra como se garda esta nun ficheiro baixo o
	  nome <lit>especif.spc</lit> no directorio de traballo do usuario.
	  (Cae na conta de que a extensión <lit>.spc</lit> é requirida polo
	  X-13ARIMA.)
	</para>
	<code>
	  bundle b = _(save_spc=1)
	  deseas(y, &amp;b)
	  outfile especif.spc
	     print b.x13a_spc
	  end outfile
	</code>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor do determinante de <argname>A</argname>,
	  calculado mediante a descomposición LU. Se o que realmente queres é o
	  logaritmo natural do determinante, debes en troques invocar <fncref targ="ldet"/>.
	  <seelist>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diag" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna cos valores da diagonal principal de
	  <argname>X</argname>. Advirte que se <argname>X</argname> é unha
	  matriz de orde <by r="m" c="n"/>, o número de elementos do vector
	  resultante é igual a min(<math>m</math>, <math>n</math>).
	  <seelist>
            <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coa suma directa de <argname>A</argname> e
	  <argname>B</argname>; é dicir, unha matriz que abrangue a
	  <argname>A</argname> no recanto superior esquerdo e a
	  <argname>B</argname> no recanto inferior dereito. Se
	  <argname>A</argname> e <argname>B</argname> son ambas
	  cadradas, a matriz resultante é diagonal por bloques.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do mesmo tipo que o argumento) coas primeiras
	  diferenzas. Se <argname>y</argname> é unha serie ou unha lista de series,
	  os valores iniciais son <lit>NA</lit>; se <argname>y</argname> é unha
	  matriz, a diferenciación faise por columnas e os valores iniciais son 0.
	</para>
	<para>
	  Cando esta función devolve unha lista, cada unha das variables
	  da mesma noméase de xeito automático conforme ao padrón
	  <lit>d_</lit><repl>varname</repl>, onde <repl>varname</repl>
	  substitúese polo nome da serie orixinal. De ser necesario, o nome
	  vai tronzarse; e mesmo axustarase no caso de que o conxunto de
	  nomes que se constrúe así, dea lugar a que algún deles non sexa
	  único.
	</para>
	<para>
	  <seelist>
            <fncref targ="cum"/>
            <fncref targ="ldiff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un resultado (do tipo do argumento) co valor da función
	  digamma (ou Psi) de <argname>x</argname>, é dicir, a derivada do
	  logaritmo da función Gamma.
	</para>
	<para context="tex">
	  Devolve un resultado co valor da función digamma (ou Psi) de $x$, é
	  dicir $\frac {\mathrm{d}} {\mathrm{d} x}\, \log \Gamma(x)$.
	</para>
	<para>
	  <seelist>
            <fncref targ="lngamma"/>
            <fncref targ="trigamma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="distance" section="math" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="string">metrica</fnarg>
	<fnarg optional="true" type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula as distancias entre puntos sobre unha métrica que pode ser
	  <lit>euclidean</lit> (a predeterminada), <lit>manhattan</lit>,
	  <lit>hamming</lit>, <lit>chebyshev</lit>, <lit>cosine</lit> ou
	  <lit>mahalanobis</lit>. Podes indicar a cadea de texto que identifica
	  á métrica, tronzándoa de xeito que non resulte ambigua. As outras
	  métricas adicionais, de correlación e a euclídea tipificada se admiten
	  mediante transformacións simples das anteriores (mira máis abaixo).
	</para>
	<para>
	  Cada fila da matriz <argname>X</argname> (que é <by r="m" c="n"/>)
	  trátase como un punto dun espazo <math>n</math>-dimensional; nun
	  contexto econométrico, isto probablemente represente unha única
	  observación que abranga os valores de <math>n</math>
	  variables.
	</para>
	<subhead>Casos típicos</subhead>
	<para>
	  Esta sección se aplica a tódaslas métricas, agás á distancia de
	  Mahalanobis, para a que a sintaxe é lixeiramente diferente
	  (mira máis abaixo).
	</para>
	<para>
	  Se non indicas <argname>Y</argname>, o valor que se devolve é un
	  vector columna de longura <math>m</math>(<math>m</math> &minus; 1)/2
	  que abrangue o subconxunto non redundante de tódalas distancias por
	  parellas entre os <math>m</math> puntos (as filas de <argname>X</argname>).
	  Entón, dado un vector deste tipo que teña por nome <lit>d</lit>,
	  podes xerar a matriz simétrica completa coas distancias entre os
	  puntos (con ceros na diagonal principal, naturalmente) por medio
	  de
	</para>
	<code>
	  D = unvech(d, 0)
	</code>
	<para>
	  posto que <lit>d</lit> é semellante ao vector columna resultante de
	  aplicar a función vech sobre <lit>D</lit>, sen os elementos da diagonal
	  principal. O segundo argumento (opcional) de <fncref targ="unvech"/>
	  indica que debe encherse a diagonal con ceros.
	</para>
	<para>
	  Se indicas <argname>Y</argname>, debe ser unha matriz <by r="p" c="n"/>
	  na que cada unha das súas filas se trata novamente como un punto no
	  espazo <math>n</math>-dimensional. Neste caso, o valor que se devolve
	  é unha matriz <by r="m" c="p"/> cuxo elemento <math>i,j</math> contén
	  a distancia que hai entre a fila <math>i</math> da matriz
	  <argname>X</argname> e a fila <math>j</math> da matriz
	  <argname>Y</argname>.
	</para>
	<para>
	  Para obter as distancias desde un punto de referencia dado (por exemplo,
	  o centroide) ata cada un dos <math>n</math> puntos de datos, indica
	  <argname>Y</argname> como unha única fila.
	</para>
	<subhead>Definicións das métricas admitidas</subhead>
	<ilist>
	  <li>
	    <para>
	      <lit>euclidean</lit>: a raíz cadrada da suma dos desvíos elevados
	      ao cadrado, en cada unha das dimensións.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>manhattan</lit>: a suma dos valores absolutos dos desvíos,
	      en cada unha das dimensións.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>hamming</lit>: a proporción das dimensións nas que os
	      desvíos non son nulos (acoutada entón por 0 e 1).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>chebyshev</lit>: o maior dos valores absolutos dos desvíos
	      en calquera das dimensións.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>cosine</lit>: 1 menos o coseno do ángulo que se forma entre
	      os <quote>puntos</quote>, considerados como vectores.
	    </para>
	  </li>
	</ilist>
	<subhead>Distancia de Mahalanobis</subhead>
	<para>
	  As distancias de Mahalanobis defínense como distancias euclídeas,
	  entre os puntos considerados (filas da matriz <argname>X</argname>)
	  e un centroide dado, escaladas mediante a inversa dunha matriz de
	  covarianzas. No caso máis sinxelo, o centroide está constituído polas
	  medias na mostra das variables (columnas de <argname>X</argname>)
	  e a matriz de covarianzas está formada polas covarianzas entre elas
	  na mostra.
  </para>
  <para>
	  Isto pódese obter indicando como segundo argumento a cadea de texto
	  <quote>mahalanobis</quote> ou calquera abreviatura non ambigua,
	  como en
	</para>
	<code>
	  dmahal = distance(X, "mahal")
	</code>
	<para>
    Neste caso, o terceiro argumento <argname>Y</argname> non se
    admite, e o valor que se devolve é un vector columna de longura
    <math>m</math> coas distancias de Mahalanobis desde o centroide
    de <argname>X</argname> (é dicir, a súa media na mostra). Na
    práctica, a matriz do resultado neste caso é a mesma que obtés ao
    executar a instrución <cmdref targ="mahal"/> sobre unha listaxe
    de series que se correspondan coas columnas da matriz
    <argname>X</argname>.
	</para>
	<para>
	  Para obter as distancias de Mahalanobis usando un centroide
	  distinto, <lit>mu</lit>, e/ou a inversa da matriz de covarianzas,
	  <lit>ICV</lit>, podes utilizar a seguinte sintaxe:
	</para>
	<code>
	  dmahal = distance(X*cholesky(ICV), "euc", mu)
	</code>
	<subhead>Outras métricas</subhead>
	<para>
	  Podes obter as distancias euclídeas tipificadas e as de correlacións
	  do seguinte xeito:
	</para>
	<code>
	  # Euclídea tipificada
	  dseu = distance(stdize(X), "eu")
	  # Correlación (baseada no coseno)
	  dcor = distance(stdize(X', -1)', "cos")
	</code>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do mesmo tipo que o argumento) co valor da
	  densidade da distribución de probabilidade Normal estándar en
	  <argname>x</argname>. Para obter a densidade dunha distribución Normal
	  non estándar en <math>x</math>, transforma tipificando <math>x</math>
	  en <math>z</math>, aplícalle a isto a función <lit>dnorm</lit> e
	  multiplica o resultado polo Jacobiano da transformación <math>z</math>,
	  é dicir , 1/&sigma;, conforme se ilustra deseguido:
	</para>
	<code>
	  mu = 100
	  sigma = 5
	  x = 109
	  fx = (1/sigma) * dnorm((x-mu)/sigma)
	</code>
	<para>
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha lista cos mesmos elementos que <argname>X</argname>,
	  mais excluíndo as series que causan multicolinearidade perfecta. En
	  consecuencia, se todas as series que hai en <argname>X</argname>
	  son linearmente independentes, a lista que resulta é simplemente
	  unha copia de <argname>X</argname>.
	</para>
	<para>
	  O algoritmo usa a descomposición QR (transformación de Householder),
	  polo que está suxeito a erro de precisión finita. Co obxecto de
	  calibrar a sensibilidade do algoritmo, podes especificar un segundo
	  parámetro (opcional) <argname>epsilon</argname> para facer a proba
	  de multicolinearidade máis ou menos estrita, segundo desexes. Por
	  defecto, o valor para <argname>epsilon</argname> é 1.0e-8, pero
	  axustando <argname>epsilon</argname> dándolle valores maiores,
	  elévase a probabilidade de que se descarte unha das series.
	</para>
	<para>
	  O exemplo
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # Indica un épsilon cun valor moi pequeno
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produce
	</para>
	<code>
	  ? list print X
	  foo bar foobar
	  ? list print Y
	  foo bar
	  ? list Y = dropcoll(X, 1.0e-30)
	  Substituíuse a lista Y
	  ? list print Y
	  foo bar foobar
	</code>
      </description>
    </function>

    <function name="dsort" section="matrix" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordena <argname>x</argname> de forma decrecente, descartando
	  observacións con valores ausentes cando <argname>x</argname> é
	  unha serie.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>x</argname> debe de ser unha serie discreta. Esta
	  función devolve unha lista cun conxunto de variables ficticias, unha
	  para cada un dos diferentes valores da serie. Por defecto, o menor
	  valor trátase como a categoría omitida e non vai representarse
	  explicitamente.
	</para>
	<para>
	  O segundo argumento (opcional) indica o valor de <argname>x</argname>
	  que debe de tratarse como categoría omitida. Cando se indica un único
	  argumento, o efecto é equivalente ao de utilizar a instrución:
	  <lit>dummify(x, min(x))</lit>. Para producir un conxunto completo de
	  variables ficticias, é dicir, sen omitir ningunha categoría, podes
	  usar <lit>dummify(x, NA)</lit>.
	</para>
	<para>
	  As variables que se xeran noméanse automaticamente de acordo co
	  seguinte padrón:
	  <lit>D</lit><repl>nomevariable</repl><lit>_</lit><repl>i</repl> onde
	  <repl>nomevariable</repl> indica o nome da serie orixinal e <repl>i</repl>
	  é un índice enteiro positivo. De ser necesario, a porción orixinal do
	  nome vai tronzarse, e mesmo axustarase no caso de que o conxunto de
	  nomes que se constrúe así, dea lugar a que algún deles non sexa
	  único.
	</para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Poñendo un ano como argumento <argname>y</argname>, devolve un
	  resultado do mesmo tipo ca este, coa data do domingo de Pascua dese
	  ano no calendario gregoriano, co formato <math>mes + día/100</math>.
	  Por exemplo, en 2014 a data do domingo de Pascua foi o 20 de abril,
	  o que se representa con esta convención como 4,2. (Cae na conta de que
	  o día 2 de abril devólvese como 4,02.) O seguinte código amosa como
	  poden extraerse o día e o mes do valor que devolve esta función:
	</para>
	<code>
	  scalar e = easterday(2014)
	  scalar m = floor(e)
	  scalar d = round(100*(e-m))
	</code>
      </description>
    </function>

    <function name="ecdf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a función de distribución acumulativa (CDF) empírica de
	  <argname>y</argname>. O resultado devólvese en formato de matriz
	  con dúas columnas: a primeira contén os valores únicos ordenados de
	  <argname>y</argname>; e a segunda contén a frecuencia relativa 
	  acumulada, é dicir o número de casos nos que o seu valor é menor ou
	  igual ao valor correspondente da primeira columna, dividido polo
	  número total de observacións.
	</para>
	<para context="tex">
	  Calcula a función de distribución acumulativa (CDF) empírica de
	  <argname>y</argname>. O resultado devólvese en formato de matriz
	  con dúas columnas: a primeira contén os valores únicos ordenados de
	  <argname>y</argname>; e a segunda contén a frecuencia relativa acumulada
	  \[ F(y) =
	  \frac{1}{n} \sum_{i=1}^n I(y_i \leq y)
	  \]
	  onde $n$ é o número total de observacións, e $I()$ denota a función
	  indicadora.
	</para>
      </description>
    </function>

    <function name="eigen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
	<fnarg type="matrixref" optional="true">&amp;W</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula os autovalores (e opcionalmente os autovectores dereitos
	  e/ou esquerdos) da matriz <argname>A</argname> de dimensión
	  <by r="n" c="n"/>, que pode ser real ou complexa. Os autovalores
	  devólvense nun vector columna complexo. Para obter a norma dos
	  autovalores podes utilizar a función <fncref targ="abs"/>, que
	  admite argumentos complexos.
	</para>
	<para>
	  Se queres recuperar os autovectores dereitos (como no caso dunha
	  matriz complexa de dimensión <by r="n" c="n"/>), indica o nome
	  dunha matriz xa existente, precedido por <lit>&amp;</lit> para
	  indicar a <quote>dirección</quote> da matriz en cuestión, como
	  segundo argumento. Doutro xeito, podes omitir este argumento.
	</para>
	<para>
	  Para recuperar os autovectores esquerdos (de novo, como nunha
	  matriz complexa), indica a dirección dunha matriz como terceiro
	  argumento. Cae na conta de que, se queres os autovectores esquerdos
	  pero non os dereitos, debes usar a palabra chave <lit>null</lit>
	  como marcador para o segundo argumento.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona da mesma forma que a función <fncref targ="eigen"/>,
	  agás que o argumento <argname>A</argname> debe de ser simétrico
	  (polo que, neste caso, pódense acurtar os cálculos), e os
	  autovalores devólvense en orde ascendente. Se desexas obter os
	  autovalores en orde descendente (e ter os autovectores reordenados
	  en consecuencia), podes facer o seguinte:
	</para>
	<code>
	  matrix U
	  e = eigensym(A, &amp;U)
	  Tmp = msortby((-e' | U)',1)'
	  e = -Tmp[1,]'
	  U = Tmp[2:,]
	  # Agora os autovalores de maior a menor
	  print e U
	</code>
	<para>
	  Aviso: Se o que te interesa é a descomposición espectral
	  dunha matriz da forma <math>X'X</math>, é preferible calcular
	  o argumento a través do operador <lit>X'X</lit>, en lugar de
	  utilizar a sintaxe máis xeral <lit>X'*X</lit>. A primeira
	  expresión utiliza un algoritmo especializado que ofrece maior
	  eficiencia dende o punto de vista do cómputo, e garante que o
	  resultado vai ser exactamente simétrico.
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Resolve o problema do autovalor xeneralizado de tipo
	  |<math>A</math> &minus; &lgr;<math>B</math>| = 0, onde ambas
	  <math>A</math> e <math>B</math> son matrices simétricas, e
	  <math>B</math> defínese positiva. Devólvese directamente unha matriz
	  cos autovalores ordenados de forma ascendente. Cando utilizas o
	  terceiro argumento (opcional), este debe de ser o nome dunha matriz xa
	  existente, precedida por <lit>&amp;</lit>. Neste caso, os autovectores
	  xeneralizados escríbense nesta matriz que se indica.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">día</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar ou unha serie, co número do día especificado polo
	  ano, mes e día, nesa orde, na época actual. O número do día é igual
	  a 1 para o día 1 de xaneiro do ano 1 despois de Cristo, no calendario
	  Gregoriano proléptico, e a 733786 para a data 01-01-2010. Se algún
	  dos argumentos é unha serie, o valor que se devolve tamén terá a
	  forma dunha serie; noutro caso, devólvese un escalar.
	</para>
	<para>
	  Por defecto, os valores dos argumentos <argname>ano</argname>,
	  <argname>mes</argname> e <argname>día</argname> se
	  presupón que se están indicando de acordo co calendario Gregoriano,
    mais se o ano ten un valor negativo, a interpretación muda á do
    calendario Xuliano.
	</para>
	<para>
	  Tamén admítese unha petición alternativa: se indicas un único
	  argumento, vaise considerar que é unha data (ou unha serie de
	  datas) en formato numérico ISO 8601 <quote>básico</quote>,
	  <lit>YYYYMMDD</lit>. Deste xeito, as seguintes dúas peticións
	  producen o mesmo resultado, en concreto 700115.
	</para>
	<code>
	  eval epochday(1917, 11, 7)
	  eval epochday(19171107)
	</code>
	<para>
	  Para a inversa desta función consulta <fncref targ="isodate"/>, e
	  tamén <fncref targ="juldate"/> (para o calendario Xuliano). Para
	  ver outros medios de conversión de datas en días de época, consulta
	  <fncref targ="strpday"/>.
	</para>
      </description>
    </function>

    <function name="errmsg" section="programming" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto coa mensaxe de fallo do GRETL asociada
	  a <argname>errno</argname>, que debe de ser un número enteiro.
	  Consulta tamén <fncref targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="errorif" section="programming" output="scalar">
      <fnargs>
	<fnarg type="bool">condicion</fnarg>
	<fnarg type="string">mensaxe</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función só se aplica no contexto dunha función definida polo
	  usuario, ou dentro dun bloque <cmdref targ="mpi"/>. Se a
	  <argname>condicion</argname> se valora como non nula,
	  iso implica que a execución da función vixente remate coa presentación
	  dunha mensaxe condicionada a que se produza un fallo; entón o
	  argumento <argname>mensaxe</argname> vaise presentar como parte
	  da mensaxe de fallo que se amosa ao chamar á función en cuestión.
	</para>
	<para>
	  O valor que se devolve con esta función (1) é simplemente nominal.
	</para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar non nulo se <argname>nome</argname> (que debe ser
	  un identificador válido de GRETL) denomina un obxecto cunha definición
	  vixente, sexa un escalar, unha serie, unha matriz, unha lista, unha
	  cadea de texto, un feixe ou un arranxo. Noutro caso devolve 0.
	</para>
	<para>
	  O uso pretendido disto é para o caso no que unha función definida
	  polo usuario teña un parámetro opcional cun <lit>nulo</lit> por
	  defecto. O redactor da función pode utilizar <lit>exists()</lit>,
	  indicando o nome do parámetro, para comprobar se o chamador
	  proporciona un argumento. Por favor, pero ten en conta que as listas
	  son unha excepción a este respecto: se un parámetro dunha lista
	  ten un <lit>nulo</lit> por defecto e o chamador non proporciona un
	  argumento, a función colle unha lista baleira en lugar de non tomar
	  ningunha lista; en consecuencia, a función <lit>exists</lit> sempre
	  vai devolver non nulo. Para comprobar o baleiro no argumento de
	  unha lista, utiliza <fncref targ="nelem"/>.
	</para>
	<para>
	  Para comprobacións relacionadas, consulta <fncref targ="typeof"/>
	  e <fncref targ="inbundle"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) con <math>e</math><sup>x</sup>.
	  Cae na conta de que con argumento matricial, aplícase elemento a elemento.
	  Para a función exponencial matricial consulta <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-list-or-mat">f</fnarg>
	<fnarg optional="true" type="bool">U2</fnarg>
      </fnargs>
      <description>
	<para>
	  Xera unha matriz que contén varios estatísticos que serven
	  para avaliar a <argname>f</argname> como predición dos datos
	  observados <argname>y</argname>.
	</para>
	<para>
	  Cando <argname>f</argname> é unha serie ou un vector, o resultado
	  é un vector columna. Cando <argname>f</argname> é unha lista con
	  <math>k</math> elementos ou unha matriz de dimensión <by r="T" c="k"/>,
	  o resultado ten <math>k</math> columnas nas que cada unha contén
	  os estatísticos do termo correspondente (serie da lista ou columna
	  da matriz) como predición de <argname>y</argname>.
	</para>
	<para>
	  En tódolos casos, a dimensión <quote>vertical</quote> dos datos
	  introducidos (o longo da mostra vixente para unha serie ou lista,
	  e o número de filas para unha matriz) debe de coincidir entre os dous
	  argumentos.
	</para>
	<para>
	  As filas da matriz que se devolve son como se indica deseguido:
	</para>
	<code>
	  1  Media dos erros
	  2  Raíz do erro cadrado medio
	  3  Media dos valores absolutos dos erros
	  4  Media dos erros relativos, en porcentaxe
	  5  Media dos valores absolutos dos erros relativos, en porcentaxe
	  6  U de Theil (U1 ou U2)
	  7  Proporción de nesgo, UM
	  8  Proporción de regresión, UR
	  9  Proporción de perturbación, UD
	</code>
	<para>
	  A variante do U de Theil que se presenta por defecto depende da
	  natureza dos datos: cando se sabe que son series de tempo, amósase
	  o U2; noutro caso, prodúcese o U1. Pero podes forzar esta elección
	  mediante o derradeiro argumento opcional: indica un valor non nulo
	  para forzar o U2, ou un valor de cero para forzar o U1.
	</para>
	<para>
	  Para obter máis detalles sobre o cálculo deses estatísticos e da
	  interpretación dos valores de <math>U</math>, consulta o
	  <guideref targ="chap:forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">chamaf</fnarg>
	<fnarg optional="true" type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite calcular unha aproximación numérica ao Jacobiano
	  asociado ao <math>n</math>-vector <argname>b</argname>,
	  así como a función de transformación especificada polo
	  argumento <argname>chamaf</argname>. Ao apelar a esta función
	  debes de utilizar <argname>b</argname> como primeiro argumento
	  da mesma (ben directamente ou en forma de punteiro), seguido
	  de calquera argumento adicional que poda necesitarse; e como
	  resultado debérase producir unha matriz <by r="m" c="1"/>.
	  Cando se executa con éxito, <lit>fdjac</lit> vai devolver
	  unha matriz <by r="m" c="n"/> que contén o Jacobiano.
	</para>
	<para>
	  Podes utilizar o terceiro argumento (opcional) para determinar o
	  tamaño da medida <math>h</math> que se usa no mecanismo de
	  aproximación (mira máis abaixo). Cando omites este argumento, o
	  tamaño da medida determínase automaticamente.
	</para>
	<para>
	  Aquí tes un exemplo do seu uso:
	</para>
	<code>
	  matrix J = fdjac(theta, mifunc(&amp;theta, X))
	</code>
	<para>
	  A función pode utilizar tres métodos distintos: diferenza simple cara
	  adiante, diferenza bilateral ou extrapolación de 4-nodos de Richardson.
	  Estas correspóndense respectivamente con:
	</para>
	<para context="tex">
	  \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
	</para>
	<para context="tex">
	  \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
	</para>
	<para context="tex">
	  \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
	</para>
	<para context="notex">
	  <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>2</sub>  = <math>[8(f(x+h) - f(x-h)) -
	  (f(x+2h) - f(x-2h))] /12h</math>
	</para>
	<para>
	  Estas tres alternativas xeralmente proporcionan unha conciliación
	  entre precisión e velocidade. Podes elixir entre os distintos
	  métodos mediante a instrución <cmdref targ="set"/>: especifica o
	  valor 0, 1 ou 2 para a variable <lit>fdjac_quality</lit>. O valor
	  por defecto é 0.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	          <fncref targ="numhess"/>
            <cmdref targ="set"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="feval" section="programming" output="seebelow">
      <fnargs>
	<fnarg type="string">nomefuncion</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Fundamentalmente útil para os creadores de funcións. O primeiro
	  argumento debe de ser o nome dunha función; os argumentos
	  restantes se pasarán á función especificada. Isto permite tratar
	  á propia función identificada mediante <argname>nomefuncion</argname>
	  como unha variable en si mesma. O valor que se devolve é calquera
	  cousa que produza a función indicada, dados os argumentos
	  especificados.
	</para>
	<para>
	  O exemplo de abaixo, ilustra algúns dos seus posibles usos.
	</para>
	<code>
	  function scalar utilidade (scalar c, scalar sigma)
	      return (c^(1-sigma)-1)/(1-sigma)
	  end function

	  strings S = defarray("log", "utilidade")

	  # Chamada a unha función integrada de 1 argumento
	  x = feval(S[1], 2.5)
	  # Chamada a unha función definida polo usuario
	  x = feval(S[2], 5, 0.5)
	  # Chamada a unha función integrada de 2 argumentos
	  func = "zeros"
	  m = feval(func, 5-2, sqrt(4))
	  print m
	  # Chamada a unha función integrada de 3 argumentos
	  x = feval("monthlen", 12, 1980, 5)
	</code>
	<para>
	  Existe unha feble semellanza entre a función <lit>feval</lit> e
	  <fncref targ="genseries"/>: ámbalas dúas funcións volven variable
	  a un elemento sintáctico que habitualmente se fixa ao tempo no
	  que se redacta un guión.
	</para>
	<para>
	  <seelist>
            <fncref targ="fevalb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fevalb" section="programming" output="seebelow">
      <fnargs>
	<fnarg type="string">nomefunc</fnarg>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é unha variante da función <fncref targ="feval"/> que afronta unha
	  situación na que se poden atopar os creadores de funcións, cando non
	  se coñece de antemán o número e os tipos de argumentos que se van
	  pasar á función indicada. En troques de que se pasen os argumentos
	  un por un, se pasan como membros dun argumento <argname>b</argname>
	  de tipo feixe.
	</para>
	<para>
	  Posto que orde dos membros dun feixe de GRETL é indeterminada,
	  requírese algún mecanismo para asegurarnos de que estes se pasan
	  á función en cuestión, na orde axeitada. Isto asegúrase de xeito
	  automático se a orde lexicográfica das claves que hai no feixe,
	  indica tamén a orde dos argumentos. Por exemplo, as claves
	  poderían ser <lit>arg1</lit>, <lit>arg2</lit>, etcétera (ou
	  <lit>arg01</lit>, <lit>arg02</lit>, etcétera no improbable caso
	  de que a función tivera máis de nove argumentos). Como alternativa,
	  o feixe pode conter un arranxo de cadeas de texto baixo a
	  clave reservada <lit>arglist</lit>. Este arranxo debe conter
	  exactamente as claves do feixe <argname>b</argname> (agás o
	  propio <lit>arglist</lit>), na orde
	  desexada.
	</para>
	<para>
	  Os exemplos de abaixo ilustran ámbalas dúas propostas, aplicadas á
	  función <fncref targ="monthlen"/>.
	</para>
	<code>
	  # Utilizando a orde lexicográfica
	  bundle b = _(arg1=12, arg2=1980, arg3=5)
	  n = feval("monthlen", b)

	  # Utilizando arglist
	  bundle b = _(month=12, year=1980, wkdays=5)
	  b.arglist = defarray("month", "year", "wkdays")
	  n = feval("monthlen", b)
	</code>
	<para>
	  <seelist>
            <fncref targ="feval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fevd" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="int">efecto</fnarg>
	<fnarg type="int">motivo</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función proporciona unha alternativa máis flexible ca o
	  accesorio <fncref targ="$fevd"/> para obter unha matriz
	  de descomposición da varianza do erro de predición (FEVD),
	  logo de estimar un VAR ou un VECM. Se falta o argumento final
	  (opcional), só está dispoñible cando o último modelo estimado
	  foi un VAR ou un VECM. Como alternativa, podes gardar nun
	  feixe a información sobre estes tipos de sistemas, mediante o
	  accesorio <fncref targ="$system"/>, e posteriormente pasarlle
	  a función <lit>fevd</lit>.
	</para>
	<para>
	  Os argumentos da función, <argname>efecto</argname> e
	  <argname>motivo</argname>, teñen a forma de índices enteiros
	  positivos das variables endóxenas do sistema, tomando o 0 para
	  representar <quote>todas</quote>. O seguinte fragmento de código,
	  ilustra o seu uso. No primeiro exemplo, a matriz <lit>fe1</lit>
	  contén as partes da FEVD para <lit>y1</lit> debidas a cada
	  parte de <lit>y1</lit>, <lit>y2</lit> e <lit>y3</lit> (polo tanto,
	  as filas suman 1 en total). No segundo, <lit>fe2</lit> contén
	  a contribución de <lit>y2</lit> á varianza do erro de predición
	  das tres variables (entón, as filas non suman 1 en total).
	  No terceiro caso, o que se devolve é un vector columna que
	  amosa a <quote>parte propia</quote> da FEVD de
	  <lit>y1</lit>.
	</para>
	<code>
	  var 4 y1 y2 y3
	  bundle vb = $system
	  matrix fe1 = fevd(1, 0, vb)
	  matrix fe2 = fevd(0, 2, vb)
	  matrix fe3 = fevd(1, 1, vb)
	</code>
	<para>
	  O número de períodos (filas) sobre os que se traza a
	  descomposición, determínase automaticamente en base á
	  frecuencia dos datos, pero podes ignorar isto mediante o
	  argumento <lit>horizon</lit> da instrución <cmdref targ="set"/>,
    como en <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="irf"/></seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co resultado da transformación discreta de
	  Fourier. A matriz <argname>X</argname> do argumento pode ser
	  real ou complexa. O resultado é unha matriz complexa que ten
	  a mesma dimensión ca <argname>X</argname>.
	</para>
	<para>
	  Se fora necesario calcular a transformación de Fourier sobre
	  varios vectores co mesmo número de elementos, é máis eficiente
	  agrupalos nunha matriz, en troques de executar <lit>fft</lit>
	  para cada vector por separado.
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz con <math>n</math> columnas, co resultado da
	  transformación inversa de Fourier discreta. Asúmese que a matriz
	  <argname>X</argname> consta de <math>n</math> vectores columna complexos.
	</para>
	<para>
	  Cando necesites aplicar a transformación inversa de Fourier
	  sobre varios vectores co mesmo número de elementos, resulta
	  máis eficiente agrupar os vectores nunha matriz ca executar
	  <lit>ffti</lit> para cada un
	  por separado.
	  <seelist>
            <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="timeseries" output="seebelow">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
	<fnarg optional="true" type="scalar-or-vec">x0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o resultado de aplicar un filtro semellante a un ARMA, ao
	  argumento <argname>x</argname>. A transformación pode escribirse como
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> =
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub><math>y</math><sub>t-p</sub>
	</para>
	<para>
	  Se o argumento <argname>x</argname> é unha serie, o resultado que se
	  devolve tamén é unha serie. Noutro caso, se <argname>x</argname> é
	  unha matriz con <math>T</math> filas e <math>k</math> columnas, o
	  que se devolve é a matriz do mesmo tamaño que resulta de aplicar o
	  filtro columna por columna.
	</para>
	<para>
	  Os argumentos <argname>a</argname> e <argname>b</argname> son
	  opcionais. Poden ser escalares, vectores ou a palabra chave
	  <lit>null</lit>.
	</para>
	<para>
	  Cando <argname>a</argname> é un escalar, vaise utilizar como
	  <math>a</math><sub>0</sub> e iso implicará que <math>q=0</math>.
	  Cando é un vector con <math>q+1</math> elementos, vai conter
	  os coeficientes dende <math>a</math><sub>0</sub> ata
	  <math>a</math><sub>q</sub>. Cando <argname>a</argname> é
	  <lit>null</lit> ou se omite, isto é equivalente a definir
	  <math>a</math><sub>0</sub> <math>=1</math> e
	  <math>q=0</math>.
	</para>
	<para>
	  Cando <argname>b</argname> é un escalar, vaise utilizar como
	  <math>b</math><sub>1</sub> e implicará que <math>p=1</math>.
	  Cando é un vector con <math>p</math> elementos, vai conter
	  os coeficientes dende <math>b</math><sub>1</sub> ata
	  <math>b</math><sub>p</sub>. Cando <argname>b</argname> é
	  <lit>null</lit> ou se omite, isto é equivalente a definir
	  <math>B(L)=1</math>.
	</para>
	<para>
	  O argumento escalar opcional <argname>y0</argname> utilízase para
	  representar todos os valores de <math>y</math> anteriores ao comezo
	  da mostra (úsase só cando <math>p &gt; 0</math>). Cando se omite,
	  enténdese que é igual a 0. De forma similar, podes usar o argumento
	  opcional <argname>x0</argname> para especificar un ou máis valores
	  de <math>x</math> anteriores ao comezo da mostra (información só
	  relevante cando <math>q &gt; 0</math>). Doutro xeito, asúmese que os
	  valores de <argname>x</argname> anteriores ao comezo da mostra son 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
            <fncref targ="fracdiff"/>
            <fncref targ="hpfilt"/>
            <fncref targ="movavg"/>
            <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produce
	</para>
	<code>
          index            y

          1            1     -0,40000
          2            2      1,36000
          3            3      0,27600
          4            4      1,75160
          5            5      0,92356

          x (5 x 2)

          1   1
          2   0
          3   0
          4   0
          5   0

          w (5 x 2)

          -0,40000     -0,40000
           1,3600       0,36000
           0,27600     -0,32400
           1,7516       0,29160
           0,92356     -0,26244
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">namostra</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número enteiro positivo que indexa a primeira observación
	  non ausente da serie <argname>y</argname>. Por defecto, analízase
	  todo o rango da mostra, de xeito que, se está activa algunha forma
	  de submostraxe, o valor que se devolve pode ser menor ca o valor
	  devolto polo accesorio <fncref targ="$t1"/>. Pero se indicas un
	  valor non nulo en <argname>namostra</argname>, só vai terse en
	  conta o rango da mostra vixente.
	  <seelist>
            <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">nomesobrio</fnarg>
	<fnarg type="bool" optional="true">underscore</fnarg>
      </fnargs>
      <description>
	<para>
	  En principio, esta función está ideada para utilizarse en conxunto coa instrución
	  <cmdref targ="join"/>. Devolve unha cadea co resultado da conversión
	  de <argname>nomesobrio</argname> nun identificador válido de GRETL;
	  debe iniciarse cunha letra, debe de conter só letras ASCII, díxitos
	  e/ou guión baixo, e non debe de ter máis ca 31 caracteres. As regras
	  que se utilizan na conversión son:
	</para>
	<para>
	  1. Quitar, do inicio do nome, calquera carácter que non sexa unha letra.
	</para>
	<para>
	  2. Ata que se acada o límite dos 31 caracteres ou ata que se esgota o
	  indicado no argumento: transcribe os caracteres <quote>legais</quote>,
	  substitúe un ou varios espazos consecutivos por un guión baixo
	  (agás que o carácter anterior transcrito sexa un guión baixo,
	  pois entón elimínase o espazo), e omite os outros tipos de caracteres
	  <quote>ilegais</quote>.
	</para>
	<para>
	  Se estás convencido de que a entrada non é demasiado longa (entón
	  susceptible de ser tronzada), podes querer substituír secuencias
	  de un ou máis caracteres ilícitos mediante un guión baixo
	  (en troques de só eliminalos) pois isto podería xerar un identificador
	  máis lexible. Para acadar este efecto, proporciona un valor non
	  nulo para o segundo argumento (opcional). Mais isto non é
	  recomendable no contexto da instrución <cmdref targ="join"/>,
	  posto que o nome <quote>fixado</quote> automaticamente non
	  vai utilizar guións baixos deste xeito.
	</para>
      </description>
    </function>

    <function name="flatten" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="matrices-or-strings">A</fnarg>
	<fnarg optional="true" type="int-or-string">alt</fnarg>
      </fnargs>
      <description>
	<para>
	  <quote>Achanza</quote> ben un arranxo de matrices nunha única
	  matriz, ou ben un arranxo de cadeas de texto nunha única cadea.
	</para>
        <subhead>Matrices</subhead>
	<para>
	  No caso das matrices, o xeito no que se xuntan as matrices de
	  <argname>A</argname> depende do argumento <argname>alt</argname>,
	  que debe ter un valor de 0 (horizontalmente), 1 (verticalmente)
	  ou 2 (<quote>tipo vector</quote>). O mellor xeito de explicar
	  a diferenza entre as tres alternativas é, por exemplo,
	  o código:
	</para>
	<code>
	  X = {1,3,5; 2,4,6}
	  A = defarray(X, X+6)
	  U = flatten(A,0) # = A[1] ~ A[2]
	  V = flatten(A,1) # = A[1] | A[2]
	  W = flatten(A,2) # = vec(A[1]) ~ vec(A[2])
	</code>
	<para>
	  que xera as seguintes tres matrices:
	</para>
	<code>
	  U (2 x 6)

	  1    3    5    7    9   11
	  2    4    6    8   10   12

	  V (4 x 3)

	  1    3    5
	  2    4    6
	  7    9   11
	  8   10   12

	  W (6 x 2)

	  1    7
	  2    8
	  3    9
	  4   10
	  5   11
	  6   12
	</code>
	<para>
	  Amósase un fallo cando as matrices do arranxo non sexan convenientes
	  para a operación. Consulta a función <fncref targ="msplitby"/> para
	  a operación inversa.
	</para>
        <subhead>Cadeas de texto</subhead>
	<para>
	  No caso de cadeas de texto, o resultado por defecto mantén as
	  cadeas de <argname>A</argname>, ordenadas unha en cada liña.
	  Se indicas un valor numérico non nulo para <argname>alt</argname>,
	  as cadeas sepáranse mediante espazos en troques de novas liñas;
	  pero tamén se admite un uso alternativo de <argname>alt</argname>:
	  podes indicar unha cadea de texto específica para utilizar como
	  separador. A función inversa para o caso das cadeas de texto é
	  <fncref targ="strsplit"/>.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor do maior enteiro
	  que é menor ou igual que <argname>x</argname>. Cae na conta de que
	  <fncref targ="int"/> e <lit>floor</lit> teñen efectos distintos
	  con argumentos negativos:<lit>int(-3.5)</lit> xera &minus;3,
	  namentres <lit>floor(-3.5)</lit> xera &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha serie coa diferenza fraccionaria de orde
	  <argname>d</argname> da serie <argname>y</argname>.
	</para>
	<para context="tex">
          \[
          \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
          \]
	  onde
          \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Observa que, en teoría, a diferenciación fraccionaria supón un filtro
	  infinitamente longo. Os valores de <math>y</math><sub>t</sub>
	  anteriores á mostra, na práctica asúmese que son iguais a cero.
	</para>
	<para>
	  Podes utilizar valores negativos para <argname>d</argname>, e nese
	  caso a función realiza a integración fraccionaria.
	</para>
      </description>
    </function>

    <function name="fzero" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar-or-vec">inicio</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Trata de atopar unha raíz simple dunha función continua <math>f</math>
	  (normalmente non linear) &mdash;é dicir, un valor da variable escalar
	  <math>x</math> que fai que <math>f</math>(<math>x</math>) = 0.
	  O argumento <argname>fcall</argname> debe de proporcionar unha
	  chamada á función en cuestión;<argname>fcall</argname> pode
	  incluír un número arbitrario de argumentos, pero o primeiro
	  debe de ser un escalar que represente o papel de <math>x</math>.
	  Cando se complete a función con éxito, vaise devolver o valor
	  da raíz.
	</para>
	<para>
	  O método utilizado é o de <cite key="ridders79">Ridders (1979)</cite>.
	  Isto require un intervalo inicial
	  &lbr;<math>x</math><sub>0</sub>, <math>x</math><sub>1</sub>&rbr;
	  tal que ambos os dous valores <math>x</math> pertenzan
	  ao dominio da función, e que os respectivos valores da
	  función sexan de signo contrario. Probablemente, vas
	  obter mellores resultados se es capaz de proporcionar,
	  mediante o segundo argumento, un vector bidimensional
	  que conteña puntos finais axeitados para o intervalo. Se
	  isto falla, podes proporcionar un único valor escalar, e
	  <lit>fzero</lit> tratará de atopar unha parella. Se omites
	  o segundo argumento, o valor de <math>x</math><sub>0</sub>
	  se inicia cun pequeno número positivo, e logo vaise procurar
	  un valor axeitado para <math>x</math><sub>1</sub>.
	</para>
	<para>
	  Podes usar o argumento <argname>toler</argname> (opcional)
	  para axustar a máxima diferenza absoluta que resulte aceptable
	  entre <math>f</math>(<math>x</math>) e cero, sendo esta igual a
	  1.0e&minus;14 por defecto.
	</para>
	<para>
	  Por defecto, esta función traballa silandeiramente, pero podes
	  amosar a evolución do método iterativo executando a instrución
	  <quote><lit>set max_verbose on</lit></quote> antes de chamar
	  a <lit>fzero</lit>.
	</para>
	<para>
	  Deseguido indícanse algúns exemplos sinxelos:
	</para>
	<code>
	  # Aproximar 'pi' atopando o valor que anula a
	  # función sin() no intervalo de 2.8 a 3.2
	  x = fzero(sin(x), {2.8, 3.2})
	  printf "\nx = %.12f vs pi = %.12f\n\n", x, $pi

	  # Aproximar a 'constante Omega' comezando en x = 0.5
	  function scalar f(scalar x)
	      return log(x) + x
	  end function
	  x = fzero(f(x), 0.5)
	  printf "x = %.12f f(x) = %.15f\n", x, f(x)
	</code>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor da función Gamma de <argname>x</argname>.
	</para>
	<para>
	  Consulta tamén <fncref targ="bincoeff"/> e <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="genseries" section="programming" output="scalar">
      <fnargs>
	<fnarg type="string">nomevar</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciónalle ao guionista un procedemento adecuado para xerar
	  series cuxos nomes non se coñecen a priori; e/ou de crear series e
	  engadilas a unha lista por medio dunha única operación (devolve
	  un escalar).
	</para>
	<para>
	  O primeiro argumento proporciona o nome da serie que se vai crear
	  (ou modificar); e pode ser un texto literal, unha cadea de texto ou
	  unha expresión cuxo resultado sexa unha cadea de texto. O segundo
	  argumento, <argname>rhs</argname> (<quote>lado dereito</quote> en
	  inglés), define a serie orixinal: isto pode ser o nome dunha serie
	  existente ou unha expresión cuxo resultado sexa unha serie, no
	  xeito no que aparece habitualmente do lado dereito do símbolo de
	  igualdade cando se definen series.
	</para>
	<para>
	  O valor que devolve esta función é un escalar co número ID da serie
	  no conxunto de datos, que é axeitado para incluír a serie nunha lista
	  (ou &minus;1 no caso de fallar a execución da función).
	</para>
	<para>
	  Por exemplo, supón que queres engadir <math>n</math> series
	  aleatorias con distribución de probabilidade Normal ao conxunto de
	  datos, e colocalas nunha lista. O seguinte código fai iso:
	</para>
	<code>
	  nulldata 10
	  list Normais = null
	  scalar n = 3
	  loop i = 1 .. n
	      Normais += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  Ao rematar a execución, a lista <lit>Normais</lit> vai conter as
	  series <lit>norm1</lit>, <lit>norm2</lit> e <lit>norm3</lit>.
	</para>
	<para>
	  A aqueles que atopedes útil a función <lit>genseries</lit>, pode que
	  vos interese explorar a función <fncref targ="feval"/>.
	</para>
      </description>
    </function>

    <function name="geoplot" section="data-utils" output="none">
      <fnargs>
	<fnarg type="string">ficheiromap</fnarg>
	<fnarg optional="true" type="series">carga</fnarg>
	<fnarg optional="true" type="bundle">opcions</fnarg>
      </fnargs>
      <description>
	<para>
	  Solicita a produción dun mapa, cando se dispón de datos xeográficos
	  axeitados. Na maioría dos casos o argumento <argname>mapfile</argname>
	  debe proporcionarse como <fncref targ="$mapfile"/>,
	  o que indica un accesorio co que se vai recuperar o nome do ficheiro
	  que sexa relevante, de tipo GeoJSON ou de tipo ESRI de forma. O
	  argumento opcional <argname>carga</argname> utilízase para indicar
	  o nome dunha serie coa que se colorean as rexións do mapa. E o
	  argumento final de tipo feixe (bundle) te permite que podas establecer
	  numerosas opcións.
	</para>
	<para>
	  Podes consultar <doc>geoplot.pdf</doc> coa documentación sobre a función,
	  para obter detalles e exemplos completos. Aí se explican todos os axustes
	  que se poden configurar mediante o argumento <argname>opcions</argname>.
	</para>
      </description>
    </function>

    <function name="getenv" section="programming" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando xa está definida unha variable de entorno co nome do argumento
	  <argname>s</argname>, a función devolve o valor desa variable como
	  cadea de texto; noutro caso, devolve unha cadea de texto baleira.
	  Consulta tamén <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getinfo" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve información sobre a serie especificada, que podes indicala
	  mediante o seu nome ou o seu número ID. O feixe que se devolve
	  contén tódolos atributos que se poden establecer por medio da
	  instrución <cmdref targ="setinfo"/>. E tamén contén información
	  adicional relevante para series que se xeraron como transformacións
	  de datos primarios (mediante retardos, logaritmos, etc.); isto inclúe
	  a palabra da instrución de GRETL para a transformación coa 
	  clave <quote>transform</quote>, e o nome da serie asociada primaria
	  coa clave <quote>parent</quote>. Para as series retardadas, podes
	  atopar o número específico de retardos baixo a clave
	  <quote>lag</quote>.
	</para>
	<para>
	  Aquí tes un exemplo do seu uso:
	</para>
	<code>
	  open data9-7
	  lags QNC
	  bundle b = getinfo(QNC_2)
	  print b
	</code>
	<para>
	  Ao executar o anterior, podemos ver:
	</para>
	<code>
	  has_string_table = 0
	  lag = 2
	  parent = QNC
	  name = QNC_2
	  graph_name =
	  coded = 0
	  discrete = 0
	  transform = lags
	  description = = QNC(t - 2)
	</code>
	<para>
	  Para comprobar se a serie 5 dun conxunto de datos é un termo retardado,
	  podes facer este tipo de cousas:
	</para>
	<code>
	  if getinfo(5).lag != 0
	     printf "A serie 5 é un retardo de %s\n", getinfo(5).parent
	  endif
	</code>
	<para>
	  Ten en conta que podes utilizar a notación co punto para acceder aos
	  elementos dun feixe, mesmo cando o feixe é <quote>anónimo</quote>
	  (non gardado co seu propio nome).
	</para>
      </description>
    </function>

    <function name="getkeys" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un arranxo das cadeas de texto que conteñen as chaves que
	  identifican o contido de <argname>b</argname>. Se o feixe está
	  baleiro, devólvese un arranxo baleiro.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">orixe</fnarg>
	<fnarg type="stringref">&amp;destino</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función le filas consecutivas de <argname>orixe</argname>,
	  que debe de ser unha cadea de texto xa definida. Con cada chamada á
	  función escríbese unha liña de texto en <argname>destino</argname>
	  (que tamén debe de ser unha cadea de texto, indicada en formato de
	  punteiro) sen o carácter de nova liña. O valor que se devolve é un
	  escalar igual a 1, cando existe algo por ler (incluídas filas en
	  branco), ou igual a 0 se todas as filas de <argname>orixe</argname>
	  xa se leron.
	</para>
	<para>
	  A continuación preséntase un exemplo no que o contido dun ficheiro de
	  texto divídese en filas:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, &amp;line)
	      printf "line %d = '%s'\n", i++, line
	  endloop
	</code>
	<para>
	  No exemplo pódese asegurar que, cando remate o bucle, o texto de
	  <argname>orixe</argname> está xa esgotado. Se non desexas esgotalo
	  todo, podes facer unha chamada normal a <lit>getline</lit>, seguida
	  dunha nova chamada de <quote>limpeza</quote>, trocando o argumento
	  <argname>destino</argname> por <lit>null</lit> (ou deixalo en branco),
	  co que se reinicia a lectura de <argname>orixe</argname>, como en
	</para>
	<code>
	  getline(s, &amp;line) # Obtén unha única fila
	  getline(s, null) # Reinicia a lectura
	</code>
	<para>
	  Ten en conta que, aínda que avanza a posición de lectura cada vez que
	  se executa <lit>getline</lit>, o argumento <argname>orixe</argname>
	  non se altera con esa función; só cambia <argname>destino</argname>.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;dP</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a aproximación GHK (Geweke, Hajivassiliou, Keane) á función
	  de distribución Normal multivariante; podes consultar, por exemplo,
	  <cite key="geweke91">Geweke (1991)</cite>. O valor que se devolve é
	  un vector <by r="n" c="1"/> de probabilidades.
	</para>
	<para>
	  O argumento matricial <argname>C</argname> (<by r="m" c="m"/>) debe de
	  achegar o factor de Cholesky (matriz triangular inferior) da matriz de
	  covarianzas de <math>m</math> variables Normais. Os argumentos
	  matriciais <argname>A</argname> e <argname>B</argname> deben de ser
	  ambos <by r="n" c="m"/>; e indicar respectivamente os límites inferior
	  e superior que se aplican ás variables en cada unha das <math>n</math>
	  observacións. Onde as variables non teñan límites, iso débese indicar
	  usando a constante <fncref targ="$huge"/> ou o seu negativo.
	</para>
	<para>
	  A matriz <argname>U</argname> debe de ser <by r="m" c="r"/>, onde
	  <math>r</math> indica o número de extraccións pseudoaleatorias dunha
	  distribución Uniforme. Para crear <argname>U</argname> son adecuadas
	  as funcións <fncref targ="muniform"/> e <fncref targ="halton"/>.
	</para>
	<para>
	  Debaixo ilústrase isto cun exemplo relativamente simple, no que as
	  probabilidades multivariantes poden calcularse analiticamente.
	  As series <lit>P</lit> e <lit>Q</lit> deben de ser numericamente
	  moi semellantes unha á outra, denotando como <lit>P</lit> á
	  probabilidade <quote>verdadeira</quote> e como <lit>Q</lit> á súa
	  aproximación GHK:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = halton(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
	<para>
	  O argumento opcional <argname>dP</argname> úsase para obter a matriz
	  <by r="n" c="k"/> de derivadas analíticas das probabilidades, onde <math>k</math>
	  equivale a 2<math>m</math> + <math>m</math>(<math>m</math> + 1)/2.
	  As primeiras <math>m</math> columnas van conter as derivadas
	  con respecto a os límites inferiores; as <math>m</math> seguintes
	  van recoller as derivadas con respecto a os límites superiores;
	  e as restantes columnas van recoller as derivadas con respecto
	  a os elementos singulares da matriz <math>C</math>, na orde que
	  sigue a semivectorización <quote>vech</quote> dunha matriz simétrica.
	</para>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co índice de desigualdade de Gini para a serie ou
	  vector (non negativos) <argname>y</argname>. Un valor de Gini igual a
	  cero indica igualdade perfecta. O máximo valor de Gini para unha serie
	  con <math>n</math> elementos é (<math>n</math> &minus; 1)/<math>n</math>,
	  o que acontece cando unicamente un elemento ten un valor positivo;
	  polo tanto, un valor de Gini igual a 1.0 é o límite que se acada cando
	  unha serie moi longa ten máxima desigualdade.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="scalar" optional="true">tol</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz <math>A</math><sup>+</sup>, a matriz pseudoinversa
	  de Moore&ndash;Penrose ou inversa xeneralizada dunha matriz
	  <argname>A</argname> de orde <by r="r" c="c"/>, calculada por medio
	  da descomposición en valores singulares.
	</para>
	<para>
	  O resultado desta operación depende do número de valores singulares
	  da matriz <argname>A</argname> que numericamente se consideran
	  iguais a 0. Podes usar o parámetro opcional <argname>tol</argname>
	  para retocar este aspecto. Se consideran os valores singulares iguais
	  a 0 cando son menores que <math>m &times; tol &times; s</math>,
	  onde <math>m</math> é o maior valor de entre <math>r</math> e
	  <math>c</math>, e sendo <math>s</math> o que expresa o valor
	  singular máis grande. Cando omites o segundo argumento, establécese
	  que <argname>tol</argname> sexa igual ao épsilon da máquina
	  (consulta <fncref targ="$macheps"/>). Nalgúns casos, podes desexar
	  establecer que <argname>tol</argname> sexa un valor máis grande
	  (p.e. 1.0e-9) co obxecto de evitar que se sobreestime o rango da
	  matriz <argname>A</argname> (o que podería dar lugar a resultados
	  numericamente inestables).
	</para>
	<para context="notex">
	  Esta matriz posúe as seguintes propiedades: <math>A</math>
	  <math>A</math><sup>+</sup> <math>A</math> = <math>A</math>
	  e <math>A</math><sup>+</sup> <math>A</math>
	  <math>A</math><sup>+</sup> = <math>A</math><sup>+</sup>.
	  Ademais diso, os produtos <math>A</math> <math>A</math><sup>+</sup>
	  e <math>A</math><sup>+</sup> <math>A</math> son simétricos por
	  construción.
	</para>
	<para context="tex">
	  Esta matriz posúe as seguintes propiedades:
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+
	  \end{eqnarray*}
	  Ademais diso, os produtos $A A^+$ e $A^+ A$ son
	  simétricos por construción.
	</para>
	<para>
	  <seelist>
            <fncref targ="inv"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="GSSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Maximización unidimensional mediante o método Golden Section Search
	  (GSS). A matriz <argname>b</argname> do argumento debe de ser un
	  vector de 3 elementos. Ao definila, o primeiro elemento ignórase, mentres
	  que o segundo e terceiro elementos establecen os límites inferior e
	  superior da procura. O argumento <argname>fncall</argname> deberá de
	  especificar unha chamada á función que devolve o valor do concepto a
	  maximizar; o termo 1 de <argname>b</argname> (que deberá conter o valor
	  vixente do parámetro que se axusta cando se invoca a función) debe de
	  indicarse como primeiro argumento; calquera outro argumento requirido
	  pode ir entón a continuación. A función en cuestión deberá de ser
	  unimodal (non debe de ter outro máximo local que non sexa o máximo
	  global) no rango estipulado, pois do contrario non se asegura que GSS
	  atope o máximo.
	</para>
	<para>
	  Ao completarse con éxito, <lit>GSSmax</lit> devolverá o valor
	  óptimo do concepto que se quere maximizar, mentres que
	  <argname>b</argname> conterá o valor óptimo do parámetro
	  xunto cos límites da súa xanela de valores.
	</para>
	<para>
	  O terceiro argumento (opcional) pode utilizarse para establecer
	  a tolerancia para acadar a converxencia; é dicir, a amplitude
	  máxima admisible da xanela final de valores do parámetro.
	  Se non indicas este argumento, utilízase o valor 0.0001.
	</para>
	<para>
	  Se o teu obxectivo realmente é acadar un mínimo, podes
	  ben trocar a función considerando o negativo do criterio,
	  ou ben, alternativamente, podes invocar a función
	  <lit>GSSmax</lit>baixo o alcume <lit>GSSmin</lit>.
	</para>
	<para>
	  Aquí tes un exemplo sinxelo de utilización:
	</para>
	<code>
	  function scalar trigfunc (scalar theta)
	      return 4 * sin(theta) * (1 + cos(theta))
	  end function

	  matrix m = {0, 0, $pi/2}
	  eval GSSmax(&amp;m, trigfunc(m[1]))
	  printf "\n%10.7f", m
	</code>
      </description>
    </function>

    <function name="GSSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="GSSmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="halton" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">desfasam</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz <by r="m" c="r"/> que contén <math>m</math>
	  secuencias de Halton de lonxitude <math>r</math>. As secuencias
	  constrúense utilizando os primeiros <math>m</math> números primos.
	  Por defecto, descártanse os primeiros 10 elementos de cada unha das
	  secuencias, aínda que podes axustar isto por medio do argumento
	  opcional <argname>desfasam</argname>, que debe de ser un número
	  enteiro non negativo. Para obter máis detalles podes consultar
	  <cite key="halton64">Halton e Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz que resulta do produto directo horizontal de dúas
	  matrices. Os dous argumentos deben de ter o mesmo número de filas,
	  <math>r</math>. O valor que se devolve é unha matriz que ten
	  <math>r</math> filas, e na que a <math>i</math>-ésima fila é o produto
	  de Kronecker das respectivas filas das matrices <argname>X</argname>
	  e <argname>Y</argname>. Se omites <argname>Y</argname>, aplícase
	  a sintaxe <quote>curta</quote> (mira abaixo).
	</para>
	<para context="tex">
	  Se $X$ é unha matriz $r \times k$, $Y$ é unha matriz $r \times m$
	  e $Z$ é a matriz resultante do produto directo horizontal de
	  $X$ times $Y$, entón $Z$ vai ter $r$ filas e $k\cdot m$ columnas;
	  máis aínda, \[ Z_{in} = X_{ij} Y_{il} \]
	  onde $n = (j-1) m + l$.
	</para>
	<para context="notex">
	  Se <argname>X</argname> é unha matriz <math>r x k</math> e
	  <argname>Y</argname> é unha matriz <math>r x m</math>, o resultado
	  vai ser unha matriz con <math>r</math> filas e con <math>k x m</math>
	  columnas.
	</para>
	<para>
	  Esta operación chámase <quote>produto directo horizontal</quote>
	  de acordo coa forma na que se pon en funcionamento, e se aplica
	  na linguaxe de programación GAUSS. A súa equivalente na álxebra
	  matricial estándar podería denominarse produto horizontal (row-wise)
	  de Khatri-Rao, ou produto <quote>de división de caras</quote>
	  (face-splitting) na literatura sobre o procesamento de sinais.
	</para>
	<para>
	  Exemplo: o código...
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produce a seguinte matriz:
	</para>
	<code>
          0    1    0    2    0    3
         -4    4   -5    5   -6    6
	</code>
	<subhead>Sintaxe curta</subhead>
	<para>
	  Cando <argname>X</argname> e <argname>Y</argname> son a mesma
	  matriz, entón cada fila do resultado representa a vectorización
	  dunha matriz simétrica. Nestes casos, podes omitir o segundo
	  argumento; porén, a matriz que se vai devolver conterá unicamente
	  as columnas non redundantes e, en consecuencia, vai ter
	  <math>k(k+1)/2</math> columnas. Por exemplo,
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  C = hdprod(A)
	</code>
	<para>
	  xera
	</para>
	<code>
	  1    2    3    4    6    9 
	  16   20   24   25   30   36 
	</code>
	<para context="tex">
	  Cae na conta de que a $i$-ésima fila de $C$ é $\mathrm{vech}(a_i a_i')$,
	  onde $a_i$ é a $i$-ésima fila de $A$.
	</para>
	<para context="notex">
	  Cae na conta de que a <math>i</math>-ésima fila de <math>C</math> é
	  <math>vech(a</math><sub>i</sub> <math>a</math><sub>i</sub><math>')</math>,
	  onde
	  <math>a</math><sub>i</sub> é a <math>i</math>-ésima fila de
	  <math>A</math>.
	</para>
	<para>
	  Cando utilices a sintaxe curta con matrices complexas, o segundo
	  argumento que se suporá implícito vai ser o <i>conxugado</i> do
	  primeiro, de xeito que fará que cada fila do resultado sexa a
	  vectorización simétrica dunha matriz Hermitiana.
	</para>
      </description>
    </function>

    <function name="hfdiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplicador</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha <cmdref targ="MIDAS_list"/>, a función devolve outra lista
	  da mesma lonxitude que contén as primeiras diferenzas de alta
	  frecuencia. O segundo argumento é opcional e, por defecto, igual a 1:
	  podes utilizalo para multiplicar as diferenzas por algunha constante.
	</para>
      </description>
    </function>

    <function name="hfldiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplicador</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha <cmdref targ="MIDAS_list"/>, a función devolve outra lista
	  da mesma lonxitude que contén as diferenzas logarítmicas de alta
	  frecuencia. O segundo argumento é opcional e, por defecto, igual a 1:
	  pode utilizarse para multiplicar as diferenzas por algunha constante;
	  por exemplo, poderías darlle o valor 100 para obter aproximadamente
	  as variacións porcentuais.
	</para>
      </description>
    </function>

    <function name="hflags" section="midas" output="list">
      <fnargs>
	<fnarg type="int">retardomin</fnarg>
	<fnarg type="int">retardomax</fnarg>
	<fnarg type="list">hfvars</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha <cmdref targ="MIDAS_list"/>, <repl>hfvars</repl>, a función
	  devolve outra lista cos retardos de alta frecuencia desde
	  <repl>retardomin</repl> ata <repl>retardomax</repl>. Debes utilizar valores
	  positivos para indicar os retardos, e negativos para indicar os
	  adiantos. Por exemplo, se <repl>retardomin</repl> é &minus;3, e
	  <repl>retardomax</repl> é 5, entón a lista que se vai devolver conterá
	  9 series: 3 adiantos, o valor actual e 5 retardos.
	</para>
	<para>
	  Cae na conta de que o retardo 0 de alta frecuencia correspóndese co
	  primeiro período de alta frecuencia, dentro dun período de baixa
	  frecuencia; por exemplo, correspondería co primeiro mes dentro dun
	  trimestre ou co primeiro día dentro dun mes.
	</para>
      </description>
    </function>

    <function name="hflist" section="midas" output="list">
      <fnargs>
	<fnarg type="vector">x</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg type="string">prefixo</fnarg>
      </fnargs>
      <description>
  <para>
	  Produce unha <cmdref targ="MIDAS_list"/> de <repl>m</repl> series
	  a partir do vector <repl>x</repl>, onde <repl>m</repl> indica a
	  razón entre a frecuencia (maior) das observacións da variable
	  <repl>x</repl>, e a frecuencia base (menor) do conxunto vixente
	  de datos. O valor de <repl>m</repl> debe de ser maior ou igual a 3, e
	  o tamaño de <repl>x</repl> debe de ser igual a <repl>m</repl> veces
	  o tamaño do rango da mostra vixente.
  </para>
  <para>
	  Os nomes das series da lista que se devolve, constrúense a partir do
	  <repl>prefixo</repl> indicado (que debe de ser unha cadea de texto,
	  dunha lonxitude máxima de 24 caracteres ASCII, e válida como
	  identificador de GRETL), á que se engade un ou máis díxitos que
	  representan o subperíodo da observación. Se algún deses nomes repite
	  o de algún obxecto xa existente, amósase un fallo.
  </para>
      </description>
    </function>

    <function name="hpfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
	<fnarg type="bool" optional="true">unha-parte</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que recolle a compoñente cíclica do filtro de
	  Hodrick&ndash;Prescott aplicado á serie <argname>y</argname>. Se
	  non se indica o parámetro de suavizado <argname>lambda</argname>, o
	  GRETL usa valores por defecto baseados na periodicidade dos datos;
	  concretamente, o parámetro é igual a 100 veces o cadrado da
	  periodicidade (100 para datos anuais, 1600 para datos trimestrais, etc).
	</para>
	<para>
	  Por defecto, o filtro é o da habitual versión de dúas partes
	  (pasado e futuro), pero se indicas o terceiro argumento (opcional)
	  mediante un valor non nulo, calcúlase a variante dunha soa
	  parte (sen ollada cara adiante) do xeito no que se indica en
	  <cite key="stock-watson1999">Stock e Watson (1999)</cite>.
	</para>
	<para>
	  O uso máis habitual do filtro HP é para a eliminación da tendencia,
	  pero se estás interesado na propia tendencia, é doado de obtela
	  mediante subtracción, como no exemplo seguinte:
	</para>
	<code>
	  series hptrend = y - hpfilt(y)
	</code>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="hyp2f1" section="math" output="scalar-or-matrix">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg type="scalar">c</fnarg>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve o valor da función hiperxeométrica gausiana para o
	  argumento real <argname>x</argname>. Os valores válidos para
	  <argname>x</argname> están no intervalo pechado [&minus;1, 1].
	  Esta función é moi xeral, e redúcese a unha función máis simple
	  nalgúns casos especiais, como por exemplo
	  <math>-</math>log(<math>1-x</math>)/<math>x</math>
	  cando <math>a=b=1</math> e <math>c=2</math>. Consulta
	  <url>https://en.wikipedia.org/wiki/Hypergeometric_function</url>
	  para obter máis detalles.
	</para>
	<para context="tex">
	  Devolve o valor da función hiperxeométrica gausiana
    <math>{}_2F_1(a,b;c;z) = \sum_{n=0}^\infty \frac{(a)_n (b)_n}{(c)_n} \frac{z^n}{n!}</math>
    para o argumento real <argname>x</argname>.
    Os valores válidos para <argname>x</argname> están no intervalo
    pechado [&minus;1, 1]. Esta función é moi xeral, e redúcese a
    unha función máis simple nalgúns casos especiais,
    como por exemplo
	  <math>-\frac{\log(1-x)}{x}</math>
	  cando <math>a=b=1</math> e <math>c=2</math>. Consulta
	  <url>https://en.wikipedia.org/wiki/Hypergeometric_function</url>
	  para obter máis detalles.
	</para>
	<para>
	  Cando <argname>x</argname> é un escalar, o valor que se devolve
	  vai ser un escalar; doutro xeito, vai ser unha matriz coa mesma
	  dimensión ca <argname>x</argname>. Por exemplo,
	</para>
	<code>
	  a = hyp2f1(1, 1, 2, {-1, 0, 0.5})
	  print a
	</code>
	<para>
	  produce o seguinte resultado:
	</para>
	<code>
	  a (1 x 3)

	  0.69315       1.0000       1.3863
	</code>
      </description>
    </function>

    <function name="I" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg optional="true" type="int">m</fnarg>
      </fnargs>
      <description>
	<para>
	  Se omites <argname>m</argname>, devolve unha matriz identidade
	  de orde <argname>n</argname>. Doutro xeito, devolve unha matriz
	  <by r="n" c="m"/> que contén uns na diagonal principal e ceros
	  no resto da matriz.
	</para>
      </description>
    </function>

    <function name="Im" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz real coa mesma dimensión que <argname>C</argname>,
	  que contén a parte imaxinaria da matriz do argumento. Consulta
	  tamén <fncref targ="Re"/>.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que indica cal é a fila que ten o valor máis grande,
	  por cada columna da matriz <argname>X</argname>. Para columnas que teñan
	  valores <lit>NA</lit>s, o resultado tamén establécese como <lit>NA</lit>,
	  agás cando non sexa cero o argumento opcional <argname>obviar_na</argname>,
	  en cuxo caso devólvese o índice da maior entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna que indica cal é a columna que ten o valor máis grande,
	  por cada fila da matriz <argname>X</argname>. Para filas que teñan
	  valores <lit>NA</lit>s, o resultado tamén establécese como <lit>NA</lit>,
	  agás cando non sexa cero o argumento opcional <argname>obviar_na</argname>,
	  en cuxo caso devólvese o índice da maior entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a Prob(<math>u'Au</math> &lt; <math>x</math>) para unha forma
	  cuadrática de variables Normais estándar, <math>u</math>, usando o
	  procedemento desenvolvido por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Calcula a ${\rm Prob}(u'Au &lt; x)$ para unha forma cuadrática de
	  variables Normais estándar, $u$, usando o procedemento desenvolvido
	  por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  Se o primeiro argumento <argname>M</argname> é unha matriz cadrada,
	  tómase para que represente a <math>A</math>. Se é un vector columna,
	  tómanse os seus elementos como se fosen os autovalores calculados
	  previamente de <math>A</math>, e noutro caso preséntase un fallo.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que indica cal é a fila que ten o valor máis pequeno,
	  por cada columna da matriz <argname>X</argname>. Para columnas que teñan
	  valores <lit>NA</lit>s, o resultado tamén establécese como <lit>NA</lit>,
	  agás cando non sexa cero o argumento opcional <argname>obviar_na</argname>,
	  en cuxo caso devólvese o índice da menor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="imaxc"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna que indica cal é a columna que ten o valor máis pequeno,
	  por cada fila da matriz <argname>X</argname>. Para filas que teñan
	  valores <lit>NA</lit>s, o resultado tamén establécese como <lit>NA</lit>,
	  agás cando non sexa cero o argumento opcional <argname>obviar_na</argname>,
	  en cuxo caso devólvese o índice da menor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="imaxr"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">chave</fnarg>
      </fnargs>
      <description>
	<para>
	  Comproba se o feixe ('bundle') <argname>b</argname>
	  contén un elemento co nome <argname>chave</argname>. Devolve un enteiro
	  co código do tipo de elemento: 0 no caso de non achalo e, no caso de
	  atopalo, 1 para un escalar, 2 para unha serie, 3 para unha matriz, 4 para
	  unha cadea de texto, 5 para un feixe, 6 para un arranxo e 7 para unha lista.
	  En base ao valor do seu código, a función <fncref targ="typestr"/> pódese
	  usar para obter a cadea de texto que expresa o tipo de elemento que é.
	</para>
      </description>
    </function>

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un escalar coa norma-infinito da matriz <argname>X</argname>,
	  é dicir, o máximo valor que se obtén ao sumar os valores absolutos
	  dos elementos da matriz <argname>X</argname> que hai en cada fila.
	</para>
	<para context="tex">
	  Devolve un escalar coa norma-$\infty$ da matriz $r\times c$,
	  <argname>X</argname>, concretamente
          \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro positivo coa posición de <argname>y</argname> na
	  lista <argname>L</argname>, ou 0 se <argname>y</argname> non está
	  presente en <argname>L</argname>.
	</para>
	<para>
	  O segundo argumento podes indicalo tanto co nome da serie como co
	  enteiro positivo que identifica a serie (ID). Cando sabes que existe
	  unha serie cun nome concreto (por exemplo, <lit>foo</lit>), podes
	  executar esta función da seguinte forma:
	</para>
  <code>
	  pos = inlist(L, foo)
  </code>
  <para>
	  Coa expresión anterior estás pedindo: <quote>Indícame cun enteiro a
	  posición da serie <lit>foo</lit> na lista <lit>L</lit> (ou 0 se non
	  está incluída nesa lista)</quote>. De calquera xeito, se non tes
	  certeza de que exista unha serie cun nome concreto, debes indicar
	  ese nome entre comiñas desta forma:
	</para>
	<code>
	  pos = inlist(L, "foo")
  </code>
  <para>
	  Neste caso, o que estás solicitando é: <quote>Se existe unha serie
	  chamada <lit>foo</lit> na lista <lit>L</lit>, indícame a súa posición;
	  no caso de que non exista, devolve un 0.</quote>
	</para>
      </description>
    </function>

    <function name="instring" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="bool">ign_maius</fnarg>
      </fnargs>
      <description>
	<para>
	  Este é un booleano relativo de <fncref targ="strstr"/>:
	  devolve 1 se <argname>s1</argname> contén
	  <argname>s2</argname>, e 0 noutro caso. Deste xeito,
	  a expresión condicional
	</para>
	<code>
	  if instring("gatada", "gata")
	</code>
	<para>
	  é equivalente loxicamente (pero máis eficiente) ca
	</para>
	<code>
	  if strlen(strstr("gatada", "gata")) &gt; 0
	</code>
	<para>
	  Se o argumento opcional <argname>ign_maius</argname> non é cero,
	  a procura non distinguirá maiúsculas de minúsculas. Por exemplo:
	</para>
	<code>
	  instring("Gatada", "gata")
	</code>
	<para>
	  devolve 0, pero
	</para>
	<code>
	  instring("Gatada", "gata", 1)
	</code>
	<para>
	  devolve 1.
	</para>
      </description>
    </function>

    <function name="instrings" section="strings" output="seebelow">
      <fnargs>
	<fnarg type="strings">S</fnarg>
	<fnarg type="string">cotexo</fnarg>
	<fnarg type="bool" optional="true">simple</fnarg>
      </fnargs>
      <description>
	<para>
	  Comproba se os elementos do arranxo de cadeas de texto
	  <argname>S</argname> son iguais a <argname>cotexo</argname>.
	  Por defecto, devolve un vector columna de longura igual ao número de
	  coincidencias que se producen, e que contén a posición que
	  ocupa cada coincidencia dentro do arranxo (ou ben unha matriz
	  baldeira en caso de non haber coincidencias).
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  strings S = defarray("A", "B", "C", "B")
	  eval instrings(S, "B")
	  2
	  4
	</code>
	<para>
	  Cando se indica un valor non nulo para o argumento opcional
	  <argname>simple</argname>, o valor que se devolve é un escalar:
	  1 se <argname>cotexo</argname> se atopa en <argname>S</argname>,
	  e 0 doutro xeito. Neste caso, a implementación é capaz de coller
	  un atallo, polo que é máis eficiente se só queres unha resposta
	  booleana.
	</para>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa parte enteira de
	  <argname>x</argname>, tronzando a parte decimal; ou <lit>NA</lit>
	  se non se pode representar o resultado como un enteiro de 32-bit con
	  signo (se non cae no intervalo [&minus;2147483648, 2147483647]).
	</para>
	<para>
	  Nota: <lit>int</lit> e <fncref targ="floor"/> producen distintos
	  efectos con argumentos negativos: <lit>int(-3.5)</lit> xera &minus;3,
	  namentres <lit>floor(-3.5)</lit> xera &minus;4.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="round"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="interpol" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie na que os valores ausentes de <argname>x</argname>
	  se imputan mediante interpolación linear, tanto para datos de series
	  temporais como para a dimensión temporal dun conxunto de datos de
	  panel. Pero non se fai extrapolación; os valores ausentes substitúense
	  unicamente se están precedidos e seguidos á vez de observacións
	  válidas.
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz inversa de <argname>A</argname>. Cando esta última
	  é unha matriz singular ou non cadrada, prodúcese unha mensaxe de fallo
	  e non se devolve nada. Cae na conta de que GRETL comproba
	  automaticamente a estrutura de <argname>A</argname>, e utiliza o
	  procedemento numérico máis eficiente para realizar a inversión.
	</para>
	<para>
	  Os tipos de matriz que GRETL comproba automaticamente son:
	  identidade, diagonal, simétrica definida positiva, simétrica definida
	  non positiva, e triangular.
	</para>
	<para>
	  Nota: En boa lóxica, só debes utilizar esta función cando tratas de
	  aplicar a inversa de <argname>A</argname> máis dunha vez. Cando
	  unicamente necesitas calcular, por exemplo, unha expresión da forma
	  <math>A</math><sup>-1</sup><math>B</math>, é preferible que
	  utilices os operadores de <quote>división</quote>: <lit>\</lit> e
	  <lit>/</lit>. Para obter máis detalles, podes consultar o
	  <guideref targ="chap:matrices"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ginv"/>
            <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">u</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a inversa da función de distribución acumulativa.
	  Para unha distribución continua devolve un resultado (do tipo
	  do argumento) co valor de <math>x</math> que cumpre
	  <equation status="inline" ascii="P(X &le; x) = u" tex="$P(X \le x) = u$"/>,
	  con <argname>u</argname> dentro do intervalo entre 0 e 1.
	  Para unha distribución discreta (Binomial ou Poisson), devolve
	  o valor máis pequeno de <math>x</math> para o que se cumpre
	  <equation status="inline" ascii="P(X &le; x) &ge; u" tex="$P(X \le x) \ge u$"/>.
	</para>
	<para>
	  A distribución de <math>X</math> especifícase por medio da letra
	  <argname>d</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>u</argname>, podes necesitar algún argumento adicional
	  escalar para especificar os parámetros da distribución de que se
	  trate. Isto faise da forma que se indica a continuación:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (c = z, n ou N): sen argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media, escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Khi-cadrado non central (ncX): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F non central (ncF): graos de liberdade (num.), graos de liberdade (den.),
	      parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t non central (nct): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribución} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Gamma &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  gl &amp; -- &amp; --\\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  gl &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  gl (num.) &amp; gl (den.) &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
    $\lambda$ &amp; --  &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
    media &amp; escala  &amp; -- \\
	  Erro Xeneralizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ non central &amp; \texttt{ncX} &amp;
	  gl &amp; non centralidade &amp; --\\
	  $F$ non central &amp; \texttt{ncF} &amp;
	  gl (num.) &amp; gl (den.) &amp; non centralidade\\
	  $t$ non central &amp; \texttt{nct} &amp;
	  gl &amp; non centralidade &amp; --\\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="critical"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa razón inversa de
	  Mills en <argname>x</argname>, é dicir, a razón entre a densidade
	  Normal estándar e o complementario da función de distribución
	  Normal estándar, ambas avaliadas en <argname>x</argname>.
	</para>
	<para>
	  Esta función utiliza un algoritmo axeitado que proporciona unha
	  precisión moito mellor que a que se acada facendo os cálculos con
	  <fncref targ="dnorm"/> e <fncref targ="cnorm"/>; agora ben, a
	  diferenza entre os dous métodos é considerable só para valores
	  moi negativos de <argname>x</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
	<fnarg optional="true" type="scalarref">&amp;logdet</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz cadrada resultante de inverter a matriz simétrica
	  definida positiva <argname>A</argname>. Para matrices moi grandes,
	  esta función é lixeiramente máis rápida ca <fncref targ="inv"/> posto
	  que con ela non se comproba se a matriz é simétrica. Por esta razón,
	  a función debe utilizarse con prudencia.
	</para>
	<para>
	  Se está presente o argumento <argname>&amp;logdet</argname>
	  (opcional), o escalar resultante vai conter (se remata con éxito a
	  función) o logaritmo do determinante da matriz <argname>A</argname>.
	  Dispor disto pode ser moi interesante nalgúns casos; por exemplo,
	  no contexto da avaliación do logaritmo dunha versosimilitude de tipo
	  Normal (Gaussiana), porque o logaritmo do determinante é un
	  subproduto do algoritmo da inversion, e conseguilo mediante o
	  argumento <argname>&amp;logdet</argname> evita cálculos
	  adicionais.
	</para>
	<para>
	  Nota: Se pretendes inverter unha matriz da forma <math>X'X</math>,
	  onde <math>X</math> é unha matriz moi grande, é preferible que a
	  calcules por medio do operador principal <lit>X'X</lit> en lugar
	  de usar a sintaxe máis xeral <lit>X'*X</lit>. A primeira expresión
	  utiliza un algoritmo especializado que ten unha dobre vantaxe:
	  resulta máis eficiente desde o punto de vista do cómputo; e vai
	  garantir que a matriz resultante estea libre, por construción, dos
	  artefactos de precisión de máquina que puideran convertela en
	  numericamente non simétrica.
	</para>
      </description>
    </function>

    <function name="irf" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="int">efecto</fnarg>
	<fnarg type="int">choque</fnarg>
	<fnarg type="pscalar" optional="true">alfa</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciona unha matriz coas funcións estimadas de resposta ao
	  impulso que corresponden a un VAR ou un VECM, trazadas sobre un
	  determinado horizonte de predición. Sen o argumento final (opcional),
	  esta función serve só cando o último modelo estimado foi un VAR ou un
	  VECM. Como alternativa, podes gardar a información sobre un deses
	  sistemas como feixe, mediante o accesorio <fncref targ="$system"/>, e
	  posteriormente aplicarlle a función <lit>irf</lit>.
	</para>
	<para>
	  Os argumentos <argname>efecto</argname> e <argname>choque</argname>
	  son índices, con formato de números enteiros, das variables endóxenas
	  do sistema; e se usa 0 para indicar <quote>todas</quote>. As respostas
	  (expresadas nas unidades da variable <argname>efecto</argname>) o
	  son ante unha innovación de un desvío padrón na variable
	  <argname>choque</argname>. Cando lle das un valor positivo que
	  sexa axeitado a <argname>alfa</argname>, as estimacións inclúen
	  un intervalo de confianza de 1 &minus; &agr; (deste xeito, por
	  exemplo, indica 0.1 se queres obter un intervalo do 90 por
	  cen).
	</para>
	<para>
	  O seguinte anaco de código ilustra o seu uso. No primeiro exemplo,
	  a matriz <lit>ir1</lit> contén as respostas de <lit>y1</lit> ante as
	  innovacións en cada unha das <lit>y1</lit>, <lit>y2</lit> e <lit>y3</lit>
	  (son estimacións por punto xa que se omite <argname>alfa</argname>).
	  No segundo exemplo, <lit>ir2</lit> contén as respostas de todas as
	  variables de efecto a unha innovación en <lit>y2</lit>, con intervalos
	  de confianza do 90 por cen. Neste caso, a matriz que se devolve terá
	  9 columnas: cada vía de resposta ocupa 3 columnas contiguas que
	  indican a estimación por punto, o límite inferior e o límite superior.
	  O derradeiro exemplo produce unha matriz con 27 columnas: 3 columnas
	  para cada resposta ante cada variable de efecto, multiplicadas por
	  cada unha das tres variables de choque.
	</para>
	<code>
	  var 4 y1 y2 y3
	  matrix ir1 = irf(1, 0)
	  matrix ir2 = irf(0, 2, 0.1)
	  matrix ir3 = irf(0, 0, 0.1)
	</code>
	<para>
	  O número de períodos (filas) sobre os que se traza a resposta se
	  determina automaticamente dependendo da frecuencia dos datos; mais
	  iso pode axustarse por medio da instrución <cmdref targ="set"/>,
	  como por exemplo con <lit>set horizon 10</lit>.
	</para>
	<para>
	  Cando se presentan os intervalos de confianza, estes xéranse
	  mediante a técnica de mostraxe repetida 'bootstrapping' dos erros
	  orixinais. Asúmese que o nivel de retardo do VAR ou do VECM xa
	  é suficiente como para eliminar a autocorrelación dos erros. Por
	  defecto, o número de repeticións da mostraxe 'bootstrap' é de 1999,
	  pero podes axustar isto mediante a instrución <cmdref targ="set"/>,
	  como en
	</para>
	<code>
	  set boot_iters 2999
	</code>
	<para>
	  <seelist>
	    <fncref targ="fevd"/>
	    <fncref targ="vma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa Taxa Interna de Rendemento (TIR) para
	  <argname>x</argname>, considerada como unha secuencia de pagos
	  (negativos) e ingresos (positivos).
	  <seelist>
            <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iscomplex" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Comproba se <argname>nome</argname> é o identificador dunha matriz
	  complexa. O valor que se devolve é algún dos seguintes:
	</para>
  <para>
    <lit>NA</lit>: <argname>nome</argname> non identifica a unha
    matriz.
  </para>
  <para>
    <lit>0</lit>: <argname>nome</argname> identifica unha matriz real,
    na súa totalidade formada por números normais de punto flotante
    (<quote>dobres</quote>, na terminoloxía de C).
  </para>
  <para>
    <lit>1</lit>: <argname>nome</argname> identifica unha matriz
    <quote>en principio</quote> complexa, formada por números que
    teñen tanto unha parte real como outra imaxinaria, pero nos que
    as partes imaxinarias son nulas.
  </para>
  <para>
    <lit>2</lit>: a matriz en cuestión contén, cando menos, un valor
    <quote>autenticamente</quote> complexo, con unha parte imaxinaria
    que non é nula.
  </para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">codigo-panel</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen o segundo argumento (opcional), devolve o número enteiro igual
	  a 1 cando <argname>y</argname> teña un valor constante ao longo da
	  mostra vixente seleccionada (ou ao longo de toda a súa extensión se
	  <argname>y</argname> é un vector); noutro caso, devolve o enteiro 0.
	</para>
	<para>
	  O segundo argumento só se acepta cando <argname>y</argname> é unha
	  serie, e o conxunto vixente de datos é un panel. Neste caso, un valor
	  de <argname>codigo-panel</argname> igual a 0 solicita que a función
	  verifique se a serie non varía co paso do tempo; e un valor igual a
	  1 fai que a función verifique se a serie non varía transversalmente
	  (é dicir, se o valor de <argname>y</argname> en cada período de
	  tempo, é o mesmo para todos os grupos).
	</para>
	<para>
	  Se <argname>y</argname> é unha serie, as observacións con valores
	  ausentes ignóranse durante a verificación da invariabilidade da serie.
	</para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>nome</argname> é unha cadea que identifica unha serie xa
	  definida, e se está marcada como de tipo discreto, a función devolve
	  un enteiro igual a1; noutro caso, devolve 0. Se <argname>nome</argname>
	  non identifica unha serie, a función devolve <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se todos os valores contidos en <argname>x</argname> son iguais a 0 ou
	  a 1 (ou ausentes), devolve un enteiro co reconto de uns; senón, devolve 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado un argumento escalar, devolve 1 se <argname>x</argname> non é un
	  número, <quote>Not a Number</quote> (NaN); noutro caso, devolve 0. Dada
	  unha matriz como argumento, devolve outra matriz da mesma dimensión
	  que contén valores iguais a 1 nas posicións nas que os elementos que lles
	  corresponden da matriz de entrada son NaN, e 0 nas demais posicións.
	</para>
      </description>
    </function>

    <function name="isoconv" section="calendar" output="int">
      <fnargs>
	<fnarg type="series">data</fnarg>
	<fnarg type="seriesref">&amp;ano</fnarg>
	<fnarg type="seriesref">&amp;mes</fnarg>
	<fnarg type="seriesref" optional="true">&amp;día</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada a serie <argname>data</argname> que contén datas no formato
	  ISO 8601 <quote>básico</quote> (<lit>YYYYMMDD</lit>), esta función
	  converte as compoñentes de ano, mes e (opcionalmente) día en novas
	  series designadas polo segundo e seguintes argumentos. Un exemplo
	  da súa aplicación, asumindo que a serie <lit>datas</lit> contén valores
	  axeitados de 8 díxitos, sería:
	</para>
	<code>
	  series y, m, d
	  isoconv(datas, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  Esta función devolve o valor nominal 0 no caso de completarse con
	  éxito; no caso de que non funcione, amósase un fallo.
	</para>
      </description>
    </function>

    <function name="isocountry" section="strings" output="asinput">
      <fnargs>
	<fnarg type="string-or-strings">orixe</fnarg>
	<fnarg type="int" optional="true">resultado</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función está relacionada coas catro notacións para países
	  que están incluídas no estándar ISO 3166; en concreto
	</para>
	<nlist>
	  <li><para>
	    Nome de país
	  </para></li>
	  <li><para>
	    Código alfa-2 (dúas letras maiúsculas)
	  </para></li>
	  <li><para>
	    Código alfa-3 (tres letras maiúsculas)
	  </para></li>
	  <li><para>
	    Código numérico (3 díxitos)
	  </para></li>
	</nlist>
	<para>
	  Cando indicas un país con algunha desas formas, o resultado é a
	  súa representación na forma (da 1 á 4) que escollas mediante o
	  argumento opcional <argname>resultado</argname>. Se omites ese
	  argumento, a conversión por defecto faise do xeito seguinte:
	  cando o argumento <argname>orixe</argname> é un nome dun país,
	  o resultado é o código de 2 letras do país; noutro caso, o resultado
	  é o nome do país. Debaixo ilústranse varias solicitudes válidas con
	  formato interactivo.
	</para>
	<code>
	  ? eval isocountry("Bolivia")
	  BO
	  ? eval isocountry("Bolivia", 3)
	  BOL
	  ? eval isocountry("GB")
	  United Kingdom of Great Britain and Northern Ireland
	  ? eval isocountry("GB", 3)
	  GBR
	  ? strings S = defarray("ES", "DE", "SD")
	  ? strings C = isocountry(S)
	  ? print C
	  Arranxo de strings, longura 3
	  [1] "Spain"
	  [2] "Germany"
	  [3] "Sudan"
	  ? matrix m = {4, 840}
	  ? C = isocountry(m)
	  ? print C
	  Arranxo de strings, longura 2
	  [1] "Afghanistan"
	  [2] "United States of America"
	</code>
	<para>
	  Cando <argname>orixe</argname> ten a forma 4 (código numérico),
	  isto pode indicarse mediante unha cadea de texto ou un arranxo de
	  cadeas (por exemplo, <quote>032</quote> para Argentina) ou con
	  formato numérico. No derradeiro caso, <argname>orixe</argname>
	  pode indicarse como unha serie ou como un vector, pero vaise amosar
	  un fallo se algún dos números está fóra do rango de 0 a 999.
	</para>
	<para>
	  En todos os casos (mesmo cando escollas o formato 4 de resultados)
	  devólvese unha cadea de texto ou un arranxo de cadeas; se necesitas os
	  valores numéricos, podes obtelos usando a función <fncref targ="atof"/>.
	  Cando <argname>orixe</argname> non coincide con ningunha entrada
	  da táboa ISO 3166, o resultado é unha cadea baleira, e nese caso
	  amósase unha advertencia.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat">ed</fnarg>
	<fnarg type="bool" optional="true">como-cadea</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>ed</argname> interprétase como un día de
	  época (que tomará o valor 1 para o primeiro día de xaneiro do ano 1
	  despois de Cristo, no calendario Gregoriano proléptico). O valor que
	  se devolve por defecto é un número de 8 díxitos do mesmo tipo ca
	  <argname>ed</argname>, ou unha serie composta por números desa
	  clase. Séguese o padrón <lit>YYYYMMDD</lit> (formato ISO 8601
	  <quote>básico</quote>) para proporcionar a data no calendario
	  Gregoriano que se corresponde ao día na época actual.
	</para>
	<para>
	  Se o segundo argumento <argname>como-cadea</argname> (opcional) é
	  non nulo, a función non devolve un valor numérico senón máis ben
	  unha cadea de texto que segue o padrón <lit>YYYY-MM-DD</lit>
	  (formato ISO 8601 <quote>estendido</quote>), ou unha serie con
	  valores en formato de texto se <argname>ed</argname> é unha serie,
	  ou un arranxo de cadeas de texto se <argname>ed</argname> é un vector.
	  Para ver un medio máis flexible de obter representacións dos días
	  de época con cadeas de texto, consulta <fncref targ="strfday"/>.
	</para>
	<para>
	  Con relación á función inversa consulta <fncref targ="epochday"/>.
	  Consulta tamén <fncref targ="juldate"/>.
	</para>
      </description>
    </function>

    <function name="isoweek" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">día</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número de semana (en formato ISO 8601) que se corresponde
	  coa(s) data(s) especificada(s) polos tres argumentos, ou <lit>NA</lit>
	  se a data non é válida. Cae na conta de que os tres argumentos deben
	  de ser todos do mesmo tipo, ben escalares (enteiros) ou ben series.
	</para>
	<para>
	  As semanas en formato ISO numéranse de 01 a 53. Os máis dos
	  anos teñen 52 semanas, pero unha media de 71 de 400 anos teñen
	  53 semanas. A semana 01, segundo a definición ISO 8601, é a semana
	  que contén o primeiro xoves do ano no calendario Gregoriano.
	  Para obter unha explicación completa, consulta
	  <url>https://en.wikipedia.org/wiki/ISO_week_date</url>.
	</para>
	<para>
	  Admítese tamén unha solicitude alternativa: cando se indica un
	  único argumento, considérase que é unha data (ou unha serie de
	  datas) en formato numérico <quote>básico</quote> ISO 8601,
	  <lit>YYYYMMDD</lit>. Deste xeito, as seguintes dúas solicitudes
	  xeran o mesmo resultado, concretamente 13.
	</para>
	<code>
	  eval isoweek(2022, 4, 1)
	  eval isoweek(20220401)
	</code>
      </description>
    </function>

    <function name="iwishart" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada <argname>S</argname> (unha matriz de orde <by r="p" c="p"/>
	  definida positiva), esta función devolve unha matriz xerada a
	  partir dunha realización da distribución Inversa de Wishart con
	  <argname>v</argname> graos de liberdade, onde <argname>v</argname>
	  non debe ser menor que <math>p</math>.
	  O resultado que se devolve tamén é unha matriz <by r="p" c="p"/>.
	  Utilízase o algoritmo de
	  <cite key="odell-feiveson66">Odell e Feiveson (1966)</cite>.
	</para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">ruta</fnarg>
	<fnarg optional="true" type="scalarref">&amp;nler</fnarg>
      </fnargs>
      <description>
	<para>
	  Como argumento <argname>buf</argname> deberás utilizar
	  un búfer JSON, tal como pode recuperarse dun sitio web
	  adecuado por medio da función <fncref targ="curl"/>; e como
	  argumento <argname>ruta</argname> deberás usar unha
	  especificación de tipo JsonPath.
	</para>
	<para>
	  Esta función devolve unha cadea de texto que representa os datos que
	  se atopan no búfer na ruta especificada. Se admiten os tipos de datos
	  <quote>double</quote> (punto flotante), <quote>int</quote> (enteiro)
	  e cadea de texto. No caso de enteiros ou de puntos flotantes,
	  devólvese a súa representación como cadeas de texto (usando para os
	  segundos, <quote>C</quote> local). Se o obxecto ao que se refire
	  a <argname>ruta</argname> é un arranxo, os seus elementos
	  imprímense na cadea de texto devolta, un por cada fila.
	</para>
	<para>
	  Por defecto, amósase un fallo se <argname>ruta</argname>
	  non coincide no búfer JSON; pero este comportamento
	  modifícase se indicas o terceiro argumento (opcional) pois, neste
	  caso, o argumento recupera un reconto das coincidencias, devolvéndose
	  unha cadea baleira se non hai ningunha. Chamada de exemplo:
	</para>
	<code>
	  ngot = 0
	  ret = jsonget(jbuf, "$.some.thing", &amp;ngot)
	</code>
	<para>
	  Agora ben, aínda vaise amosar un fallo no caso de facer unha solicitude
	  mal configurada.
	</para>
	<para>
	  Podes atopar unha exposición fidedigna da sintaxe JsonPath en
	  <url>http://goessner.net/articles/JsonPath/</url>. De calquera
	  xeito, observa que o sostemento de <lit>jsonget</lit> o fornece
	  <lit>json-glib</lit>, que non necesariamente soporta tódolos
	  elementos de JsonPath. E ademais, a funcionalidade concreta
	  que desenvolve <lit>json-glib</lit> pode ser moi diferente,
	  dependendo da versión que teñas no teu sistema. Podes consultar
	  <url>https://wiki.gnome.org/Projects/JsonGlib</url> se necesitas
	  ter máis detalles.
	</para>
	<para>
	  Dito isto, os seguintes operadores deberan de estar dispoñibles
	  para <lit>jsonget</lit>:
	</para>
	  <ilist>
	    <li>
              <para>
		nodo raíz, por medio do carácter <lit>$</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador descendente recursivo: <lit>..</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador comodín: <lit>*</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador subíndice: <lit>[]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de notación de conxunto, por exemplo <lit>[i,j]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de tronzado: <lit>[inicio:fin:paso]</lit>
              </para>
	    </li>
	  </ilist>
      </description>
    </function>

    <function name="jsongetb" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string" optional="true">ruta</fnarg>
      </fnargs>
      <description>
	<para>
	  Como argumento <argname>buf</argname> deberás utilizar un búfer
	  JSON, tal como pode recuperarse dun sitio web adecuado por medio
	  da función <fncref targ="curl"/>. A especificación e o efecto do
	  argumento opcional <argname>ruta</argname> descríbese
	  máis abaixo.
	</para>
	<para>
	  O que se devolve é un feixe (bundle) cuxa estrutura basicamente
	  reflicte a da entrada: os obxectos JSON tórnanse feixes de GRETL,
	  e os arranxos JSON tórnanse arranxos de GRETL; cada un deles
	  pode conter cadeas de texto, feixes ou arranxos. Os nodos de
	  <quote>valor</quote> JSON tórnanse compoñentes de feixes ou
	  elementos de arranxos; no último caso, os valores numéricos se
	  converten en cadeas de texto utilizando <lit>sprintf</lit>. Cae na
	  conta de que, aínda que a especificación JSON permite arranxos de
	  tipo mixto, estes non se poden manexar mediante <lit>jsongetb</lit>
	  dado que os arranxos de GRETL deben ser de tipo único.
	</para>
	<para>
	  Podes usar o argumento <argname>ruta</argname> para limitar
	  os elementos JSON incluídos no feixe que se devolve. Ten en
	  conta que isto non é un <quote>JsonPath</quote> tal como se
	  describe na axuda para <fncref targ="jsonget"/>; isto é unha
	  sinxela composición suxeita á seguinte especificación:
	</para>
	<ilist>
	  <li>
	    <para>
	      <argname>ruta</argname> é unha formación de elementos separados
	      por unha barra, onde esta barra (<quote>/</quote>) indica o
	      desprazamento a un nivel <quote>máis baixo</quote> na árbore
	      JSON representada por <argname>buf</argname>. Permítese unha
	      barra inicial pero non é necesaria, pois implicitamente a ruta
	      sempre comeza na raíz. Non debes de incluír caracteres estraños
	      para espazos en branco.
	    </para>
	  </li>
	  <li>
	    <para>
	      Cada elemento que se separa con unha barra debe de ter
	      unha das seguintes formas: (a) un nome unicamente, en
	      cuxo caso só se vai incluír un elemento JSON cuxo nome
	      coincida no nivel estrutural indicado; ou (b) <quote>*</quote>
	      (asterisco), en cuxo caso vanse incluír todos aqueles
	      elementos do nivel indicado; ou (c) un arranxo de nomes
	      separados con comas e contornados entre chaves
	      (<quote>{</quote> e <quote>}</quote>), en cuxo caso só
	      se van incluír os elementos JSON cuxos nomes coincidan
	      con un dos nomes indicados.
	    </para>
	  </li>
	</ilist>
	<para>
	  Consulta tamén a función orientada a cadeas <fncref targ="jsonget"/>;
	  pois, dependendo da túa intención, unha destas funcións pódeche ser
	  de máis axuda que a outra.
	</para>
      </description>
    </function>

    <function name="juldate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat">ed</fnarg>
	<fnarg type="bool" optional="true">como-cadea</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta funcion simplemente opera como <fncref targ="isodate"/>,
	  agás en que as datas do resultado son relativas ao calendario
	  Xuliano en troques do Gregoriano.
	</para>
      </description>
    </function>

    <function name="kdensity" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-list-or-mat">x</fnarg>
	<fnarg type="scalar" optional="true">escala</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha estimación (ou un conxunto de estimacións) da densidade
	  kernel para o argumento <argname>x</argname>, que pode ser unha serie
	  única, unha lista ou unha matriz con máis dunha columna. A matriz
	  que se devolve ten <math>k</math> + 1 columnas, sendo <math>k</math>
	  o número de elementos (series ou columnas) de <argname>x</argname>.
	  A primeira columna inclúe un conxunto de abscisas equidistantes, e
	  o resto das columnas inclúen a densidade (ou densidades) estimada
	  correspondente a cada unha delas.
	</para>
  <para>
    A fórmula utilizada para calcular a densidade estimada en
	  cada punto de referencia (<math>x</math>) é
	  <equation status="display"
	           tex="\[f(x)=(1/nh) \sum_{t-1}^{n} k\left((x-x_t)/h\right)\]"
	           ascii="f(x) = (1/nh) sum(t=1 to n) k((x - x(t)) / h)"
	           graphic="kernel1"/>
	  onde <math>n</math> denota o número de puntos con datos,
	  <math>h</math> é un parámetro de <quote>largo de banda</quote>,
	  e <math>k</math>() é a función Kernel. Canto maior sexa o valor
	  do parámetro de largo de banda, máis suave vai ser a densidade
	  estimada.
  </para>
  <para>
	  O parámetro <argname>escala</argname> (opcional) podes usalo
	  para axustar o grao de suavizado en relación ao valor por defecto
	  que é 1.0; este se corresponde coa regra xeral proposta por
	  <cite key="silverman86">Silverman (1986)</cite>, concretamente
	  <equation status="display"
	     tex="\[h=0.9 {\rm min}(s, {\rm IQR}/1.349) n^{-1/5}\]"
	     ascii="h = 0.9 min(s, IQR/1.349) n^{-1/5}"
	     graphic="kernel2"/>
	  onde <math>s</math> indica o desvío padrón dos datos e IQR é o
	  rango intercuartil. O parámetro <argname>control</argname>
	  (opcional) actúa como un booleano: 0 (valor por defecto) significa
	  que se utiliza o kernel gaussiano; un valor non nulo troca ao
	  kernel de Epanechnikov.
	</para>
	<para>
	  Podes obter un gráfico dos resultados utilizando a instrución
	  <cmdref targ="gnuplot"/>, como se indica abaixo. Cae na conta de que
	  a columna que contén as abscisas debe ir ao final para representar
	  a gráfica.
	</para>
	<code>
	  matrix d = kdensity(x)
	  # Se x ten un único elemento
	  gnuplot 2 1 --matrix=d --with-lines --fit=none
	  # Se x ten dous elementos
	  gnuplot 2 3 1 --matrix=d --with-lines --fit=none
	</code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza o suavizado das perturbacións dun feixe de Kalman, configurado
	  previamente mediante a instrución <fncref targ="ksetup"/>; e devolve
	  o enteiro 0 cando se completa con éxito, ou un número non nulo cando
	  se atopan problemas numéricos. E deberías comprobar o valor que se
	  devolve, antes de facer uso dos resultados.
	</para>
	<para>
	  Cando se completa con éxito a operación, as perturbacións suavizadas
	  van estar dispoñibles como <lit>kb.smdist</lit>.
	</para>
	<para>
	  O argumento <argname>MSE</argname> (opcional) determina o contido
	  da chave <lit>kb.smdisterr</lit>. Cando é 0 ou se omite, esta
	  matriz vai estar composta polos desvíos padrón incondicionais
	  das perturbacións suavizadas, que habitualmente se utilizan para
	  calcular os denominados <emphasis>erros auxiliares</emphasis>.
	  Mais, en caso contrario, <lit>kb.smdisterr</lit> vai conter as
	  raíces dos desvíos cadrados medios entre os erros auxiliares
	  e os seus valores verdadeiros.
	</para>
	<para>
	  Para obter máis detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza o filtrado cara adiante dun feixe de Kalman configurado
	  previamente mediante a instrución <fncref targ="ksetup"/>, e
	  devolve o escalar 0 cando se completa con éxito, ou o escalar 1
	  cando se atopan problemas numéricos.
	</para>
	<para>
	  Cando se completa con éxito, os erros de predición adiantados un paso
	  van estar dispoñibles como <lit>kb.prederr</lit>, e a secuencia das
	  súas matrices de covarianzas como <lit>kb.pevar</lit>. Por outra
	  banda, <lit>kb.llt</lit> permitirá que teñas acceso a un
	  <math>T</math>-vector que vai conter o logaritmo da verosimilitude
	  de cada observación.
	</para>
	<para>
	  Para obter máis detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kmeier" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co cálculo do estimador non paramétrico
	  de Kaplan&ndash;Meier da función de supervivencia
	  (<cite key="kaplan-meier">Kaplan e Meier, 1958</cite>), dada unha
	  mostra <argname>d</argname> de datos de duración, posiblemente
	  acompañada dun rexistro de estado de censura, <argname>cens</argname>.
	  A matriz que se devolve ten tres columnas que conteñen,
	  respectivamente: os valores únicos ordenados en <argname>d</argname>,
	  a estimación da función de supervivencia que se corresponde cos
	  valores de duración da columna 1, e o desvío padrón (para mostras
	  grandes) do estimador, calculados por medio do método de
	  <cite key="greenwood26">Greenwood (1926)</cite>.
	</para>
	<para>
	  Cando indicas a serie <argname>cens</argname>, utilízase o valor 0
	  para sinalar que unha observación non está censurada, namentres
	  que o valor 1 indica que unha observación está censurada do lado
	  dereito (é dicir, o período de observación do individuo en cuestión
	  concluíu antes da duración, ou o período rexistrouse como rematado).
	  Cando non indicas <argname>cens</argname>, asúmese que todas as
	  observacións son non censuradas. (Aviso: a semántica de
	  <argname>cens</argname> pode estenderse nalgún punto para cubrir
	  outros tipos de censura.)
	</para>
	<para>
	  <seelist>
            <fncref targ="naalen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">tendenc</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que contén os valores críticos aos niveis de
	  10, 5 e 1 por cento da proba KPSS para a estacionariedade dunha
	  serie temporal. O argumento <argname>T</argname> debe de indicar o
	  número de observacións, e o argumento <argname>tendenc</argname> debe de
	  ser igual a 1 se a proba inclúe unha constante (ou 0 noutro caso).
	</para>
	<para>
	  Os valores críticos que se ofrecen están baseados en superficies
	  de resposta estimadas do xeito que está establecido por
	  <cite key="sephton95">Sephton (Economics Letters,1995)</cite>.
	  Consulta tamén a instrución <cmdref targ="kps"/>.
 	</para>
      </description>
    </function>

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">Z</fnarg>
	<fnarg type="scalar-or-matrix">T</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">R</fnarg>
      </fnargs>
      <description>
	<para>
	  Configura un feixe de Kalman, é dicir, un obxecto que contén toda
	  a información necesaria para definir un modelo de espazo dos estados
	  linear, da forma
	  <equation status="display"
		    tex="\[y_t=Z\alpha_t + u_t\]"
		    ascii="y(t) = Za(t) + u(t)"
		    graphic="kalman1"/>
	  na que Var<math>(u) = R</math>, e coa ecuación de transición de
	  estado
	  <equation status="display"
		    tex="\[\alpha_{t+1}=T \alpha_t + v_t\]"
		    ascii="a(t+1) = T a(t) + v(t)"
		    graphic="kalman2"/>
	  na que Var<math>(v) = Q</math>.
	</para>
	<para>
	  Os obxectos que creas mediante esta función podes utilizalos máis
	  adiante, coa intervención das seguintes funcións específicas:
	  <fncref targ="kfilter"/> para facer filtrado, <fncref targ="ksmooth"/>
	  e <fncref targ="kdsmooth"/> para suavizado, e <fncref targ="ksimul"/>
	  para facer simulacións.
	</para>
	<para>
	  En realidade, o tipo de modelos que GRETL pode manexar é moito máis
	  amplo ca o implicado na anterior representación: é posible dispoñer
	  de modelos variantes no tempo, de modelos con precedentes difusos
	  e con variable esóxena na ecuación de medida, e de modelos con
	  innovacións con correlacións cruzadas. Para obter máis detalles,
	  consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksimul" section="sspace" output="matrix">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="bool" optional="true">extra</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz. Utiliza un feixe de tipo Kalman previamente
	  definido coa función <fncref targ="ksetup"/> para levar a cabo
	  simulacións, tomándose as perturbacións da matriz <argname>U</argname>.
	  Por defecto, a matriz que se devolve (que vai ter tantas filas como
	  <argname>U</argname>) contén valores simulados do(s) observable(s),
	  pero cando indicas un valor non nulo para <argname>extra</argname>,
	  tamén se vai incluír o estado simulado. Neste último caso,
	  cada fila contén primeiro o estado, e despois o(s)
	  observable(s).
	</para>
	<para>
	  Para obter máis detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksmooth" section="sspace" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza un suavizado de punto fixo (cara atrás) dun feixe de Kalman
	  previamente configurado mediante <fncref targ="ksetup"/>; e devolve
	  un 0 cando se executa con éxito, ou un número non nulo cando se
	  atopan problemas numéricos. E deberías comprobar o valor que se
	  devolve, antes de facer uso dos resultados.
	</para>
	<para>
	  Cando se completa con éxito, vas ter á túa disposición o estado xa
	  suavizado como <lit>kb.state</lit>, e a secuencia das súas matrices
	  de varianzas-covarianzas como <lit>kb.stvar</lit>. Para obter máis
	  detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o exceso de curtose da serie <argname>x</argname>,
	  descartando calquera observación ausente.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list-or-mat">
      <fnargs>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="series-list-or-mat">y</fnarg>
	<fnarg type="bool" optional="true">xretardo</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando o primeiro argumento é un escalar, xera os retardos do 1 ao
	  <argname>p</argname> da serie <argname>y</argname>. Cando
	  <argname>y</argname> é unha lista, xera eses retardos para todas as
	  series que contén esa lista. Cando <argname>y</argname> é unha matriz,
	  xera eses retardos para todas as columnas da matriz. No caso de que
	  <argname>p</argname> = 0, e <argname>y</argname> sexa unha serie
	  ou unha lista, o retardo máximo toma por defecto a periodicidade dos
	  datos; aparte diso <argname>p</argname> deberá de ser positivo.
	</para>
	<para>
	  Cando o primeiro argumento é un vector, os retardos xerados son os
	  que están especificados nese vector. Neste caso, un uso habitual
	  podería ser o de poñer, por exemplo, <argname>p</argname> como
	  <lit>seq(3,7)</lit>, daquela omitindo o primeiro e segundo retardos.
	  Así e todo, tamén é correcto indicar un vector con saltos como en
	  <lit>{3,5,7}</lit>, aínda que os retardos deberán indicarse sempre
	  en orde ascendente.
	</para>
	<para>
	  No caso de que o resultado sexa unha lista, noméanse automaticamente as
	  variables xeradas co padrón <repl>nomevar</repl><lit>_</lit><repl>i</repl>,
	  no que <repl>nomevar</repl> estará indicando o nome da serie orixinal,
	  e <repl>i</repl> expresará o retardo concreto de cada caso. A parte
	  orixinal do nome vaise tronzar cando así resulte necesario, e mesmo
	  poderá axustarse oportunamente para garantir que resulte único dentro
	  do conxunto de nomes que así se vaian construír.
	</para>
	<para>
	  Cando o segundo argumento <argname>y</argname> é unha lista ou unha
	  matriz con máis dunha columna, e o nivel de retardo é maior ca 1, a
	  disposición por defecto dos elementos na lista que se devolve é por orde
	  de variable: primeiro devólvense todos os retardos da primeira serie
	  ou columna contida nese argumento, seguidos de todos os da segunda, e
	  así de forma sucesiva. O terceiro argumento (opcional) podes usalo para
	  cambiar isto: se <argname>xretardo</argname> é non nulo, entón os elementos
	  ordénanse por retardo: o primeiro retardo de todas as series ou columnas,
	  logo o segundo retardo de todas as series ou columnas, etc.
	</para>
	<para>
	  Consulta tamén <fncref targ="mlag"/> para a utilización con matrices.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">namostra</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número enteiro positivo que indexa a última observación
	  non ausente da serie <argname>y</argname>. Por defecto, analízase
	  todo o rango da mostra, de xeito que, se está activa algunha forma
	  de submostraxe, o valor que se devolve pode ser maior ca o valor
	  devolto polo accesorio <fncref targ="$t2"/>. Pero se indicas un
	  valor non nulo en <argname>namostra</argname>, só vai terse en
	  conta o rango da mostra vixente.
	  <seelist>
            <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co logaritmo natural do determinante de
	  <math>A</math>, calculado por medio da descomposición LU.
	  Cae na conta de que isto é máis eficiente que invocar
	  <fncref targ="det"/> e tomar o logaritmo do resultado. Alén diso,
	  nalgúns casos <lit>ldet</lit> é capaz de devolver un resultado
	  válido mesmo cando o determinante de <math>A</math> é
	  numericamente <quote>infinito</quote> (excedendo o número
	  máximo de dobre precisión da librería de C).
	  <seelist>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coas primeiras diferenzas
	  do logaritmo deste; os valores iniciais considéranse <lit>NA</lit>.
	</para>
	<para>
	  Cando se devolve unha lista, as variables individuais noméanse de
	  forma automática seguindo o padrón <lit>ld_</lit><repl>varname</repl>,
	  no que <repl>varname</repl> indica o nome da serie orixinal. A parte
	  orixinal do nome vai tronzarse cando así resulte necesario, e mesmo
	  poderá axustarse para garantir que sexa único dentro do conxunto de
	  nomes que así se vaian construír.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha nova serie calculada como unha combinación linear das
	  series da lista <argname>L</argname>. Os coeficientes veñen dados
	  polo vector <argname>b</argname>, cuxo tamaño debe de ser igual ao
	  número de series que hai en <argname>L</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="linearize" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Para executalo é preciso ter instalado o TRAMO. Devolve unha serie
	  que é unha versión <quote>linearizada</quote> do argumento; é dicir,
	  unha serie na que calquera valor ausente substitúese por valores
	  interpolados, e na que as observacións anómalas axústanse. Para iso
	  utilízase un mecanismo completamente automático do TRAMO. Para obter
	  máis detalles, consulta a documentación do TRAMO.
	</para>
	<para>
	  Cae na conta de que, se a serie do argumento non posúe valores
	  ausentes nin observacións que o TRAMO considere anómalas, esta
	  función devolve unha copia da serie orixinal.
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co cálculo do estatístico Q de Ljung&ndash;Box
	  para a serie <argname>y</argname>, utilizando o nivel de retardo
	  <argname>p</argname>, ao longo da mostra seleccionada nese momento.
	  O nivel de retardo debe de ser maior ou igual a 1, e menor ca o número
	  de observacións dispoñibles.
	</para>
	<para>
	  Ese valor do estatístico podes cotexalo coa distribución Khi-cadrado
	  con <argname>p</argname> graos de liberdade, para verificar a
	  hipótese nula de que a serie <argname>y</argname> non ten
	  autocorrelación.
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo da función Gamma de <argname>x</argname>.
	</para>
	  <seelist>
            <fncref targ="bincoeff"/>
            <fncref targ="gammafun"/>
	  </seelist>
      </description>
    </function>

    <function name="lnmgamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o logaritmo da función Gamma multivariante de
	  <argname>x</argname> con parámetro <argname>p</argname> de forma.
	</para>
	<para>
	  Para a súa definición e propiedades, consulta
	  <url>https://dlmf.nist.gov/35.3</url> ou
	  <url>https://en.wikipedia.org/wiki/Multivariate_gamma_function</url>.
	</para>
	  <seelist>
            <fncref targ="lngamma"/>
	  </seelist>
      </description>
    </function>

    <function name="loess" section="nonparam" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robusta</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza unha regresión polinómica ponderada localmente, e devolve
	  unha serie que contén os valores previstos de <argname>y</argname>
	  para cada valor non ausente de <argname>x</argname>. O método que
	  se utiliza é do tipo que está descrito por
	  <cite key="cleveland79">William Cleveland (1979)</cite>.
	</para>
	<para>
	  Os argumentos <argname>d</argname> e <argname>q</argname> (opcionais)
	  permiten especificar: a orde do polinomio de <argname>x</argname>
	  e que proporción dos puntos de datos se van utilizar na estimación
	  local, respectivamente. Os valores que se lles supoñen por defecto
	  son <argname>d</argname> = 1 e <argname>q</argname> = 0.5; e outros
	  valores admisibles para <argname>d</argname> son 0 e 2. Cando
	  establezas <argname>d</argname> = 0, vas reducir a regresión local
	  a unha forma de media móbil. O valor de <argname>q</argname> debe
	  de ser maior ca 0, e non pode ser maior ca 1; os valores máis grandes
	  producen un resultado final máis suavizado.
	</para>
	<para>
	  Cando se especifica un valor non nulo para o argumento
	  <argname>robusta</argname>, as regresións locais reitéranse dúas veces,
	  con modificacións nas ponderacións en base aos erros da iteración
	  previa, e de xeito que teñan menos influenza as observacións anómalas.
	</para>
	<para>
	  Revisa tamén a función <fncref targ="nadarwat"/> e, por engadido,
	  consulta o <guideref targ="chap:nonparam"/> para obter máis detalles
	  sobre métodos non paramétricos.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo natural de
	  <argname>x</argname>, xerando <lit>NA</lit> se este non é positivo.
	  Aviso: <lit>ln</lit> é un pseudónimo admisible para <lit>log</lit>.
	</para>
	<para>
	  Cando se devolve unha lista, as variables individuais noméanse de
	  forma automática seguindo o padrón <lit>l_</lit><repl>varname</repl>,
	  no que <repl>varname</repl> indica o nome da serie orixinal. A parte
	  orixinal do nome vai tronzarse cando así resulte necesario, e mesmo
	  poderá axustarse para garantir que sexa único dentro do conxunto de
	  nomes que así se vaian construír.
	</para>
	<para>
	  Observa que, no caso de que o argumento sexa unha matriz, a función
	  opera elemento a elemento. Para a función logarítmica matricial,
	  consulta <fncref targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo en base 10 de
	  <argname>x</argname>, xerando <lit>NA</lit> se este non é positivo.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo en base 2 de
	  <argname>x</argname>, xerando <lit>NA</lit> se este non é positivo.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Devolve un resultado (do mesmo tipo do argumento <argname>x</argname>)
	  coa función FDA loxística deste; isto é, $\Lambda(x) = 1/(1+e^{-x})$. Se
	  <argname>x</argname> é unha matriz, a función aplícase a cada elemento.
	</para>
	<para context="notex">
	  Devolve un resultado (do mesmo tipo do argumento <argname>x</argname>)
	  coa función FDA loxística deste; é dicir,
	  1/(1+<math>e</math><sup>&minus;x</sup>). Se <argname>x</argname>
	  é unha matriz, a función aplícase a cada elemento.
	</para>
      </description>
    </function>

    <function name="lpsolve" section="math" output="bundle">
      <fnargs>
	<fnarg type="bundle">specs</fnarg>
      </fnargs>
      <description>
	<para>
	  Soluciona un problema de programación linear, utilizando a biblioteca
	  lpsolve. Consulta <doc>gretl-lpsolve.pdf</doc> para obter máis
	  detalles e exemplos de utilización.
	</para>
      </description>
    </function>

    <function name="lower" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz triangular inferior de orde <by r="n" c="n"/>: os
	  elementos da diagonal principal e de debaixo desta son iguais aos elementos
	  correspondentes de <argname>A</argname>, e os demais son iguais a cero.
	</para>
	<para context="tex">
	  Devolve <math>B</math>, unha matriz triangular inferior $n\times n$,
	  na que para cada $B_{ij} = A_{ij}$ se $i \ge j$, e 0 noutro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrcovar" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="bool" optional="true">senmedia</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coas varianzas e covarianzas de longo prazo
	  das columnas da matriz <argname>A</argname>. Primeiro, aos datos
	  se lles resta a media, agás que se asigne un cero ao segundo
	  argumento (opcional). Podes escoller o tipo de kernel e o parámetro
	  de tronzado do retardo (o tamaño da xanela), antes de chamar a
	  esta función mediante as opcións relacionadas co HAC que ofrece
	  a instrución <cmdref targ="set"/>, tales como <lit>hac_kernel</lit>,
	  <lit>hac_lag</lit>, ou <lit>hac_prewhiten</lit>. Consulta tamén
	  a sección sobre datos de series de tempo e matrices de covarianzas
	  HAC no <guideref targ="chap:robust_vcv"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="lrvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrvar" section="timeseries" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
	<fnarg type="scalar" optional="true">mu</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa varianza de longo prazo do argumento
	  <argname>y</argname>, calculada usando un núcleo (<quote>kernel</quote>) de
	  Bartlett con tamaño de xanela igual a <argname>k</argname>. Se omites o
	  segundo argumento (ou lle asignas un valor negativo), o tamaño da xanela
	  establécese por defecto igual á parte enteira da raíz cúbica do tamaño da mostra.
	</para>
	<para context="tex">
	  Fórmula:
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \mu) (y_{t-i} - \bar{Y})
	  \right] \]
	  con
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
	<para>
	  Para o cálculo da varianza, a serie <argname>y</argname> se
	  centra con respecto ao parámetro opcional <argname>mu</argname>;
	  e cando este se omite ou é <lit>NA</lit>, utilízase a media
	  mostral.
	</para>
	<para>
	  Para unha contrapartida multivariante, consulta <fncref targ="lrcovar"/>.
	</para>
      </description>
    </function>

    <function name="Lsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">L</fnarg>
	<fnarg type="matrix">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Resolve <math>x</math> en <math>Ax = b</math>, onde
	  <argname>L</argname> é o factor de Cholesky triangular
	  inferior da matriz definida positiva <math>A</math>, que
	  cumpre <math>LL' = A</math>. Podes obter un axeitado factor
	  <argname>L</argname> utilizando a función <fncref targ="cholesky"/>
	  con <math>A</math> como argumento.
	</para>
	<para>
	  Os seguintes dous cálculos deberan de producir o mesmo resultado
	  (dependendo da precisión da máquina), pero a primeira variante
	  permite volver a utilizar un factor de Cholesky calculado previamente,
	  e polo tanto debera de ser substancialmente máis rápido se estás
	  solucionando de xeito repetido para unha mesma <math>A</math>,
	  e distintos valores de <math>b</math>. O aumento da velocidade será
	  maior, canto maior sexa a dimensión de <math>A</math>.
	</para>
	<code>
	  # Variante 1
	  matrix L = cholesky(A)
	  matrix x = Lsolve(L, b)
	  # Variante 2
	  matrix x = A \ b
	</code>
      </description>
    </function>

    <function name="mat2list" section="data-utils" output="list">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="string">prefixo</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é unha función conveniente para elaborar unha lista de series
	  utilizando as columnas dunha matriz axeitada como entrada. A dimensión
	  das filas de <argname>X</argname> debe ser igual ben á longura do
	  conxunto de datos vixente, ou ben ao número de observacións do
	  rango da mostra vixente.
	</para>
	<para>
	  As series da lista que se devolve noméanse do seguinte xeito.
	  Primeiro, cando se proporciona o argumento opcional
	  <argname>prefixo</argname>, a serie creada da columna <math>i</math>
	  de <argname>X</argname> noméase engadindo <math>i</math> á cadea
	  de texto proporcionada, como en <lit>prefixo1</lit>, <lit>prefixo2</lit>,
	  etcétera. Pola contra, se a matriz <argname>X</argname> ten un
	  conxunto de nomes das columnas (consulta <fncref targ="cnameset"/>),
	  utilízanse eses nomes. Finalmente, se non se cumpre ningunha das
	  condicións anteriores, os nomes son <lit>columna1</lit>,
	  <lit>column2</lit>, etcétera. Cae na conta de que esta política pode
	  ter como consecuencia que se sobrescriban series xa existentes;
	  se non queres que iso aconteza, toma a precaución de nomear as
	  columnas explicitamente mediante a función <lit>cnameset</lit>, ou
	  indica a opción <argname>prefix</argname>.
	</para>
	<para>
	  Aquí tes un exemplo ilustrativo do seu uso:
	</para>
	<code>
	  matrix X = mnormal($nobs, 8)
	  list L = mat2list(X, "xnorm")
	  # ou alternativamente, se non necesitas crear a propia X
	  list L = mat2list(mnormal($nobs, 8), "xnorm")
	</code>
	<para>
	  Isto vai engadir ao conxunto de datos, oito series de longura completa
	  nomeadas <lit>xnorm1</lit>, <lit>xnorm2</lit>, etcétera.
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="depends">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
        <fnarg optional="true" type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función ten dous modos básicos, máis un caso especial.
	</para>
	<para>
	  O primeiro modo se activa cando se indica un único argumento de tipo
	  escalar, de tipo serie ou de tipo matriz. O valor que se vai devolver
	  é un escalar, que expresa o valor válido máximo <quote>dentro</quote>
	  do argumento: se <argname>x</argname> é unha serie, expresa o
	  seu valor máximo dentro do rango vixente da mostra; ou, se
	  <argname>x</argname> é unha matriz, o seu maior elemento (ignorándose
	  os valores ausentes). No caso de que o argumento sexa escalar se
	  admite por razóns de completude; simplemente vas obter de volta
	  o seu mesmo valor.
	</para>
	<para>
	  O segundo modo se activa cando se indican dous argumentos. Os
	  argumentos <argname>x</argname> e <argname>y</argname> deben
	  ser do mesmo tipo; e deben ser escalares, series ou matrices (de ser
	  matrices, deben ter a mesma dimensión). O valor que se devolve é
	  un obxecto do mesmo tipo que os argumentos, que contén o máximo
	  (ou máximos) <quote>entre</quote> ou <quote>transversais</quote>.
	  Cando os argumentos son escalares, obtés o maior dos dous;
	  se son series, obtés unha serie constituída polos valores que resultan
	  ser os maiores ao comparar os dous valores das series para cada
	  observación, no rango vixente da mostra; se son matrices, obtés
	  unha matriz que contén os valores que resultan ser os maiores ao
	  comparar os dous valores das matrices para cada fila e columna.
	  Para cada unha das comparacións por parellas, se algún dos termos
	  está ausente, o resultado é tamén un valor ausente.
	</para>
	  <subhead>O caso especial</subhead>
	<para>
	  Este xurde cando se indica un argumento con unha única lista.
	  O valor que se devolve é unha serie que contén, en cada observación
	  do rango vixente da mostra, o maior dos valores que teñen as series
	  da lista, en cada observación.
        </para>
	<para>
	  <seelist>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que contén o valor máis grande de cada columna
	  da matriz <argname>X</argname>. Para columnas que teñan valores
	  <lit>NA</lit>s, o resultado tamén establécese como <lit>NA</lit>, agás
	  cando non sexa cero o argumento opcional <argname>obviar_na</argname>,
	  en cuxo caso devólvese a maior entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna que contén o valor máis grande de cada fila
	  da matriz <argname>X</argname>. Para filas que teñan valores
	  <lit>NA</lit>s, o resultado tamén establécese como <lit>NA</lit>, agás
	  cando non sexa cero o argumento opcional <argname>obviar_na</argname>,
	  en cuxo caso devólvese a maior entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha matriz de correlacións (de Pearson), tratando cada columna
	  da matriz argumento <argname>X</argname> como se fose unha variable.
	</para>
	<para>
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int" optional="true">gl_corr</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha matriz de varianzas-covarianzas, tratando cada columna
	  da matriz argumento <argname>X</argname> como se fose unha
	  variable. O divisor é <math>n</math> &minus; 1, no que
	  <math>n</math> é o número de filas de <argname>X</argname>;
	  agás que indiques o segundo argumento (opcional), en cuxo caso
	  se utiliza <math>n</math> &minus; <argname>gl_corr</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz covariograma para outra matriz <argname>X</argname>
	  de orde <by r="T" c="k"/> (que xeralmente contén regresores), un
	  vector <argname>u</argname> de orde <math>T</math> (opcional,
	  que adoita conter os erros), un vector <argname>w</argname> de orde
	  <math>p</math>+1 (opcional, que contén unhas ponderacións), e un
	  número enteiro <argname>p</argname> que indica o nivel de retardo
	  e debe de ser maior ou igual a 0.
	</para>
	<para context="tex">
	  A matriz que se devolve ven dada por
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t u_t
	  u_{t-j} X_{t-j}')\]
	</para>
	<para context="notex">
	  A matriz que se devolve é a suma para <math>j</math> dende
	  <math>-p</math> ata <math>p</math> de
	  <math>w(|j|) * X(t)X(t-j)' * u(t)u(t-j)</math>, onde <math>X(t)'</math> é
	  a <math>t</math>-ésima fila de <argname>X</argname>.
	</para>
	<para>
	  Se <argname>u</argname> ven indicado como <lit>nulo</lit>,
	  os termos <math>u</math> omítense, e se
	  <argname>w</argname> ven indicado como <lit>nulo</lit>,
	  todas as ponderacións asúmese que son 1.0.
	</para>
	<para>
	  Por exemplo, o seguinte anaco de código
	</para>
	<code>
	  set seed 123
	  X = mnormal(6,2)
	  Retardo = mlag(X,1)
	  Adianto = mlag(X,-1)
	  print X Retardo Adianto
	  eval X'X
	  eval mcovg(X, , , 0)
	  eval X'(X + Retardo + Adianto)
	  eval mcovg(X, , , 1)
	</code>
	<para>
	  produce este resultado:
	</para>
	<code>
	  ? print X Retardo Adianto
	  X (6 x 2)

	    -0,76587      -1,0600
	    -0,43188      0,30687
	    -0,82656      0,40681
	     0,39246      0,75479
	     0,36875       2,5498
	     0,28855     -0,55251

	  Retardo (6 x 2)

	      0,0000       0,0000
	    -0,76587      -1,0600
	    -0,43188      0,30687
	    -0,82656      0,40681
	     0,39246      0,75479
	     0,36875       2,5498

	  Adianto (6 x 2)

	    -0,43188      0,30687
	    -0,82656      0,40681
	     0,39246      0,75479
	     0,36875       2,5498
	     0,28855     -0,55251
	      0,0000       0,0000

	  ? eval X'X
	      1,8295       1,4201
	      1,4201       8,7596

	  ? eval mcovg(X,,, 0)
	      1,8295       1,4201
	      1,4201       8,7596

	  ? eval X'(X + Retardo + Adianto)
	      3,0585       2,5603
	      2,5603       10,004

	  ? eval mcovg(X,,, 1)
	      3,0585       2,5603
	      2,5603       10,004
	</code>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, a función devolve un escalar
	  coa súa media na mostra, ignorando calquera observación ausente.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, a función devolve unha
	  serie <math>y</math> tal que <math>y</math><sub>t</sub> indica
	  a media dos valores das variables desa lista na observación
	  <math>t</math>. Por defecto, se hai algún valor ausente en
	  <math>t</math>, a media rexístrase como <lit>NA</lit>; pero
	  se lle das un valor non nulo a <argname>parcial</argname>,
	  calquera valor non ausente se usará para crear o
	  estatístico.
	</para>
	<para>
	  O seguinte exemplo ilustra o funcionamento da función:
	</para>
	<code>
	  open denmark.gdt
	  eval mean(LRM)
	  list L = dataset
	  eval mean(L)
	</code>
	<para>
    A primeira solicitude devolverá un escalar co valor medio da serie
    <argname>LRM</argname>, e a segunda devolverá unha
    serie.
	</para>
	<para>
	  <seelist>
            <fncref targ="median"/>
            <fncref targ="sum"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
            <fncref targ="sd"/>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila con cada unha das medias de cada columna de
	  <argname>X</argname>. Se indicas un valor non nulo para o segundo
	  argumento (opcional), ignóranse os valores ausentes; doutro xeito, o
	  resultado é <lit>NA</lit> para cada columna que conteña valores ausentes.
	</para>
	<para>
	  Por exemplo, o seguinte anaco de código...
	</para>
	<code>
	  matrix m = mnormal(5, 2)
	  m[1,2] = NA
	  print m
	  eval meanc(m)
	</code>
	<para>
	  xera este resultado:
	</para>
	<code>
	  ? print m
	  m (5 x 2)

	   -0,098299          nan
	      1,1829      -1,2817
	     0,46037     -0,92947
	      1,4896     -0,91970
	     0,91918      0,47748

	  ? eval meanc(m)
	     0,79075          nan
	</code>
	<para>
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
            <fncref targ="maxc"/>
            <fncref targ="minc"/>
            <fncref targ="sdc"/>
            <fncref targ="prodc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna con cada unha das medias de cada fila de
	  <argname>X</argname>. Se indicas un valor non nulo para o segundo
	  argumento (opcional), ignóranse os valores ausentes; doutro xeito, o
	  resultado é <lit>NA</lit> para cada fila que conteña valores ausentes.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, a función devolve un escalar
	  coa súa mediana na mostra, ignorando calquera observación ausente.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, a función devolve unha serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> indica a mediana
	  dos valores das variables desa lista na observación <math>t</math>,
	  ou <lit>NA</lit> no caso de que exista algún valor ausente en
	  <math>t</math>.
	</para>
	<para>
	  O seguinte exemplo ilustra o funcionamento da función:
	</para>
	<code>
	  set verbose off
	  open denmark.gdt
	  eval median(LRM)
	  list L = dataset
	  series m = median(L)
	</code>
	<para>
    A primeira solicitude devolverá un escalar co valor mediano da
    serie <argname>LRM</argname>, e a segunda devolverá unha
    serie.
	</para>
	<para>
	  <seelist>
            <fncref targ="mean"/>
            <fncref targ="sum"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
            <fncref targ="sd"/>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a matriz exponencial dunha matriz cadrada <argname>A</argname>.
	  Se <argname>A</argname> é unha matriz real, utilízase para elo o
	  algoritmo 11.3.1 de <cite key="golub96">Golub e Van Loan (1996)</cite>.
	  Se <argname>A</argname> é unha matriz complexa, o algoritmo utiliza
	  a descomposición en autovalores e <argname>A</argname> debe ser
	  diagonalizable.
	</para>
	<para context="tex">
	  Calcula e devolve a matriz exponencial dunha matriz cadrada,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\]
	  (A serie que está implícita nesta expresión seguramente vai converxer.)
	  Se <argname>A</argname> é unha matriz real, utilízase para elo o
	  algoritmo 11.3.1 de <cite key="golub96">Golub e Van Loan (1996)</cite>.
	  Se <argname>A</argname> é unha matriz complexa, o algoritmo utiliza
	  a descomposición en autovalores e <argname>A</argname> debe ser
	  diagonalizable.
	</para>
	<para>
	  Consulta tamén <fncref targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="mgradient" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Derivadas analíticas para as ponderacións dun MIDAS. Denotando como
	  <math>k</math> ao número de elementos que compoñen o vector
	  <repl>theta</repl> de hiperparámetros, esta función devolve unha
	  matriz de orde <by r="p" c="k"/>, que contén o gradiente do vector de
	  ponderacións (tal como o calcula a función <fncref targ="mweights"/>)
	  con respecto a os elementos de <repl>theta</repl>. O primeiro
	  argumento representa o nivel de retardo desexado, e o derradeiro
	  argumento especifica o tipo de disposición de parámetros. Consulta
	  a función <lit>mweights</lit> para ter unha relación dos valores
	  admisibles para <repl>tipo</repl>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="midasmult"/>
	    <fncref targ="mlincomb"/>
	    <fncref targ="mweights"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="midasmult" section="midas" output="matrix">
      <fnargs>
	<fnarg type="bundle">mod</fnarg>
	<fnarg type="bool">acumular</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o cálculo dos multiplicadores MIDAS. O argumento
	  <argname>mod</argname> debe ser un feixe que inclúa un
	  modelo MIDAS, do tipo que se xera mediante a instrución
	  <cmdref targ="midasreg"/> e que é accesible mediante a clave
	  <fncref targ="$model"/>. A función devolve unha matriz cos
	  multiplicadores implícitos MIDAS para a variable <argname>v</argname>
	  na primeira columna, e os desvíos padrón correspondentes na
	  segunda columna. Se o argumento <argname>acumular</argname> non
	  é cero, os multiplicadores se acumulan.
	</para>
	<para>
	  Observa que automaticamente fornécese a matriz que se devolve de
	  etiquetas adecuadas para as filas, de xeito que resultan indicadas para
	  usar como primeiro argumento da instrución <cmdref targ="modprint"/>.
	  Por exemplo, o código
	</para>
	<code>
	  open gdp_midas.gdt
	  list dIP = ld_indpro*
	  smpl 1985:1 ;
	  midasreg ld_qgdp 0 ; mds(dIP, 0, 6, 2)
	  matrix ip_m = midasmult($model, 0, 1)
	  modprint ip_m
	</code>
	<para>
	  xera o seguinte resultado:
	</para>
	<code>
             Coeficiente   Desv. padrón     z       Valor p
  ---------------------------------------------------------
  dIP_0      0,343146      0,0957752     3,583     0,0003   ***
  dIP_1      0,402547      0,0834904     4,821     1,43e-06 ***
  dIP_2      0,176437      0,0673776     2,619     0,0088   ***
  dIP_3      0,0601876     0,0621927     0,9678    0,3332
  dIP_4      0,0131263     0,0259137     0,5065    0,6125
  dIP_5      0,000965260   0,00346703    0,2784    0,7807
  dIP_6      0,00000       0,00000      NA        NA
	</code>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
            <fncref targ="mweights"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="depends">
      <fnargs>
        <fnarg type="anyfloat">x</fnarg>
        <fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Por favor, consulta a axuda para <fncref targ="max"/>; esta función
	  opera exactamente do mesmo xeito, agás polo feito de que devolve
	  o mínimo ou mínimos.
	</para>
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que contén o valor máis pequeno de cada columna
	  da matriz <argname>X</argname>. Para columnas que teñan valores
	  <lit>NA</lit>s, o resultado tamén establécese como <lit>NA</lit>, agás
	  cando non sexa cero o argumento opcional <argname>obviar_na</argname>,
	  en cuxo caso devólvese a menor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna que contén o valor máis pequeno de cada fila
	  da matriz <argname>X</argname>. Para filas que teñan valores
	  <lit>NA</lit>s, o resultado tamén establécese como <lit>NA</lit>, agás
	  cando non sexa cero o argumento opcional <argname>obviar_na</argname>,
	  en cuxo caso devólvese a menor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha variable binaria (do mesmo tipo que o argumento) que toma
	  o valor 1 cando <argname>x</argname> é <lit>NA</lit>. Se ese argumento
	  é unha serie, faise a comprobación para cada elemento. No caso de que
	  <argname>x</argname> sexa unha lista de series, devolve unha serie que
	  toma o valor 1 nas observacións nas que ao menos unha das series presenta
	  un valor ausente, e o valor 0 noutro caso. Por exemplo, o seguinte código
	</para>
	<code>
    nulldata 3
    series x = normal()
    x[2] = NA
		series x_ismiss = missing(x)
		print x x_ismiss --byobs
	</code>
	<para>
	  establece un valor ausente na segunda observación de <argname>x</argname>,
    e xera unha nova serie booleana <argname>x_ismiss</argname> que
	  identifica a observación ausente.
	</para>
	<code>
		             y     y_ismiss

		1    -1,551247            0
		2                         1
		3    -2,244616            0
	</code>
	<para>
	  <seelist>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado do tipo do argumento, mudando os <lit>NA</lit>s
	  en ceros. Se <argname>x</argname> é unha serie ou unha matriz, múdase
	  elemento a elemento. Por exemplo, o seguinte código
	</para>
	<code>
		nulldata 3
		series x = normal()
		x[2] = NA
		y = misszero(x)
		print x y --byobs
	</code>
	<para>
	  establece un valor ausente na segunda observación de
	  <argname>x</argname>, e xera unha nova serie <argname>y</argname>
	  na que se substitúe a observación ausente por un cero:
	</para>
	<code>
	             x            y

		1    0,7355250    0,7355250
		2                     0,000
		3   -0,2465936   -0,2465936
	</code>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Move cara arriba ou abaixo as filas da matriz <argname>X</argname>.
	  Cando <argname>p</argname> é un escalar positivo, a función devolve
	  unha matriz semellante a <argname>X</argname>, pero cos valores de
	  cada columna desprazados <argname>p</argname> filas cara abaixo,
	  e coas primeiras <argname>p</argname> filas cubertas co valor
	  <argname>m</argname>. Cando <argname>p</argname> é un número
	  negativo, a matriz que se devolve seméllase a <argname>X</argname>,
	  pero cos valores de cada columna desprazados cara arriba, e as últimas
	  filas cubertas co valor <argname>m</argname>. Se omites
	  <argname>m</argname>, enténdese que é igual a cero.
	</para>
	<para context="tex">
	  Move cara arriba ou abaixo as filas da matriz <argname>X</argname>.
	  Cando $p$ é un escalar positivo, a función devolve unha matriz
	  $Y$ cuxo elemento característico é $Y_{i,j} = X_{i-p,j}$ para $i \ge p$,
	  e cero noutro caso. Noutras palabras, devolve unha matriz semellante
	  a <argname>X</argname>, pero cos valores de cada columna desprazados
	  <argname>p</argname> filas cara abaixo, e coas primeiras
	  <argname>p</argname> filas cubertas co valor <argname>m</argname>.
	  Cando <argname>p</argname> é un número negativo, a matriz que se
	  devolve seméllase a <argname>X</argname>, pero cos valores de cada
	  columna desprazados cara arriba, e as últimas filas cubertas co valor
	  <argname>m</argname>. Se omites <argname>m</argname>, enténdese que
	  é igual a cero.
	</para>
	<para>
	  Se <argname>p</argname> é un vector, a operación indicada no parágrafo
	  anterior realízase con cada un dos elementos de <argname>p</argname>,
	  e as matrices resultantes xúntanse horizontalmente. O seguinte código
	  ilustra este uso, introducindo para elo unha matriz <argname>X</argname>
	  que ten dúas columnas, e o argumento <argname>p</argname> que indica
	  os retardos 1 e 2. Tamén se determina que os valores ausentes teñan
	  o valor NA, en contraposición ao 0 establecido por defecto.
	</para>
	<code>
	matrix X = mnormal(5, 2)
	print X
	eval mlag(X, {1, 2}, NA)
	</code>
	<code>
	m (5 x 2)

	    1,5953    -0,070740
    -0,52713     -0,47669
	   -2,2056     -0,28112
	   0,97753       1,4280
	   0,49654      0,18532

	       nan          nan          nan          nan
     1,5953    -0,070740          nan          nan
	   -0,52713     -0,47669       1,5953    -0,070740
	   -2,2056     -0,28112     -0,52713     -0,47669
	   0,97753       1,4280      -2,2056     -0,28112
	</code>
	<para>
	  Consulta tamén <fncref targ="lags"/>.
	</para>
      </description>
    </function>

    <function name="mlincomb" section="midas" output="series">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é unha función MIDAS moi oportuna que combina as funcións
	  <fncref targ="lincomb"/> e <fncref targ="mweights"/>. Dada a lista
	  <repl>hfvars</repl>, elabora unha serie que é unha suma ponderada
	  dos elementos desa lista. As ponderacións baséanse no vector
	  <repl>theta</repl> de hiperparámetros e no tipo de disposición de
	  parámetros: consulta a función <lit>mweights</lit> para obter máis
	  detalles. Cae na conta de que <fncref targ="hflags"/> xeralmente
	  é o mellor xeito de crear unha lista apropiada para que sexa o
	  primeiro argumento desta función.
	</para>
	<para>
	  Para ser máis explícitos, a expresión
	</para>
	<code>
	  series s = mlincomb(hfvars, theta, 2)
	</code>
	<para>
	  é equivalente a
	</para>
	<code>
	  matrix w = mweights(nelem(hfvars), theta, 2)
	  series s = lincomb(hfvars, w)
	</code>
	<para>
	  pero utilizar a función <lit>mlincomb</lit>, permite economizar algo
	  ao teclear e tamén nalgúns ciclos de uso de CPU.
	</para>
      </description>
    </function>

    <function name="mlog" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co logaritmo matricial de <argname>A</argname>.
	  O algoritmo que se usa baséase na descomposición en autovalores, polo
	  que necesita que a matriz <argname>A</argname> sexa diagonalizable.
	  Consulta tamén <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz feita con valores xerados de forma pseudoaleatoria
	  mediante variables con distribución Normal estándar, e que vai ter
	  <argname>r</argname> filas e <argname>c</argname> columnas. Se o omites,
	  o número de columnas establécese en 1 (vector columna), por defecto.
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz <by r="k" c="n"/> de estimacións de parámetros
	  obtidos mediante a regresión de Mínimos Cadrados Ordinarios da matriz
	  <argname>Y</argname> de orde <by r="T" c="n"/> sobre a matriz
	  <argname>X</argname> de orde <by r="T" c="k"/>.
	</para>
	<para>
	  Cando se indica o terceiro argumento, e non é <lit>null</lit>, a
	  función vai xerar unha nova matriz <argname>U</argname> de orde
	  <by r="T" c="n"/>, que contén os erros. Cando se indica o último
	  argumento, e non é <lit>null</lit>, a matriz <argname>V</argname>
	  que se xera vai ser de orde <by r="k" c="k"/>, e contén (a) a matriz
	  de covarianzas dos estimadores dos parámetros, se <argname>Y</argname>
	  ten só unha columna, ou (b) a matriz <math>X'X</math><sup>-1</sup>
	  se <argname>Y</argname> ten varias columnas.
	</para>
	<para>
	  Por defecto, as estimacións obtéñense por medio da descomposición de
	  Cholesky, cun último recurso á descomposición QR se as columnas de
	  <argname>X</argname> teñen alto grao de multicolinearidade. Podes forzar
	  o uso da descomposición SVD mediante a instrución <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mpols"/>
            <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="int">duracsemana</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do mesmo tipo que o argumento) que expresa
	  cantos días (relevantes) ten un mes dun ano (no calendario Gregoriano
	  proléptico). O argumento <argname>duracsemana</argname>, que debe
	  de ser igual a 5, 6 ou 7, indica o número de días da semana que se
	  deben contar (co valor 6 non se contan os domingos, e con 5 non se
	  contan nin os sábados nin os domingos).
	</para>
	<para>
	  O valor que se devolva vai ser un escalar se son escalares tanto
	  <argname>mes</argname> coma <argname>ano</argname>; noutro caso
	  vai ser unha serie.
	</para>
	<para>
	  Por exemplo, se tes aberto un conxunto de datos mensuais, a expresión
	</para>
	<code>
	  series wd = monthlen($obsminor, $obsmajor, 5)
	</code>
	<para>
	  devolverá unha serie que vai conter o número de días laborables
	  de cada un dos meses da mostra.
	</para>
      </description>
    </function>

    <function name="movavg" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
	<fnarg type="scalar" optional="true">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que é unha media móbil de <argname>x</argname>
	  e, dependendo do valor do parámetro <argname>p</argname>, resultará
	  unha media móbil simple ou ponderada exponencialmente.
	</para>
	<para context="notex">
	  Cando <argname>p</argname> &gt; 1, a función calcula unha media
	  móbil simple de <argname>p</argname> elementos; é dicir, calcula
	  a media aritmética de <math>x</math> desde o período <math>t</math>
	  ata o período <math>t-p+1</math>. Cando indicas un valor non nulo
	  para o argumento <argname>control</argname> (opcional), a media
	  móbil <quote>céntrase</quote>; noutro caso, <quote>retárdase</quote>.
	  O outro argumento <argname>y0</argname> non se vai ter en
	  conta.
	</para>
	<para context="tex">
	  Cando $p&gt;1$, a función calcula unha media móbil simple de
	  <argname>p</argname> elementos; é dicir, calcula
	  $\frac{1}{p} \sum_{i=0}^{p-1} x_{t-i}$. Cando indicas un valor non
	  nulo para o argumento <argname>control</argname> (opcional), a media
	  móbil <quote>céntrase</quote>; noutro caso, <quote>retárdase</quote>.
	  O outro argumento <argname>y0</argname> non se vai ter en conta.
	</para>
	<para context="notex">
	  Cando <argname>p</argname> é un fracción decimal entre 0 e 1, a
	  función calcula unha media móbil exponencial:
	</para>
	<para context="notex">
	  <math>y(t) = p*x(t) + (1-p)*y(t-1)</math>
	</para>
	<para context="notex">
	  Por defecto, a serie <math>y</math> que se devolve, iníciase
	  utilizando o primeiro valor válido de <argname>x</argname>. Pero
	  podes utilizar o parámetro <argname>control</argname> para
	  especificar un número de observacións iniciais, de forma que
	  a súa media tomarase como <math>y(0)</math>; un valor de cero para
	  <argname>control</argname> indica que deben de tomarse todas as
	  observacións para calcular ese valor. Outra posibilidade consiste
	  en que podes especificar o valor inicial utilizando o argumento
	  opcional <argname>y0</argname>; nese caso, o argumento
	  <argname>control</argname> non vai terse en conta.
	</para>
	<para context="tex">
	  Cando $0 &lt; p &lt; 1$, a función calcula unha media móbil
	  exponencial: \[y_t = p x_t + (1-p)y_{t-1}\]. Esta é a fórmula de
	  <cite key="roberts59">Roberts (1959)</cite>. Por defecto, a serie
	  $y$ que se devolve, iníciase utilizando o primeiro valor válido de
	  $x$. Pero podes utilizar o parámetro <argname>control</argname>
	  para especificar un número de observacións iniciais, de forma que
	  a súa media tomarase como $y_0$; un valor de cero para
	  <argname>control</argname> expresa que deben de tomarse todas as
	  observacións para calcular ese valor. Outra posibilidade consiste
	  en que podes especificar o valor inicial utilizando o argumento
	  opcional <argname>y0</argname>; nese caso, o argumento
	  <argname>control</argname> non vai terse en conta.
	</para>
      </description>
    </function>

    <function name="mpiallred" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;object</fnarg>
	<fnarg type="string">op</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocalo todos
	  os procesos. Esta función opera igual que <fncref targ="mpireduce"/>
	  agás polo feito de que todos os procesos (non só o proceso principal)
	  reciben unha copia do obxecto <quote>reducido</quote> en troques
	  do orixinal. Polo tanto, isto é equivalente ao que fai a función
	  <lit>mpireduce</lit> seguida por unha chamada á función
	  <fncref targ="mpibcast"/>, pero máis eficiente.
	</para>
      </description>
    </function>

    <function name="mpibarrier" section="mpi" output="int">
      <description>
	<para>
	  Só dispoñible cando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); non require
	  argumentos. Forza a sincronización dos procesos MPI: ningún
	  proceso pode continuar máis alá da barreira ata que a acaden
	  todos eles.
	</para>
	<code>
	  # Ningún pasa ata que todos cheguen aquí
	  mpibarrier()
	</code>
      </description>
    </function>

    <function name="mpibcast" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;obxecto</fnarg>
	<fnarg type="int" optional="true">raíz</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocalo todos
	  os procesos. Difunde o argumento <argname>obxecto</argname>,
	  que deberás indicar en forma punteiro, a todos os procesos. O
	  obxecto en cuestión (unha matriz, un feixe, un escalar, un arranxo
	  unha cadea de texto ou unha lista) debe indicarse en todos os
	  procesos anteriores á difusión. Ningún proceso pode continuar
	  despois dunha chamada a <lit>mpibcast</lit> ata que todos os
	  procesos o consigan executar con éxito.
	</para>
	<para>
	  Por defecto, enténdese que a <quote>raíz</quote> ou orixe da
	  difusión é o proceso MPI con rango 0; pero podes axustar isto
	  por medio do segundo argumento (opcional), que deberá ser un
	  número enteiro entre 0 e o número de procesos MPI menos 1.
	</para>
	<para>
	  Deseguido temos un exemplo sinxelo. Cando se complete con
	  éxito, cada proceso vai ter unha copia da matriz <lit>X</lit>
	  definida no rango 0.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	      X = mnormal(T, k)
	  endif
	  mpibcast(&amp;X)
	</code>
      </description>
    </function>

    <function name="mpirecv" section="mpi" output="object">
      <fnargs>
	<fnarg type="int">src</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>). Para maior aclaración,
	  consulta a función <fncref targ="mpisend"/>, coa que <lit>mpirecv</lit>
	  deberá sempre emparellarse. O argumento <argname>src</argname>
	  especifica a xerarquía do proceso do que se vai recibir o obxecto,
	  no rango que vai desde 0 ata o número de procesos MPI
	  menos 1.
	</para>
      </description>
    </function>

    <function name="mpireduce" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;obxecto</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">raíz</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocalo todos
	  os procesos. Esta función reúne obxectos (escalares, matrices ou
	  arranxos) cun nome determinado indicados en forma de punteiro,
	  de todos os procesos, e os <quote>reduce</quote> a un único
	  obxecto no nodo raíz.
	</para>
	<para>
	  O argumento <lit>op</lit> especifica a operación ou método
	  de redución. Os métodos admitidos para os escalares son
	  <lit>sum</lit> (suma), <lit>prod</lit> (produto), <lit>max</lit>
	  (máximo) e <lit>min</lit> (mínimo). Para as matrices, os métodos
	  son <lit>sum</lit>, <lit>prod</lit> (produto de Hadamard),
	  <lit>hcat</lit> (concatenación horizontal) e <lit>vcat</lit>
	  (concatenación vertical). Para os arranxos só se admite
	  <lit>acat</lit> (concatenación).
	</para>
	<para>
	  Por defecto, enténdese que a <quote>raíz</quote> ou meta da
	  redución é o proceso MPI con rango 0; pero podes axustar isto
	  por medio do terceiro argumento (opcional), que deberá ser un
	  enteiro entre 0 e o número de procesos MPI menos 1.
	</para>
	<para>
	  Deseguido temos un exemplo. Cando se complete con éxito o antedito,
	  o proceso raíz vai ter unha matriz <lit>X</lit> que será a suma das
	  matrices <lit>X</lit> de todos os procesos.
	</para>
	<code>
	  matrix X
	  X = mnormal(T, k)
	  mpireduce(&amp;X, sum)
	</code>
      </description>
    </function>

    <function name="mpiscatter" section="mpi" output="int">
      <fnargs>
	<fnarg type="matrixref">&amp;M</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">raíz</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocalo
	  todos os procesos. Esta función distribúe anacos dunha matriz
	  do proceso raíz, a todos os procesos. Debes anunciar a matriz en
	  todos os procesos que preceden a invocar a <lit>mpiscatter</lit>,
	  e debes indicalo en forma de punteiro.
	</para>
	<para>
	  O argumento <lit>op</lit> debe ser, ou ben <lit>byrows</lit> ou
	  ben <lit>bycols</lit>. Denotemos con <math>q</math> ao cociente
	  entre o número de filas da matriz que se vai dispersar, e o número
	  de procesos. No caso <lit>byrows</lit>, o proceso raíz vai enviar
	  as primeiras <math>q</math> filas ao proceso 0; as seguintes
	  <math>q</math> ao proceso 1, etcétera. Se queda un remanente
	  do reparto de filas, engádese á derradeira asignación. O caso
	  <lit>bycols</lit> é exactamente análogo pero o reparto da matriz
	  faise por columnas.
	</para>
	<para>
	  A continuación temos un exemplo. Se temos 4 procesos, cada un
	  (incluído o raíz) vai ter unha porción <by r="2500" c="10"/>
	  da <lit>X</lit> orixinal, tal como se atopaba no proceso raíz.
	  Se quixeras manter a matriz completa no proceso raíz, é
	  necesario que fagas unha copia da mesma antes de invocar a
	  <lit>mpiscatter</lit>.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	      X = mnormal(10000, 10)
	  endif
	  mpiscatter(&amp;X, byrows)
	</code>
      </description>
    </function>

    <function name="mpisend" section="mpi" output="int">
      <fnargs>
	<fnarg type="object">obxecto</fnarg>
	<fnarg type="int">destino</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>). Envía o obxecto indicado
	  (unha matriz, un feixe, un arranxo, un escalar, unha cadea de texto
	  ou unha lista) desde o proceso vixente cara ao identificado polo
	  enteiro <argname>destino</argname> (desde 0 ata o número de
	  procesos MPI menos 1).
	</para>
	<para>
	  Unha chamada a esta función debe sempre estar emparellada cunha
	  chamada a <fncref targ="mpirecv"/> no proceso <argname>destino</argname>,
	  como no seguinte exemplo no que se envía unha matriz desde o
	  rango 2 ata o rango 3.
	</para>
	<code>
	  if $mpirank == 2
	      matrix C = cholesky(A)
	      mpisend(C, 3)
	  elif $mpirank == 3
	      matrix C = mpirecv(2)
	  endif
	</code>
      </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona igual que <fncref targ="mols"/>, devolvendo unha matriz, agás
	  que os cálculos fanse con alta precisión utilizando a biblioteca GMP.
	</para>
	<para>
	  Por defecto, GMP utiliza 256 bits para cada número de punto flotante,
	  pero podes axustar isto utilizando a variable de contexto
	  <lit>GRETL_MP_BITS</lit>; por exemplo, <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-matrix">p1</fnarg>
	<fnarg type="scalar-or-matrix" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">filas</fnarg>
	<fnarg type="int">columnas</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
  <example>matrix D = mrandgen(dir, {0.5,1,2,4}, 30)</example>
      </examples>
      <description>
	<para>
	  Con unha excepción (mira máis abaixo), esta función opera da mesma
	  forma que a función <fncref targ="randgen"/> agás polo feito de que
	  devolve unha matriz en troques dunha serie. Os argumentos iniciais
	  (cuxo número depende da distribución escollida) para esta función
	  xa se describen para <lit>randgen</lit>, pero deben estar seguidos
	  por dous números enteiros para especificar as dimensións de filas e
	  de columnas que vai ter a matriz aleatoria desexada. Se indicas
	  <argname>p1</argname> ou <argname>p2</argname> en forma matricial,
	  deben ter un número de elementos que sexa igual ao
	  produto de <argname>filas</argname> por
	  <argname>columnas</argname>.
	</para>
	<para>
	  Un caso excepcional é a distribución de Dirichlet. Esta é unha
	  distribución multivariante, e facer unha chamada a <lit>mrandgen</lit>
	  con <quote>dir</quote> como primeiro parámetro carrexa unha sintaxe
	  especial: o segundo argumento debe ser un vector <math>a</math>,
	  positivo con <math>k</math> elementos, e o terceiro argumento debe
	  ser un escalar <math>r</math>. A función vai devolver unha matriz
	  de orde <by r="r" c="k"/> na que cada fila é unha extracción
	  independente dunha distribución de Dirichlet con parámetro
	  <math>a</math>.
	</para>
	<para>
	  O primeiro dos exemplos precedentes solicita un vector columna de 50
	  elementos, extraídos a partir dunha distribución Uniforme en [0,100].
	  O segundo exemplo especifica unha matriz aleatoria de orde
	  <by r="20" c="20"/>, con valores extraídos dunha distribución
	  <math>t</math> con 14 grados de liberdade; e o terceiro devolve unha
	  matriz de orde <by r="30" c="4"/> que contén 30 extraccións da
	  distribución de Dirichlet indicada.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg optional="true" type="bool">importar</fnarg>
      </fnargs>
      <description>
	<para>
	  Le unha matriz gardada no ficheiro chamado
	  <argname>nomeficheiro</argname>. Se no nome non está especificado o
	  camiño completo ata o ficheiro, vaise procurar en algunhas localizacións
	  que se consideren <quote>probables</quote>, empezando polo cartafol
	  de traballo establecido nese momento en <cmdref targ="workdir"/>. Non
	  obstante, cando se indica un valor non nulo para o segundo argumento
	  <argname>importar</argname> (opcional) da función, o ficheiro procúrase
	  no cartafol <quote>punto</quote> do usuario. Isto ten a intención de
	  que se use esta función xunto coas que exportan matrices, e que se
	  ofrecen no contexto da instrución <cmdref targ="foreign"/>. Nese caso,
	  o argumento <argname>nomeficheiro</argname> debe de ser un nome de
	  ficheiro simple, sen indicar o camiño ata o ficheiro.
	</para>
	
	<para>Polo de agora, a función recoñece catro formatos de ficheiro:
	</para>

	<subhead>Formato de texto orixinal</subhead>
	<para>
	  Estes ficheiros identifícanse grazas á extensión
	  <quote><lit>.mat</lit></quote>, e son completamente compatibles co
	  formato de ficheiro de matriz Ox. Cando o nome do ficheiro ten a
	  extensión <quote><lit>.gz</lit></quote>, asúmese que ao gardar
	  os datos se aplicou a compresión gzip.

	  O ficheiro asúmese que é de texto plano, de acordo coa seguinte
	  especificación:
	</para>
	<ilist>
	  <li>
            <para>
	          O ficheiro comeza con ningún ou con un número calquera de
	          comentarios, definidos por liñas que comezan co carácter
	          cancelo, <lit>#</lit>; estas liñas van ignorarse.
            </para>
	  </li>
	  <li>
            <para>
              A primeira liña que non sexa un comentario contén dous
              enteiros, separados por un carácter de tabulación, para
              indicar o número de filas e de columnas, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              As columnas se separan mediante tabulacións.
            </para>
	  </li>
	  <li>
            <para>
              O separador decimal é o carácter punto,
              <quote><lit>.</lit></quote>.
            </para>
	  </li>
	</ilist>

	<subhead>Ficheiros binarios</subhead>
	<para>
	  Os ficheiros coa extensión <quote><lit>.bin</lit></quote> asúmese
	  que están en formato binario. A extensión <quote><lit>.gz</lit></quote>
	  tamén se recoñece para a compresión gzip. Os primeiros 19 bytes
	  conteñen os caracteres <lit>gretl_binary_matrix</lit>; os seguintes
	  8 bytes conteñen dous enteiros de 32 bits que proporcionan
	  o número de filas e de columnas; e o que resta do ficheiro contén
	  os elementos da matriz ordenados por orde de maior columna, con
	  formato de <quote>dobres</quote> en extremo menor (little-endian).
	  Se executas GRETL nun sistema de extremo maior (big-endian), os
	  valores binarios convértense a extremo menor cando se escriben, e
	  convértense a extremo maior cando se len.
	</para>

	<subhead>Ficheiros con texto delimitado</subhead>
	<para>
	  Se o nome do ficheiro que se vai ler ten a extensión
	  <quote><lit>.csv</lit></quote>, as regras que administran a lectura
	  do ficheiro segundo o seu formato son diferentes, e máis laxas.
	  Neste caso, o conxunto de datos presentes <emphasis>non</emphasis>
	  debe estar precedido por unha liña que especifique o número de
	  filas e de columnas. GRETL vai tratar de determinar o delimitador
	  utilizado (coma, espazo, ou punto e coma), e fará o que poda para
	  importar a matriz, permitindo o uso da coma como separador decimal,
	  se é necesario. Cae na conta de que o delimitador non debe ser o
	  carácter do tabulador, polo risco de confundir ese tipo de ficheiros
	  cos que teñen o formato de matrices <quote>orixinal</quote> de GRETL.
	</para>

	<subhead>Ficheiros de conxuntos de datos de GRETL</subhead>
	<para>
	  Os ficheiros que teñan extensión <quote><lit>.gdt</lit></quote> ou
	  <quote><lit>.gdtb</lit></quote> trátanse como ficheiros orixinais de
	  datos de GRETL, tal como os crea a instrución <cmdref targ="store"/>
	  (gardar). En tal caso, a matriz que se vai devolver contén os valores
	  numéricos das series do conxunto de datos, ordenadas en columnas. Cae
	  na conta de que as series con valores en cadeas de texto non se len
	  como tales; a matriz só vai conter as súas codificacións numéricas.
	</para>

	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">porcolumna</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que contén as filas de <argname>X</argname>
	  en orde inversa; ou as columnas en orde inversa se o segundo
	  argumento ten un valor non nulo.
	</para>
      </description>
    </function>

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Mínimos cadrados restrinxidos: Xera a matriz de orde <by r="k" c="n"/>
	  cos parámetros estimados mediante a regresión de mínimos cadrados da
	  matriz <argname>Y</argname> de orde <by r="T" c="n"/>, sobre a matriz
	  <argname>X</argname> de orde <by r="T" c="k"/>, suxeita ao conxunto
	  de restricións lineais dos parámetros <math>RB </math> = <math>q</math>,
	  onde <math>B</math> representa o vector que formarían os parámetros
	  encastelados uns sobre os outros. <argname>R</argname> debe de ter
	  <math>kn</math> columnas, e cada liña dela indica os coeficientes dunha
	  das restricións lineais. O número de filas de <argname>q</argname>
	  debe de coincidir co número de filas de <argname>R</argname>.
	</para>
	<para>
	  Se o quinto argumento da función non é <lit>null</lit>, entón a
	  matriz <argname>U</argname> de orde <by r="T" c="n"/> vai conter
	  os erros. Cando proporcionas un argumento final que non é
	  <lit>null</lit>, entón a matriz <argname>V</argname> de orde
	  <by r="k" c="k"/> vai gardar a contrapartida restrinxida da matriz
	  <math>X'X</math><sup>-1</sup>. Podes construír a matriz de
	  varianzas-covarianzas dos estimadores da ecuación <math>i</math>
	  multiplicando a submatriz apropiada de <argname>V</argname> por
	  unha estimación da varianza da perturbación desa
	  ecuación.
	</para>
      </description>
    </function>

    <function name="mshape" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Reordena os elementos da matriz <argname>X</argname> nunha nova matriz
	  que ten <argname>r</argname> filas e <argname>c</argname> columnas. Os
	  elementos lense e gárdanse comezando polo da primeira columna e primeira fila
	  de <argname>X</argname>, e seguindo cos das seguintes filas ata acabar
	  cos desa columna; e logo coas demais columnas. Se <argname>X</argname>
	  ten menos elementos ca <math>k</math>= <math>rc</math>, estes vanse
	  repetir de forma cíclica. Noutro caso, se <argname>X</argname> ten
	  máis elementos, só se utilizan os primeiros <math>k</math> elementos.
	</para>
	<para>
	  Se omites o terceiro argumento, por defecto <argname>c</argname>
	  establécese igual a 1 se <argname>X</argname> é <by r="1" c="1"/>;
	  noutro caso, establécese igual a <math>N</math>/<argname>r</argname>
	  onde <math>N</math> representa o número total de elementos que
	  hai en <argname>X</argname>. Porén, cando <math>N</math> non é
	  un múltiplo enteiro de <argname>r</argname> se presenta un
	  erro.
	</para>
	<para>
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coas mesmas filas da matriz do argumento
	  <argname>X</argname> reordenadas de forma crecente de acordo cos
	  elementos da columna <argname>j</argname>. Esta orde é estable: as
	  filas que comparten o mesmo valor na columna <argname>j</argname>
	  non se intercambian.
	</para>
      </description>
    </function>

    <function name="msplitby" section="matrix" output="matrices">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-matrix">v</fnarg>
	<fnarg type="bool">porcolum</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un arranxo de matrices, como resultado de separar horizontal
	  ou verticalmente a matriz <argname>X</argname>, baixo o control dos
	  argumentos <argname>v</argname> e <argname>porcolum</argname>.
	  Se o argumento <argname>porcolum</argname> non é nulo, a matriz
	  vaise separar por columnas; noutro caso e como predeterminado, faise
	  por filas.
	</para>
	<para>
	  O argumento <argname>v</argname> pode ser ben un vector ou ben
	  un escalar.
  </para>
    <ilist>
      <li>
        <para>
        Vector: Debe ter unha longura igual á dimensión relevante (de
        filas ou de columnas) da matriz <argname>X</argname>; amais
        debe conter números enteiros positivos. O maior enteiro establece
        a longura do arranxo que se devolve. Cada elemento de
        <argname>v</argname> indica o índice que ten, no arranxo,
        a matriz á que deberá asignarse a correspondente fila de
        <argname>X</argname>.
        </para>
      </li>
      <li>
        <para>
        Escalar: A dimensión relevante da matriz <argname>X</argname>
        (fila ou columna, según determine <argname>porcolum</argname>)
        debe ser un múltiplo exacto do valor deste escalar. A matriz
        <argname>X</argname> vaise separar en anacos con
        <argname>v</argname> filas ou columnas en cada un deles.
        </para>
      </li>
    </ilist>
	<para>
	  No seguinte exemplo separamos as filas dunha matriz <by r="4" c="3"/>
	  en tres matrices: as dúas primeiras filas asígnanse á primeira
	  matriz; a segunda matriz déixase baleira; a terceira e cuarta
	  matrices inclúen a terceira e cuarta filas de <argname>X</argname>,
	  respectivamente.
	</para>
	<code>
	  matrix X = {1,2,3; 4,5,6; 7,8,9; 10,11,12}
	  matrices M = msplitby(X, {1,1,3,4})
	  print M
	</code>
	<para>
	  A orde de impresión depara
	</para>
	<code>
	  Arranxo de matrices, longura 4
	  [1] 2 x 3
	  [2] null
	  [3] 1 x 3
	  [4] 1 x 3
	</code>
	<para>
	  O seguinte exemplo separa <argname>X</argname> equitativamente:
	</para>
	<code>
	  matrix X = {1,2,3; 4,5,6; 7,8,9; 10,11,12}
	  matrices MM = msplitby(X, 2)
	  print MM[1]
	  print MM[2]
	</code>
	<para>
	  que depara
	</para>
	<code>
	  ? print MM[1]
	  1   2   3 
	  4   5   6 

	  ? print MM[2]
	  7    8    9 
	  10   11   12 
	</code>
	<para>
	  Consulta a función <fncref targ="flatten"/> para a operación inversa.
	</para>
      </description>
    </function>

    <function name="muniform" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz feita con números xerados de forma pseudoaleatoria
	  mediante variables con distribución Uniforme (0,1), e que vai ter
	  <argname>r</argname> filas e <argname>c</argname> columnas. Se o omites,
	  o número de columnas establécese en 1 (vector columna), por defecto.
	  Aviso: O método predilecto para xerar números pseudoaleatorios con
	  distribución Uniforme é o que usa a función <fncref targ="randgen1"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mweights" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector de orde <math>p</math> coas ponderacións MIDAS
	  que se aplican aos <math>p</math> retardos dunha serie de alta
	  frecuencia, baseado no vector <repl>theta</repl> de hiperparámetros.
	</para>
	<para>
	  O argumento <repl>tipo</repl> identifica o tipo de disposición de
	  parámetros que vai regular o número <math>k</math> de elementos
	  que se solicitan para <repl>theta</repl>: 1 = para Almon exponencial
	  normalizada (<math>k</math> debe de ser cando menos igual a1,
	  habitualmente 2); 2 = para Beta normalizada co retardo final nulo
	  (<math>k</math> = 2); 3 = para Beta normalizada co retardo final
	  non nulo (<math>k</math> = 3); e 4 = para Almon polinómico
	  (<math>k</math> debe de ser cando menos igual a 1). Ten en conta
	  que, no caso de Beta normalizada, os dous primeiros elementos de
	  <repl>theta</repl> deben de ser positivos.
	</para>
	<para>
	  Podes indicar o <repl>tipo</repl> como un código enteiro, tal e
	  como se amosa máis abaixo, ou mediante unha das seguintes cadeas
	  de texto (respectivamente): <lit>nealmon</lit>, <lit>beta0</lit>,
	  <lit>betan</lit> ou <lit>almonp</lit>. Se utilizas unha cadea de
	  texto, esta deberá de estar situada entre comiñas. Por exemplo,
	  as dúas seguintes expresións son equivalentes:
	</para>
	<code>
	  W = mweights(8, theta, 2)
	  W = mweights(8, theta, "beta0")
	</code>
	<para>
	  <seelist>
	    <fncref targ="mgradient"/>
	    <fncref targ="midasmult"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg optional="true" type="bool">exportar</fnarg>
      </fnargs>
      <description>
	<para>
	  Escribe a matriz do argumento <argname>X</argname> nun ficheiro co
	  nome <argname>nomeficheiro</argname>. Por defecto, este ficheiro
	  vai ser de texto plano e, na primeira liña, vai conter dous números
	  enteiros que representan o número de filas e de columnas separados
	  (respectivamente) por un carácter de tabulación. Nas seguintes filas,
	  os elementos da matriz amósanse con notación científica, separados
	  por tabulacións (unha liña por fila). Para evitar confusións á hora
	  da súa lectura, os ficheiros que se escriban neste formato deben
	  ser nomeados co sufixo <quote><lit>.mat</lit></quote>. Para formatos
	  alternativos, mira máis abaixo.
	</para>
	<para>
	  Cando xa existe un ficheiro chamado <argname>nomeficheiro</argname>,
	  vaise sobrescribir. A execución da función devolve un valor nominal de 0
	  cando se completa con éxito; se fracasa a escritura, amósase un fallo.
	</para>
	<para>
	  O ficheiro cos resultados vai escribirse no cartafol establecido
	  como vixente, <cmdref targ="workdir"/>, agás que a cadea de texto
	  do argumento <repl>nomeficheiro</repl> especifique o cartafol co
	  camiño completo. Non obstante, se indicas un valor non nulo para o
	  argumento <argname>exportar</argname>, o ficheiro cos resultados vai
	  escribirse no cartafol <quote>punto</quote> do usuario, onde estará
	  accesible por defecto por medio das funcións para cargar matrices
	  que se ofrecen no contexto da instrución <cmdref targ="foreign"/>.
	  Neste caso, debes de indicar un simple nome de ficheiro para o
	  segundo argumento, sen a parte que expresa o camiño ao cartafol.
	</para>
	<para>
	  As matrices gardadas mediante a forma que ten por defecto a función
	  <lit>mwrite</lit>, poden lerse doadamente con outros programas.
	  Consulta o <guideref targ="chap:matrices"/> para obter máis detalles.
	</para>
	<para>
	  Tres matizacións, que se exclúen mutuamente, desta función están
	  dispoñibles como se indica deseguido:
	</para>
	<ilist>
	  <li>
	    <para>
	      Se o argumento <argname>nomeficheiro</argname> ten a extensión
	      <quote><lit>.gz</lit></quote>, entón o ficheiro gárdase co formato
	      descrito máis arriba, pero usando a compresión gzip.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se o argumento <argname>nomeficheiro</argname> ten a
	      extensión <quote><lit>.bin</lit></quote>, entón a matriz gárdase
	      con formato binario. Neste caso, os primeiros 19 bytes
	      conteñen os caracteres <lit>gretl_binary_matrix</lit>; os seguintes
	      8 bytes conteñen dous enteiros de 32 bits que proporcionan
	      o número de filas e de columnas; e o que resta do ficheiro contén
	      os elementos da matriz ordenados por orde de maior columna, con
	      formato de <quote>dobres</quote> en extremo menor (little-endian).
	      Se executas GRETL nun sistema de extremo maior (big-endian), os
	      valores binarios convértense a extremo menor cando se escriben, e
	      convértense a extremo maior cando se len.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se o argumento <argname>nomeficheiro</argname> ten a extensión
	      <quote><lit>.csv</lit></quote>, entón a matriz gárdase con
	      formato de separación con comas, sen a liña de encabezamento
	      que indique o número de filas e de columnas que a seguen.
	      Isto podería facer máis doado o tratamento con programas de
	      terceiros, pero non se recomenda cando se pretende ler o
	      ficheiro cos elementos da matriz por medio de GRETL.
	    </para>
	  </li>
	</ilist>
	<para>
	  Cae na conta de que, se vas ler o ficheiro coa matriz utilizando
	  outro software alleo, non resulta aconsellable que utilices as
	  opcións gzip nin binario. Pero se o queres para que o lea GRETL,
	  estes dous formatos alternativos permiten aforrar espazo; e co
	  formato binario logras unha lectura máis rápida de matrices
	  grandes. O formato gzip non é recomendable para matrices moi
	  grandes porque a descompresión pode ser bastante lenta.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
	  </seelist>
	  Para escribir unha matriz nun ficheiro, como conxunto de datos,
	  consulta <cmdref targ="store"/>.
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que inclúe a tabulación cruzada dos valores
	  contidos en <argname>x</argname> (por filas) e <argname>y</argname>
	  (por columnas). Os dous argumentos desta función deben ser do
	  mesmo tipo (ser series ambas ou vectores columna ambos). Xeralmente
	  agárdase (aínda que non é imprescindible) que os argumentos teñan
	  valores discretos, con menos valores diferentes que observacións.
	  Doutro xeito, a tabulación cruzada pode resultar moi grande e non
	  moi informativa.
	</para>
	<para>
	  <seelist>
            <fncref targ="values"/>
            <fncref targ="corresp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="naalen" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o cálculo do estimador non paramétrico de Nelson&ndash;Aalen
	  da función de risco (<cite key="nelson72">Nelson, 1972</cite>;
	  <cite key="aalen78">Aalen, 1978</cite>), dada unha mostra
	  <argname>d</argname> de datos de duración, que posiblemente estea
	  acompañada dun rexistro de estado de censura, <argname>cens</argname>.
	  A matriz que devolve a función ten tres columnas que conteñen,
	  respectivamente: os valores únicos ordenados en
	  <argname>d</argname>, a estimación da función de risco acumulado
	  que se corresponde cos valores de duración da columna 1, e o desvío
	  padrón do estimador.
	</para>
	<para>
	  Cando indicas a serie <argname>cens</argname>, utilízase o valor 0
	  para sinalar que unha observación non está censurada, namentres
	  que o valor 1 indica que unha observación está censurada do lado
	  dereito (é dicir, o período de observación do individuo en cuestión
	  concluíu antes da duración ou o período rexistrouse como rematado).
	  Cando non indicas <argname>cens</argname>, asúmese que todas as
	  observacións son non censuradas. (Aviso: a semántica de
	  <argname>cens</argname> pode estenderse nalgún punto para cubrir
	  outros tipos de censura.)
	</para>
	<para>
	  <seelist>
            <fncref targ="kmeier"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="nonparam" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar" optional="true">h</fnarg>
	<fnarg type="bool" optional="true">LOO</fnarg>
	<fnarg type="scalar" optional="true">recorte</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha serie coa estimación non paramétrica da media
	  condicional de <argname>y</argname> dado <argname>x</argname>,
	  de Nadaraya-Watson. A serie que devolve a función contén
	  <math>m(x</math><sub>i</sub><math>)</math>, os valores das estimacións
	  de <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  para cada un dos elementos non ausentes da serie
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i - x_j)}
	  {\sum_{j=1}^{n} K_h(x_i - x_j)} \]
	  onde a función kernel <math>K_h(\cdot)</math> ven dada por
	  \[ K_h(x) = \exp\left(-\frac{x^2}{2h}\right) \]
	  para $|x| &lt; \tau$, e cero noutro caso.
	  ($\tau$ = Parámetro de recorte.)
	</para>
	<para context="notex">
	  A función núcleo (kernel) empregada por este estimador dada por
	  <math>K = exp(-x</math><sup>2</sup><math>/2h)</math> cando
	  <math>|x|&lt;T</math>, e é igual a cero noutro caso.
	  (<math>T</math> = Parámetro de recorte.)
	</para>
	<para>
	  Os tres argumentos opcionais modulan o comportamento do
	  estimador tal como se describe máis abaixo.
	</para>
	<subhead>Ancho de banda</subhead>
	<para>
	  Podes usar o argumento <argname>h</argname> para controlar o ancho
	  de banda (<quote>bandwidth</quote>), mediante un número real positivo.
	  Habitualmente este é un número pequeno, pois valores máis grandes de
	  <argname>h</argname> fan que <math>m(x)</math> sexa máis suave. Unha
	  escolla popular é facer que <argname>h</argname> sexa proporcional a
	  <math>n</math><sup>-0.2</sup>. Se omites <argname>h</argname> ou o
	  igualas a cero, o ancho de banda establécese por defecto cun valor
	  determinado polos datos, utilizando a proporcionalidade que se acaba de
	  mencionar, pero introducindo a dispersión dos datos de <argname>x</argname>
	  tal como a mide o rango inter-cuartil ou o desvío padrón; consulta
	  o <guideref targ="chap:nonparam"/> para obter máis detalles.
	</para>
	<subhead>Deixar-unha-fóra</subhead>
	<para>
	  <quote>Deixar-unha-fóra</quote> é unha variante do algoritmo,
	  que omite a observación <math>i</math>-ésima cando se avalía
	  <math>m(x</math><sub>i</sub><math>)</math>. Isto fai que o
	  estimador de Nadaraya&ndash;Watson sexa numericamente máis
	  robusto, e por iso recoméndase habitualmente utilizalo cando o
	  estimador se calcula con intención de facer inferencias. Esta
	  variante non está permitida por defecto, pero actívase cando se
	  indica un valor non nulo para o argumento <argname>LOO</argname>.
	</para>
	<para context="tex">
          Nas fórmulas, este estimador é
          \[
          m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i - x_j)}
          {\sum_{j \ne i} K_h(x_i - x_j)}
          \]
	</para>
	<subhead>Recorte</subhead>
	<para>
	  Podes usar o argumento <argname>recorte</argname> para controlar
	  o grao de <quote>recorte</quote> que se impón para previr
	  problemas numéricos, cando a función 'kernel' se está a avalíar
	  demasiado lonxe do cero. Este parámetro exprésase como un
	  múltiplo de <argname>h</argname>, sendo 4 o valor por defecto.
	  Nalgúns casos, pode ser preferible utilizar un valor maior ca 4.
	  De novo, consulta o <guideref targ="chap:nonparam"/> para
	  obter máis detalles.
	</para>
	<para>
	  Consulta tamén <fncref targ="loess"/>.
	</para>
      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="listetc">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co número de elementos que hai no argumento; este
	  pode ser unha lista, unha matriz, un feixe, un arranxo ou unha cadea
	  de texto, pero non unha serie. No caso dun argumento de cadea de texto
	  devólvese o número de bytes (que pode non ser igual ao número de
	  caracteres na cadea); consulta tamén <fncref targ="strlen"/>.
	</para>
      </description>
    </function>

    <function name="ngetenv" section="programming" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor numérico dunha variable de contexto que
	  ten o nome do argumento <argname>s</argname>, se esa variable está
	  definida e se ten un valor numérico; noutro caso devolve NA.
	  Consulta tamén <fncref targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa cantidade de filas completas (é dicir, filas
	  que rematan co carácter de nova liña) en <argname>buf</argname>.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        scalar number = nlines(web_page)
        print number
    </code>
      </description>
    </function>

    <function name="NMmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="int">maxavalfunc</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización numérica feita co
	  método do simplex sen derivadas de Nelder&ndash;Mead. O argumento
	  <argname>b</argname> debe de conter os valores iniciais dun conxunto
	  de parámetros, e o argumento <argname>f</argname> debe de especificar
	  unha chamada á función que vai calcular o criterio obxectivo (escalar)
	  que se quere maximizar, dados os valores vixentes dos parámetros, así
	  como calquera outros datos que sexan relevantes. Cando se completa
	  con éxito a súa execución, <lit>NMmax</lit> devolve o valor maximizado
	  do criterio obxectivo, e <argname>b</argname> contén finalmente os
	  valores dos parámetros que producen o máximo.
	</para>
	<para>
	  Podes utilizar o terceiro argumento (opcional) para indicar o número
	  máximo de avaliacións da función; se o omites ou o estableces igual
	  a cero, o máximo tómase por defecto igual a 2000. Como indicación
	  especial para esta función, podes poñer un valor negativo para o
	  argumento <argname>maxavalfunc</argname>. Nese caso, tómase o seu
	  valor absoluto e <lit>NMmax</lit> amosa un fallo se o mellor valor
	  atopado para a función obxectivo despois de realizar o máximo número
	  de avaliacións da función, non é un óptimo local. Por outra parte,
	  neste senso a non converxencia non se trata coma un fallo.
	</para>
	<para>
	  Se o teu obxectivo realmente é acadar un mínimo, podes
	  ben trocar a función considerando o negativo do criterio,
	  ou ben, alternativamente, podes invocar a función
	  <lit>NMmax</lit>baixo o alcume <lit>NMmin</lit>..
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NMmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="NMmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, devolve o número de
	  observacións non ausentes desa serie, na mostra vixente
	  seleccionada.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, devolve unha serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> representa
	  o reconto das series da lista que non teñen un valor ausente na
	  observación <math>t</math>.
	</para>
	<para>
	  <seelist>
            <fncref targ="pnobs"/>
            <fncref targ="pxnobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie xerada cunha variable pseudoaleatoria gaussiana
	  de media &mu; e desvío padrón &sigma;. Se non indicas ningún
	  argumento, os valores que se devolven son os dunha variable con
	  distribución de probabilidade Normal estándar, <math>N</math>(0,1).
	  Os valores prodúcense utilizando o método Ziggurat
	  (<cite key="marsaglia00" p="true">Marsaglia e Tsang, 2000</cite>).
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normtest" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">método</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz cos resultados de realizar unha(s) proba(s) de
	  Normalidade sobre <argname>y</argname>. A función fai por defecto
	  a proba de Doornik&ndash;Hansen, pero podes utilizar o argumento
	  <argname>método</argname> (opcional) para escoller unha alternativa.
	  Indica: <lit>swilk</lit> para executar a proba de Shapiro&ndash;Wilk,
	  <lit>jbera</lit> para realizar a proba de Jarque&ndash;Bera, ou
	  <lit>lillie</lit> para efectuar a proba de KS-Lilliefors. Ou indica
	  <lit>all</lit> no argumento do <argname>método</argname> para
	  realizar as catro probas.
	</para>
	<para>
	  Podes indicar o segundo argumento con formato entre comiñas ou sen
	  elas. Neste último caso, tamén podes indicar unha cadea de texto cuxo
	  valor sexa o nome dun dos métodos, polo que se vai substituír cando se
	  executa.
	</para>
	<para>
	  A matriz que se devolve é de orde <by r="1" c="2"/> para unha única
	  proba, ou <by r="4" c="2"/> cando se fan tódalas probas. Os estatísticos
	  das probas atópanse na primeira columna, e as probabilidades asociadas
	  na segunda. O estatístico de proba non segue a mesma distribución de
	  probabilidade en tódolos casos. Para as de Doornik&ndash;Hansen e de
	  Jarque&ndash;Bera é unha Khi-cadrado(2); nos outros métodos trátase
	  dun estatístico peculiar para cuxas probabilidades asociadas requírese
	  un cálculo especial.
	</para>
	<para>
	  Consulta tamén a instrución <cmdref targ="normtest"/>.
	</para>
      </description>
    </function>

    <function name="npcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">método</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila cos cálculos dunha medida de correlación entre
	  <argname>x</argname> e <argname>y</argname>, utilizando un método
	  non paramétrico. Se indicas o terceiro argumento, este debe de ser
	  <lit>kendall</lit> (para o método por defecto, o tau de Kendall,
	  versión b) ou ben <lit>spearman</lit> (para o rho de Spearman).
	</para>
	<para>
	  O resultado que se devolve é un vector fila con 3 valores que indican:
	  a medición da correlación, o valor do estatístico de proba da hipótese
	  nula de incorrelación, e a probabilidade asociada a ese valor. Advirte
	  que, se o tamaño da mostra é moi pequeno, o estatístico de proba e/ou
	  a probabilidade pode ser <lit>NaN</lit> (non é número, ou ausente).
	</para>
	<para>
	  Consulta tamén <fncref targ="corr"/> para a correlación de Pearson.
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co Valor Actual Neto de <argname>x</argname>,
	  considerado este como unha secuencia de pagos (negativos) e ingresos
	  (positivos), avaliados a unha taxa de desconto anual que debes de
	  indicar no argumento <argname>r</argname> como fracción decimal entre
	  0 e 1, non como porcentaxe (por exemplo 0.05, e non 5<lit>%</lit>).
	  O primeiro valor da serie/vector do primeiro argumento considérase
	  que está datado <quote>agora</quote>, e non se desconta. Para imitar
	  unha función VAN na que se desconte o primeiro valor, engade un cero
	  ao principio da serie/vector do primeiro argumento.
	</para>
	<para>
	  O tipo de frecuencia dos datos que admite esta función pode ser anual,
	  trimestral, mensual e sen data (este tipo trátase como se fora anual).
	</para>
	<para>
	  <seelist>
            <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización numérica feita co
	  método de Newton&ndash;Raphson. O argumento <argname>b</argname>
	  debe de conter os valores iniciais do conxunto de parámetros, e o
	  argumento <argname>f</argname> debe de indicar unha chamada á función
	  que vai calcular o criterio obxectivo (escalar) que queres maximizar,
	  dados os valores vixentes dos parámetros, así como calquera outro dato
	  relevante. Se o que queres realmente é minimizar o criterio obxectivo,
	  esta función debera de devolver o valor negativo do mesmo. Cando se
	  completa con éxito a súa execución, <lit>NRmax</lit> devolve o valor
	  maximizado do criterio obxectivo, e <argname>b</argname> vai conter
	  os valores dos parámetros que proporcionan o máximo dese criterio.
	</para>
	<para>
	  O terceiro e cuarto argumentos (opcionais) proporcionan xeitos de
	  indicar, respectivamente, as derivadas analíticas e unha matriz
	  hessiana analítica (negativa). As funcións ás que se refiren estes
	  argumentos <argname>g</argname> e <argname>h</argname>
	  deben de ter, como primeiro elemento, unha matriz definida con
	  anterioridade que sexa do rango correcto para poder conter o vector
	  gradiente ou a matriz hessiana, indicados en forma de punteiro.
	  Ademais, outro dos seus elementos, debe de ser o vector de parámetros
	  (en forma de punteiro ou non). Outro tipo de elementos son opcionais.
	  Se omites calquera dos argumentos opcionais (ou os dous), utilízase
	  unha aproximación numérica.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="NRmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz co cálculo do espazo nulo á dereita correspondente
	  á matriz <argname>A</argname>, feito mediante a descomposición en
	  valores singulares: o resultado é unha matriz <math>B</math> que fai
	  que o produto <math>AB</math> sexa unha matriz nula. Como excepción,
	  se a matriz <argname>A</argname> ten rango completo por columnas, o
	  resultado que se devolve é unha matriz baleira. Por outra banda, se
	  <argname>A</argname> é de orde <by r="m" c="n"/>, entón <math>B</math>
	  vai ser <math>n</math> por (<math>n</math> &minus; <math>r</math>),
	  onde <math>r</math> é o rango de <argname>A</argname>.
	</para>
	<para context="notex">
	  Se <argname>A</argname> non ten rango completo por columnas,
	  entón ao concatenar verticalmente a matriz <argname>A</argname> e
	  a matriz trasposta de <argname>B</argname>, xérase unha matriz con
	  rango completo.
	</para>
	<para context="tex">
	  Devolve unha matriz co cálculo do espazo nulo á dereita correspondente
	  á matriz <argname>A</argname>, feito mediante a descomposición en
	  valores singulares: o resultado é unha matriz $B$ que fai que
	  \begin{itemize}
	  \item $AB = [0]$. Como excepción, se a matriz $A$ ten rango completo
	  por columnas, o resultado que se devolve é unha matriz baleira. Por
	  outra banda, se $A$ é de orde $m \times n$, entón $B$ vai ser unha
	  matriz de orde $n \times (n-r)$, onde $r$ é o rango $A$.
	  \item Se $A$ non ten rango completo por columnas, entón ao concatenar
	  verticalmente $A$ e $B'$, xérase unha matriz con rango completo.
	  \end{itemize}
	</para>
    <para>
        Exemplo:
    </para>
    <code>
      A = mshape(seq(1,6),2,3)
      B = nullspace(A)
      C = A | B'

      print A B C

      eval A*B
      eval rank(C)
    </code>
    <para>
        produce...
    </para>
    <code>
      ? print A B C
      A (2 x 3)

      1   3   5
      2   4   6

      B (3 x 1)

      -0,5
         1
      -0,5

      C (3 x 3)

         1      3      5
         2      4      6
      -0,5      1   -0,5

      ? eval A*B
      -4,4409e-16
      -4,4409e-16

      ? eval rank(C)
      3
    </code>
    <para>
      <seelist>
        <fncref targ="rank"/>
        <fncref targ="svd"/>
      </seelist>
	</para>
      </description>
    </function>

    <function name="numhess" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha aproximación numérica á matriz hessiana asociada
	  ao vector <math>n</math>-dimensional <argname>b</argname>,
	  e á función obxectivo que se especifique mediante o argumento
	  <argname>fcall</argname>. A chamada á función debe de ter
	  <argname>b</argname> como primeiro argumento (ben directamente
	  ou ben en forma de punteiro), seguido de calquera argumento
	  adicional que poida ser necesario, e debe devolver como
	  resultado un escalar. Ao completarse con éxito <lit>numhess</lit>
	  devolve unha matriz <by r="n" c="n"/> que contén a hessiana,
	  e que é exactamente simétrica por construción.
	</para>
	<para>
	  O método utiliza a extrapolación de Richardson, con catro pasos.
	  Podes usar o terceiro argumento (opcional) para establecer a
	  fracción <math>d</math> do valor do parámetro que se utiliza
	  para determinar o tamaño do paso inicial. Cando omites este
	  argumento, por defecto vai ser <math>d</math> = 0.01.
	</para>
	<para>
	  Aquí tes un exemplo do seu uso:
	</para>
	<code>
	  matrix H = numhess(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	          <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Devolve unha serie de números enteiros consecutivos, correspondendo o
	  1 co comezo do conxunto de datos. Ten en conta que o resultado non vai
	  depender de que teñas escollida unha submostra. Esta función é útil
	  especialmente con conxuntos de datos de series temporais. Advertencia:
	  Podes escribir <lit>t</lit> en vez de <lit>obs</lit>, co mesmo efecto.
	</para>
	<para>
	  <seelist>
            <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string-or-strings">
      <fnargs>
	<fnarg type="scalar-or-vec">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>t</argname> é un escalar, devolve unha única cadea de
	  texto que representa o marcador de etiquetado da observación
	  <argname>t</argname>. Podes facer a operación inversa mediante a
	  función <fncref targ="obsnum"/>.
	</para>
	<para>
	  Se <argname>t</argname> é un vector, devolve un arranxo de cadeas de
	  texto que representan os marcadores de etiquetado das observacións
	  indicadas polos elementos de <argname>t</argname>.
	</para>
	<para>
	  De todos os xeitos, os valores <argname>t</argname> deben ser enteiros
	  que podan resultar válidos como índices enteiros das observacións no
	  conxunto de datos vixente; noutro caso, amósase un aviso de fallo.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número enteiro que indica a observación que se corresponde
	  coa cadea do argumento <math>s</math>. Ten en conta que o resultado non
	  vai depender de que teñas escollida unha submostra. Esta función é útil
	  con conxuntos de datos de series temporais. Por exemplo, o seguinte código ...
	</para>
	<code>
	  open denmark
	  k = obsnum(1980:1)
	</code>
	<para>
	  ... xera <lit>k = 25</lit>, indicando que o primeiro trimestre de 1980
	  é a vixésimo quinta observación da base de datos <lit>denmark</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="obs"/>
            <fncref targ="obslabel"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando o argumento <argname>x</argname> é un escalar, esta función
	  devolve 1 se <argname>x</argname> non é <lit>NA</lit>, e 0 noutro
	  caso. Cando <argname>x</argname> é unha serie, devolve outra serie que
	  toma o valor 1 nas observacións nas que o argumento non ten valores
	  ausentes, e toma o valor cero nos demais. Se <argname>x</argname> é
	  unha lista, o resultado é unha serie con 0 nas observacións nas que
	  ao menos unha serie da lista ten un valor ausente, e 1 noutro caso.
	</para>
	<para>
	  Cando o argumento <argname>x</argname> é unha matriz,
	  a función devolve outra matriz da mesma dimensión que
	  <argname>x</argname>, co valor 1 nas posicións que se corresponden
	  con elementos finitos de <argname>x</argname>, e co valor 0 nas
	  posicións nas que os elementos non son finitos (ou ben infinitos, ou ben
	  <quote>non números</quote>, para o estándar IEEE 754).
	</para>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	  Pero ten en conta que estas funcións non son aplicables a matrices.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un escalar coa norma 1 da matriz <argname>X</argname>,
	  é dicir, o máximo dos resultados de sumar os valores absolutos dos
	  elementos de <argname>X</argname> por columnas.
	</para>
	<para context="tex">
	  Devolve un escalar coa norma 1 da matriz
	  <argname>X</argname> de orde $r \times c$:
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
            <fncref targ="infnorm"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz con <math>r</math> filas e <math>c</math>
	  columnas, cuberta con valores iguais a 1. Se o omites, o número
	  de columnas establécese en 1 (vector columna), por defecto.
	</para>
	<para>
	  <seelist>
            <fncref targ="seq"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura
	  de panel, e devolve unha serie co cálculo dos desvíos ortogonais
	  adiantadas para a variable <argname>y</argname>.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura
	  de panel, e devolve unha serie co cálculo dos desvíos ortogonais
	  adiantadas para a variable <argname>y</argname>, é dicir
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t}{T_i - t + 1}} \left( y_{i,t} -
	  \frac{1}{T_i - t} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  Algunhas veces se utiliza esta transformación en troques da
	  diferenciación para eliminar os efectos individuais dos datos de
	  panel. Por compatibilidade coas primeiras diferenzas, os desvíos
	  gárdanse adiantados un paso da súa localización temporal verdadeira
	  (é dicir, o valor na observación <math>t</math> é o desvío que,
	  expresándoo de maneira estrita, pertence a <math>t</math> &minus; 1).
	  Deste xeito, pérdese a primeira observación en cada serie temporal,
	  non a derradeira.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, forma, escala, y)</example>
      </examples>
      <description>
	<para>
	  Calcula o valor da función de densidade de probabilidade, e devolve
	  un resultado (do mesmo tipo ca o argumento) coa densidade en
	  <argname>x</argname> da distribución identificada polo código
	  <argname>d</argname>. Consulta <fncref targ="cdf"/> para obter máis
	  detalles acerca dos argumentos (escalares) esixidos. Esta función
	  <lit>pdf</lit> acepta as distribucións: Normal, <math>t</math> de
	  Student, Khi-cadrado, <math>F</math>, Gamma, Beta, Exponencial, Weibull,
	  Laplace, Erro Xeneralizado, Binomial e Poisson. Cae na conta de que
	  para a Binomial e a Poisson, o que se calcula de feito é a masa de
	  probabilidade no punto especificado. Para <math>t</math> de Student,
	  Khi-cadrado e <math>F</math> tamén están dispoñibles as súas
	  variantes non centrales.
	</para>
	<para>
	  Para a distribución Normal, consulta tamén <fncref targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">anchobanda</fnarg>
      </fnargs>
      <description>
	<para>
	  Se só indicas a serie ou vector do primeiro argumento, calcúlase o seu
	  periodograma na mostra. Se indicas o escalar do segundo argumento,
	  calcula a estimación do espectro de <argname>x</argname> cunha xanela
	  de retardos de Bartlett cun ancho de banda igual a ese escalar, ata un
	  máximo igual á metade do número de observacións (<math>T</math>/2).
	</para>
	<para>
	  Devolve unha matriz con <math>T</math>/2 filas e dúas columnas: a
	  primeira destas ten a frecuencia (&omega;) desde 2&pi;/<math>T</math>
	  ata &pi;, e a segunda das columnas contén a densidade espectral
	  correspondente.
	</para>
      </description>
    </function>

    <function name="pexpand" section="panel" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
	<fnarg type="bool" optional="true">por_elemento</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura
	  de panel, e por defecto realiza a operación inversa á que fai
	  <fncref targ="pshrink"/>. É dicir, dado un vector que ten unha
	  lonxitude igual ao número de elementos da mostra (de panel) vixente
	  seleccionada, esta función devolve unha serie na cal cada valor do
	  argumento repítese <math>T</math> veces, onde <math>T</math>
	  expresa a lonxitude temporal do panel. Deste xeito, a serie resultante
	  é invariante en relación ao tempo.
	</para>
	<para>
    Se indicas un valor para <argname>por_elemento</argname> que non
    sexa cero, a longura de <argname>v</argname> deberá ser igual a
    <math>T</math>, e a repetición realízase a través dos elementos
    do panel.
	</para>
      </description>
    </function>

    <function name="pmax" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén cada un dos valores máximos
	  da variable <argname>y</argname> en cada unidade de corte transversal
	  (repetíndoo nos períodos temporais de cada unha destas).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén cada unha das medias temporais
	  da variable <argname>y</argname> en cada unidade de corte transversal
	  (repetindo cada valor nos períodos temporais de cada unha destas).
	  As observacións ausentes ignóranse no cálculo das medias.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén cada unha das medias temporais
	  da variable <argname>y</argname> en cada unidade de corte transversal,
	  é dicir, \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ representa o número de observacións válidas da unidade
	  $i$.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxmean"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén cada un dos valores mínimos
	  da variable <argname>y</argname> en cada unidade de corte transversal
	  (repetindo cada valor nos períodos temporais de cada unha destas).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén o número de observacións
	  válidas da variable <argname>y</argname> en cada unidade de corte
	  transversal (repetíndoo nos períodos temporais de cada unha destas).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="math" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve as raíces dun polinomio. Se o polinomio é de grao
	  <math>p</math>, o vector <argname>a</argname> debe de conter
	  <math>p</math> + 1 coeficientes en orde ascendente; é dicir,
	  comezando coa constante e finalizando co coeficiente de
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  O valor que se devolve é un vector columna complexo con
	  longura igual a <math>p</math>.
	</para>
      </description>
    </function>

    <function name="polyfit" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie, axustando unha tendencia polinómica de orde
	  <argname>q</argname> á serie do argumento <argname>y</argname>,
	  utilizando o método de polinomios ortogonais. A serie que se xera
	  contén os valores axustados.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">matrizcov</fnarg>
      </fnargs>
      <description>
	<para>
	  Sexa <argname>X</argname> unha matriz de orde <by r="T" c="k"/>,
	  que contén <math>T</math> observacións sobre <math>k</math>
	  variables. O argumento <argname>p</argname> debe de ser un número
	  enteiro positivo menor que ou igual a <math>k</math>. Esta función
	  devolve unha matriz <math>P</math>, de orde <by r="T" c="p"/>,
	  que contén as <math>p</math> primeiras compoñentes principais de
	  <argname>X</argname>.
	</para>
	<para>
	  O terceiro argumento (opcional) opera coma un conmutador booleano:
	  se non é cero, as compoñentes principais calcúlanse en base á matriz
	  de varianzas-covarianzas das columnas de <argname>X</argname>
	  (por defecto utilízase a matriz de correlacións).
	</para>
	<para context="notex">
	  Os elementos da matriz <math>P</math> que se devolve, calcúlanse
	  como a suma desde <math>i</math> ata <math>k</math> de
	  <math>Z</math><sub>ti</sub> veces <math>v</math><sub>ji</sub>,
	  onde <math>Z</math><sub>ti</sub> representa o valor
	  estandarizado (ou simplemente o valor centrado, se utilizas a matriz
	  de covarianzas) da variable <math>i</math> na observación
	  <math>t</math>, e <math>v</math><sub>ji</sub> representa o
	  <math>j</math>-ésimo autovector da matriz de correlacións (ou a
	  matriz de covarianzas) entre as <math>X</math><sub>i</sub>s, cos
	  autovectores ordenados de acordo cos valores decrecentes dos
	  autovalores correspondentes.
	</para>
	<para context="tex">
	  Os elementos da matriz $P$ que se devolve, calcúlanse como
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \]
	  onde $Z_{ti}$ representa o valor estandarizado (ou simplemente
	  o valor centrado, se utilizas a matriz de covarianzas) da variable $i$
	  na observación $t$, $Z_{ti} = (X_{ti} - \bar{X}_i) / \hat{\sigma}_i$,
	  e $v^{(j)_i}$ representa o $j$-ésimo autovector da matriz de
	  correlacións (ou de covarianzas) dos $X_i$s, cos autovectores
	  ordenados de acordo cos valores decrecentes dos autovalores
	  correspondentes.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila cos produtos dos elementos de cada columna da
	  matriz <argname>X</argname>. Se indicas un valor non nulo para o
	  segundo argumento (opcional), ignóranse os valores ausentes; doutro
	  xeito, o resultado é <lit>NA</lit> para cada columna que conteña valores
	  ausentes. Cae na conta de que indicar <argname>obviar_na</argname>
	  é equivalente a tratar os valores como se fosen 1s.
	</para>
	<para>
	  <seelist>
            <fncref targ="prodr"/>
            <fncref targ="meanc"/>
            <fncref targ="sdc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna cos produtos dos elementos de cada fila da
	  matriz <argname>X</argname>. Se indicas un valor non nulo para o
	  segundo argumento (opcional), ignóranse os valores ausentes; doutro
	  xeito, o resultado é <lit>NA</lit> para cada fila que conteña valores
	  ausentes. Cae na conta de que indicar <argname>obviar_na</argname>
	  é equivalente a tratar os valores como se fosen 1s.
	</para>
	<para>
	  <seelist>
            <fncref targ="prodc"/>
            <fncref targ="meanr"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén o desvío padrón (na mostra)
	  da variable <math>y</math> en cada unidade de corte transversal
	  (repetindo cada valor nos períodos temporais de cada unha destas).
	  O denominador que se utiliza é o tamaño da mostra en cada unidade
	  menos 1, agás que só haxa 1 única observación válida para unha
	  unidade dada (pois neste caso devólvese 0) ou que non haxa ningunha
	  (neste caso devólvese <lit>NA</lit>).
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén o desvío padrón (na mostra)
	  da variable <math>y</math> en cada unidade de corte transversal, é dicir,
	  \[ \sigma_i = \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} -
	  \bar{y}_i)^2 } \]. Esta fórmula aplícase cando $T_i \ge 2$, onde
	  $T_i$ representa o número de observacións válidas para a unidade
	  $i$; se $T_i = 0$ devólvese <lit>NA</lit>, e se $T_i = 1$
	  devólvese 0.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
  </para>
	<para>
	  Nota: Esta función permite comprobar se unha variable calquera
	  (por exemplo, <lit>X</lit>) é invariante ao longo do tempo,
	  por medio da condición <lit>max(psd(X)) == 0</lit>.
	</para>
	<para>
		<seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="bool" optional="true">probapsd</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz cadrada que resulta de aplicarlle á matriz simétrica
	  <argname>A</argname> do argumento, unha variante xeneralizada da
	  descomposición de Cholesky. A matriz do argumento debe de ser
	  semidefinida positiva (aínda que pode ser singular) pero, se non é
	  cadrada, amósase unha mensaxe de fallo. A simetría asúmese e non se
	  comproba; só se le o triángulo inferior de <argname>A</argname>.
	  O resultado é unha matriz triangular inferior, <math>L</math>, que
	  cumpre <equation status="inline" ascii="A = LL'" tex="$A = LL'$"/>.
	  Os elementos indeterminados da solución establécense como iguais a cero.
	</para>
	<para>
	  Para forzar a comprobación de que <argname>A</argname> é semidefinida
	  positiva, indica un valor non nulo para o segundo argumento (opcional).
	  Nese caso, amósase un fallo se o máximo valor absoluto de
	  <equation status="inline" ascii="A &minus; LL'" tex="$A - LL'$"/>
	  pasa de 1.0e-8. Este tipo de comprobación tamén podes facela
	  manualmente:
	</para>
	<code>
	  L = psdroot(A)
	  chk = maxc(maxr(abs(A - L*L')))
	</code>
	<para>
	  Para o caso no que a matriz <argname>A</argname> é definida positiva,
	  consulta <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="panel" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve un vector que contén cada unha das primeiras
	  observacións válidas da serie <argname>y</argname> en cada unidade
	  de corte transversal do panel, ao longo do rango da mostra vixente.
	  Se a serie ten algunha unidade sen observacións válidas, esa
	  unidade ignórase.
	</para>
	<para>
	  Esta función te proporciona un xeito de compactar as series que
	  te van devolver algunhas funcións tales como <fncref targ="pmax"/>
	  e <fncref targ="pmean"/>, nas que se repite un mesmo valor nos
	  diferentes períodos de tempo dunha mesma unidade de corte
	  transversal.
	</para>
	<para>
	  Consulta <fncref targ="pexpand"/> para a operación inversa.
	</para>
      </description>
    </function>

    <function name="psum" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie na que cada valor é a suma da variable
	  <argname>y</argname> nos distintos períodos temporais de cada unidade
	  de corte transversal. En cada unha destas, a suma así calculada se
	  repite para cada período temporal. As observacións ausentes ignóranse
	  no cálculo das sumas.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie na que cada valor é a suma da variable
	  <argname>y</argname> nos distintos períodos temporais de cada unidade
	  de corte transversal, é dicir, \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ indica o número de observacións válidas da unidade $i$.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  Calcula valores <math>P</math> de probabilidade, e devolve un
	  resultado (do mesmo tipo ca o argumento) coa probabilidade
	  <equation status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>, onde
	  a distribución de probabilidade de <math>X</math> indícase coa letra
	  <argname>c</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>p</argname>, podes necesitar algún argumento adicional
	  escalar para especificar os parámetros da distribución de que se
	  trate. Para máis detalles, consulta <fncref targ="cdf"/>. As
	  distribucións soportadas pola función <lit>pvalue</lit> son:
	  Normal estándar, <math>t</math>, Khi-cadrado, <math>F</math>, Gamma,
	  Binomial, Poisson, Exponencial, Weibull, Laplace e Erro Xeneralizado.
	</para>
	<para>
	  <seelist>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="urcpval"/>
            <fncref targ="imhof"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxmean" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura
	  de panel. Devolve unha serie que contén a media de sección cruzada
	  da variable <argname>y</argname> en cada período de tempo,
	  repetíndose os valores para cada unidade. As observacións ausentes
	  se eliminan ao calcular as medias.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel. Calcula unha serie que contén a media de sección cruzada
	  da variable <argname>y</argname> en cada período de tempo;
	  é dicir, \[ \bar{y}_t = \frac{1}{N_t} \sum_{i=1}^{N_t} y_{i,t}\]
	  onde $N_t$ é o número de observacións válidas para o período
	  $t$.
	</para>
	<para>
	  Cando se indica o segundo argumento (opcional), se ignoran as
	  observacións para as que o valor de <argname>máscara</argname>
	  é cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxnobs" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén o número de observacións
	  válidas de <argname>y</argname> en cada período de tempo (o valor
	  calculado repítese en cada unha das unidades de corte transversal).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  Cae na conta de que esta función opera na outra dimensión do panel,
	  diferente á da función <fncref targ="pnobs"/>.
	</para>
      </description>
    </function>

    <function name="pxsum" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten estrutura de panel,
	  e devolve unha serie na que cada valor é a suma de <argname>y</argname>
	  nas distintas unidades de corte transversal de cada período temporal.
	  As sumas así calculadas repítense en cada unidade de corte transversal.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten estrutura de panel,
	  e devolve unha serie na que cada valor é a suma de <argname>y</argname>
	  nas distintas unidades de corte transversal de cada período temporal,
	  é dicir, \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] onde $N$ é o número
	  de unidades de corte transversal.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  Cae na conta de que esta función opera na outra dimensión do panel,
	  diferente á da función <fncref targ="psum"/>.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz co resultado de calcular a forma cuadrática
	  <equation status="inline" ascii="Y = xAx'" tex="$Y = x A x'$"/>.
	  Se a matriz simétrica <argname>A</argname> do argumento é de tipo
	  xenérico, cando utilizas esta función en vez da típica multiplicación
	  de matrices, garantes unha maior rapidez e mellor precisión. Porén, no
	  caso especial de que <argname>A</argname> sexa unha matriz
	  identidade, a simple expresión <lit>x'x</lit> resulta moito mellor ca
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Devolve unha matriz co resultado de calcular a forma cuadrática
	  <equation status="inline" ascii="Y = xAx'" tex="$Y = x A x'$"/>.
	  Se a matriz simétrica <argname>A</argname> do argumento é de tipo
	  xenérico, cando utilizas esta función en vez da típica multiplicación
	  de matrices, garantes unha maior rapidez e mellor precisión. Porén, no
	  caso especial <equation status="inline" ascii="A = I" tex="$A = I$"/>,
	  a simple expresión <lit>x'x</lit> resulta moito mellor ca
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	  No caso especial de que <argname>A</argname> sexa unha matriz
	  diagonal, podes indicar o segundo argumento como un vector do
	  tamaño axeitado, no que se entende que está contida a diagonal
	  principal de <argname>A</argname>. Nese caso, utilízase un algoritmo
	  máis eficiente.
	</para>
	<para>
	  Se <argname>x</argname> e <argname>A</argname> non son matrices
	  conformables, ou se <argname>A</argname> non é simétrica, a función
	  devolve un fallo.
	</para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">gl</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa probabilidade asociada (<math>P</math>) ao valor
	  do estatístico para facer a proba LR de Quandt (ou sup-Wald) de cambio
	  estrutural nun punto descoñecido (consulta <cmdref targ="qlrtest"/>),
	  segundo <cite key="hansen97">Bruce Hansen (1997)</cite>.
	</para>
	<para>
	  O primeiro argumento, <argname>X2</argname>, indica o valor do
	  estatístico de proba de Wald máximo (en formato khi-cadrado), e o
	  segundo, <argname>gl</argname>, indica os seus graos de liberdade.
	  O terceiro e o cuarto argumentos, representan os puntos de comezo e
	  de remate do rango central de observacións sobre o que se van calcular
	  os sucesivos estatísticos de Wald das probas, e debes expresalos como
	  fraccións decimais en relación ao rango total de estimación. Por
	  exemplo, se queres adoptar o enfoque estándar de recorte do 15 por
	  cento, debes de establecer <argname>p1</argname> igual a 0.15 e
	  <argname>p2</argname> igual a 0.85.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos cuantís dunha
	  Normal estándar que se corresponden con cada valor do argumento. Se
	  <argname>x</argname> non está entre 0 e 1, devólvese <lit>NA</lit>.
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
	<fnarg type="matrixref" optional="true">&amp;P</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co cálculo dunha <quote>tenue</quote>
	  descomposición QR dunha matriz <argname>X</argname> de orde
	  <by r="m" c="n"/> sendo <math>m</math> &ge; <math>n</math>,
	  de xeito que <math>X = QR</math> onde <math>Q</math> é unha
	  matriz <by r="m" c="n"/> ortogonal, e <math>R</math> é unha
	  matriz <by r="n" c="n"/> triangular superior. A matriz <math>Q</math>
	  devólvese directamente, mentres que podes obter <math>R</math>
	  mediante o segundo argumento (opcional).
	</para>
	<para>
	  Se indicas o terceiro argumento (opcional), a descomposición
	  utiliza o pivotado de columnas e, cando se completa con éxito,
	  <argname>P</argname> contén a ordenación final das columnas
	  en forma dun vector fila. Se as columnas non están realmente
	  reordenadas, <argname>P</argname> vaise equipar a
	  <fncref targ="seq"/><lit>(1, n)</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">tipo</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz <by r="n" c="2"/> para utilizar coa cuadratura
	  Gaussiana (en integración numérica). A primeira columna contén os
	  nodos ou abscisas, e a segunda as ponderacións.
	</para>
	<para>
	  O primeiro argumento especifica o número de puntos (filas) que se
	  van calcular. O segundo argumento codifica o tipo de cuadratura:
	  utiliza 1 para a Gauss&ndash;Hermite (a establecida por defecto);
	  2 para a Gauss&ndash;Legendre; ou 3 para a Gauss&ndash;Laguerre.
	  O sentido dos parámetros <argname>a</argname> e <argname>b</argname>
	  (opcionais) depende do <argname>type</argname> seleccionado,
	  como se explica deseguido.
	</para>
	<para context="notex">
	  A cuadratura Gaussiana é un método para aproximar numericamente a
	  integral definida de algunha función que te interese. Supoñamos que a
	  función se representa mediante o produto <math>f(x)W(x)</math>.
	  Os distintos tipos de cuadratura difiren na especificación da
	  compoñente <math>W(x)</math>: no caso da Hermite isto é igual a
	  exp(&minus;<math>x</math><sup>2</sup>); no caso da Laguerre é
	  igual a exp(&minus;<math>x</math>); e no caso da Legendre simplemente
	  é <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  A cuadratura Gaussiana é un método para aproximar numericamente a
	  integral definida de algunha función que te interese. Supoñamos que a
	  función se representa mediante o produto $f(x)W(x)$. Os distintos
	  tipos de cuadratura difiren na especificación da compoñente $W(x)$:
	  no caso da Hermite temos $W(x) = \exp(-x^2)$; no caso da Laguerre,
	  $W(x) = \exp(-x)$; e no caso da Legendre temos simplemente
	  $W(x) = 1$.
	</para>
	<para context="notex">
	  Para cada especificación de <math>W</math>, pode calcularse un
	  conxunto de nodos (<math>x</math><sub>i</sub>) e un conxunto de
	  ponderacións (<math>w</math><sub>i</sub>), de tal xeito que a suma
	  desde <math>i</math>=1 ata <math>n</math> de
	  <math>w</math><sub>i</sub>
	  <math>f</math>(<math>x</math><sub>i</sub>) vaise aproximar á
	  integral desexada. Para isto vaise utilizar o método de
	  <cite key="golub69">Golub e Welsch (1969)</cite>.
	</para>
	<para context="tex">
	  Para cada especificación de $W(x)$, pode calcularse un conxunto de
	  nodos ($x_i$) e un conxunto de ponderacións ($w_i$), de tal xeito que
	  $\sum_{i=1}^n f(x_i) w_i$ vaise aproximar á integral desexada. Vaise
	  usar o método de <cite key="golub69">Golub e Welsch (1969)</cite>.
	</para>
	<para context="notex">
	  Cando se selecciona o tipo de Gauss&ndash;Legendre, podes utilizar
	  os argumentos opcionais <argname>a</argname> e <argname>b</argname>
	  para controlar os límites inferior e superior da integración, sendo
	  neste caso os valores por defecto &minus;1 e 1. (Na cuadratura
	  de Hermite, os límites están fixados en menos e máis infinito;
	  mentres que no caso da cuadratura de Laguerre, están fixados en 0
	  e infinito.)
	</para>
	<para context="tex">
	  Cando se selecciona o tipo de Gauss&ndash;Legendre, podes utilizar
	  os argumentos opcionais <argname>a</argname> e <argname>b</argname>
	  para controlar os límites inferior e superior da integración, sendo
	  neste caso os valores por defecto $-1$ e 1. (Na cuadratura
	  de Hermite, os límites están fixados en $-\infty$ e $+\infty$;
	  mentres que no caso de Laguerre, están fixados en 0 e $\infty$.)
	</para>
	<para context="notex">
	  No caso de Hermite, <argname>a</argname> e <argname>b</argname>
	  xogan papeis diferentes: poden utilizarse para substituír a forma
	  por defecto de <math>W</math>(<math>x</math>) pola distribución
	  Normal de probabilidade con media <argname>a</argname> e desvío
	  padrón <argname>b</argname> (coa que está estreitamente emparentada).
	  Por exemplo, se indicas os valores 0 e 1 para estes parámetros,
	  respectivamente, vas provocar que <math>W</math>(<math>x</math>)
	  sexa a función de densidade de probabilidade Normal estándar; o
	  que é equivalente a multiplicar os nodos por defecto pola raíz
	  cadrada de dous, e dividir as ponderacións pola raíz cadrada de
	  &pi;.
	</para>
	<para context="tex">
	  No caso de Hermite, <argname>a</argname> e <argname>b</argname>
	  xogan papeis diferentes: poden utilizarse para substituír a forma
	  por defecto de $W(x)$ pola distribución Normal de probabilidade con
	  media <argname>a</argname> e desvío padrón <argname>b</argname>
	  (coa que está estreitamente emparentada). Por exemplo, se indicas
	  os valores 0 e 1 para estes parámetros, respectivamente, vas
	  provocar que $W(x)$ sexa a función de densidade de probabilidade
	  Normal estándar; o que é equivalente a multiplicar os valores
	  $x_i$ por defecto por $\sqrt{2}$, e dividir as ponderacións por defecto
	  $w_i$ por $\sqrt{\pi}$.
	</para>
      </description>
    </function>

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>y</argname> é unha serie, devolve un escalar que
	  representa o cuantil <argname>p</argname> da mesma. Por exemplo,
	  cando <math>p</math> = 0.5, devólvese a mediana.
	</para>
	<para>
	  Se <argname>y</argname> é unha matriz, devolve un vector fila que
	  contén os <argname>p</argname> cuantís das diferentes columnas
	  de <argname>y</argname>; é dicir, cada unha das súas columnas
	  trátase como una serie.
	</para>
	<para>
	  Amais, para unha matriz <argname>y</argname> admítese unha forma
	  alternativa do segundo argumento: podes indicar <argname>p</argname>
	  coma un vector. Nese caso, o valor que se te devolve é unha matriz
	  de orde <by r="m" c="n"/>, na que <repl>m</repl> indica o número de
	  elementos de <argname>p</argname> e <repl>n</repl> indica o número
	  de columnas de <argname>y</argname>.
	</para>
	<para>
	  <cite key="hyndman96">Hyndman e Fan (1996)</cite> describen nove
	  métodos distintos para calcular os cuantís da mostra. En GRETL, por
	  defecto, o método é o que eles denominan <math>Q</math><sub>6</sub>
	  (que tamén o é en Python, por defecto). En troques, podes seleccionar
	  os métodos <math>Q</math><sub>7</sub> (que é o usado por defecto
	  en R) ou <math>Q</math><sub>8</sub> (que é o recomendado por
	  Hyndman e Fan) mediante a instrución <cmdref targ="set"/>,
	  como en
	</para>
	<code>
	  set quantile_type Q7 # ou Q8
	</code>
	<para context="tex">
	  O cuantil $p$ ($Q_p$) dunha serie $y$ que ten longura igual
	  a $n$ defínese como:
	  \[Q_p = y_{[k]} + (h - k) (y_{[k+1]} - y_{[k]})\]
	  onde $k$ representa a parte enteira de $h$, un termo que difire
	  segundo o método
	  ---$h=(n+1)p$ para $Q_6$, $(n-1)p+1$ para $Q_7$ e $(n+1/3)p + 1/3$ para $Q_8$---
	  onde $y_{[i]}$ representa o elemento $i$-ésimo da serie cando se
	  ordena de menor a maior.
	</para>
	<para>
	Por exemplo, o código
	</para>
	<code>
	  set verbose off
	  matrix x = seq(1,7)'
	  set quantile_type Q6
	  printf "Q6: %g\n", quantile(x, 0.45)
	  set quantile_type Q7
	  printf "Q7: %g\n", quantile(x, 0.45)
	  set quantile_type Q8
	  printf "Q8: %g\n", quantile(x, 0.45)
	</code>
	<para>
	produce o seguinte resultado:
	</para>
	<code>
	  Q6: 3.6
	  Q7: 3.7
	  Q8: 3.63333
	</code>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  Devolve unha serie calculada cun xerador universal de números
	  aleatorios. O argumento <argname>d</argname> é unha cadea de texto
	  (que xeralmente está formada por un só carácter) que permite
	  especificar o tipo de distribución de probabilidade da que se extraen
	  os números pseudoaleatorios. Os argumentos de <argname>p1</argname>
	  a <argname>p3</argname> especifican os parámetros da distribución
	  escollida; o número destes parámetros (e nalgúns casos, a súa
	  natureza) depende desa distribución.
	</para>
	<para>
	  Para outras distribucións diferentes á Beta-Binomial e á Discreta
	  xenérica, os parámetros <argname>p1</argname> e (caso de ser aplicable)
	  <argname>p2</argname> podes indicalos en formato de escalar ou de
	  serie. Cando os utilizas en formato escalar, a serie que resulta
	  procede de distribucións identicamente distribuídas. Cando utilizas
	  series para os argumentos <argname>p1</argname> ou
	  <argname>p2</argname>, a serie resultante procede de distribucións
	  condicionadas ao valor dos parámetros en cada observación.
	</para>
	<para>
          Os dous casos especiais teñen os seguintes requirimentos:
        </para>
        <ilist>
          <li>
            <para>
              Beta-binomial: os tres parámetros deben ser escalares.
            </para>
          </li>
          <li>
            <para>
              Discreta xenérica: se necesita un único parámetro; en
              concreto un vector <math>k</math> cuxos elementos
              representen as probabilidades dunha variable aleatoria
              con valores enteiros con soporte de 1 a <math>k</math>.
            </para>
          </li>
        </ilist>
	<para>
	  A continuación indícanse detalles máis específicos: o código de
	  texto para cada tipo de distribución móstrase entre parénteses,
	  seguido da interpretación do argumento <argname>p1</argname> e,
	  cando é aplicable, das interpretacións de <argname>p2</argname>
	  e de <argname>p3</argname>.
	</para>

	<ilist context="notex">
	  <li>
            <para>
              Uniforme (continua) (u ou U): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Uniforme (discreta) (i): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Normal (z, n ou N): media, desvío padrón
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Exponencial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Loxística (lgt ou s): posición, escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media, escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): forma1, forma2
            </para>
	  </li>
	  <li>
            <para>
              Beta-Binomial (bb): ensaios, forma1, forma2
            </para>
	  </li>
	  <li>
            <para>
              Discreta xenérica (disc): probabilidades
            </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textbf{Distribución} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniforme (continua) &amp; \texttt{u} ou \texttt{U} &amp; mínimo &amp; máximo &amp; --\\
	  Uniforme (discreta) &amp; \texttt{i} &amp; mínimo &amp; máximo &amp; --\\
	  Normal &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp; media &amp; desvío padrón &amp; --\\
	  $t$ de Student &amp; \texttt{t} &amp; graos de liberdade &amp; -- &amp; --\\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp; graos de liberdade &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp; gl (num.) &amp; gl (den.) &amp; --\\
	  Gamma &amp; \texttt{g} ou \texttt{G} &amp; forma &amp; escala  &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp; media &amp; --  &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp; escala &amp; -- &amp; --\\
	  Loxística &amp; \texttt{s} &amp; posición &amp; escala &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp; forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp; media &amp; escala &amp; --\\
	  Erro Xeneralizado &amp; \texttt{E} &amp; forma &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; forma1 &amp; forma2 &amp; --\\
	  Beta-Binomial &amp; \texttt{bb} &amp; $n$ &amp; forma1 &amp; forma2 \\
	  Discreta xenérica &amp; \texttt{disc} &amp; $\mathbf{p}$ &amp; -- &amp; --
	</tabular>
	<para>
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="uniform"/>
            <fncref targ="mrandgen"/>
            <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Funciona do mesmo xeito que <fncref targ="randgen"/> agás polo
	  feito de que devolve un escalar en troques dunha serie.
	</para>
	<para>
	  O primeiro exemplo de enriba devolve un valor extraído da distribución
	  Normal estándar, mentres que o segundo devolve un valor extraído da
	  distribución Gamma cun parámetro de forma igual a 3 e de escala a 2.5.
	</para>
	<para>
	  <seelist>
            <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro pseudoaleatorio no intervalo pechado
	  [<argname>min</argname>, <argname>max</argname>].
	  <seelist>
	    <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randperm" section="probdist" output="vector">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Se indicas só o primeiro argumento, devolve un vector fila que
	  contén unha permutación aleatoria dos números enteiros desde 1
	  ata ese valor <argname>n</argname>, sen repetición dos elementos.
	  Cando indiques o segundo argumento, deberá ser un número enteiro
	  positivo dentro do rango de 1 a <argname>n</argname>; nese caso
	  a función devolve un vector fila que contén <argname>k</argname>
	  número enteiros escollidos de xeito aleatorio desde 1 ata
	  <argname>n</argname>, sen substitución.
	</para>
	<para>
	  Se queres extraer unha mostra de <math>k</math> filas dunha matriz
	  <lit>X</lit> que ten <math>n</math> filas (e sen substitución), iso
	  podes conseguilo tal como se amosa debaixo:
	</para>
	<code>
	  matrix S = X[randperm(n, k),]
	</code>
	<para>
	  E se desexas manter a orde orixinal das filas na
	  mostra:
	</para>
	<code>
	  matrix S = X[sort(randperm(n, k)),]
	</code>
	<para>
	  Consulta tamén a función <fncref targ="resample"/> para repetir a
	  mostraxe, con substitución.
	</para>
      </description>
    </function>

    <function name="randstr" section="strings" output="string">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto aleatoria cun largo de <argname>n</argname>
	  bytes. Na cadea vanse incluír coa mesma probabilidade os números
	  que van de <lit>0</lit> ata <lit>9</lit>, e as letras minúsculas
	  que van de <lit>a</lit> ata <lit>f</lit>; e se interpreta como
	  un enteiro hexadecimal. O seu uso previsto é como un identificador
	  único. Por exemplo, con <argname>n</argname> = 16, xérase unha
	  cadea de entre preto de 10<sup>19</sup> posibilidades, polo que
	  será única cunha probabilidade próxima a 1.
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">tol</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co rango da matriz <argname>X</argname> de orde
	  <by r="r" c="c"/>, calculado numericamente mediante a descomposición
	  en valores singulares.
	</para>
	<para>
	  O resultado desta operación é o número de valores singulares
	  da matriz <argname>X</argname> que numericamente se consideran
	  maiores que 0. O parámetro opcional <argname>tol</argname> podes
	  usalo para retocar este aspecto. Vaise considerar que os valores
	  singulares non son nulos cando resultan ser maiores que
	  <math>m &times; tol &times; s</math>, onde <math>m</math> é o
	  maior valor de entre <math>r</math> e <math>c</math>, sendo
	  <math>s</math> o que expresa o valor singular máis grande. Cando
	  omites o segundo argumento, establécese que <argname>tol</argname>
	  sexa igual ao épsilon da máquina (consulta <fncref targ="$macheps"/>).
	  Nalgúns casos, podes desexar establecer que <argname>tol</argname>
	  sexa un valor máis grande (p.e. 1.0e-9) co obxecto de evitar que
	  se sobreestime o rango da matriz <argname>X</argname> (o que
	  podería dar lugar a resultados numericamente
	  inestables).
	</para>
	<para>
	  <seelist>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie ou vector coas posicións xerárquicas dos valores
	  de <math>y</math>. A observación <math>i</math> ten unha posición
	  na xerarquía que ven determinada polo número de elementos que son
	  menores ca <math>y</math><sub>i</sub>, máis a metade do número
	  de elementos que son iguais a <math>y</math><sub>i</sub>.
	  (Intuitivamente, podes imaxinalo como a xerarquía nun torneo de
	  xadrez, no que cada vitoria supón conceder un punto ao gañador, e
	  cada empate supón conceder medio punto). Engádese un 1 de forma
	  que o número máis pequeno para unha posición é 1, e non 0.
	</para>
	<para context="tex">
	  Formalmente,
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \]
	  onde $I$ denota a función índice.
	</para>
	<para>
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co número de condición recíproco da matriz cadrada
	  <argname>A</argname> a respecto da norma 1. En moitos casos, este
	  mide de forma máis axeitada ca o determinante, a sensibilidade de
	  <argname>A</argname> ás operacións numéricas tales como a inversión.
	</para>
	<para context="notex">
	  O valor calcúlase como o inverso (ou recíproco) do resultado de
	  multiplicar a norma 1 da matriz cadrada <argname>A</argname>, pola
	  norma 1 da matriz inversa de <argname>A</argname>.
	</para>
	<para context="tex">
	  Dada unha matriz cadrada <math>A</math> non singular, pódese definir
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\]
	  A función devolve $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="ldet"/>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="Re" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz real coa mesma dimensión que <argname>C</argname>,
	  e que contén a parte real da matriz dese argumento. Consulta
	  tamén <fncref targ="Im"/>.
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg type="string" optional="true">código</fnarg>
      </fnargs>
      <description>
	<para>
	  Se existe (e pode lerse) un ficheiro co nome do argumento
	  <argname>nomeficheiro</argname>, a función devolve unha cadea de
	  texto que inclúe o contido dese ficheiro; noutro caso amosa un fallo.
	  Se <argname>nomeficheiro</argname> non indica unha especificación
	  da ruta completa ao ficheiro, vaise procurar en distintas localizacións
	  <quote>probables</quote>, comezando polo cartafol vixente nese
	  momento, <cmdref targ="workdir"/>. Cando o ficheiro en cuestión
	  está comprimido con gzip, manéxase do xeito evidente.
	</para>
	<para>
	  Se <argname>nomeficheiro</argname> comeza cun identificador dun protocolo
	  de internet que sexa admisible (<lit>http://</lit>, <lit>ftp://</lit>
	  ou <lit>https://</lit>), actívase unha orde a 'libcurl' para que
	  descargue o recurso. Para outras operacións de descarga máis
	  complicadas, consulta tamén <fncref targ="curl"/>.
	</para>
	<para>
	  Cando o texto que se quere ler non está codificado en UTF-8, GRETL vai
	  tratar de volver a codificalo desde o tipo vixente de codificación
	  local (se este non é UTF-8), ou desde ISO-8859-15 noutro caso. Se este
	  sinxelo funcionamento por defecto non cumpre coas túas necesidades,
	  podes usar o segundo argumento (opcional) para especificar un tipo de
	  codificación. Por exemplo, se queres ler texto que está no tipo de
	  páxina de código Microsoft 1251, e este non é o teu tipo de código
	  local, deberás de indicar <lit>"cp1251"</lit> como segundo argumento.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        print web_page

        string current_settings = readfile("@dotdir/.gretl2rc")
        print current_settings
    </code>
	<para>
	  Consulta tamén as funcións <fncref targ="sscanf"/> e
	  <fncref targ="getline"/>.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string">atopada</fnarg>
	<fnarg type="string">substit</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é unha cadea única, devolve unha cadea de
	  texto cunha copia de <argname>s</argname> na que todos os casos nos
	  que ocorre o padrón <argname>atopada</argname>, substitúense por
	  <argname>substit</argname>. Os dous argumentos <argname>atopada</argname>
	  e <argname>substit</argname> interprétanse como expresións regulares
	  de estilo Perl. Se <argname>s</argname> é un arranxo de cadeas
	  de texto ou unha serie que contén cadeas de valores, esta operación
	  realízase con cada unha das cadeas do arranxo ou da
	  serie.
	</para>
	<para>
	  Consulta tamén a función <fncref targ="strsub"/> para a substitución
	  simple de cadeas de texto.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nomeficheiro</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o ficheiro do argumento <argname>nomeficheiro</argname> existe
	  e se o usuario o pode modificar, esta función o elimina e devolve
	  un 0. Se non existe o ficheiro, ou non pode eliminarse por algunha
	  razón, a función devolve un código non nulo indicando un
	  fallo.
	</para>
	<para>
	  Cando <argname>nomeficheiro</argname> non especifica a ruta
	  completa, entón asúmese que o ficheiro ao que se refire, está
	  no cartafol vixente de traballo (<cmdref targ="workdir"/>).
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">achar</fnarg>
	<fnarg type="scalar-or-vec">substit</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo de) <argname>x</argname> trocando os
	  seus elementos que sexan iguais ao elemento <math>i</math>-ésimo de
	  <argname>achar</argname> polo concordante de <argname>substit</argname>.
	</para>
	<para>
	  Cando o segundo argumento (<argname>achar</argname>) é un escalar, o
	  terceiro argumento (<argname>substit</argname>) tamén debe de ser un
	  escalar. Cando ambos son vectores, deben de ter o mesmo número de
	  elementos. Pero cando <argname>achar</argname> é un vector e
	  <argname>substit</argname> é un escalar, entón todas as coincidencias de
	  aquel substitúense en <argname>x</argname> por <argname>substit</argname>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  acha = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, acha, subst)
	  print a b
	</code>
	<para>
	  produce...
	</para>
	<code>
          a (2 x 3)

          1   2   3
          3   4   5

          b (2 x 3)

          -1    2   -8
          -8    0    5
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">tamañobloque</fnarg>
	<fnarg optional="true" type="int">extraccions</fnarg>
      </fnargs>
      <description>
	<para>
	  A descrición inicial desta función refírese aos casos con datos
	  de corte transversal ou con series temporais; mira máis abaixo
	  para os casos con datos de panel.
	</para>
	<para>
	  Devolve o resultado (do tipo do argumento) que se obtén facendo unha
	  mostraxe por repetición de <argname>x</argname> con substitución. Se
	  o argumento é unha serie, cada valor <math>y</math><sub>t</sub> da
	  serie que se devolve, obtense de entre todos os valores de
	  <math>x</math><sub>t</sub> que teñen a mesma probabilidade. Cando
	  o argumento é unha matriz, cada fila da matriz que se devolve vaise
	  obter das filas de <argname>x</argname> que teñen a mesma
	  probabilidade. Consulta tamén <fncref targ="randperm"/> para
	  extraer unha mostra de filas dunha matriz sen substitución.
	</para>
	<para>
	  O argumento <argname>tamañobloque</argname> (opcional) representa o
	  tamaño do bloque para facer a mostraxe por repetición movendo
	  bloques. Cando se indique este argumento, deberá de ser un enteiro
	  positivo maior ou igual a 2. Como consecuencia, o resultado vaise
	  compoñer por selección aleatoria con substitución, de entre todas as
	  posibles secuencias contiguas de lonxitude <argname>tamañobloque</argname>
	  do argumento. (No caso de que o argumento sexa unha matriz, isto
	  significa filas contiguas.) Se a lonxitude dos datos non é un número
	  enteiro que sexa múltiplo do tamaño do bloque, o derradeiro bloque
	  seleccionado trónzase para que se axuste.
	</para>
	<subhead>Número de extraccións</subhead>
	<para>
	  Por defecto, o número de observacións que se volven extraer
	  para acadar o resultado é igual ó do argumento indicado
	  &mdash;se <argname>x</argname> fose unha serie, sería a longura do
	  rango mostral vixente; se <argname>x</argname> fose unha matriz, sería
	  o número das súas filas. No caso matricial, <emphasis>só</emphasis>
	  podes axustar isto por medio do terceiro argumento (opcional), que
	  deberá ser un número enteiro positivo. Cae na conta de que se o
	  argumento <argname>tamañobloque</argname> é maior ca 1, o
	  argumento <argname>extraccions</argname> refírese ao número de
	  observacións individuais, non ao número de bloques.
	</para>
	<subhead>Datos de panel</subhead>
	<para>
	  Cando o argumento <argname>x</argname> é unha serie, e o conxunto
	  de datos ten formato de panel, non se admite facer a mostraxe por
	  repetición movendo bloques. A forma básica de facer este tipo de
	  mostraxe está admitida, pero ten a súa propia interpretación: faise
	  a mostraxe por repetición dos datos <quote>por individuo</quote>.
	  Supón que tes un panel no que se observan 100 individuos ao longo
	  de 5 períodos. Entón, a serie que se devolve tamén vai estar composta
	  por 100 bloques de 5 observacións: cada bloque vai obterse con igual
	  probabilidade das 100 series temporais individuais, conservándose
	  a orde das series temporais.
	</para>
      </description>
    </function>

    <function name="rgbmix" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="string">cor1</fnarg>
	<fnarg type="string">cor2</fnarg>
	<fnarg type="matrix">f</fnarg>
	<fnarg type="bool" optional="true">grafica</fnarg>
      </fnargs>
      <description>
	<para>
	  Dadas dúas cores e un vector <argname>f</argname> de lonxitude
	  <math>n</math> que conteña valores en [0,1], esta función devolve
	  un arranxo de <math>n</math> cadeas de texto, no que o seu elemento
	  <math>i</math> contén o código RGB hexadecimal para unha mestura
	  de tipo (1-<math>f</math><sub>i</sub>) &times; <lit>cor1</lit>
	  + <math>f</math><sub>i</sub> &times; <lit>cor2</lit>. A media
	  ponderada cóllese sobre os canais de Vermello, Verde e Azul das
	  cores de entrada.
	</para>
	<para>
	  Podes especificar os argumentos de cor mediante nomes recoñecidos por
	  <cmdref targ="gnuplot"/>, ou como valores hexadecimais co formato
	  <lit>0xrrggbb</lit> ou <lit>#rrggbb</lit>. No primeiro destes formatos,
	  podes indicar numericamente os valores hex; noutro caso, as cadeas
	  de texto son necesarias. Se indicas un valor non nulo para o argumento
	  <argname>grafica</argname>, prodúcese unha gráfica que amosa as
	  mesturas de cores.
	</para>
	<para>
	  Esta función ofrece un medio de xerar un conxunto de cores relacionadas
	  cun propósito de representación gráfica, sendo o seu uso principal a
	  especificación de múltiples franxas nunha gráfica (por exemplo, para
	  indicar intervalos de confianza con máis dun nivel). A continuación
	  hai tres exemplos: o primeiro xera sucesivos aclarados dun azul
	  inicial; o segundo xera progresivos escurecementos dun ton rosa; e
	  o terceiro, unha transición do vermello ao amarelo.
	</para>
	<code>
	  f = {0, 0.5, 0.75, 0.875, 0.9375}
	  mesturas = rgbmix(0x1b43dc, "white", f, 1)
	  print mesturas
	  f = {0, 0.1, 0.2, 0.3, 0.4}
	  rgbmix(0xefd0d3, "black", f, 1)
	  f = {0, 0.2, 0.4, 0.6, 0.8, 1}
	  rgbmix("red", "yellow", f, 1)
	</code>
	<para>
	  O resultado da instrución <lit>print</lit> para o primeiro exemplo
	  será
	</para>
	<code>
	  [1] "0x1b43dc"
	  [2] "0x8da1ee"
	  [3] "0xc6d0f6"
	  [4] "0xe2e8fb"
	  [5] "0xf1f3fd"
	</code>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado, do tipo do argumento, que o arredonda ao
	  enteiro máis próximo. Ten en conta que se <math>x</math> está xusto
	  entre dous enteiros, o arredondamento faise "afastándose de cero" de
	  xeito que, por exemplo, 2.5 arredóndase a 3, pero <lit>round(-3.5)</lit>
	  devolve &minus;4. Esta convención é común en software de follas de
	  cálculo, mais outro tipo de software pode xerar resultados diferentes.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Se indicas o argumento <argname>r</argname>, devolve unha
	  cadea co nome da fila <argname>r</argname> da matriz
	  <argname>M</argname>. Se as filas de <argname>M</argname>
	  non teñen nome, entón devólvese unha cadea baleira; e se
	  <argname>r</argname> está fóra dos límites do número de filas
	  desta matriz, amósase un fallo.
	</para>
	<para>
	  Se non indicas o segundo argumento, devolve un arranxo de cadeas
	  de texto que contén os nomes das filas de <argname>M</argname>,
	  ou un arranxo baleiro se a matriz non ten asignados nomes para as súas
	  filas.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  rnameset(A, "Primeira Segunda")
	  string name = rnameget(A, 2)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="rnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameset" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite engadir nomes ás filas dunha matriz <argname>M</argname>
	  de orde <by r="m" c="n"/>. Cando o argumento <argname>S</argname>
	  se refire a unha lista, os nomes tómanse das series da lista (que
	  deberá de ter <math>m</math> elementos). Cando <argname>S</argname>
	  é un arranxo de cadeas de texto, deberá de ter <math>m</math>
	  elementos. Admítese tamén que indiques unha única cadea de texto
	  como segundo argumento; neste caso esta deberá de ter <math>m</math>
	  subcadeas de texto separadas por espazos.
	</para>
	<para>
	  Se devolve o valor nominal 0 cando as filas se nomean con éxito;
	  en caso de fracaso, amósase un fallo. Consulta tamén
	  <fncref targ="cnameset"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(3)
	  S[1] = "Fila1"
	  S[2] = "Fila2"
	  S[3] = "Fila3"
	  rnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="rows" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co número de filas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="schur" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;Z</fnarg>
	<fnarg type="matrixref" optional="true">&amp;w</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a descomposición de Schur da matriz complexa
	  <argname>A</argname> do argumento, devolvendo unha matriz
	  triangular superior complexa <math>T</math>. Cando indicas un
	  segundo argumento que non sexa <lit>null</lit> (nulo), recolle
	  unha matriz complexa <math>Z</math> que contén os vectores de
	  Schur asociados a <math>A</math> e <math>T</math>, tales que
	  <math>A</math> = <math>ZTZ</math><sup>H</sup>. Cando indicas o
	  terceiro argumento, recolle os autovalores da matriz <math>A</math>
	  nun vector columna complexo.
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, a función devolve un escalar
	  co seu desvío padrón na mostra, descartando as observacións ausentes.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, a función devolve unha
	  serie <math>y</math> tal que <math>y</math><sub>t</sub>
	  representa o desvío padrón na mostra dos valores das
	  series da lista, na observación <math>t</math>. Por defecto,
	  se hai algún valor ausente en <math>t</math>, o desvío
	  padrón rexístrase como <lit>NA</lit>; pero se lle das un valor
	  non nulo a <argname>parcial</argname>, calquera valor non
	  ausente se usará para crear o estatístico.
	</para>
	<para>
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">gl</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila cos desvíos padrón das columnas da
	  matriz <argname>X</argname>. Se <argname>gl</argname> é positivo,
	  utilízase como divisor para as varianzas das columnas; noutro caso,
	  o divisor é igual ao número de filas que ten <argname>X</argname>
	  (é dicir, nese caso non se aplica a corrección polos graos de
	  liberdade). Se indicas un valor non nulo para o terceiro argumento
	  (opcional), ignóranse os valores ausentes; doutro xeito, o resultado
	  é <lit>NA</lit> para cada columna que conteña valores
	  ausentes.
	</para>
	<para>
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado co cálculo das diferenzas estacionais:
	  <equation status="inline" ascii="y(t) - y(t-k)"  tex="$y_t - y_{t-k}$"/>,
	  onde <math>k</math> indica a periodicidade do conxunto vixente de
	  datos (consulta <fncref targ="$pd"/> ou <fncref targ="$panelpd"/>).
	  Os valores iniciais defínense como <lit>NA</lit>.
	</para>
	<para>
	  Cando se devolve unha lista, cada variable individual desta noméase de
	  forma automática seguindo o padrón <lit>sd_</lit><repl>nomevar</repl>,
	  no que <repl>nomevar</repl> indica o nome da serie orixinal. A parte
	  orixinal do nome vai tronzarse cando así resulte necesario, e mesmo
	  poderá axustarse para garantir que sexa único dentro do conxunto de
	  nomes que así se vaian construír.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="ldiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">base</fnarg>
	<fnarg optional="true" type="bool">centro</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura
	  de series temporais con periodicidade maior ca 1. Devolve unha lista con
	  variables ficticias que representan cada período ou estación, e que se
	  nomean como <lit>S1</lit>, <lit>S2</lit>, etc.
	</para>
	<para>
	  Utiliza o argumento <argname>base</argname> (opcional) para
	  excluír da lista á variable ficticia que representa un dos períodos.
	  Por exemplo, se lle asignas un valor igual a 1 tendo un conxunto de
	  datos trimestrais, obtés unha lista que só ten as variables ficticias
	  dos trimestres 2, 3 e 4. Se omites este argumento ou é igual a 0,
	  xéranse variables ficticias para todos os períodos; e se non é cero,
	  deberá ser un enteiro comprendido entre 1 e a periodicidade dos datos.
	</para>
	<para>
	  O argumento <argname>centro</argname>, se non é nulo, indica que
	  as variables ficticias van centrarse; é dicir, os seus valores van
	  calcularse restándolle as medias na poboación. Por exemplo, con
	  datos trimestrais, as variables ficticias estacionais centradas van
	  ter valores iguais a &minus;0.25 e 0.75 en vez de 0 e 1.
	</para>
	<para>
	  Con datos de frecuencia semanal, o resultado concreto depende
	  de se os datos teñen data ou non. Se teñen data, créanse ata
	  53 series estacionais, baseadas no número de semana ISO 8601
	  (consulta <fncref targ="isoweek"/>); se non a teñen, o número
	  máximo de series é 52 (e ao longo dun período prolongado as series
	  <quote>estacionais</quote> vanse desfasar co ano do calendario).
	  No caso de ter datos semanais, se desexas xerar series estacionais
	  mensuais podes facelo do seguinte xeito:
	</para>
	<code>
	  series month = $obsminor
	  list months = dummify(month)
	</code>
	<para>
	  Para obter máis detalles, consulta <fncref targ="dummify"/>.
	</para>
      </description>
    </function>

    <function name="selifc" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz tras seleccionar só aquelas columnas de
	  <argname>A</argname> nas que o elemento correspondente de
	  <argname>b</argname> non é nulo. O <argname>b</argname> debe de ser un
	  vector fila co mesmo número de columnas que <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz tras seleccionar só aquelas filas de
	  <argname>A</argname> nas que o elemento correspondente de
	  <argname>b</argname> non é nulo. O <argname>b</argname> debe de ser un
	  vector columna co mesmo número de filas que <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifc"/>
            <fncref targ="trimr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matrix" output="rvec">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg optional="true" type="scalar">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Con só dous argumentos, devolve un vector fila coa secuencia crecente
	  (sumando 1) desde <argname>a</argname> ata <argname>b</argname>, se o
	  primeiro argumento é menor ca o segundo; ou coa secuencia decrecente
	  (restando 1) se o primeiro argumento é maior ca o segundo.
	</para>
	<para>
	  Se indicas o terceiro argumento <argname>k</argname> (opcional),
	  a función vai devolver un vector fila coa secuencia iniciada en
	  <argname>a</argname>, e ampliada (ou diminuída no caso inverso de
	  que <argname>a</argname> sexa maior ca <argname>b</argname>) en
	  <argname>k</argname> unidades a cada paso. A secuencia remata no
	  maior valor posible que sexa menor ou igual a <argname>b</argname>
	  (ou no menor valor posible que sexa maior ou igual a <argname>b</argname>,
	  no caso inverso). O argumento <argname>k </argname> debe de ser
	  positivo.
	</para>
	<para>
	  <seelist>
            <fncref targ="ones"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">clave</fnarg>
	<fnarg type="string">nota</fnarg>
      </fnargs>
      <description>
	<para>
	  Insire unha nota descritiva para un obxecto que se identifica pola
	  <argname>clave</argname>, dentro dun feixe <argname>b</argname>.
	  Vaise amosar esa nota cando se utilice a instrución <lit>print</lit>
	  co feixe. Esta función devolve un enteiro igual a 0 no caso de
	  executarse con éxito, e un valor non nulo no caso de fallo (por
	  exemplo, se non existe ningún obxecto <argname>clave</argname> no
	  feixe <argname>b</argname>).
	</para>
      </description>
    </function>

    <function name="sgn" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a función signo de <argname>x</argname>; é dicir,
	  0 se <argname>x</argname> é cero, 1 se <argname>x</argname> é
	  positivo, &minus;1 se <argname>x</argname> é negativo, ou
	  <lit>NA</lit> se <argname>x</argname> é Non Numérico.
	</para>
      </description>
    </function>

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Pon en práctica o recocemento simulado, que pode ser útil para
	  mellorar a determinación do punto de partida dun problema de
	  optimización numérica.
	</para>
	<para>
	  Indicando o primeiro argumento, establécese o valor inicial dun
	  vector de parámetros; e indicando o segundo argumento, se especifica
	  unha chamada a unha función que devolve o valor escalar da
	  función obxectivo a maximizar. O terceiro argumento (opcional)
	  especifica o número máximo de iteracións (que por defecto é de 1024).
	  Cando se completa con éxito, a función <lit>simann</lit> devolve un
	  escalar co valor final da función obxectivo a maximizar, e
	  <argname>b</argname> contén o vector de parámetros asociado.
	</para>
	<para>
	  Para obter máis detalles e un exemplo, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co seno de <argname>x</argname>.
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co seno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="asinh"/>
            <fncref targ="cosh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor do coeficiente de asimetría da serie
	  <argname>x</argname>, descartando calquera observación ausente.
	</para>
      </description>
    </function>

    <function name="sleep" section="programming" output="scalar">
      <fnargs>
	<fnarg type="scalar">ns</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función non ten ningún uso directo en Econometría, mais pode
	  ser de utilidade para comprobar métodos de computación en paralelo.
	  Simplemente provoca que se <quote>durma</quote> a liña de cómputo
	  vixente (é dicir, que se pare) durante <argname>ns</argname>
	  segundos. O argumento debe ser un escalar non negativo. Ao
	  <quote>espertar</quote>, a función devolve o escalar 0.
	</para>
      </description>
    </function>

    <function name="smplspan" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">obsinicio</fnarg>
	<fnarg type="string">obsfin</fnarg>
	<fnarg type="int">pd</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número de observacións que hai contando desde
	  <argname>obsinicio</argname> ata <argname>obsfin</argname>
	  (ambas incluídas), para datos de series temporais que teñen
	  unha frecuencia <argname>pd</argname>.
	</para>
	<para>
	  Deberías de indicar os dous primeiros argumentos no formato
	  que prefire GRETL para datos de tipo anual, trimestral ou
	  mensual (por exemplo, <lit>1970</lit>, <lit>1970:1</lit>
	  ou <lit>1970:01</lit> para cada unha desas frecuencias,
	  respectivamente) ou como datas no formato ISO 8601,
	  <lit>YYYY-MM-DD</lit>.
	</para>
	<para>
	  O argumento <argname>pd</argname> debe de ser ben 1, 4
	  ou 12 (datos anuais, trimestrais ou mensuais), ben unha
	  das frecuencias diarias (5, 6, 7), ou ben 52 (semanal).
	  Se <argname>pd</argname> é igual a 1, 4 ou 12, entón as
	  datas ISO 8601 acéptanse para os dous primeiros argumentos,
	  se indican o comezo do período en cuestión. Por exemplo,
	  <lit>2015-04-01</lit> admítese en troques de <lit>2015:2</lit>
	  para representar o segundo trimestre de 2015.
	</para>
	<para>
	  Se xa tes un conxunto de datos con frecuencia <argname>pd</argname>
	  preparado, e cun rango suficiente de observacións, entón podes
	  imitar doadamente o comportamento desta función utilizando
	  a función <fncref targ="obsnum"/>. A vantaxe de <lit>smplspan</lit>
	  consiste en que podes calcular o número de observacións sen
	  necesidade de ter preparado un conxunto apropiado de datos
	  (nin ningún conxunto de datos). Deseguido, un exemplo:
	</para>
	<code>
	  scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  nulldata T
	  setobs 5 2010-01-01
	</code>
	<para>
	  Isto xera
	</para>
	<code>
	  ? scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  Xerouse o escalar T = 1565
	  ? nulldata T
	  Periodicidade: 1, máx. obs: 1565
	  Rango de observacións: 1 ata 1565
	  ? setobs 5 2010-01-01
	  Rango completo de datos: 2010-01-01 - 2015-12-31 (n = 1565)
	</code>
	<para>
	  Despois do anterior, podes ter confianza en que a derradeira
	  observación do conxunto de datos que se vai xerar por medio
	  de <cmdref targ="nulldata"/> vai ser <lit>2015-12-31</lit>.
	  Cae na conta de que o número 1565 sería máis ben complicado
	  calculalo doutro xeito.
	</para>
      </description>
    </function>

    <function name="sort" section="matrix" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado do tipo de <argname>x</argname> cos valores ordenados
	  de forma ascendente. As observacións con valores ausentes se descartan cando
	  <math>x</math> é unha serie, pero ordénanse no final se <math>x</math> é un vector.
	  <seelist>
            <fncref targ="dsort"/>
            <fncref targ="values"/>
	  </seelist>
	  Para matrices, en especial, consulta <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que contén os elementos de <argname>y2</argname>
	  ordenados de acordo cos valores crecentes do primeiro argumento
	  <argname>y1</argname>.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sphericorr" section="stats" output="matrix">
      <fnargs>
       <fnarg type="matrix">X</fnarg>
       <fnarg type="int">modo</fnarg>
       <fnarg type="matrixref" optional="true">&amp;J</fnarg>
      </fnargs>
      <description>
       <para>
	 Permite facer a representación en coordenadas esféricas dunha
	 matriz de correlacións, ou a operación inversa, dependendo do
	 valor do parámetro <argname>modo</argname>.
       </para>
       <para>
	 Cando se omite <argname>modo</argname>, ou é igual a 0, asúmese
	 que <argname>X</argname> é unha matriz de correlacións de orde
	 <by r="n" c="n"/>. O valor que se devolve é un vector que ten
	 <math>n(n-1)/2</math> elementos entre 0 e &pi;. Neste modo, ignórase
	 a referencia a <argname>J</argname>.
       </para>
       <para>
	 Cando <argname>modo</argname> é igual a 1 ou a 2, realízase a
	 transformación inversa, polo que <argname>X</argname> debe ser un
	 vector que teña <math>n(n-1)/2</math> elementos entre 0 e &pi;.
	 O valor que se devolve agora é a matriz <math>R</math> de correlacións
	 cando a opción <argname>modo</argname> é igual a 1; ou o seu factor
	 <math>K</math> de Cholesky cando <argname>modo</argname> é igual a 2.
	 Nestes casos, cando se indica, o punteiro opcional á matriz
	 <argname>J</argname> permite recuperar o Xacobiano de
	 vech(<math>R</math>) ou de vech(<math>K</math>) con respecto a
	 <math>X</math>.
       </para>
       <para>
	 Cae na conta de que a representación en coordenadas esféricas
	 fai moi sinxelo o cálculo do log-determinante da matriz de
	 correlacións <math>R</math>:
	</para>
       <code>
	 omega = sphericorr(X)
	 log_det = 2 * sum(log(sin(omega)))
	</code>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">formato</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto (<quote>string</quote>) que se constrúe
	  representando os valores dos argumentos (indicados polos puntos de
	  arriba) que acompañan á instrución, baixo o control do argumento
	  <argname>formato</argname>. Ten a intención de darte gran flexibilidade
	  para crear cadeas de texto. Utiliza <argname>formato</argname> para
	  indicar o xeito preciso no que queres que se presenten os argumentos.
	</para>
	<para>
	  En xeral, o argumento <argname>formato</argname> debe de ser unha
	  expresión que se corresponda cunha cadea de texto, pero nos máis
	  dos casos só vai ser unha cadea de texto literal (unha secuencia
	  alfanumérica contornada entre comiñas). Algunhas secuencias de
	  caracteres de formato teñen un significado especial: aquelas que
	  comezan co símbolo (%) interprétanse como <quote>comodíns</quote>
	  para os elementos que contén a lista de argumentos. Amais, caracteres
	  especiais (por exemplo, o de nova liña) represéntanse por medio dunha
	  combinación de símbolos que comeza cunha barra diagonal inversa.
	</para>
	<para>
	  Por exemplo, o código de abaixo...
	</para>
	<code>
	  scalar x = sqrt(5)
	  string claim = sprintf("sqrt(%d) é (aproximadamente) %6.4f.\n", 5, x)
	  print claim
	</code>
	<para>
	  vai producir...
	</para>
	<code>
	  sqrt(5) é (aproximadamente) 2.2361.
	</code>
	<para>
	  A expresión <lit>%d</lit> na cadea de formato, indica que se quere un
	  número enteiro nese preciso lugar da saída que se vai presentar, e dado
	  que esa é a expresión co símbolo <quote>por cento</quote> que está
	  máis á esquerda, emparéllase co primeiro argumento, é dicir 5.
	  A segunda secuencia especial é <lit>%6.4f</lit>, e representa un
	  valor con 6 díxitos de largo como mínimo, e con 4 díxitos despois do
	  separador decimal. O número desas secuencias debe de coincidir coa
	  cantidade de argumentos que acompañan á cadea de texto para o formato.
	</para>
	<para>
	  Consulta a páxina de axuda da instrución <cmdref targ="printf"/>
	  para obter máis detalles en relación coa sintaxe que podes utilizar
	  nas cadeas de texto para o formato.
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado, do mesmo tipo ca <argname>x</argname>, coa raíz
	  cadrada positiva deste. Xera <lit>NA</lit> para valores negativos deste.
	</para>
	<para>
	  Advirte que, se o argumento é unha matriz, realízase a operación
	  para cada elemento. Para a <quote>raíz cadrada matricial</quote>
	  consulta <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">produtos-cruz</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha lista que contén os cadrados das variables da lista
	  <argname>L</argname>, cos seus elementos nomeados de acordo co
	  seguinte padrón :<lit>sq_</lit><repl>nomevariable</repl>. Cando indicas
	  o segundo argumento (opcional) e ten un valor non nulo, a lista
	  tamén vai incluír os produtos cruzados dos elementos da lista
	  <argname>L</argname>, que se nomearán de acordo co formato do
	  padrón <repl>var1</repl><lit>_</lit><repl>var2</repl>. De ser
	  necesario, o nome das series dos argumentos vai tronzarse e mesmo
	  axustarse o nome do resultado final, para evitar a duplicación de
	  nomes na lista que se devolve.
	</para>
	<para>
	  Cae na conta de que as variables ficticias serán eliminadas cando
	  se calculen os cadrados para evitar que se xeren series idénticas,
	  pero vaise calcular o seu produto (<quote>interacción</quote>) con
	  outras series da lista <argname>L</argname> de entrada.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string-or-strings">orixe</fnarg>
	<fnarg type="string">formato</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Le valores indicados polo argumento <argname>orixe</argname> baixo
	  o control do argumento <argname>formato</argname>, e asigna estes
	  valores a un ou máis dos argumentos seguintes, indicados polos
	  puntos de arriba. Devolve un enteiro co número de valores que se
	  asignan. Esta función é unha versión simplificada da función
	  <lit>sscanf</lit> da linguaxe C de programación, cunha extensión
	  para escanear unha matriz enteira, e que se describe máis abaixo
	  baixo o título <quote>Escaneando unha matriz</quote>. Ten en conta que
	  indicar un arranxo de cadeas de texto como <argname>orixe</argname>
	  só se acepta no caso de que escanees unha matriz.
	</para>
	<para>
	  Como argumento <repl>orixe</repl> podes usar unha cadea de texto literal
	  contornada entre comiñas, ou ben o nome dunha cadea de texto que
	  definiras previamente. O argumento <repl>formato</repl> indícase de
	  xeito similar á cadea do argumento <quote>formato</quote> en
	  <cmdref targ="printf"/> (mira máis abaixo); nesta última función,
	  <repl>elementos</repl> debe de ser unha lista de variables definidas antes,
	  separadas por comas e que son os obxectivos da conversión de
	  <repl>orixe</repl>. (Para os afeitos a C: podedes fixar previamente os
	  nomes das variables numéricas con <lit>&amp;</lit>, pero non se esixe.)
	</para>
	<para>
	  O texto literal no argumento <repl>formato</repl> compárase con
	  <repl>orixe</repl>. Os elementos que especifican a conversión comezan
	  co carácter <lit>%</lit>, e as conversións que están admitidas
	  inclúen: <lit>%f</lit>, <lit>%g</lit> ou <lit>%lf</lit> para números
	  de punto flotante; <lit>%d</lit> para números enteiros; e <lit>%s</lit>
	  para cadeas de texto. Podes inserir un enteiro positivo despois do
	  símbolo de porcentaxe, que establece o número máximo de caracteres
	  que se van ler para a conversión indicada. Como forma alternativa,
	  podes inserir un carácter literal de asterisco, <lit>*</lit>, logo do
	  símbolo de porcentaxe para eliminar a conversión (saltándose así
	  calquera carácter que, doutro xeito, podería terse convertido ao tipo
	  indicado). Por exemplo, a expresión <lit>%3d</lit> converte os
	  seguintes 3 caracteres de <repl>orixe</repl> nun enteiro, en caso
	  de que sexa posible; e a expresión <lit>%*g</lit> permite saltarse
	  tantos caracteres de <repl>orixe</repl> como os que poderían
	  converterse nun número de punto flotante simple.
	</para>
	<para>
	  Ademais da conversión <lit>%s</lit> para cadeas de texto, tamén
	  está dispoñible unha versión simplificada do formato C
	  <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit>.
	  Neste formato, <repl>N</repl> representa o número máximo de
	  caracteres que se van ler, e <repl>chars</repl> expresa un conxunto de
	  caracteres que sexan admisibles, contornados entre corchetes:
	  o proceso de lectura remata cando se acada <repl>N</repl>, ou cando
	  se atopa un carácter que non está en <repl>chars</repl>. Podes
	  trocar o funcionamento de <repl>chars</repl>indicando o circunflexo
	  <lit>^</lit> como primeiro carácter; nese caso, o proceso de lectura
	  remata cando se atopa un carácter que está indicado no conxunto.
	  (A diferenza do que acontece en C, o guión non xoga ningún papel
	  especial no conxunto <repl>chars</repl>.)
	</para>
	<para>
	  Se a cadea de texto da orixe non coincide (exactamente) co formato,
	  o número de conversións pode quedarse curta a respecto do número
	  de argumentos indicados. Isto non é por si mesmo un fallo no que
	  atinxe a GRETL. Así e todo, poderías querer comprobar o número de
	  conversións que se completaron; isto indícase no valor que se
	  devolve De seguido indícanse varios exemplos:
	</para>
	<code>
	  # Escaneando valores escalares
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)
	  # Escaneando valores de cadea de texto
	  string s = "un dous"
	  string s1
	  string s2
	  sscanf(s, "%s %s", s1, s2)
	  print s1 s2
	</code>
	<subhead>Escaneando unha matriz</subhead>
	<para>
	  O escaneado de matrices debe sinalarse mediante a especificación
	  especial de conversión, <quote><lit>%m</lit></quote>. Podes indicar
	  o número máximo de filas a ler, inserindo un número enteiro entre o
	  signo <quote><lit>%</lit></quote> e a <quote><lit>m</lit></quote>
	  indicativa de matriz. Se permiten dúas variantes: que
	  <argname>orixe</argname> indique unha cadea de texto única que
	  represente unha matriz, e que <argname>orixe</argname> indique un
	  arranxo de cadeas de texto. Estas opcións descríbense de vez.
	</para>
	<para>
	  Se <argname>orixe</argname> é un argumento de cadea de texto única,
	  o escáner le unha liña da entrada e conta o número de campos numéricos
	  (separados por espazo ou por tabulador). Isto define o número de
	  columnas da matriz. Por defecto, o proceso de lectura continúa con
	  todas as liñas (filas) que conteñan o mesmo número de columnas
	  numéricas, mais o número máximo de filas pode limitarse mediante
	  o valor enteiro opcional mencionado antes.
	</para>
	<para>
	  Se <argname>orixe</argname> é un arranxo de cadeas de texto, o
	  resultado vai ser forzosamente un vector columna, do que cada
	  elemento vai ser a conversión numérica da cadea correspondente, ou
	  <lit>NA</lit> se a cadea de texto non representa un número.
	  A continuación, tes varios exemplos:
	</para>
	<code>
	  # Escaneando unha única cadea de texto
	  string s = sprintf("1 2 3 4\n5 6 7 8")
	  print s
	  matrix m
	  sscanf(s, "%m", m)
	  print m
	  # Escaneando un arranxo de cadeas de texto
	  strings S = defarray("1.1", "2.2", "3.3", "4.4", "5.5")
	  sscanf(S, "%4m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa suma dos cadrados dos desvíos respecto á
	  media (SCT), das observacións non ausentes da serie ou vector
	  <argname>y</argname>.
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="stack" section="panel" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">desprazamento</fnarg>
      </fnargs>
      <description>
	<para>
	  Deseñado para o manexo de datos no formato de series de tempo
	  encasteladas, que necesita GRETL para datos de panel. O valor
	  que se devolve é unha serie que se obtén encastelando de forma
	  <quote>vertical</quote>, grupos de <argname>n</argname>
	  observacións de cada serie da lista <argname>L</argname>. Por
	  defecto, se usan as primeiras <argname>n</argname> observacións
	  (iso se corresponde con <argname>desprazamento</argname> = 0),
	  pero podes trasladar o punto de inicio indicando un valor positivo
	  para <argname>desprazamento</argname>. Se a serie resultante fose
	  máis longa que o conxunto de datos vixente, engádense tantas
	  observacións como sexan necesarias.
	</para>
	<para>
	  Con esta función podes manexar o caso dun ficheiro de datos que conteña
	  series de tempo colocadas unhas a carón das outras, para un grupo de
	  unidades de sección cruzada. E tamén cando se considera o tempo en
	  sentido horizontal, e cada fila representa unha unidade atemporal.
	</para>
	<para>
	  Consulta a sección titulada <quote>Panel data specifics</quote>
	  no <guideref targ="chap:datafiles"/> para obter detalles e exemplos
	  do seu uso.
	</para>
      </description>
    </function>

    <function name="stdize" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-list-or-mat">X</fnarg>
	<fnarg type="int" optional="true">v</fnarg>
	<fnarg type="bool" optional="true">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Por defecto, devolve un resultado do mesmo tipo que o argumento, coa
	  versión tipificada desa serie, lista ou matriz: o argumento céntrase
	  e divídese polo seu desvío padrón mostral (con corrección de 1,
	  nos graos de liberdade). No caso de que o argumento sexa unha matriz,
	  os resultados calcúlanse por columnas.
	</para>
	<para>
	  Podes usar o segundo argumento (opcional) para modular o resultado.
	  Un valor non negativo dese <argname>v</argname> permite configurar
	  a corrección nos graos de liberdade que se utilizan para o desvío
	  padrón; así <argname>v</argname> = 0 solicita utilizar o estimador
	  máximo-verosímil. Como caso especial, se estableces que
	  <argname>v</argname> sexa igual a &minus;1, unicamente
	  se vai centrar o primeiro argumento.
	</para>
	<para>
	  Por defecto, os valores ausentes se obvian no caso dunha entrada de
	  tipo serie ou lista, pero non no caso dunha entrada de tipo matriz.
	  Para que se ignoren os valores ausentes no caso matricial, indica
	  un valor non nulo para <argname>obviar_na</argname>.
	</para>
      </description>
    </function>

    <function name="strfday" section="calendar" output="depends">
      <fnargs>
	<fnarg type="anyfloat">dia_epoca</fnarg>
	<fnarg type="string" optional="true">formato</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función opera como <fncref targ="strftime"/>, convertendo un valor
	  numérico nunha cadea de texto rexida por <argname>formato</argname>,
	  agás cando a entrada sexa un <quote>día de época</quote> (para cuxa
	  definición podes consultar a función <fncref targ="epochday"/>).
	  Dado que a resolución é de tipo diario, só se manexan formatos
	  relacionados con datas; os formatos relacionados con tempo
	  proporcionan resultados indefinidos.
	</para>
	<para>
	  Se omites o segundo argumento, o formato por defecto establécese
	  en ISO 8601 extendido, <lit>YYYY-MM-DD</lit>.
	</para>
      </description>
    </function>

    <function name="strftime" section="calendar" output="depends">
      <fnargs>
	<fnarg type="anyfloat">tm</fnarg>
	<fnarg optional="true" type="string">formato</fnarg>
	<fnarg optional="true" type="scalar">desprazamento</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>tm</argname> utilízase para proporcionar
	  o <quote>tempo Unix</quote>, é dicir o número de segundos dende
	  o inicio do ano 1970, de acordo co UTC. O valor que se devolve é
	  unha cadea de texto que proporciona a data e/ou hora correspondente,
	  ben nun formato especificado mediante o segundo argumento (opcional)
	  ou, por defecto, mediante a
	  <quote>representación preferida de data e hora no entorno local vixente</quote>
	  tal como determinaría a biblioteca do sistema C. Mira máis abaixo para
	  máis detalles sobre a especificación do formato.
	</para>
	<para>
	  Podes usar o argumento <argname>desprazamento</argname> (opcional)
	  para especificar un desprazamento en segundos en relación a UTC,
	  seleccionando así unha zona horaria diferente á predeterminada (que
	  é sempre a hora local). Por exemplo, un desprazamento de 3600
	  selecciona a Hora Central Europea, mentres que 0 selecciona a GMT.
	  O valor absoluto de <argname>desprazamento</argname> non debe
	  exceder de 86400 (24 horas).
	</para>
	<para>
	  O tipo concreto que se devolve, depende do tipo de <argname>tm</argname>:
	  cando <argname>tm</argname> é un escalar, un vector ou unha serie,
	  o resultado é unha única cadea de texto, un arranxo de cadeas ou unha
	  serie con cadeas de valores, respectivamente.
	</para>
	<para>
	  Podes obter valores axeitados de <argname>tm</argname> para
	  utilizar con esta función mediante o accesorio <fncref targ="$now"/>
	  ou a función <fncref targ="strptime"/>.
	</para>
	<para>
	  Cae na conta de que mentres que <argname>tm</argname> se considera
	  en relación ao UTC, o resultado predeterminado desta función é
	  <quote>local</quote> (en relación coa zona horaria establecida no
	  ordenador servidor). Por iso, un mesmo <argname>tm</argname> vai
	  amosar un tempo distinto (e talvez unha distinta data) en zonas
	  horarias diferentes. Pero se queres unha cadea de texto que represente
	  o UTC en troques do tempo local, GRETL pode facelo; mira máis
	  abaixo.
	</para>
	<subhead>Opcións de formato</subhead>
	<para>
	  Podes atopar as opcións típicas de formato consultando a páxina
	  sobre <lit>strftime</lit> do manual, nos sistemas que teñan esas
	  páxinas; ou por medio dun dos moitos sitios web que presentan
	  información relevante, como por exemplo
	  <url>https://devhints.io/strftime</url>. Ademais dos formatos
	  típicos, GRETL tamén recoñece unha opción especial: se
	  <argname>formato</argname> é <quote><lit>8601</lit></quote>
	  simplemente, a data e o tempo se presentan no formato
	  ISO 8601.
  </para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciona un xeito de definir valores de cadea de texto para a
	  serie <argname>y</argname>. Para que isto funcione, deben de
	  cumprirse dúas condicións: a serie obxectivo non debe de ter outra
	  cousa que non sexan valores enteiros positivos (ningún deles menor
	  ca 1); e o arranxo <argname>S</argname> debe de ter polo menos
    <math>n</math> elementos, sendo <math>n</math> o maior valor de
    <argname>y</argname>. Amais, cada elemento de <argname>S</argname>
	  debe de ter un formato UTF-8 válido. Se non se cumpre algunha destas
	  condicións, amósase un fallo. O valor nominal que devolve esta
	  función é cero, cando se completa con éxito.
	</para>
	<para>
	  Unha alternativa a <lit>stringify</lit> que te pode ser de utilidade
	  nalgúns contextos é a asignación directa dun arranxo de cadeas de
	  texto a unha serie: isto xera unha serie cuxos valores se toman da
	  serie de forma secuencial; o número de elementos do arranxo debe
	  ser igual, ben á longura total do conxunto de datos ou ben á longura
	  do rango da mostra vixente, e os valores pódense repetir como sexa
	  necesario.
	</para>
	<para>
	  <seelist>
      <fncref targ="strvals"/>
	    <fncref targ="strvsort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string-or-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é unha cadea de texto simple, devolve
	  a cantidade de caracteres UTF-8 que contén. Ten en conta que esta
	  vai ser menor que o número de bytes, se a cadea de texto contén
	  calquera carácter de tipo muti-byte (non ASCII). Cando desexes
	  obter o número de bytes, podes usar a función <fncref targ="nelem"/>.
	  Por exemplo:
	</para>
	<code>
	  string s = "Olé!"
	  printf "strlen(s) = %d, nelem(s) = %d\n", strlen(s), nelem(s)
	</code>
	<para>
	  debera devolver
	</para>
	<code>
	  strlen(s) = 5, nelem(s) = 7
	</code>
	<para>
	  Se o argumento é un arranxo de cadeas de texto, o valor que se devolve
	  é un vector columna que contén o número de caracteres de cada cadea.
	  Tamén se acepta que uses como argumento unha serie con cadeas de
	  valores; nese caso, o valor que se devolve é unha serie que contén a
	  longura das cadeas de valores ao longo do rango mostral vixente.
	</para>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Compara as dúas cadeas de texto dos argumentos, e devolve un enteiro
	  que é menor, igual ou maior ca 0 cando <argname>s1</argname> é
	  (respectivamente) menor, igual ou maior que <argname>s2</argname>,
	  ata os <argname>n</argname> primeiros caracteres. Cando se omite
	  <argname>n</argname>, a comparación continúa ata onde resulte
	  posible.
	</para>
	<para>
	  Cae na conta de que, se só queres comprobar se dúas cadeas de texto
	  son iguais, podes facelo sen necesidade de utilizar esta función, como
	  coa indicación <lit>if (s1 == s2)...</lit>.
	</para>
      </description>
    </function>

    <function name="strpday" section="calendar" output="depends">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string" optional="true">formato</fnarg>
      </fnargs>
      <description>
	<para>
	 Esta función compórtase de xeito similar á función <fncref targ="strptime"/>,
	 agás en que o valor que se devolve é de tipo <quote>día de época</quote>
	 (para cuxa definición podes consultar <fncref targ="epochday"/>).
	 Dado que a solución é de tipo diario, ignórase calquera información
	 que haxa en <argname>s</argname>, sobre o momento do día.
	</para>
      </description>
    </function>

    <function name="strptime" section="calendar" output="depends">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string" optional="true">formato</fnarg>
      </fnargs>
      <description>
	<para>
	 Esta función é a recíproca de <fncref targ="strftime"/>. Analiza unha
	 ou máis cadeas de texto que expresan tempo ou data, utilizando o
	 <argname>formato</argname> especificado; e devolve o número de
	 segundos transcorridos dende o inicio de 1970 segundo o Tempo Universal
	 Coordinado (UTC). O tipo concreto de valor que se devolve depende do de
	 <argname>s</argname>: se <argname>s</argname> é unha cadea de texto,
	 un arranxo de cadeas ou unha serie con cadeas de valores, o resultado é
	 un escalar, un vector columna ou unha serie numérica, respectivamente.
	</para>
	<para>
	  Se omites a opción <argname>formato</argname>, este se establece por
	  defecto en ISO 8601 <quote>extendido</quote>, <lit>YYYY-MM-DD</lit>
	  (o que se traduce a <quote><lit>%Y-%m-%d</lit></quote> como formato
	  de strptime).
	</para>
	<para>
	  Como caso especial, podes indicar o primeiro argumento
	  como un enteiro de 8 díxitos, de conformidade co formato de datas
	  <quote>básico</quote> do ISO 8601, <lit>YYYYMMDD</lit> (ou un
	  vector ou serie que conteña eses valores). Nese caso, deberás
	  omitir a opción <argname>formato</argname>.
	</para>
	<para>
	  Cae na conta de que o primeiro argumento desta función considérase
	  en relación coa zona horaria que está establecida no ordenador
	  servidor. Entón, por exemplo, a chamada
	</para>
	<code>
	  strptime("13/02/2009 23:31.30", "%d/%m/%Y %H:%M.%S")
	</code>
	<para>
	  vai devolver como resultado 1234567890, se o tempo do teu sistema
	  está establecido en UTC; pero se o está na zona horaria de Europa
	  Central (UTC+01:00), o resultado será 1234564290.
	</para>
	<para>
	  Podes atopar as opcións de <argname>formato</argname> consultando
	  a páxina sobre <lit>strptime</lit> do manual, en sistemas que dispoñan
	  das mesmas; ou por medio dun dos moitos sitios web que presentan
	  información relevante, como por exemplo
	  <url>http://man7.org/linux/man-pages/man3/strptime.3.html</url>.
	</para>
	<para>
	  O exemplo de debaixo amosa como podes converter información
	  de datas dun a outro formato.
	</para>
	<code>
	  scalar tm = strptime("Sunday 17/02/19", "%A %d/%m/%y")
	  eval strftime(tm) # Resultado por defecto
	  eval strftime(tm, "%A, %d de %B de %Y")
	</code>
	<para>
	  No entorno local de Galiza, o resultado é
	</para>
	<code>
	  07/02/2019 0:00:00
	  Febreiro 07, 2019
	</code>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg optional="true" type="string">sep</fnarg>
	<fnarg optional="true" type="int">i</fnarg>
      </fnargs>
      <description>
	<para>
	  No seu funcionamento básico, cun único argumento, devolve o arranxo de
	  cadeas de texto que resulta ao separar o contido de <argname>s</argname>
	  conforme aos espazos baleiros que ten (é dicir, conforme a calquera
	  combinación dos caracteres de espazo, tabulación e/ou liña nova).
	</para>
	<para>
	  Podes utilizar o segundo argumento (opcional) para especificar
	  o separador que se usa para separar <argname>s</argname>.
	  Por exemplo...
	</para>
	<code>
	  string Cesta = "Plátano,Mazá,Yaca,Laranxa"
	  strings S = strsplit(Cesta,",")
	</code>
	<para>
	  vai separar o primeiro argumento da función nun arranxo de catro
	  cadeas de texto, usando a coma como elemento separador.
	</para>
	<para>
	  As secuencias de barra diagonal esquerda para escapar, indicadas
	  mediante <quote><lit>\n</lit></quote>, <quote><lit>\r</lit></quote>
	  e <quote><lit>\t</lit></quote>, considérase que representan unha
	  liña nova, un salto de liña e unha tabulación cando se indican no
	  argumento opcional <argname>sep</argname>. Se queres incluír unha
	  barra diagonal esquerda literal como carácter separador, debes de
	  duplicala como en <quote><lit>\\</lit></quote>. Exemplo:
	</para>
	<code>
	  string s = "c:\fiddle\sticks"
	  strings S = strsplit(s, "\\")
	</code>
	<para>
	  Con independencia do separador, aos elementos do arranxo que se
	  devolve, se lles recorta calquera espazo en branco ao comezo ou
	  ao final. En consecuencia, se <argname>sep</argname> contén
	  caracteres que non son espazos en branco, entón se lle quita
	  calquera espazo ao comezo ou ao final.
	</para>
	<para>
	  Cando indicas un valor enteiro maior ca cero como terceiro argumento,
	  o valor que se devolve é unha única cadea de texto; en concreto, o
	  elemento <argname>i</argname> (en base 1) do arranxo que se xeraría
	  doutro xeito sen ese terceiro argumento. Cando <argname>i</argname>
	  sexa menor ca 1, se produce un fallo; mais cando <argname>i</argname>
	  excede o número de elementos implicados, devólvese unha cadea de
	  texto baleira.
	</para>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="bool">ign_maius</fnarg>
      </fnargs>
      <description>
	<para>
	  Procura en <argname>s1</argname> a cadea <argname>s2</argname>.
	  No caso de atopar a cadea de texto, devolve outra cadea cunha copia da
	  parte de <argname>s1</argname> que comeza con <argname>s2</argname>;
	  noutro caso, devolve unha cadea de texto baleira.
	</para>
  <para>
          Exemplo:
  </para>
  <code>
          string s1 = "GRETL é un programa de Econometría"
          string s2 = strstr(s1, "un")
          print s2
  </code>
	<para>
	  Se o argumento opcional <argname>ign_maius</argname> non é cero,
	  a procura non distinguirá maiúsculas de minúsculas. Por exemplo:
	</para>
	<code>
	  strstr("Bilbao", "b")
	</code>
	<para>
	  devolve <quote>bao</quote>, pero
	</para>
	<code>
	  strstr("Bilbao", "b",1)
	</code>
	<para>
	  devolve <quote>Bilbao</quote>.
	</para>
	<para>
	  Se unicamente queres descubrir se <argname>s1</argname>
	  contén a <argname>s2</argname> (proba booleana), consulta
	  <fncref targ="instring"/>.
	</para>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto cunha copia de <argname>s</argname>
	  na que se eliminaron os espazos en branco do inicio e do final.
	</para>
  <para>
          Exemplo:
  </para>
  <code>
          string s1 = "    Moito espazo en branco.  "
          string s2 = strstrip(s1)
          print s1 s2
  </code>
      </description>
    </function>

    <function name="strsub" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string">atopada</fnarg>
	<fnarg type="string">substit</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é unha cadea única, devolve unha cadea
	  de texto cunha copia de <argname>s</argname> na que se substituíu
	  toda a cadea <argname>atopada</argname> por <argname>substit</argname>.
	  Se <argname>s</argname> é un arranxo de cadeas de texto ou unha
	  serie que contén cadeas de valores, esta operación realízase con
	  cada unha das cadeas do arranxo ou da serie. Consulta tamén
	  <fncref targ="regsub"/> para outras substitucións máis complexas
	  mediante expresións regulares.
	</para>
  <para>
          Exemplo:
  </para>
  <code>
          string s1 = "Hola, GRETL!"
          string s2 = strsub(s1, "GRETL", "HANSL")
          print s2
  </code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg optional="true" type="bool">submostra</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando a serie <argname>y</argname> se compón de cadeas de texto
	  que expresan valores, esta función devolve por defecto un arranxo que
	  contén todos eses valores (con independencia do rango mostral que
	  estea vixente), ordenados numericamente comezando polo 1. Se está
	  vixente unha submostra do conxunto de datos, podes proporcionar
	  un valor non nulo para o segundo argumento (opcional) e obter deste
	  xeito un arranxo que conteña só as cadeas de texto presentes na
	  submostra.
	</para>
	<para>
	  Cando <argname>y</argname> non se compón de cadeas de texto que
	  expresan valores, devólvese un arranxo de cadeas de texto baleiras.
	  <seelist>
            <fncref targ="stringify"/>
	  </seelist>
	</para>
	<para>
	  Unha alternativa a <lit>strvals</lit> que te pode ser de utilidade
	  nalgúns contextos é a asignación directa dunha serie con valores
	  de cadeas de texto a un arranxo de cadeas de texto: isto non só
	  proporciona os valores que sexan diferentes, senón tódolos valores
	  da serie no rango da mostra vixente.
	</para>
      </description>
    </function>

    <function name="strvsort" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg optional="true" type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Leva a cabo un dos dous tipos de nova ordenación da serie
	  <argname>y</argname>, que debe constar de valores en cadeas de
	  texto. O valor nominal que se devolve é 0, cando se completa con
	  éxito.
	</para>
	<para>
	  Método 1: Se non indicas o segundo argumento, o efecto que se
	  produce é a ordenación de <argname>y</argname> neste senso: os
	  valores de cadea diferentes se alfabetizan e a serie se recodifica
	  entón de xeito que se asigna o 1 á primeira cadea ordenada, o 2
	  á segunda, etcétera. Isto pode ser útil, entre outras razóns, para
	  asegurar unha codificación uniforme para múltiples series que
	  compartan o mesmo conxunto de valores en cadeas.
	</para>
	<para>
	  Método 2: Se indicas o segundo argumento, este debe ser un arranxo
	  que conteña exactamente os diferentes valores de <argname>y</argname>
	  en cadeas (e que poden conseguirse mediante <fncref targ="strvals"/>),
	  pero colocados nunha orde preferida. O efecto entón consiste nunha
	  nova codificación da serie de xeito que o valor 1 se asigna á primeira
	  cadea de texto de <argname>S</argname>, o valor 2 á segunda, etcétera.
	  Isto pode ser útil para asegurar que os códigos numéricos
	  <quote>teñan sentido</quote> cando os valores en cadeas de texto
	  podan concibirse como naturalmente ordenados.
	</para>
	<para>
	  A principal utilización destes métodos é no manexo de series con
	  valores en cadeas de texto importadas de fontes de terceiros, como son
	  os ficheiros con información separada por comas. Para eses datos,
	  GRETL asigna códigos numéricos baseados simplemente na orden na que
	  están as cadeas de texto ao longo das filas do ficheiro. Así, nunha
	  serie cos valores <lit>baixo</lit>, <lit>medio</lit> e <lit>alto</lit>,
	  vaise asignar a <lit>alto</lit> o código 1 se acontece primeiro, en
	  troques de 3 (o que sería claramente máis <quote>natural</quote>).
	  Isto pódese fixar utilizando o Método 2. Ademáis, se dúas ou máis
	  series comparten os mesmos valores en cadeas de texto, vanse
	  codificar de xeito distinto agás que aconteza que os seus valores
	  diferentes aparezan na mesma orde no ficheiro de datos. Isto pódese
	  fixar mediante calquera dos métodos.
	</para>
	<para>
	  <seelist>
	    <fncref targ="stringify"/>
	    <fncref targ="strvals"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="int">inicio</fnarg>
	<fnarg type="int">fin</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é unha cadea única, devolve a subcadea do
	  argumento <argname>s</argname>, comezando no carácter indicado polo
	  enteiro positivo de <argname>inicio</argname>, e rematando no indicado
	  polo de <argname>fin</argname>, ambos incluídos; ou desde
	  <argname>inicio</argname> ata o remate de <argname>s</argname> se
	  <argname>fin</argname> é igual a &minus;1. Se o argumento é un arranxo
	  de cadeas de texto ou unha serie que contén cadeas de valores, esta
	  operación realízase con cada unha das cadeas do arranxo ou da serie.
	</para>
  <para>
          Por exemplo, o código de abaixo
  </para>
  <code>
          string s1 = "Hola, GRETL!"
          string s2 = substr(s1, 7, 11)
          print s2
  </code>
  <para>
          proporciona:
  </para>
  <code>
    ? print s2
    GRETL
  </code>
  <para>
          Debes de darte de conta de que, nalgúns casos, poderías estar
          desexando intercambiar claridade por concisión, e utilizar operadores
          de redución e incremento, como en
  </para>
  <code>
          string s1 = "Hola, GRETL!"
          string s2 = s1[7:11]
          string s3 = s1 + 6
          print s2
          print s3
  </code>
  <para>
    o que te proporcionaría
  </para>
  <code>
    ? print s2
    GRETL
    ? print s3
    GRETL!
  </code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando <argname>x</argname> é unha serie, devolve un escalar co
	  resultado de sumar as observacións non ausentes do argumento
	  <argname>x</argname>. Consulta tamén <fncref targ="sumall"/>.
	</para>
	<para>
	  Cando <argname>x</argname> é unha matriz, devolve un escalar co
	  resultado de sumar os elementos da matriz.
	</para>
	<para>
	  Cando <argname>x</argname> é unha lista de variables, a
	  función devolve unha serie <math>y</math>, na que cada valor
	  <math>y</math><sub>t</sub> indica a suma dos valores das
	  variables da lista na observación <math>t</math>. Por defecto,
	  se hai algún valor ausente en <math>t</math>, a suma rexístrase
	  como <lit>NA</lit>; pero se lle das un valor non nulo a
	  <argname>parcial</argname>, calquera valor non ausente se
	  usará para crear a suma.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado de sumar as observacións da serie
	  <argname>x</argname> na mostra seleccionada, ou <lit>NA</lit> se
	  existe algún valor ausente. Utiliza <fncref targ="sum"/> se queres
	  obter a suma descartando os valores ausentes.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila coas sumas de cada columna da matriz
	  <argname>X</argname>. Se indicas un valor non nulo para o segundo
	  argumento (opcional), ignóranse os valores ausentes; doutro xeito, o
	  resultado é <lit>NA</lit> para cada columna que conteña valores ausentes.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna coas sumas de cada fila da matriz
	  <argname>X</argname>. Se indicas un valor non nulo para o segundo
	  argumento (opcional), ignóranse os valores ausentes; doutro xeito, o
	  resultado é <lit>NA</lit> para cada fila que conteña valores ausentes.
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un vector fila co resultado de descompoñer a matriz
	  <argname>X</argname> en valores singulares.
	</para>
	<para context="tex">
	  Devolve un vector fila co resultado de descompoñer a matriz $X$
	  de orde $r \times c$, en valores singulares:
	  \[ X = U \left[
	  \begin{array}{cccc}
	  \sigma_1 \\
	  &amp; \sigma_2 \\
	  &amp; &amp; \ddots \\
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \]
	  onde $n = \min(r,c)$. $U$ é $r \times n$ e $V$ é $n \times c$,
	  con $U'U = I$ e $VV' = I$.
	</para>
	<para>
	  Os valores singulares devólvense nun vector fila. Podes obter o
	  vector singular esquerdo <math>U</math> e/ou o dereito <math>V</math>
	  indicando valores non nulos nos argumentos 2 e 3, respectivamente.
	  Para calquera matriz <lit>A</lit>, o código...
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V)
	  B = (U .* s) * V
	</code>
	<para>
	  ... debera proporcionar unha matriz <lit>B</lit> idéntica a
	  <lit>A</lit> (agás pequenas diferenzas debida á precisión de cálculo).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svm" section="nonparam" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="bundle">bparms</fnarg>
	<fnarg type="bundleref" optional="true">bmod</fnarg>
	<fnarg type="bundleref" optional="true">bprob</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función te permite o adestramento (e a predición baseada nela)
	  dunha MSV (Máquina de Soporte Vectorial ou SVM), utilizando a librería
	  LIBSVM como soporte. O argumento de tipo lista <argname>L</argname>
	  deberá de incluír a variable dependente seguida das variables
	  independentes; ademáis, o feixe <argname>bparms</argname>
	  emprégase para pasarlle opcións ao mecanismo da MSV. O valor
	  que se devolve é unha serie que contén as predicións da MSV.
	  Podes utilizar os dous argumentos opcionais punteiro-feixe para
	  recuperar información adicional despois do adestramento e/ou predición.
	</para>
	<para>
	  Para obter máis detalles, consulta a documentación PDF para
	  <mnu targ="gretlSVM">gretl + SVM</mnu>.
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa tanxente de <argname>x</argname>.
	  <seelist>
            <fncref targ="atan"/>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa tanxente hiperbólica de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="atanh"/>
            <fncref targ="cosh"/>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tdisagg" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="series-or-mat">Y</fnarg>
	<fnarg optional="true" type="series-list-or-mat">X</fnarg>
	<fnarg type="scalar">s</fnarg>
	<fnarg optional="true" type="bundle">opcions</fnarg>
	<fnarg optional="true" type="bundle">resultados</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a desagregación temporal (conversión a unha frecuencia maior)
	  dos datos de tipo serie temporal que haxa en <argname>Y</argname>.
	  O argumento <argname>s</argname> proporciona o factor de expansión
	  (por exemplo, 3 para pasar de trimestrais a mensuais). O argumento
	  <argname>X</argname> pode conter unha ou máis covariantes (que teñan
	  a frecuencia maior) para axudar no proceso de desagregación. Podes
	  asumir diversas opcións no argumento <argname>opcions</argname>,
	  e podes recoller os detalles da desagregación por medio de
	  <argname> resultados</argname>.
	</para>
	<para>
	  Consulta o <guideref targ="chap:tdisagg"/> para obter máis detalles.
	</para>
      </description>
    </function>

    <function name="thresh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
	<fnarg type="anyfloat">a</fnarg>
	<fnarg optional="true" type="scalar">forza</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza unha delimitación suave ou forte sobre <argname>x</argname>,
	  dependendo do valor do parámetro Booleano opcional
	  <argname>forza</argname>, cuxo valor predeterminado é 0.
	</para>
	<para>
	  Nos dous casos, as entradas de <argname>x</argname> cuxos valores
	  absolutos sexan menores que <argname>a</argname> se asignan a 0.
	  Coa delimitación suave, as demais entradas se encollen hacia 0.
	  Por exemplo, o código de abaixo
	</para>
	<code>
	  s = seq(-2,2,0.5)'
	  eval s ~ thresh(s, 0.5) ~ thresh(s, 0.5, 1)
	</code>
	<para>
	  xera
	</para>
	<code>
             -2      -1.5       -2
           -1.5        -1     -1.5
             -1      -0.5       -1
           -0.5         0        0
              0         0        0
            0.5         0        0
              1       0.5        1
            1.5         1      1.5
              2       1.5        2
	</code>
	<para>
	  Cando os dous argumentos difiren no tipo, o tipo do resultado
	  é o do <quote>maior</quote> dos dous, onde a ordenación sería
	  matriz &gt; serie &gt; escalar. Por exemplo, cando sexa un escalar
	  <argname>y</argname> e sexa <argname>x</argname> un
	  <math>n</math>-vector (ou viceversa), o resultado será un
	  <math>n</math>-vector. Cae na conta de que os argumentos matriciais
	  deben ser vectores; e de que, se ningún dos argumentos é un escalar,
	  os dous argumentos deben ter a mesma longura.
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
	<fnarg optional="true" type="scalarref">&amp;det</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna coa solución dun sistema Toeplitz
	  de ecuacións lineais, é dicir <math>Tx = b</math>
	  onde <math>T</math> é unha matriz cadrada cuxo elemento
	  <math>T</math><sub>i,j</sub> é
	  igual a <math>c</math><sub>i-j</sub>
	  cando <equation status="inline" ascii="i&gt;=j" tex="$i\ge j$"/>, e
	  igual a <math>r</math><sub>j-i</sub>
	  cando <equation status="inline" ascii="i&lt;=j" tex="$i\le j$"/>.
	  Ten en conta que os primeiros elementos dos dous vectores
	  <math>c</math> e <math>r</math> deben de ser iguais, pois
	  noutro caso se devolve un fallo. Cando se completa con éxito,
	  a execución desta función permite obter o vector
	  <math>x</math>.
	</para>
	<para>
	  O algoritmo que se utiliza aquí aproveita a especial estrutura da
	  matriz <math>T</math>, o que o fai moito máis eficiente ca outros
	  algoritmos non especializados, particularmente para problemas moi
	  longos. Advertencia: Nalgúns casos, a función podería suxerir
	  falsamente un fallo na singularidade da matriz <math>T</math> cando
	  realmente non é singular; de calquera xeito, este problema non
	  poderá xurdir cando a matriz <math>T</math> sexa definida
	  positiva.
	</para>
	<para>
	  Cando se indica o argumento opcional <argname>det</argname> (en
	  forma de punteiro), ao finalizar, este vai conter o determinante de
	  <math>T</math>. Por exemplo, o código:
	</para>
	<code>
	  A = unvech({3;2;1;3;2;3})    # Configura unha matriz 3x3 de Toeplitz
	  x = ones(3,1)                # e un vector 3x1
	  print A x
	  eval A\x                     # Soluciona mediante a inversión xeral
	  eval det(A)                  # Presenta o determinante
	  a = A[1,]
	  d = 0
	  eval toepsolv(a, a, x, &amp;d)   # Utiliza a función específica
	  print d
	</code>
	<para>
	  produce
	</para>
	<code>
A (3 x 3)

  3   2   1
  2   3   2
  1   2   3

x (3 x 1)

  1 
  1 
  1 

     0,25000
 -3.3307e-17
     0,25000

8
     0,25000
  2,7756e-17
     0,25000


d =  8,0000000
	</code>
      </description>
    </function>

    <function name="tolower" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é unha cadea única, devolve unha copia de
	  <argname>s</argname>, na que todas as letras en maiúsculas convertéronse
	  en minúsculas. Se <argname>s</argname> é un arranxo de cadeas de
	  texto ou unha serie que contén cadeas de valores, esta operación
	  realízase con cada unha das cadeas do arranxo ou da serie.
	</para>
	<para>
          Exemplo:
	</para>
	<code>
          string s1 = "Hola, GRETL!"
          string s2 = tolower(s1)
          print s2
	</code>
      </description>
    </function>

    <function name="toupper" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é unha cadea única, devolve unha copia de
	  <argname>s</argname>, na que todas as letras en minúsculas convertéronse
	  en maiúsculas. Se <argname>s</argname> é un arranxo de cadeas de
	  texto ou unha serie que contén cadeas de valores, esta operación
	  realízase con cada unha das cadeas do arranxo ou da serie.
	</para>
	<para>
          Exemplo:
	</para>
	<code>
          string s1 = "Hola, GRETL!"
          string s2 = toupper(s1)
          print s2
	</code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa traza da matriz cadrada <argname>A</argname>,
	  é dicir, a suma dos elementos da súa diagonal.
	  <seelist>
            <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que é a trasposta de <argname>X</argname>. Aviso:
	  Esta función utilízase raramente. Para traspor unha matriz, en xeral
	  podes usar simplemente o operador para transposición: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trigamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un resultado do mesmo tipo que o argumento coa función trigamma de
	  <argname>x</argname>; isto é, a segunda derivada do logaritmo da función Gamma.
	</para>
	<para context="tex">
	  Devolve un resultado do mesmo tipo que o argumento coa función trigamma
	  de $x$; isto é, $\frac {\mathrm{d}^2} {\mathrm{d} x^2}\, \log \Gamma(x)$.
	</para>
	<para>
	  <seelist>
            <fncref targ="lngamma"/>
            <fncref targ="digamma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="trimr" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">tsup</fnarg>
	<fnarg type="int">tinf</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que é unha copia da matriz <argname>X</argname>
	  na que se eliminaron as <argname>tsup</argname> filas superiores
	  e as <argname>tinf</argname> filas inferiores. Os dous últimos
	  argumentos non deben de ser negativos, e a súa suma debe de ser menor
	  ca o total de filas de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typename" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  Unha función de conveniencia que combina as funcións
	  <fncref targ="typeof"/> e <fncref targ="typestr"/>, cun pequeno valor
	  engadido. En esencia, os dous seguintes enunciados serían
	  equivalentes ...
	</para>
	<code>
	  eval typestr(typeof(x))
	  eval typename(x)
	</code>
	<para>
	  ... agás en que cando <argname>expr</argname> denomina un arranxo,
	  <lit>typename</lit> devolve o tipo específico de arranxo, como
	  en
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  eval typestr(typeof(S))  # presenta "array"
	  eval typename(S)         # presenta "strings"
	</code>
      </description>
    </function>

    <function name="typeof" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un código numérico indicando o tipo de <argname>expr</argname>
	  cando denomina unha variable vixente xa definida, especifica un obxecto
	  secundario como un elemento dun feixe ou un elemento dun arranxo,
	  ou é unha expresión correcta que se poda colocar no lado dereito
	  dunha operación de asignación. Os códigos son: 1 para un escalar,
	  2 para unha serie, 3 para unha matriz, 4 para unha cadea de texto,
	  5 para un feixe, 6 para un arranxo e 7 para unha lista. Ao devolverse
	  un  valor igual a 0, se indica que <argname>expr</argname> denomina
	  un obxecto que non existe ou, con máis xeneralidade, que fallaría
	  unha asignación con <argname>expr</argname> no lado dereito.
	</para>
	<para>
	  A continuación, algúns exemplos:
	</para>
	<code>
	  strings S = defarray("foo", "bar")
	  eval typeof(S)            # presenta 6 (arranxo)
	  eval typeof(S[1])         # presenta 4 (cadea de texto)
	  eval typeof(S[7])         # presenta 0 (fóra dos límites)
	  eval typeof(S[x])         # presenta 0 (índice incorrecto)
	  eval typeof(1+1)          # presenta 1 (escalar)
	  eval typeof(sqrt("foo"))  # presenta 0 (incorrecto)
	</code>
	<para>
	  Pódese utilizar a función <fncref targ="typestr"/> para conseguir
	  a cadea de texto que se corresponde co valor que se devolve con
	  <lit>typeof</lit>; aínda que se unicamente queres o resultado da
	  cadea, <fncref targ="typename"/> pode ser unha alternativa máis
	  conveniente.
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">codigotipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado un código de tipo do GRETL (por exemplo, obtido mediante
	  <fncref targ="typeof"/> ou <fncref targ="inbundle"/>), devolve unha
	  cadea de texto que indica o nome dese tipo. A asignación de
	  códigos a cadeas de texto é: 1 = <quote>scalar</quote> (escalar),
	  2 = <quote>series</quote> (serie), 3 = <quote>matrix</quote> (matriz),
	  4 = <quote>string</quote> (cadea de texto), 5 = <quote>bundle</quote>
	  (feixe), 6 = <quote>array</quote> (arranxo), 7 = <quote>list</quote>
	  (lista), e 0 = <quote>null</quote> (nulo).
	</para>
	<para>
	  Consulta tamén <fncref targ="typename"/> como alternativa.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que se xera cunha variable pseudoaleatoria
	  Uniforme que toma valores dentro do intervalo (<argname> a</argname>,
	  <argname>b</argname>) ou, se non indicas eses argumentos, no
	  intervalo (0,1). O algoritmo que se utiliza por defecto é o
	  <quote>SIMD-oriented Fast Mersenne Twister</quote> desenvolvido por 
	  <cite key="saito_matsumoto08">Saito e Matsumoto (2008)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="normal"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector que contén os distintos elementos non ausentes do
	  argumento <argname>x</argname> sen ningunha orde especial, senón na
	  que están en <argname>x</argname>. Consulta <fncref targ="values"/>
	  para a variante desta función que devolve os valores ordenados.
	</para>
      </description>
    </function>

    <function name="unvech" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Se omites o segundo argumento, devolve a matriz simétrica de orde
	  <by r="n" c="n"/> que se obtén reordenando os elementos do vector
	  <math>v</math> en forma de matriz triangular inferior, e copiando os
	  das posicións simétricas. O número de elementos de <math>v</math> debe
	  ser un enteiro triangular, ou sexa, un número <math>k</math> tal que
	  exista un enteiro <math>n</math> que cumpra a seguinte propiedade:
	  <equation status="inline" ascii="k = n(n+1)/2" tex="$k = n(n+1)/2$"/>.
	  Esta función é a inversa de <fncref targ="vech"/>.
	</para>
	<para>
	  Se indicas o argumento <argname>d</argname>, a función devolve
	  unha matriz <by r="(n+1)" c="(n+1)"/>, coas posicións fóra da diagonal
	  principal ocupadas cos elementos de <math>v</math>, como no caso
	  anterior. Pola contra, todos os elementos da diagonal principal se
	  establece que sexan iguais a <argname>d</argname>.
	</para>
	<para>
        Exemplo:
	</para>
    <code>
        v = {1;2;3}
        matrix un = unvech(v)
        matrix dous = unvech(v, 99)
        print un dous
    </code>
    <para>
      devolve
    </para>
    <code>
      un (2 x 2)

      1   2
      2   3

      dous (3 x 3)

      99     1     2
       1    99     3
       2     3    99
    </code>
	<para>
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz triangular superior de orde <by r="n" c="n"/>. Os
	  elementos da diagonal e os de arriba desta, son iguais aos elementos que
	  se corresponden en <argname>A</argname>; os demais son iguais a cero.
	</para>
	<para context="tex">
	  Devolve unha matriz triangular superior <math>B</math> de orde
	  $n\times n$ onde $B_{ij} = A_{ij}$ se $i \le j$, e 0 noutro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa probabilidade asociada (<math>P</math>) ao
	  valor do estatístico para facer a proba de raíces unitarias de
	  Dickey-Fuller ou a proba de cointegración de Engle&ndash;Granger,
	  conforme a <cite key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  Os argumentos exprésanse deste xeito: <argname>tau</argname> indica
	  o valor do estatístico de proba que corresponda; <argname>n</argname>
	  sinala o número de observacións (ou 0 se o que queres é un resultado
	  asintótico);<argname>niv</argname> denota o número de variables
	  potencialmente cointegradas, se comprobas a cointegración (ou 1 se fas
	  unha proba univariante de raíces unitarias); e <argname>itv</argname>
	  é un código que especifica o tipo modelo (1 = sen constante, 2 = con
	  constante, 3 = con constante máis tendencia linear, 4 = con constante máis
	  tendencia cadrada).
	</para>
	<para>
	  Ten en conta que debes de darlle un valor de 0 a <argname>n</argname>
	  para obter un resultado asintótico, se a regresión auxiliar para a
	  proba é <quote>ampliada</quote> con retardos da variable dependente.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="qlrpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector que contén os distintos elementos do argumento
	  <argname>x</argname> ordenados de forma ascendente, ignorando
	  calquera dos valores ausentes. Se queres descartar a parte decimal
	  antes de aplicar esta función, utiliza a expresión
	  <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="uniq"/>
            <fncref targ="dsort"/>
            <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando <argname>x</argname> é unha serie, devolve un escalar coa
	  súa varianza na mostra, descartando calquera observación ausente.
	</para>
	<para>
	  Cando <argname>x</argname> é unha lista, devolve unha serie
	  <math>y</math> na que cada valor <math>y</math><sub>t</sub>
	  indica a varianza na mostra dos valores das variables da
	  lista na observación <math>t</math>. Por defecto, se hai
	  algún valor ausente en <math>t</math>, a varianza rexístrase
	  como <lit>NA</lit>; pero se lle das un valor non nulo a
	  <argname>parcial</argname>, calquera valor non ausente se
	  usará para crear o estatístico.
	</para>
	<para>
	  En cada un deses casos, a suma dos cadrados dos desvíos con
	  respecto á media divídese por (<math>n</math> &minus; 1) cando
	  <math>n</math> &gt; 1. Noutro caso, indícase que a varianza é igual
	  a cero se <math>n</math> = 1, ou é igual a <lit>NA</lit> se
	  <math>n</math> = 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se indica un número enteiro como argumento, a función devolve
	  unha cadea de texto co nome da variable que ten un número ID igual a
	  <argname>v</argname>, ou xera un fallo se esa variable non existe.
	</para>
	<para>
	  Cando se indica unha lista como argumento, devolve unha cadea de
	  texto que contén os nomes das variables da lista, separados por
	  comas. Se indicas unha lista que está baleira, devólvese unha cadea
	  de texto baleira. En troques, podes utilizar <fncref targ="varnames"/>
	  para obter un arranxo de cadeas de texto .
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open broiler.gdt
        string s = varname(7)
        print s
    </code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un arranxo de cadeas de texto que contén os nomes das
	  variables da lista <argname>L</argname>. Se a lista que indicas
	  está baleira, devólvese un arranxo baleiro.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open keane.gdt
        list L = year wage status
        strings S = varnames(L)
        eval S[1]
        eval S[2]
        eval S[3]
    </code>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nomevar</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un número enteiro co código ID da variable que ten o nome
	  do argumento <argname>nomevar</argname>, ou NA se esa variable
	  non existe.
	</para>
      </description>
    </function>

    <function name="varsimul" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz ao simular un VAR de orde <math>p</math> e
	  <math>n</math> variables, é dicir
	  <equation status="inline"
		    ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)."
		    tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
	  A matriz <argname>A</argname> de coeficientes fórmase agrupando
	  horizontalmente as matrices <math>A</math><sub>i</sub>; e é de
	  orde <by r="n" c="np"/>, con unha fila por cada ecuación. Esta
	  se corresponde coas primeiras <math>n</math> filas da matriz
	  <lit>$compan</lit> que proporcionan as instrucións <lit>var</lit> e
	  <lit>vecm</lit>.
	</para>
	<para>
	  Os vectores <math>u_t</math> están incluídos (como filas) na matriz
	  <argname>U</argname> (<by r="T" c="n"/>). Os valores iniciais están
	  en <argname>y0</argname> (<by r="p" c="n"/>).
	</para>
	<para>
	  Cando o VAR contén algún termo determinista e/ou regresores
	  esóxenos, podes manexalos incorporándoos á matriz
	  <argname>U</argname>: neste caso cada fila de <argname>U</argname>
	  pasa a ser entón
	  <equation status="inline"
		    ascii="u(t) = B'x(t) + e(t)."
		    tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  A matriz que resulta ten <math>T</math> + <math>p</math> filas e
	  <math>n</math> columnas; contén os <math>p</math> valores iniciais
	  das variables endóxenas, ademais de <math>T</math> valores
	  simulados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$compan"/>
            <cmdref targ="var"/>
            <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matrix" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna, encastelando as columnas de <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matrix" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg optional="true" type="bool">omitir-diag</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función volve ordenar nun vector columna, os elementos da
	  matriz <argname>A</argname> que están na diagonal principal e por
	  enriba dela, agás que lle asignes un valor non nulo á opción
	  <argname>omitir-diag</argname>, en cuxo caso só se teñen en conta
	  as posicións por enriba.
  </para>
	<para>
	  Normalmente esta función utilízase con matrices simétricas, en
	  cuxo caso, esa operación pode reverterse a través da función
	  <fncref targ="unvech"/>. Se a matriz de entrada non é simétrica e
	  o seu triángulo inferior contén os valores <quote>correctos</quote>,
	  podes obter o resultado desexado mediante <lit>vech(A')</lit>
	  (aínda que os seus elementos pode que teñan que ordenarse de
	  novo).
	  <seelist>
            <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vma" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix" optional="true">K</fnarg>
	<fnarg type="int" optional="true">horizonte</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función xera unha matriz coa representación VMA dun sistema VAR.
	  Se <math>u</math><sub>t</sub> son as perturbacións das predicións
	  adiantadas un paso e
	  <equation status="inline" ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)"
	  tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$"/>,
	  a correspondente representación VMA é
	  <equation status="inline" ascii="y(t) = C0 e(t) + C1 e(t-1) + ..."
	  tex="$y_t = C_0 e_t + C_1 e_{t-1} + \ldots$."/>.
	  A relación entre <math>u</math><sub>t</sub> (perturbacións das
	  predicións) con <math>e</math><sub>t</sub> (impactos estruturais) será
	  <equation status="inline" ascii="u(t) = K e(t)" tex="$u_t = K e_t$"/>.
	  (Cae na conta de que <math>C</math><sub>0</sub> =
	  <math>K</math>.)
	</para>
	<para>
	  A matriz <argname>A</argname> de coeficientes do primeiro argumento,
	  fórmase encastelando as matrices <math>A</math><sub>i</sub> de xeito
	  horizontal; terá rango <by r="n" c="np"/>, con unha fila por cada
	  ecuación. Isto correspóndese coas primeiras <math>n</math> filas da
	  matriz <lit>$compan</lit> que proporcionan as instrucións <lit>var</lit>
	  e <lit>vecm</lit> de GRETL. A matriz <argname>K</argname> é opcional,
	  indicando por defecto a matriz identidade. 
	</para>
	<para>
	  A matriz que devolve esta función ten un número de filas igual a
	  <argname>horizonte</argname>, e <math>n</math><sup>2</sup> columnas:
	  cada <math>i</math>-ésima fila contén <math>C</math><sub>i-1</sub>
	  en formato vectorial. O valor de <argname>horizonte</argname> se
	  establece por defecto igual a 24, cando non se indique.
	</para>
	<para>
	  <seelist>
            <fncref targ="irf"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">día</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o día da semana (de Domingo = 0 ata Sábado=6) da data
	  especificada polos tres argumentos, ou <lit>NA</lit> se a data
	  non é correcta. Ten en conta que os tres argumentos deben de ser
	  do mesmo tipo; ou sexa, deben de ser todos de tipo escalar (enteiro)
	  ou todos de tipo serie.
	</para>
	<para>
	  Admítese tamén unha solicitude alternativa: cando se indica un
	  único argumento, considérase que é unha data (ou unha serie de
	  datas) en formato numérico <quote>básico</quote> ISO 8601,
	  <lit>YYYYMMDD</lit>. Deste xeito, as seguintes dúas solicitudes
	  xeran o mesmo resultado, concretamente 2 (martes).
	</para>
	<code>
	  eval weekday(1990, 5, 1)
	  eval weekday(19900501)
	</code>
	<para>
	  Unha alternativa habitual de numeración dos días da semana vai
	  desde Luns = 1 ata Domingo = 7. Se tes unha serie denominada
	  <lit>wd</lit> obtida mediante a función <lit>weekday</lit>, e
	  queres convertela á alternativa, podes facer
	</para>
	<code>
	  altwd = wd == 0 ? 7 : wd
	</code>
	<para>
	  Cae na conta de que se unicamente engades 1 a <lit>wd</lit>, obtés
	  unha numeración que é válida pero non estándar; concretamente
	  de Domingo = 1 a Sábado = 7.
	</para>
      </description>
    </function>

    <function name="wmean" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica a media ponderada dos
	  valores (na observación <math>t</math>) das variables presentes na
	  lista <argname>Y</argname>, coas respectivas ponderacións sinaladas
	  polos valores das variables que forman a lista <argname>W</argname>
	  en cada <math>t</math>. As ponderacións poden así variar no tempo.
	  As listas <argname>Y</argname> e <argname>W</argname> de variables
	  deben de ter o mesmo tamaño, e as ponderacións deben de ser non
	  negativas.
	</para>
	<para>
	  Por defecto, o resultado é <lit>NA</lit>, se hai algún valor
	  ausente na observación <math>t</math>; pero se lle das un
	  valor non nulo a <argname>parcial</argname>, se utilizará
	  calquera valor non ausente.
	</para>
	<para>
	  <seelist>
            <fncref targ="wsd"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wsd" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica o desvío padrón ponderado
	  na mostra, dos valores (na observación <math>t</math>) das variables
	  presentes na lista <argname>Y</argname>, coas respectivas ponderacións
	  sinaladas polos valores das variables da lista <argname>W</argname>
	  en cada <math>t</math>. As ponderacións poden así variar no tempo.
	  As listas <argname>Y</argname> e <argname>W</argname> de variables
	  deben de ter o mesmo tamaño, e as ponderacións deben de ser non
	  negativas.
	</para>
	<para>
	  Por defecto, o resultado é <lit>NA</lit>, se hai algún valor
	  ausente na observación <math>t</math>; pero se lle das un
	  valor non nulo a <argname>parcial</argname>, se utilizará
	  calquera valor non ausente.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wvar" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica a varianza ponderada na mostra,
	  dos valores (na observación <math>t</math>) das variables presentes na
	  lista <argname>Y</argname>, coas respectivas ponderacións sinaladas
	  polos valores das variables que forman a lista <argname>W</argname>
	  en cada <math>t</math>. As ponderacións poden así variar no tempo.
	  As listas <argname>Y</argname> e <argname>W</argname> de variables
	  deben de ter o mesmo tamaño, e as ponderacións deben de ser non
	  negativas.
	</para>
	<para>
	  Por defecto, o resultado é <lit>NA</lit>, se hai algún valor
	  ausente na observación <math>t</math>; pero se lle das un
	  valor non nulo a <argname>parcial</argname>, se utilizará
	  calquera valor non ausente.
	</para>
	<para context="tex">
	  A varianza ponderada na mostra calcúlase mediante
	  \[ s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} \]
	  onde $n'$ indica o número de ponderacións non nulas e $\bar{x}_w$
	  indica a media ponderada.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wsd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmlget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string-or-strings">ruta</fnarg>
	<fnarg optional="true" type="scalarref">&amp;coincidencias</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>buf</argname> debe de ser un búfer
	  XML, tal como pode recuperarse dun lugar web adecuado
	  mediante a función <fncref targ="curl"/> (ou lerse dun
	  ficheiro mediante a función <fncref targ="readfile"/>);
	  e o argumento <argname>ruta</argname> debe de ser, ben
	  unha especificación XPath sinxela ou ben un arranxo delas.
	</para>
	<para>
	  Esta función devolve unha cadea de texto que representa os datos
	  atopados no búfer XML na ruta especificada. Se hai múltiples nodos
	  que coincidan coa expresión da ruta, as unidades de datos se
	  presentan unha por cada liña da cadea que se devolve. Cando indicas
	  un arranxo de rutas como segundo argumento, a cadea que se devolve
	  ten a forma dun búfer separado con comas, cuxa columna <math>i</math>
	  contén as coincidencias da ruta <math>i</math>. Neste caso, se unha
	  cadea obtida do búfer XML contén algún espazo ou coma, contórnase
	  entre comiñas.
	</para>
	<para>
	  Por defecto, amósase un fallo se <argname>ruta</argname> non
	  coincide no búfer XML; pero este comportamento modifícase
	  se indicas o terceiro argumento (opcional) pois, neste
	  caso, o argumento recupera un reconto das coincidencias, devolvéndose
	  unha cadea baleira se non hai ningunha. Chamada de exemplo:
	</para>
	<code>
	  ngot = 0
	  ret = xmlget(xbuf, "//some/thing", &amp;ngot)
	</code>
	<para>
	  Agora ben, aínda vaise amosar un fallo no caso de facer unha solicitude
	  mal configurada.
	</para>	
	<para>
	  Podes atopar unha boa introdución ao uso e á sintaxe de
	  XPath en
	  <url>https://www.w3schools.com/xml/xml_xpath.asp</url>.
	  O programa de soporte (back-end) para <lit>xmlget</lit>
	  o proporciona o módulo xpath de libxml2, que admite
	  XPath 1.0 pero non XPath 2.0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="jsonget"/>
	    <fncref targ="readfile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeromiss" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) trocando os ceros en
	  <lit>NA</lit>s. Se <argname>x</argname> é unha serie ou unha matriz,
	  a conversión faise elemento a elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz nula con <math>r</math> filas e <math>c</math>
	  columnas. Se o omites, o número de columnas establécese en 1
	  (vector columna), por defecto.
      <seelist>
        <fncref targ="ones"/>
        <fncref targ="seq"/>
      </seelist>
    </para>
      </description>
    </function>

  </funclist>
</funcref>
