<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE funcref SYSTEM "genr_funcs.dtd">

<funcref language="italian">

  <funclist name="Accessori" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
          Deve seguire la stima di un modello panel a effetti fissi. Produce le
          stime degli effetti fissi individuali (intercette delle singole
          unità).
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Produce il criterio di informazione di Akaike per l'ultimo modello
          stimato. Si veda <guideref targ="select-criteria"/> per dettagli.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Produce il criterio di informazione bayesiana di Schwarz per l'ultimo
          modello stimato. Si veda <guideref targ="select-criteria"/> per dettagli.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Produce la statistica chi-quadro complessiva per l'ultimo
	  modello stimato, se disponibile.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  L'accessore <lit>$coeff</lit> può essere usato in due modi:
	  senza argomenti produce un vettore colonna che contiene i
	  coefficienti dell'ultimo modello stimato. Con l'argomento
	  opzionale, produce uno scalare che corrisponde alla stima
	  del coefficiente chiamato <argname>s</argname>.
	  <seelist>
	    <fncref targ="$stderr"/>
	    <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg 
	  b = $coeff 
	  macoef = $coeff(theta_1)
	</code>
	<para>
	  Se il <quote>modello</quote> in questione è effettivamente
	  un sistema (un VAR o un VECM, o un sistema di equazioni
	  simultanee), <lit>$coeff</lit> senza parametri produce la
	  matrice dei coefficienti, una colonna per equazione.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Deve seguire la stima di un modello; restituisce la stringa
	  del comando relativo, come ad esempio <lit>ols</lit> oppure
	  <lit>probit</lit>.
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VAR o un VECM; produce la matrice
          compagna.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Restituisce un intero corrispondente al tipo di dataset
	  attualmente in memoria: 0 = nessun dato; 1 = dati
	  cross-sezionali (non datati); 2 = serie storiche; 3 = panel.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Deve seguire la stima di un modello ad equazione singola e
	  restituisce il nome della variabile dipendente.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Produce i gradi di libertà dell'ultimo modello stimato. Se
	  questo consiste di un sistema di equazioni, viene restituito
	  il numero dei gradi di libertà per equazione; se questo
	  differisce da un'equazione all'altra, allora il valore
	  restituito è pari al numero di osservazioni meno la media del
	  numero di coefficienti per equazione (arrotondato all'intero
	  più vicino).
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Fornisce il p-value per la statistica Durbin&ndash;Watson
	  relativa all'ultimo modello stimato, se disponibile. Tale
	  valore è calcolato ramite la procedura di Imhof.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM e restituisce una matrice
	  contenente i termini di correzione d'errore.  La matrice
	  restituita ha tante righe quante sono le osservazioni usate
	  nella stima e un numero di colonne pari al rango di
	  cointegrazione del sistema.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Restituisce il codice interno di errore, che avrà un valore
	  diverso da 0 se si è verificato un errore in presenza del
	  modificatore <cmdref targ="catch"/>. Si noti che l'uso di
	  questo accessore resetta il codice di errore interno a 0. Si
	  veda anche <fncref targ="errmsg"/>. Per il messaggio
	  d'errore associato a un dato codice, bisogna salvare il
	  valore in una variabile temporanea; ad esempio:
	</para>
	<code>
	  errval = $error if (errval) printf "Errore %d (%s)\n",
	  errval, errmsg(errval); endif
	</code>
	<seelist>
	  <cmdref targ="catch"/>
	  <fncref targ="errmsg"/>
	</seelist>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Produce la somma dei quadrati degli errori dell'ultimo modello
          stimato.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM; restituisce un vettore
	  contenente gli autovalori usati nel calcolo del test traccia 
	  per la cointegrazione.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire il comando <cmdref targ="fcast"/>; restituisce le
	  previsioni sotto forma di matrice. Se il modello usato per
	  le previsioni è un modello a più equazioni, ogni colonna
	  corrisponde ad un'equazione; altrimenti, restituisce un vettore
	  colonna.
	</para>
      </description>
    </function>

    <function name="$fcerr" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire il comando <cmdref targ="fcast"/>; restituisce gli
	  errori standard per le previsioni sotto forma di matrice. Se
	  il modello usato per le previsioni è un modello a più
	  equazioni, ogni colonna corrisponde ad un'equazione;
	  altrimenti, restituisce un vettore colonna.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VAR. Restituisce una matrice
	  contenete la scomposizione della varianza dell'errore di
	  previsione (FEVD). Questa avrà <math>h</math> righe, dove
	  <math>h</math> è l'orizzonte di previsione, che può essere
	  modificato tramite il comando <lit>set horizon</lit> o,
	  altrimenti, viene fissato automaticamente sulla base della
	  frequenza dei dati.  Per un VAR con <math>p</math>
	  variabili, la matrice ha <math>p</math><sup>2</sup>
	  colonne. La parte dell'errore di previsione sulla variabile
	  <math>i</math> attribuibile allo shock alla variabile
	  <math>j</math> si troverà nella colonna (<math>i</math> &minus;
	  1)<math>p</math> + <math>j</math>.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Restituisce la statistica F complessiva per l'ultimo modello
	  stimato, se disponibile.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Deve seguire un blocco <lit>gmm</lit>. Produce il valore della
          funzione obiettivo al suo minimo.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Deve seguire un comando <lit>garch</lit>. Produce la
	  varianza condizionale stimata.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Deve seguire un comando <lit>tsls</lit>. Produce un vettore <by r="1"
	  c="3"/> contenente nell'ordine: il valore della statistica del test di Hausman,
          i corrispondenti gradi di libertà e p-value.
	</para>
      </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Produce il criterio di informazione di Hannan-Quinn per l'ultimo
          modello stimato.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Restituisce un numero positivo molto grande. Per impostazione predefinita è pari a 1.0E100,
	  ma tale valore si può cambiare usando il comando <cmdref targ="set"/>.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM, e produce la matrice dei pesi, che
          contiene tante righe quante sono le variabili del VECM e tante colonne
          quanto è il rango di cointegrazione.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM, e produce la matrice di
          cointegrazione, che contiene tante righe quante sono le variabili del
          VECM e tante colonne quanto è il rango di cointegrazione.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM, e produce la matrice di covarianza
          stimata per gli elementi dei vettori di cointegrazione.
	</para>
	<para>
	  Nel caso di stima non vincolata, ha un numero di righe pari al numero
          di elementi non vincolati nello spazio di cointegrazione dopo la
          normalizzazione di Phillips. Se però si stima un sistema vincolato con
          il comando <lit>restrict</lit> e l'opzione <lit>--full</lit>, verrà
          prodotta una matrice singolare con <math>nr</math> righe (<math>n</math>
          è il numero delle variabili e <math>r</math> è il rango di
          cointegrazione).
	</para>
	<para>
	  Esempio: il codice
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	  b[1,1] = 1
	  b[1,2] = -1
	  b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  produce il risultato seguente.
	</para>
	<code>
	  s0 (4 x 4)

	    0.019751     0.029816  -0.00044837     -0.12227 
	    0.029816      0.31005     -0.45823     -0.18526 
	 -0.00044837     -0.45823       1.2169    -0.035437 
	    -0.12227     -0.18526    -0.035437      0.76062 

	  s1 (5 x 5)

	  0.0000       0.0000       0.0000       0.0000       0.0000 
	  0.0000       0.0000       0.0000       0.0000       0.0000 
	  0.0000       0.0000      0.27398     -0.27398    -0.019059 
	  0.0000       0.0000     -0.27398      0.27398     0.019059 
	  0.0000       0.0000    -0.019059     0.019059    0.0014180 
	</code>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  Per alcuni modelli stimati con massima verosimiglianza,
	  produce la serie della log-verosimiglianza per
	  osservazione. Al momento, questo accessore funziona solo per
	  logit e probit binari, tobit e heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Produce la log-verosimiglianza dell'ultimo modello stimato (dove
          possibile).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Restituisce il valore dell'<quote>epsilon macchina</quote>,
	  ossia un limite superiore all'errore relativo dovuto
	  all'aritmetica a virgola mobile in doppia precisione.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Dopo la stima di un modello logit multinomiale, crea una
	  matrice con le probabilità stimate per tutti i possibili
	  esiti e tutte le osservazioni usate nella stima. Le
	  osservazioni sono per riga e gli esiti per colonna.
	</para>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Produce il numero totale dei coefficienti stimati nell'ultimo modello.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" targ="dnobs" output="int">
      <description>
	<para>
	  Produce il numero delle osservazioni nel campione selezionato.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	Produce il numero delle variabili nel dataset (inclusa la costante).
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Applicabile quando il dataset corrente è una serie storica
	  con frequenza decennale, annuale, trimestrale, mensile,
	  settimanale o giornaliera, oppure è un panel in cui la
	  variabile che indicizza i periodi ha la frequenza
	  appropriata (si veda il comando <cmdref targ="setobs"/>).
	  La serie risultante ha 8 cifre con la struttura
	  <lit>YYYYMMDD</lit> (forma <quote>base</quote> delle date
	  secondo l'ISO 8601), che corrisponde al giorno
	  dell'osservazione, o al primo giorno del periodo di
	  osservazione nel caso di serie storiche con frequenza minore
	  di quella giornaliera.
	</para>
	<para>
	  Questa serie può essere utile quando si usa il comando <cmdref targ="join"/>.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  Applicabile quando le osservazioni nel dataset aperto hanno
	  una struttura maggiore:minore, come in serie storiche
	  trimestrali (anno:trimestre), mensili (anno:mese), orarie
	  (giorno:ora) e dati panel (individuo:periodo). Restituisce una
	  serie contenente la componente maggiore (a frequenza più
	  bassa, come l'anno).
	</para>
	<para>
	  <seelist>
	    <fncref targ="$obsminor"/>
	    <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  Applicabile quando le osservazioni nel dataset aperto hanno
	  una struttura maggiore:minore:micro, come in serie storiche
	  giornaliere (anno:mese:giorno). Restituisce una
	  serie contenente la componente micro (a frequenza più
	  alta, come il giorno).
	</para>
	<para>
	  <seelist>
	    <fncref targ="$obsmajor"/>
	    <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  Applicabile quando le osservazioni nel dataset aperto hanno
	  una struttura maggiore:minore, come in serie storiche
	  trimestrali (anno:trimestre), mensili (anno:mese), orarie
	  (giorno:ora) e dati panel (individuo:periodo). Restituisce una
	  serie contenente la componente minore (a frequenza più
	  alta, come il mese).
	</para>
	<para>
	  <seelist>
	    <fncref targ="$obsmajor"/>
	    <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Produce la frequenza o la periodicità dei dati (es. 4 per dati
          trimestrali).
	</para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Restituisce il valore di &pi; in doppia precisione.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" targ="dpvalue" output="scalar-or-matrix">
      <description>
	<para>
	  Produce il p-value della statistica test generata
	  dall'ultimo comando esplicito di test di ipotesi (es.
	  <lit>chow</lit>).  Si veda <guideref
	  targ="sec:genr-internal"/> per i dettagli.
	  <seelist>
	    <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Senza argomenti, produce il coefficiente autoregressivo del
          prim'ordine per i residui dell'ultimo modello. Dopo aver stimato un
          modello con il comando <lit>ar</lit>, la sintassi
	  <lit>$rho(n)</lit> produce la corrispondente stima di
	  &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Produce l'<math>R</math><sup>2</sup> non aggiustato
	  dell'ultimo modello stimato.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Deve seguire la stima di un modello ad equazione
	  singola. Restituisce una variabile binaria con 1 per le
	  osservazioni usate nella stima, 0 per osservazioni incluse
	  nel campione corrente ma non usate nella stima (ad esempio,
	  per via di valori mancanti nella variabile dipendente) e NA
	  per osservazioni al di fuori del campione corrente.
	</para>
	<para>
	  Se fosse necessario calcolare statistiche basate sul
	  campione usato per un certo modello, ad esempio, si potrebbe
	  usare la seguente sintassi:
	</para>
	<code>
	  ols y 0 xlist
	  genr sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Deve seguire un comando <lit>tsls</lit>. Produce un vettore <by r="1"
	  c="3"/> che contiene nell'ordine: il valore della statistica del test
          di Sargan per la sovraidentificazione, i corrispondenti gradi di
          libertà e il p-value.
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Restituisce lo scarto quadratico medio dei residui dell'ultimo
	  modello stimato.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  L'accessore <lit>$stderr</lit> può usarsi in due modi: senza
	  argomenti, restituisce un vettore colonna che contiene le stime
	  dei coefficienti per l'ultimo modello stimato.  Con il
	  parametro opzionale, restituisce uno scalare contenente la
	  stima del parametro <argname>s</argname>.
	</para>
	<para>
	  Se il <quote>modello</quote> in questione è un sistema, il
	  risultato dipende dalle sue caratteristiche: per sistemi VAR
	  e VECM il valore restituito è una matrice con una colonna per
	  equazione; altrimenti, è un vettore colonna contenente i
	  coefficienti della prima equazione, seguiti da quelli della
	  seconda, e così via.
	</para>
	<para>
	  <seelist>
	    <fncref targ="$coeff"/> 
	    <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Deve essere preceduto dal comando <lit>set stopwatch</lit>,
	  che attiva la misurazione del tempo di CPU.  Il primo uso di
	  questo accessore restituisce i secondi di CPU time trascorsi dal
	  comando <lit>set stopwatch</lit>. Ad ogni accesso il
	  cronometro viene riazzerato, cosicché l'uso successivo
	  dell'accessore restituisce i secondi di CPU intercorsi dalla
	  chiamata precedente.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un sistema simultaneo.  Restituisce
	  la matrice dei coefficienti delle endogene ritardate, se
	  presenti nella forma strutturale. Si veda il comando <cmdref
	  targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un sistema simultaneo.  Restituisce
	  la matrice dei coefficienti delle esogene nella forma
	  strutturale. Si veda il comando <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un sistema simultaneo.  Restituisce
	  la matrice dei coefficienti delle endogene contemporanee
	  nella forma strutturale. Si veda il comando <cmdref
	  targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Numero di osservazioni usato nella stima dell'ultimo
	  modello.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Indice (a base 1) della prima osservazione nel campione
	  attualmente selezionato.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Indice (a base 1) dell'ultima osservazione nel campione
	  attualmente selezionato.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Restituisce il valore della statistica test generata
	  dall'ultimo comando esplicitamente volto al test di ipotesi
	  (p. es: <lit>chow</lit>), se presente. Si veda <guideref
	  targ="sec:genr-internal"/> per maggiori dettagli.
	  <seelist>
	    <fncref label="\$pvalue" targ="dpvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Restituisce <math>TR</math><sup>2</sup> (ampiezza campionaria
	  per R quadro) dall'ultimo modello.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Restituisce i residui dall'ultimo modello stimato. Cosa si
	  intenda per 'residui' dipende dal modello che è stato
	  stimato. Ad esempio, dopo una stima ARMA <lit>$uhat</lit>
	  contiene gli errori di previsione a un passo; dopo un
	  probit, i residui generalizzati.
	</para>
	<para>
	  Se il modello in questione è multi-equazionale (un VAR o un
	  VECM, o un sistema simultaneo), <lit>$uhat</lit> senza
	  parametri restituisce una matrice contenente i residui nelle
	  colonne.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Valido solo per dataset di tipo panel.  Restituisce una serie
	  con 1 per la prima unità cross-sezionale, 2 per la seconda e
	  così via.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s1</fnarg>
	<fnarg optional="true" type="coeffname">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Senza argomenti, restituisce una matrice quadrata contenente le
	  covarianze stimate dei coefficienti dell'ultimo modello. Con
	  gli argomenti opzionali, restituisce uno scalare, con la
	  covarianza stimata fra i parametri di nome
	  <argname>s1</argname> e <argname>s2</argname>.
	  <seelist>
	    <fncref targ="$coeff"/> 
	    <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  Questo accessore non è disponibile per modelli di tipo VAR o
	  VECM; in tal caso, si veda piuttosto <fncref targ="$sigma"/> e
	  <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM; restituisce una matrice in cui
	  le matrici Gamma (cioè i coefficienti delle differenze
	  ritardate) sono messe una fianco all'altra.  Ogni riga
	  rappresenta un'equazione; per un VECM di ordine
	  <math>p</math> ci sono <math>p</math> &minus; 1
	  sottomatrici.
	</para>
      </description>
    </function>    

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Restituisce un valore intero che codifica la versione del
	  programma, sotto la forma <lit>x.y.z</lit> (ad esempio,
	  1.7.6).  Il valore prodotto da questo accessore è pari a
	  <lit>10000*x + 100*y + z</lit>, cosicché 1.7.6 diventa
	  10706.
	</para>
      </description>
    </function>


    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VAR o di un VECM; restituisce
	  una matrice contenente la rappresentazione VMA fino
	  all'ordine specificato tramite il comando <lit>set
	  horizon</lit>. Per maggiori dettagli, si veda <guideref
	  targ="sec:var-estim"/>.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Restituisce 1 se gretl sta girando sotto Windows e 0
	  altrimenti. Questo accessore viene tipicamente usato per
	  scrivere script portabili da un sistema operativo ad un
	  altro.
	</para>
	<para>
	  Si veda anche il comando <cmdref targ="shell"/>.
	</para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  Se l'ultimo modello stimato è un'equazione singola,
	  restituisce la lista dei regressori. Se l'ultimo modello
	  stimato è un sistema di equazioni, restituisce la lista
	  <quote>globale</quote> delle variabili esogene e
	  predeterminate (nello stesso ordine con cui compaiono in
	  <fncref targ="$sysB"/>). Se l'ultimo modello è un VAR,
	  restituisce la lista dei regressori esogeni, laddove
	  presenti.
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Quando segue la stima di un VAR o di un VECM, restituisce
	  <math>X'X</math><sup>-1</sup>, dove <math>X</math> è la
	  matrice dei regressori usati in ciascuna delle
	  equazioni. Questo accessore è disponibile solo per un VECM
	  stimato con una restrizione imposta su &agr;, la matrice dei
	  <quote>loading</quote>.
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Restituisce i valori stimati dall'ultima regressione.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  Se l'ultimo modello stimato è un VAR, un VECM o un sistema
	  di equazioni simultanee, restituisce la lista delle
	  variabili endogene nel modello. Se l'ultimo modello stimato
	  è un'equazione singola, questo accessore fornisce una lista
	  di un solo elemento: la variabile dipendente. Nel caso
	  particolare di un modello biprobit la lista contiene due
	  elementi.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Valore assoluto.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Arcocoseno di <argname>x</argname>, ossia il numero il cui
	  coseno è <argname>x</argname>.  Il risultato è in radianti;
	  l'argomento deve essere compreso fra &minus;1 e 1.
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcoseno iperbolico di <argname>x</argname>
	  (soluzione positiva). <argname>x</argname> deve essere maggiore di 1;
	  in caso contrario, viene restituito NA.
	  <seelist>
	    <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="series-or-list">byvar</fnarg>
	<fnarg type="string">funcname</fnarg>	
      </fnargs>
      <description>
	<para>
	  Nella versione più semplice, in cui sia <argname>x</argname>
	  sia <argname>byvar</argname> sono serie individuali, questa
	  funzione restituisce una matrice con tre colonne: la prima
	  contiene i valori distinti di <argname>byvar</argname>,
	  ordinati in senso crescente; la seconda contiene il numero
	  delle osservazioni in cui <argname>byvar</argname> assume
	  ciascuno di questi valori; la terza, infine, contiene i
	  valori della statistica specificata da
	  <argname>funcname</argname>, calcolata sulla serie
	  <argname>x</argname> usando solo quelle osservazioni per cui
	  <argname>byvar</argname> assume il valore specificato nella
	  prima colonna.
	</para>
	<para>
	  Più in generale, se <argname>byvar</argname> è una lista di
	  <math>n</math> elementi, allora le prime <math>n</math>
	  colonne da sinistra contengono le combinazioni dei valori
	  distinti di ciascuna delle <math>n</math> serie, mentre la
	  colonna immediatamente successiva contiene il numero delle
	  osservazioni in cui ciascuna combinazione ricorre. Se
	  <argname>x</argname> è una lista con <math>m</math>
	  elementi, allora le <math>m</math> colonne più a destra
	  contengono i valori della statistica specificata da
	  <argname>funcname</argname> per ciascuna delle variabili
	  <argname>x</argname>, calcolati sul sottocampione
	  individuato dalle prime colonne.
	</para>
	<para>
	  I seguenti valori di <argname>funcname</argname> sono
	  supportati <quote>in modo nativo</quote>: <fncref
	  targ="sum"/>, <fncref targ="sumall"/>, <fncref
	  targ="mean"/>, <fncref targ="sd"/>, <fncref targ="var"/>,
	  <fncref targ="sst"/>, <fncref targ="skewness"/>, <fncref
	  targ="kurtosis"/>, <fncref targ="min"/>, <fncref
	  targ="max"/>, <fncref targ="median"/>, <fncref targ="nobs"/>
	  e <fncref targ="gini"/>. Ciascuna di queste funzioni accetta
	  come argomento una serie e restituisce uno scalare, e in tal
	  senso può dirsi che <quote>aggrega</quote> la serie in un
	  qualche modo. È anche possibile inserire il nome di
	  una funzione definita dall'utente come aggregatore; come le
	  funzioni supportate in modo nativo, tale funzione deve
	  accettare come argomento una singola serie e ritornare uno
	  scalare.
	</para>
	<para>
	  Si noti che, benché il conteggio dei casi sia fornito
	  automaticamente, la funzione <lit>nobs</lit> non è
	  ridondante come aggregatore, poiché fornisce il numero di
	  osservazioni valide (non-missing) in <argname>x</argname>
	  per ciascuna combinazione <argname>byvar</argname>.
	</para>
	<para>
	  Come semplice esempio, si supponga che <lit>region</lit> sia
	  la codifica di regioni geografiche con valori interi da 1 ad
	  <math>n</math> e <lit>income</lit> il reddito
	  familiare. Allora quanto segue produrrà una matrice <by
	  r="n" c="3"/> contenente: nella prima colonna, i codici
	  delle regioni; nella seconda, il numero delle osservazioni
	  in ciascuna regione; nella terza, il reddito familiare medio
	  per regione:
	</para>
	<code>
	  matrix m = aggregate(income, region, mean)
	</code>
	<para>
	  Per un esempio che utilizza liste, si ipotizzi che
	  <lit>gender</lit> sia una variabile dummy maschio/femmina e
	  <lit>race</lit> una variabile categoriale con tre possibili
	  valori. Allora quanto segue genererà una matrice con 6 righe
	  e 5 colonne: le prime due colonne conterranno le
	  combinazioni possibili gender/race, mentre le ultime due la
	  deviazione standard campionaria di <lit>income</lit> e
	  <lit>age</lit>:
	</para>
	<code>
	  list BY = gender race
	  list X = income age
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  Si noti che, nel caso in cui <argname>byvar</argname> sia
	  una lista, alcune combinazioni dei valori di
	  <argname>byvar</argname> potrebbero non essere presenti nei
	  dati (il numero di osservazioni sarà zero). In tal caso, il
	  valore delle statistiche per <argname>x</argname> viene
	  registrato come <lit>NaN</lit> (Not a Number). Nel caso si
	  voglia non considerare tali casi, si può utilizzare la
	  funzione <fncref targ="selifr"/> per selezionare solo le
	  righe associate ad un numero di osservazioni diverso da
	  zero. Nel caso in cui <argname>byvar</argname> contenga
	  <math>n</math> elementi, la colonna da testare sarà quella
	  immediatamente a destra delle prime <math>n</math> colonne
	  partendo da sinistra. Possiamo quindi eseguire il seguente
	  codice:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Per <argname>s</argname>, il nome di un parametro in una
	  funzione definita dall'utente, restituisce il nome del
	  corrispondente argomento, o una stringa vuota se l'argomento
	  era anonimo.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcoseno di <argname>x</argname>, cioè, il
	  valore il cui seno è <argname>x</argname>.  Il risultato è
	  in radianti; l'input deve essere tra &minus;1 e 1, estremi
	  compresi.
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcoseno iperbolico di <argname>x</argname>.
	  <seelist>
	    <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione arcotangente.
	  <seelist>
	    <fncref targ="cos"/>
	    <fncref targ="sin"/>
	    <fncref targ="tan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcotangente iperbolica di <argname>x</argname>.
	  <seelist>
	    <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Analoga alla funzione della libreria C con lo stesso
	  nome. Restituisce il risultato della conversione della
	  stringa <argname>s</argname> (o della porzione di essa che
	  segue qualsiasi spazio iniziale) in un numero a virgola
	  mobile. In modo diverso dalla funzione <lit>atof</lit> in C,
	  comunque, per questioni di portabilità, si assume sempre che
	  il carattere decimale sia
	  <quote><lit>.</lit></quote>. Qualsiasi carattere che segue
	  la porzione di <argname>s</argname> convertita in numero
	  decimale a virgola mobile sotto questa assunzione è
	  ignorata.
	</para>
	<para>
	  Se nessuna porzione di <argname>s</argname> (che segue
	  qualsiasi spazio iniziale) risulta convertibile sotto le
	  suddette assunzioni, la funzione restituisce <lit>NA</lit>.
	</para>
	<code>
	  # examples
	  x = atof("1.234") # gives x = 1.234 
	  x = atof("1,234") # gives x = 1
	  x = atof("1.2y")  # gives x = 1.2
	  x = atof("y")     # gives x = NA
	  x = atof(",234")  # gives x = NA
	</code>	
	<para>
	  Si veda anche <fncref targ="sscanf"/> per modalità più flessibili di conversione da stringa a numero.
	</para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">type</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola una delle varianti della funzione di Bessel di
	  ordine <argname>v</argname> con argomento
	  <argname>x</argname>. Il valore restituito è dello stesso
	  tipo dell'argomento <argname>x</argname>. La variante
	  specifica della funzione è selezionata sulla base del primo
	  argomento, che deve essere <lit>J</lit>, <lit>Y</lit>,
	  <lit>I</lit>, o <lit>K</lit>.  Una buona discussione delle
	  funzioni di Bessel si trova su Wikipedia; qui forniamo una
	  breve sintesi.
	</para>
	<para>
	  caso <lit>J</lit>: Funzione di Bessel del primo
	  tipo. Ricorda un'onda sinusoidale smorzata. Definita per
	  <argname>v</argname> e <argname>x</argname> numeri
	  reali. Tuttavia, se <argname>x</argname> è negativo,
	  <argname>v</argname> deve essere un numero intero.
	</para>
	<para>
	  caso <lit>Y</lit>: Funzione di Bessel del secondo
	  tipo. Definita per <argname>v</argname> e
	  <argname>x</argname> reali, ma ha una singolarità a
	  <argname>x</argname> = 0.
	</para>
	<para>
	  caso <lit>I</lit>: Funzione di Bessel modificata del primo
	  tipo. Una funzione con crescita esponenziale. Gli argomenti
	  accettati sono gli stessi del caso <lit>J</lit>.
	</para>
	<para>
	  caso <lit>K</lit>: Funzione di Bessel modificata del secondo
	  tipo. Una funzione con decadimento esponenziale. Diverge a
	  <argname>x</argname> = 0 e non è definita per valori
	  negativi di <argname>x</argname>. È simmetrica
	  attorno a <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Massimizzazione numerica con il metodo di Broyden, Fletcher,
	  Goldfarb e Shanno. Il vettore <argname>b</argname> deve
	  contenere i valori iniziali di un insieme di parametri,
	  mentre la stringa <argname>s</argname> deve specificare la
	  chiamata a una funzione che calcola il criterio (scalare) da
	  massimizzare, dati i valori correnti dai parametri e
	  qualsiasi altro dato rilevante. Se l'oggetto è di fatto una
	  minimizzazione, è sufficiente ridefinire la funzione
	  chiamata in modo che restituisca il criterio cambiato di
	  segno. In caso di successo, <lit>BFGSmax</lit> restituisce
	  il valore massimizzato del criterio, e <argname>b</argname>
	  contiene i valori dei parametri associati al valore del
	  criterio restituito.
	</para>
	<para>
	  Per maggiori dettagli ed esempi, si veda il capitolo sulle
	  funzioni speciali in <lit>genr</lit> in <guideref
	  targ="sec:genr-numerical"/>.
	  <seelist>
	    <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bkfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Estrae la componente ciclica della serie
	  <argname>y</argname> attraverso il filtro passa banda di
	  Baxter&ndash;King, filtro simmetrico two-sided. I parametri
	  opzionali <argname>f1</argname> e <argname>f2</argname>
	  rappresentano, rispettivamente, i limiti inferiore e
	  superiore delle frequenze da estrarre, mentre
	  <argname>k</argname> è l'ordine dell'approssimazione da
	  usare. Se questi argomenti non sono forniti, vengono usati i
	  seguenti valori di default: <argname>f1</argname> = 8,
	  <argname>f1</argname> = 32, <argname>k</argname> = 8.
	  <seelist>
	    <fncref targ="bwfilt"/>
	    <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="boxcox" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce la trasformazione Box&ndash;Cox con parametro
	  <argname>d</argname> della serie positiva
	  <argname>y</argname>.
	</para>	  
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  La serie trasformata è (<math>y</math><sup>d</sup> - 1)/<math>d</math> per <math>d</math> diverso da zero, o log(<math>y</math>) per <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bwfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il risultato dell'applicazione di un filtro
	  passa-basso Butterworth di ordine <argname>n</argname> e
	  frequenza di taglio <argname>omega</argname> alla serie
	  <argname>y</argname>. La frequenza di taglio è espressa in
	  gradi e deve essere maggiore di 0 e minore di 180. Frequenze
	  di taglio minori restringono il passa banda alle frequenze
	  minori e quindi producono trend più smussati. Valori
	  maggiori di <argname>n</argname> producono un taglio più
	  netto, al costo di una possibile instabilità numerica.
	</para>
	<para>
	  L'esame del periodogramma della serie target è un utile fase
	  preliminare da compiere quando si vuole applicare una tale
	  funzione. Si veda <guideref targ="chap-filters"/> per i
	  dettagli.
	  <seelist>
	    <fncref targ="bkfilt"/>
	    <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Centra le colonne della matrice <argname>X</argname> attorno
	  alla loro media.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Calcola funzioni di ripartizione. Restituisce <equation
	  status="inline" ascii="P(X &lt; x)" tex="$P(X \le x)$"/>,
	  dove la distribuzione di <math>X</math> è determinata dal
	  carattere <argname>c</argname>. Tra gli argomenti
	  <argname>c</argname> e <argname>x</argname>, possono essere
	  richiesti parametri aggiuntivi a seconda della
	  distribuzione, come specificato qui di seguito.
	</para>
	<ilist context="notex">
	  <li>
	    <para>
	      Normale standard (c = z, n, or N): no argomenti extra
	    </para>
	  </li>
	  <li>
	    <para>
	      Normale bivariata (D): coefficiente di correlazione
	    </para>
	  </li>
	  <li>
	    <para>
	      t di Student (t): gradi di libertà 
	    </para>
	  </li>
	  <li>
	    <para>
	      Chi quadro (c, x, or X): gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      F di Snedecor (f or F): gradi di libertà (num.); gradi
	      di libertà (den.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Gamma (g or G): forma; scala
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Binomiale (b or B): probabilità; numero di prove
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Poisson (p or P): Media
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Weibull (w or W): forma; scala
	    </para>
	  </li>	
	  <li>
	    <para>
	      Generalized Error (E): forma
	    </para>
	  </li>	
	</ilist>
	<para context="tex">
	  \begin{center} 
	  \begin{tabular}{llll} 
	  \textit{Distribution} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt] 
	  Standard normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp; 
	  -- &amp; -- \\ 
	  Bivariate normal &amp; \texttt{D} &amp; 
	  $\rho$ &amp; -- \\ 
	  Student's $t$ (central) &amp; \texttt{t} &amp;  
	  gradi di libertà &amp; -- \\ 
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; 
	  gradi di libertà &amp; -- \\ 
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp;
	  df (num.) &amp; df (den.) \\ 
	  Gamma &amp; \texttt{g} or \texttt{G} &amp;
	  forma &amp; scala \\ 
	  Binomial &amp; \texttt{b} or \texttt{B} &amp;
	  probabilit\`a &amp; prove \\ 
	  Poisson &amp; \texttt{p} or \texttt{P} &amp; 
	  media &amp; -- 
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  La maggior parte delle distribuzioni usano degli alias per
	  rendere più agevole la memorizzazione dei codici.  Il caso
	  della normale bivariata è particolare: la sintassi è <lit>x
	  = cdf(D, rho, z1, z2)</lit> dove <lit>rho</lit> è la
	  correlazione fra <lit>z1</lit> e <lit>z2</lit>.
	</para>
	<para context="tex">
	  La parametrizzazione che \app{gretl} adotta per la
	  v.c. Gamma implica che la funzione di densità possa essere
	  scritta come \[ f(x; k, \theta) = \frac{x^{k-1}}{\theta^k}
	  \frac{e^{-x/\theta}}{\Gamma(k)} \] dove $k>0$ è il parametro
	  di forma e $\theta>0$ il parametro di scala.
	</para>
	<para>
	  <seelist>
	    <fncref targ="critical"/>
	    <fncref targ="invcdf"/>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Divisione complessa. I due argomenti devono avere lo stesso
	  numero di righe, <math>n</math>, e una o due colonne.  La
	  prima colonna contiene la parte reale e l'eventuale seconda
	  quella immaginaria.  Restituisce una matrice <by r="n" c="2"/>
	  oppure, se la parte immaginaria del risultato è nulla, un
	  vettore a <math>n</math> elementi.
	  <seelist>
	    <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Parte intera superiore: restituisce il più piccolo numero
	  intero maggiore o uguale a <argname>x</argname>.
	  <seelist> 
	    <fncref targ="floor"/>
	    <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Esegue la decomposizione di Cholesky della matrice
	  <argname>A</argname>, assunta simmetrica e
	  definita positiva. Il risultato è una matrice triangolare
	  inferiore <math>K</math> che soddisfa <equation
	  status="inline" ascii="A = KK'" tex="$A = KK'$"/>. La
	  funzione restituisce un errore se <argname>A</argname> non è
	  simmetrica o definita positiva.
	</para>
      </description>
    </function>

    <function name="chowlin" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">xfac</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Espande i dati in ingresso, <argname>Y</argname>, a una frequenza
	  maggiore, usando il metodo di interpolazione di <cite
	  key="chowlin71">Chow e Lin (1971)</cite>. Si assume che le
	  colonne di <argname>Y</argname> rappresentino serie di dati;
	  la matrice restituita ha tante colonne quante sono le
	  colonne di <argname>Y</argname> e tante righe quante sono
	  quelle di <argname>Y</argname> moltiplicate per
	  <argname>xfac</argname>.
	</para>
	<para>
	  Il secondo argomento rappresenta il fattore di espansione:
	  deve essere 3 per espandere la frequenza della serie da
	  trimestrale a mensile, o 4 per espansioni da annuale a
	  trimestrale. Questi sono gli unici fattori di espansione
	  supportati. Il terzo argomento opzionale può essere
	  utilizzato per generare una matrice di regressori con una
	  frequenza (obiettivo) maggiore.
	</para>
	<para>
	  I regressori utilizzati di default sono una costante e un
	  trend quadratico. Se viene fornita <argname>X</argname>, le
	  sue colonne sono utilizzate come regressori addizionali; è
	  un errore se il numero di righe in <argname>X</argname> non
	  è uguale a <argname>xfac</argname> per il numero di righe in
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmult" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Moltiplicazione complessa. I due argomenti devono avere lo
	  stesso numero di righe, <math>n</math>, e una o due colonne.
	  La prima colonna contiene la parte reale e l'eventuale
	  seconda quella immaginaria.  Restituisce una matrice <by r="n"
	  c="2"/> oppure, se la parte immaginaria del risultato è
	  nulla, un vettore a <math>n</math> elementi.
	  <seelist>
	    <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la funzione di distribuzione cumulativa di una normale standard. 
	  <seelist>
	    <fncref targ="dnorm"/>
	    <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="colname" section="strings" output="string">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il nome della colonna <argname>col</argname>
	  della matrice <argname>M</argname>. Se <argname>M</argname>
	  non ha nomi associati alle colonne, la funzione restituisce
	  una stringa vuota; se <argname>col</argname> è fuori dai
	  limiti per la matrice data, viene restituito un messaggio di
	  errore. Si veda anche <fncref targ="colnames"/>.
	</para>
      </description>
    </function>

    <function name="colnames" section="matbuild" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="list-or-string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Attribuisce dei nomi alle colonne della matrice
	  <argname>M</argname>. Se <argname>s</argname> è una lista, i
	  nomi sono copiati da quelli delle variabili; la lista deve
	  avere tanti elementi quante sono le colonne di
	  <argname>M</argname>. Se <argname>s</argname> è una stringa,
	  deve contenere un numero appropriato di sub-stringhe
	  separate da spazi.  Restituisce 0 se la funzione è andata a
	  buon fine, non-zero altrimenti. Si veda anche <fncref
	  targ="rownames"/>.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  matrix M = {1,2;2,1;4,1}
	  colnames(M, "Col1 Col2")
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Il numero di colonne di <argname>X</argname>. 
	  <seelist> 
	    <fncref targ="mshape"/>
	    <fncref targ="rows"/>
	    <fncref targ="unvech"/>
	    <fncref targ="vec"/> 
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola il coefficiente di correlazione fra
	  <argname>y1</argname> e <argname>y2</argname>.
	  <seelist> 
	    <fncref targ="cov"/>
	    <fncref targ="mcov"/>
	    <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corrgm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se sono forniti solo i primi due argomenti, calcola il
	  correlogramma di <argname>x</argname> con ritardi da 1 a
	  <argname>p</argname>. Il valore restituito è una matrice con
	  <argname>p</argname> righe e 2<math>k</math> colonne, dove
	  <math>k</math> è il numero di elementi di
	  <argname>x</argname>, ovvero: 1 se <argname>x</argname> è
	  una serie; il numero di colonne di <argname>x</argname> se
	  <argname>x</argname> è una matrice; il numero degli elementi
	  di <argname>x</argname> se <argname>x</argname> è una
	  lista. Le prime <math>k</math> colonne della matrice
	  restituita contengono le autocorrelazioni, mentre le
	  restanti colonne le rispettive autocorrelazioni parziali.
	</para>
	<para>
	  Se è fornito un terzo argomento, questa funzione calcola il
	  correlogramma incrociato per ciascuno dei <math>k</math>
	  elementi di <argname>x</argname> e <argname>y</argname>,
	  dagli anticipi (<quote>lead</quote>) di ordine
	  <argname>p</argname> fino ai ritardi (<quote>lag</quote>) di
	  ordine <argname>p</argname>. La matrice restituita ha
	  2<math>p</math> + 1 righe e <math>k</math> colonne. Se
	  <argname>x</argname> è una serie o una lista e
	  <argname>y</argname> un vettore, il vettore deve avere tante
	  righe quante sono le osservazioni nell'intervallo del
	  campione corrente.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione coseno.
	  <seelist>
	    <fncref targ="sin"/>
	    <fncref targ="tan"/>
	    <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il coseno iperbolico di <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="acosh"/>
	    <fncref targ="sinh"/>
	    <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la covarianza fra <argname>y1</argname> e
	  <argname>y2</argname>.
	  <seelist> 
	    <fncref targ="corr"/> 
	    <fncref targ="mcov"/>
	    <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Calcola i valori critici, ossia <math>x</math> tale che
	  <equation status="inline" ascii="P(X &gt; x) = p" tex="$P(X
	  &gt; x) = p$"/>, dove la distribuzione di <math>X</math> è
	  determinata dal carattere <argname>c</argname>. Tra gli
	  argomenti <argname>c</argname> e <argname>x</argname>,
	  possono essere richiesti parametri aggiuntivi a seconda
	  della distribuzione, come specificato qui di seguito.
	</para>
	<ilist context="notex">
	  <li>
	    <para>
	      Normale standard (c = z, n, or N): no argomenti extra
	    </para>
	  </li>
	  <li>
	    <para>
	      t di Student (t): gradi di libertà 
	    </para>
	  </li>
	  <li>
	    <para>
	      Chi quadro (c, x, or X): gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      F di Snedecor (f or F): gradi di libertà (num.); gradi
	      di libertà (den.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Binomiale (b or B): probabilità; numero di prove
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Poisson (p or P): Media
	    </para>
	  </li>	  
	</ilist>
	<para>
	  <seelist>
	    <fncref targ="cdf"/>
	    <fncref targ="invcdf"/>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola la somma cumulata di <argname>x</argname>. Se
	  <argname>x</argname> è una serie, restituisce una serie
	  <math>y</math> in cui ciascuno degli elementi è la somma dei
	  valori di <argname>x</argname> fino a quel punto; il primo
	  termine della somma è la prima osservazione non mancante
	  (non-missing) nel campione corrente. Se <argname>x</argname>
	  è una matrice, la somma cumulata viene calcolata per
	  ciascuna delle colonne.
	</para>
	<para context="tex">
	  Calcola la somma cumulata di <argname>x</argname>. Se
	  <math>x</math> è una serie, produce una serie $y_t =
	  \sum_{s=m}^t x_s$. Il punto iniziale della sommatoria,
	  <math>m</math>, è la prima osservazione non mancante
	  nel campione corrente. Se la funzione incontra
	  valori mancanti in <math>x</math>, i valori
	  successivi in <math>y</math> saranno mancanti. Quando
	  <argname>x</argname> è una matrice, gli elementi vengono
	  sommati per colonna.
	</para>
	<para>
	  <seelist>
	    <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="deseas" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="char">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Dipende da TRAMO/SEATS o X-12-ARIMA, che devono perciò
	  essere installati. Restituisce la serie <argname>x</argname>
	  destagionalizzata. La serie in ingresso <argname>x</argname>
	  deve essere una serie storica trimestrale o mensile. Per
	  usare X-12-ARIMA inserire <lit>X</lit> come secondo
	  argomento; per usare TRAMO inserire <lit>T</lit>. Se il
	  secondo argomento è omesso, è utilizzato X-12-ARIMA.
	</para>
	<para>
	  Se la serie in ingresso non possiede una componente
	  stagionale identificabile, la funzione fallisce. Si noti che
	  sia TRAMO/SEATS sia X-12-ARIMA hanno numerose opzioni;
	  <lit>deseas</lit> richiama i due programmi con tutte le
	  opzioni ai valori predefiniti. In entrambi i programmi i
	  fattori stagionali sono calcolati sulla base di un modello
	  ARIMA selezionato automaticamente. Una differenza tra i due
	  programmi, che a volte produce differenze sostanziali nei
	  risultati, è che per impostazione predefinita TRAMO compie
	  un aggiustamento preventivo per gli outlier, al contrario di
	  X-12-ARIMA che non lo fa.
	</para>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il determinante di <argname>A</argname>,
	  calcolato tramite la scomposizione LU.
	  <seelist> 
	    <fncref targ="ldet"/>
	    <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="diag" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la diagonale principale di <argname>X</argname> in
	  un vettore colonna. Nota: se <argname>X</argname> è una
	  matrice <by r="m" c="n"/>, il numero di elementi del vettore
	  risultato è min(<math>m</math>, <math>n</math>).
	  <seelist>
	    <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la somma diretta di <argname>A</argname> e
	  <argname>B</argname>, ossia una matrice che ha
	  <argname>A</argname> nell'angolo nord-ovest e
	  <argname>B</argname> in quello sud-est. Se
	  <argname>A</argname> e <argname>B</argname> sono entrambe
	  quadrate, la matrice risultato è diagonale a blocchi.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le differenze prime. Se <argname>y</argname> è una
	  serie, o una lista di serie, i valori iniziali restituiti
	  sono <lit>NA</lit>. Se <argname>y</argname> è una matrice,
	  le differenze prime sono calcolate per colonna e i valori
	  iniziali restituiti sono 0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="cum"/>
	    <fncref targ="ldiff"/>
	    <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Restituisce la funzione digamma (o Psi) di
	  <argname>x</argname>, cioè la derivata del logaritmo della
	  funzione Gamma.
	</para>
	<para context="tex">
	  Restituisce la funzione digamma (o Psi) di $x$, cioè
	  $\frac{\mathrm{d} \Gamma(x)}{\mathrm{d} x}$.
	</para>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la funzione di densità per una normale standard. 
	  <seelist>
	    <fncref targ="cnorm"/>
	    <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dsort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordina <argname>x</argname> in ordine discendente, saltando
	  le osservazioni con valori mancanti se <argname>x</argname> è
	  una serie. 
	  <seelist> 
	    <fncref targ="sort"/>
	    <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  L'argomento <argname>x</argname> deve essere una serie
	  discreta. Questa funzione crea un insieme di variabili dummy
	  (o binarie) che codificano i valori distinti della
	  serie. Per impostazione predefinita, il valore più piccolo
	  della serie originale è preso come categoria di riferimento
	  e, per tale valore, non viene restituita alcuna dummy.
	</para>
	<para>
	  Il secondo argomento, opzionale, rappresenta il valore di
	  <argname>x</argname> che deve essere assunto come categoria
	  di riferimento, e quindi da omettere. L'effetto che si
	  ottiene inserendo un solo argomento e tralasciando quello
	  opzionale è equivalente a <lit>dummify(x, min(x))</lit>. Al
	  fine di generare l'insieme completo delle dummy, non
	  omettendo alcuna categoria, è possibile utilizzare il
	  comando <lit>dummify(x, NA)</lit>.
	</para>
	<para> 
	  Le variabili generate sono nominate in modo automatico
	  secondo lo schema
	  <lit>D</lit><repl>varname</repl><lit>_</lit><repl>i</repl>,
	  dove <repl>varname</repl> è il nome della serie originale e
	  <repl>i</repl> un indice in cui il valore iniziale è 1
	  (<quote>1-based index</quote>). Il nome originale della
	  serie è troncato se necessario e può essere modificato in
	  caso di non unicità nell'insieme dei nomi così generato.
	</para>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola gli autovalori, e, se richiesto, gli autovettori
	  destri della matrice <by r="n" c="n"/>
	  <argname>A</argname>. Se tutti gli autovalori sono reali, la
	  funzione restituisce una matrice <by r="n" c="1"/>; in caso
	  contrario, il risultato è una matrice <by r="n" c="2"/>,
	  dove la prima colonna contiene le parti reali degli
	  autovalori, mentre la seconda le corrispondenti parti
	  immaginarie.
	</para>
	<para>
	  Il secondo argomento può essere il nome di una matrice
	  esistente preceduto da <lit>&amp;</lit> (per indicare
	  l'indirizzo della matrice in questione), e in tal caso gli
	  autovettori destri vengono scritti in questa matrice, oppure
	  la parola chiave <lit>null</lit>, e in tal caso gli
	  autovettori non vengono calcolati.
	</para>
	<para>
	  Quando il secondo argomento è diverso da <lit>null</lit>, la
	  matrice stessa è sovrascritta (non è necessario abbia la
	  dimensione giusta per ricevere il risultato). La matrice
	  risultante è organizzata come segue:
	</para>
	<ilist>
	  <li>
	    <para>
	      Se l'<math>i</math>-esimo autovalore è reale,
	      l'<math>i</math>-esima colonna di <math>U</math>
	      conterrà l'autovettore corrispondente;
	    </para>
	  </li>
	  <li>
	    <para>
	      Se l'<math>i</math>-esimo autovalore è complesso,
	      l'<math>i</math>-esima colonna di <argname>U</argname>
	      conterrà la parte reale dell'autovettore corrispondente
	      e la colonna successiva la parte
	      immaginaria. L'autovettore associato all'autovalore
	      coniugato è il coniugato dell'autovettore.
	    </para>
	  </li>
	</ilist>
	<para>
	  In altre parole, gli autovettori compaiono nello stesso
	  ordine degli autovalori, ma gli autovettori reali occupano
	  una colonna, mentre quelli complessi ne occupano due (la
	  parte reale è la prima); il numero totale di colonne è
	  comunque <math>n</math>, perché l'autovettore coniugato è
	  tralasciato.
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigensym"/>
	    <fncref targ="qrdecomp"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola gli autovalori, e, laddove richiesto, gli
	  autovettori destri, della matrice simmetrica <by r="n"
	  c="n"/> <argname>A</argname>; il secondo argomento deve
	  essere o il nome di una matrice esistente, preceduto da
	  <lit>&amp;</lit> (che indica l'indirizzo della matrice in
	  questione), e in tal caso gli autovettori vengono salvati in
	  tale matrice; o la parola chiave <lit>null</lit>, e in tal
	  caso gli autovettori non vengono calcolati.
	</para>
	<para>
	 Se il secondo argomento non è <lit>null</lit>, la matrice
	 specificata è sovrascritta inserendo gli autovettori destri
	 calcolati (non è necessario che la matrice sia già della
	 dimensione corretta per ricevere il risultato).
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigengen"/>
	    <fncref targ="qrdecomp"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Risolve il problema degli autovalori generalizzati
	  |<math>A</math> &minus; &lgr;<math>B</math>| = 0, dove sia
	  <math>A</math> sia <math>B</math> sono matrici simmetriche e
	  <math>B</math> è definita positiva. Gli autovalori vengono
	  restituiti direttamente, ordinati in senso crescente. Il
	  terzo argomento opzionale deve essere il nome di una matrice
	  esistente preceduto da <lit>&amp;</lit>. In tal caso, la
	  funzione calcola anche gli autovettori generalizzati, che
	  vengono salvati nella suddetta matrice.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">anno</fnarg>
	<fnarg type="scalar-or-series">mese</fnarg>
	<fnarg type="scalar-or-series">giorno</fnarg>
      </fnargs>
      <description>
	<para>
	  Ha come argomenti l'anno, il mese e il giorno e restituisce
	  il numero di giorni nell'epoca corrente (che è uguale ad 1
	  per il 1 gennaio dell'anno 1 d.C.).
	</para>
      </description>
    </function>

    <function name="errmsg" section="strings" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Recupera il messaggio di errore di gretl associato a
	  <argname>errno</argname>. Si veda anche <fncref
	  targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Esponenziale. Si noti che, in caso di matrici, la funzione è
	  calcolata sui singoli elementi della matrice. Per il calcolo
	  dell'esponenziale di una matrice, si veda <fncref
	  targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-or-vec">f</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore colonna contenente diverse
	  statistiche utili per valutare la serie <argname>f</argname>
	  come previsione della serie <argname>y</argname> nel
	  campione corrente. Al posto delle due serie, la funzione
	  accetta come argomenti anche due vettori della stessa
	  lunghezza.
	</para>
	<para>
	  La struttura del vettore restituito è la seguente:
	</para>
	<code>
	  1  Errore Medio (Mean Error, ME)
	  2  Errore Quadratico Medio (Mean Squared Error, MSE)
	  3  Errore Medio Assoluto (Mean Absolute Error, MAE)
	  4  Errore Medio Percentuale (Mean Percentage Error, MPE)
	  5  Errore Medio Assoluto Percentuale (Mean Absolute Percentage Error, MAPE)
	  6  Coefficiente U di Theil (Theil's U) 
	  7  Proporzione della distorsione (Bias proportion, UM)
	  8  Proporzione della regressione (Regression proportion, UR)
	  9  Proporzione del disturbo (Disturbance proportion, UD)
	</code>
	<para>
	  Per maggiori dettagli sul calcolo di queste statistiche e
	  l'interpretazione dei valori del coefficiente
	  <math>U</math>, si veda <guideref targ="chap-forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
      </fnargs> 
      <description>
	<para>
          Calcola numericamente (tramite l'approssimazione per
          differenze-in-avanti) lo Jacobiano associato al vettore
          <argname>b</argname> e la trasformazione definita dalle
          funzioni nella stringa <argname>s</argname>. Per maggiori
          dettagli ed esempi si veda il capitolo sulle funzioni
          speciali in <lit>genr</lit> in <guideref
          targ="sec:genr-numerical"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="BFGSmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Trasformata di Fourier. Se la matrice di input
	  <argname>X</argname> ha <math>n</math> colonne, l'output
	  avrà 2<math>n</math> colonne, dove le parti reali sono
	  salvate nelle colonne dispari e le parti complesse nelle
	  colonne pari.
	</para>
	<para>
	  Se fosse necessario calcolare la trasformata di Fourier su
	  diversi vettori con lo stesso numero di elementi, è
	  numericamente più efficiente raggrupparli in una matrice
	  piuttosto che invocare <lit>fft</lit> separatamente per
	  ciascuno di essi.
	  <seelist>
	    <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Trasformata di Fourier inversa. Si assume che
	  <argname>X</argname> contiene <math>n</math> vettori colonna
	  complessi, con la parte reale nelle colonne pari e la parte
	  immaginaria nelle colonne dispari: il numero totale di
	  colonne sarà quindi pari a 2<math>n</math>. Il risultato è
	  una matrice con <math>n</math> colonne.
	</para>
	<para>
	  Se si desidera calcolare la trasformata di Fourier inversa
	  su diversi vettori con lo stesso numero di elementi, è
	  numericamente più efficiente raggrupparli in una matrice
	  piuttosto che invocare <lit>ffti</lit> separatamente per
	  ciascuno di essi.
	  <seelist>
	    <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="filters" output="series">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
      </fnargs>
      <description>
	<para>
	Applica un filtro di tipo ARMA all'argomento
	<argname>x</argname>. In formule, la trasformazione è
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=i}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> = 
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub> <math>y</math><sub>t-p</sub>
	</para>
	<para>
	  Se l'argomento <argname>x</argname> è una serie, il
	  risultato sarà esso stesso una serie. Se invece
	  <argname>x</argname> è una matrice con <math>T</math> righe
	  e <math>k</math> colonne, il risultato sarà una matrice
	  delle stesse dimensioni, in cui il filtraggio vien fatto
	  colonna per colonna.
	</para>
	<para>
	  I due argomenti <argname>a</argname> e <argname>b</argname>
	  sono opzionali. Possono essere scalari, vettori o la parola
	  <lit>null</lit>.
	</para>
	<para>
	  Se <argname>a</argname> è uno scalare, viene usato come
	  <math>a</math><sub>0</sub> e implica <math>q=0</math>; se è
	  un vettore di <math>q+1</math> elementi, contiene i
	  coefficienti da <math>a</math><sub>0</sub> ad
	  <math>a</math><sub>q</sub>. Se <argname>a</argname> è
	  <lit>null</lit> oppure omesso, è equivalente ad
	  <math>a</math><sub>0</sub><math>=1</math> e
	  <math>q=0</math>.
	</para>
	<para>
	  Se <argname>b</argname> è uno scalare, viene usato come
	  <math>b</math><sub>1</sub> ed implica <math>p=1</math>; se è
	  un vettore di <math>p</math> elementi, essi sono
	  interpretati come i coefficienti da
	  <math>b</math><sub>1</sub> a <math>b</math><sub>p</sub>. Se
	  <argname>b</argname> è <lit>null</lit> oppure omesso, è
	  equivalente a <math>B(L)=1</math>.
	</para>
	<para>
	  L'argomento scalare opzionale <argname>y0</argname>
	  rappresenta i valori di <math>y</math> antecedenti
	  all'inizio del campione (usato solo se <math>p>0</math>). Se
	  omesso, si intende 0.  Valori di <argname>x</argname>
	  antecedenti all'inizio del campione sono sempre considerati
	  0.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="bkfilt"/>
	    <fncref targ="bwfilt"/>
	    <fncref targ="fracdiff"/>
	    <fncref targ="hpfilt"/>
	    <fncref targ="movavg"/>
	    <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produce
	</para>
	<code>
                   index            y   
           			      
          1            1     -0.40000   
          2            2      1.36000   
          3            3      0.27600   
          4            4      1.75160   
          5            5      0.92356   

          x (5 x 2)
           
            1   1 
            2   0 
            3   0 
            4   0 
            5   0 
           
          w (5 x 2)
           
              -0.40000     -0.40000 
                1.3600      0.36000 
               0.27600     -0.32400 
                1.7516      0.29160 
               0.92356     -0.26244 
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il primo valore non-mancante della serie
	  <argname>y</argname>. Si noti che se si sta operando su un
	  sottocampione ristretto, il valore ottenuto può essere più
	  piccolo della variabile dollaro <fncref targ="$t1"/>.
	  <seelist> 
	    <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">rawname</fnarg>
      </fnargs>
      <description>
	<para>
	  Destinato all'uso in relazione al comando <cmdref
	  targ="join"/>.  Restituisce il risultato della conversione
	  di <argname>rawname</argname> in un identificatore gretl
	  valido, che deve inizione con un carattere alfabetico,
	  contenere esclusivamente lettere (ASCII), numeri e trattino
	  basso, e non deve eccedere i 31 caratteri. Le regole
	  utilizzate per la conversione sono:
	</para>
	<para>
	  1. Eliminare qualsiasi carattere iniziale che non sia un
	  carattere alfabetico.
	</para>
	<para>
	  2. Fino al limite dei 31 caratteri o al completamento
	  dell'input: trascrivere i caratteri <quote>legali</quote>;
	  saltare i caratteri <quote>illegali</quote> esclusi gli
	  spazi; e sostituire uno o più spazi consecutivi con un
	  trattino basso, a meno che il precedente carattere
	  trascritto sia un trattino, nel qual caso lo spazio è
	  saltato.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce l'intero minore o uguale di
	  <argname>x</argname>. Nota: <fncref targ="int"/> e
	  <lit>floor</lit> differiscono nel loro effetto su argomenti
	  negativi: <lit>int(-3.5)</lit> restituisce &minus;3, mentre
	  <lit>floor(-3.5)</lit> produce &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Restituisce la differenza frazionale di ordine
	  <argname>d</argname> per la serie <argname>y</argname>.
	</para>	  
	<para context="tex">
	    \[
	    \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
	    \]
	  where
	    \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Si noti che in teoria la differenziazione frazionale
	  corrisponde ad un filtro infinitamente lungo. In pratica, i
	  valori di <math>y</math><sub>t</sub> precedenti al campione
	  estratto sono posti pari a zero.
	</para>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce la funzione gamma di <argname>x</argname>. 
	</para>
      </description>
    </function>

    <function name="getenv" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Se è definita una variabile di ambiente di nome 
	  <argname>s</argname>, questa funzione restituisce una stringa contenente il valore di quella variabile, 
          altrimenti restituisce una stringa vuota.
	  Si veda anche <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">source</fnarg>
	<fnarg type="string">target</fnarg>
      </fnargs>    
      <description>
	<para>
	  Questa funzione è usata per leggere righe successiva da
	  <argname>source</argname>, che dovrebbe essere una variabile
	  stringa. Ad ogni chiamata una linea della fonte è scritta in
	  <argname>target</argname> (anche essa una variabile
	  stringa), privata del carattere che produce una nuova
	  linea. Il risultato è 1 se non c'è ancora qualcosa da
	  leggere (incluse linee vuote), 0 se la lettura dalla fonte è
	  stata completata.
	</para>
	<para>
	  Questo è un esempio in cui il contenuto di un file di testo è riportato
	  su più righe:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, line)
	    printf "line %d = '%s'\n", i++, line
          endloop
	</code>
	<para>
	  In questo esempio possiamo essere sicuri che la fonte è
	  stata esaurita quando termina il ciclo. Se la fonte non può
	  essere completata le chiamate di <lit>getline</lit>
	  dovrebbero essere seguite da una chiamata di <quote>clean
	  up</quote>, in cui <argname>target</argname> è sostituito da
	  <lit>null</lit> (o omesso) come segue
	</para>
	<code>
	  getline(s, line)
	  getline(s, null)
	</code>
	<para>
	  Si noti che, anche se la posizione di lettura avanza ad ogni chiamata di 
	  <lit>getline</lit>, questa funzione non modifica <argname>source</argname> 
	  ma solo <argname>target</argname>.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola l'approssimazione basata sull'algoritmo GHK (Geweke,
	  Hajivassiliou, Keane) per la funzione di ripartizione della
	  normale multivariata; si veda <cite key="geweke91">Geweke
	  (1991)</cite>. Il valore prodotto è un vettore <by r="n"
	  c="1"/> di probabilità.
	</para>
	<para>
	  L'argomento <argname>C</argname> (<by r="m" c="m"/>) deve
	  contenere la smposizione di Cholesky (triangolare inferiore)
	  della matrice di varianza e covarianza delle <math>m</math>
	  variabili normali.  Gli argomenti <argname>A</argname> e
	  <argname>B</argname> dovrebbero essere entrambi <by r="n"
	  c="m"/>, fornendo rispettivamente il limite inferiore e
	  superiore da applicare alle variabili per ciascuna delle
	  <math>n</math> osservazioni. Nel caso in cui le variabili
	  siano illimitate, questo dovrebbe essere indicato
	  utilizzando la costante <fncref targ="$huge"/> o il suo
	  opposto.
	</para>
	<para>
	  La matrice <argname>U</argname> deve essere di dimensione
	  <by r="m" c="r"/>, dove <math>r</math> è il numero di
	  estrazioni pseudo-casuali dalla distribuzione uniforme;
	  funzioni idonee alla creazione di <argname>U</argname> sono
	  <fncref targ="muniform"/> e <fncref targ="halton"/>.
	</para>
	<para>
	  Nel seguente esempio, le variabili <argname>P</argname> e
	  <argname>Q</argname> dovrebbero essere numericamente molto
	  simili l'una all'altra, essendo <argname>P</argname> la
	  "vera" probabilità e <argname>Q</argname> la sua
	  approssimazione basata sull'algoritmo GHK:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = muniform(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>    
      <description>
	<para>
	  Produce l'indice di Gini per la serie <argname>y</argname>.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce <math>A</math><sup>+</sup>, l'inversa di
	  Moore&ndash;Penrose o inversa generalizzata di
	  <argname>A</argname>, calcolata attraverso la scomposizione
	  per valori singolari.
	</para>
	<para context="tex">
	  Questa matrice gode delle seguenti proprietà
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+ 
	  \end{eqnarray*}
	</para>
	<para>
	  <seelist>
	    <fncref targ="inv"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="halton" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce una matrice <by r="m" c="r"/> contenente
	  <math>m</math> sequenze di Halton di lunghezza
	  <math>r</math>; <math>m</math> è limitata ad un massimo di
	  40. Le sequenze sono costruite utilizzando i primi
	  <math>m</math> numeri primi. Se non diversamente
	  specificato, i primi 10 elementi di ogni sequenza sono
	  scartati: questo valore può essere modificato specificando
	  l'argomento opzionale <argname>offset</argname> (che deve
	  essere definito come un numero intero non-negativo). Si veda
	  <cite key="halton64">Halton and Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Prodotto diretto orizzontale. I due argomenti devo avere lo stesso
	  numero di righe, <math>r</math>. Il risultato è una matrice
	  con <math>r</math> righe, in cui la riga
	  <math>i</math>-esima è il prodotto di Kronecker 
	  delle corrispondenti righe di <argname>X</argname> e
	  <argname>Y</argname>.
	</para>
	<para context="tex">
	  In altri termini, se $X$ è una matrice $r \times k$, $Y$ è una matrice
	  $r \times m$ e $Z$ è il risultato del
	  prodotto diretto orizzontale di $X$ per $Y$, allora $Z$ avrà
	  $r$ righe e $k\cdot m$ colonne. Inoltre, 
	  \[ 
	  Z_{in} = X_{ij} Y_{il} 
	  \]
	  dove $n = (j-1) m + l$.
	</para>
	<para>
	  Non siamo a conoscenza di un nome standard per questa
	  operazione nell'algebra delle matrici. "Prodotto diretto
	  orizzontale" ("Horizontal direct product") è il modo con cui
	  questa operazione viene chiamata nel linguaggio di
	  programmazione GAUSS.
	</para>
	<para>
	  Esempio: il codice
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produce la matrice seguente:
	</para>
	<code>
         0    1    0    2    0    3 
        -4    4   -5    5   -6    6 
	</code>
      </description>
    </function>

    <function name="hpfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la componente ciclica ottenuta dall'applicazione
	  del filtro di Hodrick&ndash;Prescott alla serie
	  <argname>y</argname>. Se il parametro di lisciamento
	  <argname>lambda</argname> non viene fornito questo viene
	  automaticamente calcolato sulla base dei dati a
	  disposizione: viene posto uguale 100 volte il quadrato della
	  periodicità dei dati (100 per dati annuali, 1600 per dati
	  trimestrali, e così via).
	  <seelist> 
	    <fncref targ="bkfilt"/>
	    <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="I" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce la matrice identità con <argname>n</argname> righe e
	  colonne.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore contenente gli indici riga dei massimi
	  delle colonne di <argname>X</argname>.
	  <seelist> 
	    <fncref targ="imaxr"/> 
	    <fncref targ="iminc"/>
	    <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce un vettore contenente gli indici colonna dei massimi
	  delle righe di <argname>X</argname>.
	  <seelist> 
	    <fncref targ="imaxc"/>
	    <fncref targ="iminr"/>
	    <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Calcola Prob(<math>u'Au</math> &lt; <math>x</math>) per una
	  forma quadratica di variabili normali standard,
	  <math>u</math>, utilizzando la procedura sviluppata da <cite
	  key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Calcola ${\rm Prob}(u'Au &lt; x)$ per una forma
	  quadratica di variabili normali standard, $u$, utilizzando la procedura
	  sviluppata da <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  Il primo argomento, <argname>M</argname>, può essere una
	  matrice quadrata o un vettore colonna, altrimenti viene
	  visualizzato un messaggio di errore.  Nel primo caso
	  <argname>M</argname> è considerato per specificare
	  <math>A</math>, nel secondo caso <argname>M</argname> viene
	  considerato come il vettore contenente gli autovalori di
	  <math>A</math>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce un vettore contenente gli indici riga dei minimi
	  delle colonne di <argname>X</argname>.
	  <seelist>
	    <fncref targ="imaxc"/>
	    <fncref targ="iminr"/>
	    <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce un vettore contenente gli indici colonna dei minimi
	  delle righe di <argname>X</argname>.
	  <seelist>
	    <fncref targ="imaxr"/> 
	    <fncref targ="iminc"/>
	    <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">chiave</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce 1 se il bundle <argname>b</argname> contiene un
	  elemento di nome <argname>chiave</argname> e 0 altrimenti.
	</para>	  
      </description>
    </function>   

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Restituisce la norma infinito di <argname>X</argname>, ovvero
	  il massimo valore, lungo le righe di <argname>X</argname>, 
	  della somma dei valori assoluti degli elementi nelle righe.
	</para>
	<para context="tex">
	  Restiuisce la norma-$\infty$ di una matrice $r\times c$ 
	  <argname>X</argname>: 
	    \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
	    <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce la posizione di <argname>y</argname> (a partire
	  dalla prima posizione) nella lista <argname>L</argname>, o 0
	  se <argname>y</argname> non è presente in
	  <argname>L</argname>. Il secondo argomento può essere il
	  nome di una serie o il suo identificativo numerico (intero).
	</para>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>  
      <description>
	<para>
	  Tronca la parte frazionaria di <argname>x</argname>. Si noti
	  che <lit>int</lit> e <fncref targ="floor"/> differiscono in
	  termini di risultato sui numeri negativi:
	  <lit>int(-3.5)</lit> restituisce &minus;3, mentre
	  <lit>floor(-3.5)</lit> produce &minus;4.
	  <seelist> 
	    <fncref targ="ceil"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce l'inversa di <argname>A</argname>. Se
	  <argname>A</argname> è singolare o non quadrata, viene
	  visualizzato un messaggio di errore e non viene prodotto
	  alcun risultato. Si noti che gretl controlla automaticamente
	  la struttura di <argname>A</argname> e utilizza la procedura
	  numerica più efficiente per il calcolo dell'inversa.
	</para>
	<para>
	  I tipi di matrice che sono controllati da gretl sono:
	  identità; diagonale; simmetrica e positiva definita;
	  simmetrica ma non positiva definita; triangolare.
	</para>
	<para>
	  <seelist>
	    <fncref targ="ginv"/>
	    <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione di distribuzione inversa. Restituisce il valore
	  <math>x</math> tale che <equation status="inline" ascii="P(X
	  &lt; x) = p" tex="$P(X \le x) = p$"/>, dove la distribuzione
	  di <math>X</math> è determinata dal carattere
	  <argname>c</argname>. Tra i due argomenti
	  <argname>c</argname> e <argname>p</argname>, zero o più
	  argomenti addizionali sono richiesti al fine di specificare
	  i parametri della distribuzione, secondo le regole che
	  seguono:
	</para>
	<ilist context="notex">
	  <li>
	    <para>
	      Normale standardizzata (c = z, n, or N): nessun argomento addizionale
	    </para>
	  </li>
	  <li>
	    <para>
	      T di Student (t): numero di gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      Chi-quadrato (c, x, o X): numero di gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      F di Snedecor (f o F): gradi di libertà (num.); gradi di libertà (den.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Binomiale (b o B): probabilità; numero di prove
	    </para>
	  </li>
	</ilist>
	<para context="tex">
	  \begin{center} 
	  \begin{tabular}{llll} 
	  \textit{Distribuzione} &amp; codice, $c$ &amp;
	  \textit{Arg.} 2 &amp; \textit{Arg.} 3 \\[4pt] 
	  Normale Standard &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
	  -- &amp; -- \\ 
	  $t$ di Student (centrata) &amp; \texttt{t} &amp; 
	  gradi di libertà &amp; -- \\ 
	  Chi-quadrato &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp; 
	  gradi di libertà &amp; -- \\
	  $F$ di Snedecor &amp; \texttt{f} o \texttt{F} &amp; 
	  gradi di libertà (num.) &amp; gradi di libertà (den.) \\ 
	  Binomiale &amp; \texttt{b} or \texttt{B} &amp; 
	  $p$ &amp; $n$ \\
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  <seelist>
	    <fncref targ="cdf"/>
	    <fncref targ="critical"/>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>  
      <description>
	<para>
	  Produce il reciproco del rapporto di Mills calcolato in
	  <argname>x</argname>, ossia il rapporto tra la densità della
	  normale standard e il complemento della funzione di
	  distribuzione della normale standard, entrambe valutate in
	  <argname>x</argname>.
	</para>
	<para>
	  Questa funzione utilizza un algoritmo dedicato che produce
	  maggiore accuratezza rispetto al calcolo utilizzando <fncref
	  targ="dnorm"/> e <fncref targ="cnorm"/>, ma la differenza
	  tra i due metodi è apprezzabile solo per valori di
	  <argname>x</argname> negativi e molto grandi.
	</para>
	<para>
	  <seelist>
	    <fncref targ="cdf"/>
	    <fncref targ="cnorm"/>
	    <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce l'inversa di una matrice simmetrica, definita
	  positiva <argname>A</argname>.  Questa funzione è più veloce
	  di <fncref targ="inv"/> per grandi matrici, poichè non viene
	  effettuato nessun controllo per la simmetria; per questa
	  ragione deve essere utilizzata con attenzione.
	</para>
      </description>
    </function>

    <function name="irf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="pscalar" optional="true">alpha</fnarg>
      </fnargs>  
      <description>
	<para>
	  Questa funzione è disponibile solo quando l'ultimo modello
	  stimato è un VAR o VECM. Produce una matrice contenente le
	  risposte stimate della variabile <argname>target</argname>
	  ad un impulso di una deviazione standard nella variabile
	  <argname>shock</argname>. Queste variabili sono identificate
	  dalla loro posizione nella specificazione VAR: ad esempio,
	  se <argname>target</argname> e <argname>shock</argname> sono
	  pari a 1 e 3 rispettivamente, la matrice che ne risulta
	  fornisce le risposte della prima variabile nella
	  specificazione VAR ad uno shock nella terza variabile.
	</para>
	<para>
	  Se si specifica l'argomento opzionale
	  <argname>alpha</argname>, la matrice dei risultati ha tre
	  colonne: le stime puntuali delle risposte, seguite dai
	  limiti superiore e inferiore dell'intervallo di confidenza
	  per 1 &minus; &agr; ottenuti attraverso bootstrap.  (Quindi
	  <argname>alpha</argname> = 0.1 corrisponde a un intervallo
	  di confidenza al 90 percento.) Se <argname>alpha</argname> è
	  omesso o posto pari a zero, il risultato contiene solo le
	  stime puntuali.
	</para>
	<para>
	  Il numero di periodi (righe) su cui sono calcolate le
	  risposte è determinato automaticamente sulla base della
	  frequenza delle osservazioni, ma questa impostazione può
	  essere modificata attraverso il comando <cmdref
	  targ="set"/>, ad esempio <lit>set horizon 10</lit>.
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce il tasso interno di rendimento (Internal Rate of
	  Return) per <argname>x</argname>, considerata come una
	  sequenza di pagamenti (valori negativi) e riscossioni
	  (valori positivi).
	  <seelist>
	    <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">panel-code</fnarg>
      </fnargs>
      <description>
	<para>
	  Quando il secondo argomento (opzionale) non è specificato,
	  produce 1 se <argname>y</argname> ha un valore costante per
	  il campione corrente (o lungo tutta la sua lunghezza se
	  <argname>y</argname> è un vettore), 0 altrimenti.
	</para>
	<para>
	  Il secondo argomento è accettato solo nel caso in cui il
	  dataset corrente è un panel e <argname>y</argname> è una
	  variabile.  In questo caso un valore
	  <argname>panel-code</argname> pari a 0 richiede un controllo
	  per invarianza nel tempo, mentre un valore pari a 1 richiede
	  un controllo di invarianza tra le unità cross-section
	  (ossia, in ciascun istante temporale il valore di
	  <argname>y</argname> è lo stesso per tutti i gruppi).
	</para>
	<para>
	  Se <argname>y</argname> è una variabile, i valori mancanti
	  sono ignorati durante il controllo.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Dato un argomento scalare, restituisce 1 se
	  <argname>x</argname> è <quote>Not a Number</quote> (NaN), 0
	  altrimenti. Se l'argomento è una matrice produce una matrice
	  delle stesse dimensioni contenente 1 nelle posizioni in cui
	  l'elemento corrispondente della matrice di input è NaN e 0
	  altrimenti.
	</para>
      </description>
    </function>

    <function name="isnull" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce 0 se <argname>nome</argname> è l'identificativo di
	  un oggetto già definito, che può essere uno scalare, una
	  serie, una matrice o una lista. Usato, di solito, per
	  controllare gli argomenti da passare a funzioni.
	  <seelist>
	    <fncref targ="islist"/>
	    <fncref targ="isseries"/>
	    <fncref targ="isstring"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="isoconv" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="series">date</fnarg>
	<fnarg type="seriesref">&amp;year</fnarg>
	<fnarg type="seriesref">&amp;month</fnarg>
	<fnarg type="seriesref" optional="true">&amp;day</fnarg>
      </fnargs>
      <description>
	<para>
	  Data una variabile <argname>date</argname> contenente date
	  nel formato <quote>base</quote> ISO 8601
	  (<lit>YYYYMMDD</lit>), questa funzione scrive l'anno, il
	  mese e (opzionale) il giorno corrispondenti nella variabile
	  nominata nel secondo e nei successivi argomenti.  Un
	  esempio, assumendo che la variabile <lit>dates</lit>
	  contenga valori a 8 cifre appropriati:
	</para>
	<code>
	  series y, m, d
	  isoconv(dates, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  Il valore prodotto da questa funzione è 0 se completata con successo,
	  non-zero nel caso di errori.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  L'argomento <argname>ed</argname> è interpretato come una
	  data in formato <quote>epoch</quote> (uguale a 1 per il
	  primo gennaio nell'anno 1 AD). Il risultato di default
	  &mdash; dello stesso tipo di <argname>ed</argname> &mdash; è
	  un numero a 8 cifre, o una serie di tali numeri, del tipo
	  <lit>YYYYMMDD</lit> (formato <quote>base</quote> ISO 8601),
	  che fornisce la data di calendario corrispondente al giorno
	  epoch.
	</para>
	<para>
	  Se <argname>ed</argname> è uno scalare (solo) e il secondo
	  argomento opzionale <argname>as-string</argname> è diverso
	  da zero, il risultato non è numerico ma una stringa del tipo
	  <lit>YYYY-MM-DD</lit> (formato ISO 8601
	  <quote>esteso</quote>).
	</para>
	<para>
	  Per la funzione inversa, si veda <fncref targ="epochday"/>.
	</para>
      </description>
    </function>

    <function name="iwishart" section="stats" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Data <argname>S</argname> (una matrice positiva definita <by r="p"
	  c="p"/>), restituisce un'estrazione dalla distribuzione inversa di 
	  Wishart con <argname>v</argname> gradi di 
	  libertà. La matrice che ne risulta è anch'essa <by r="p" c="p"/>.  Si
	  utilizza l'algoritmo di <cite key="odell-feiveson66">Odell and Feiveson
	  (1966)</cite>.
	</para>
      </description>
    </function>

    <function name="kdensity" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar" optional="true">scale</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la stima della densità kernel per la serie
	  <argname>x</argname>. La matrice che ne risulta ha due
	  colonne: la prima contiene un insieme di valori in ascissa
	  uniformemente spaziati e la seconda colonna riporta le stime
	  della densità in ciascuno di questi punti.
	</para>
	<para>
	  Il parametro opzionale <argname>scale</argname> può essere
	  utilizzato per adattare il grado di lisciamento rispetto al
	  valore di default di 1.0 (valori più elevati producono un
	  risultato più liscio). Il parametro
	  <argname>control</argname> funziona come un booleano: si
	  utilizza il kernel Gaussiano quando
	  <argname>control</argname> è pari 0 (il valore di default);
	  con un valore diverso da zero si utilizza il kernel di
	  Epanechnikov.
	</para>
	<para>
	  Un grafico del risultato può essere ottenuto utilizzando il comando <cmdref
	  targ="gnuplot"/>, come segue
	</para>
	<code>
	  matrix d = kdensity(x)
	  gnuplot 2 1 --matrix=d --with-lines
	</code>
      </description>
    </function>

    <function name="kfilter" section="filters" output="scalar">
      <fnargs>
	<fnarg optional="true" type="matrixref">&amp;E</fnarg>
	<fnarg optional="true" type="matrixref">&amp;V</fnarg>
	<fnarg optional="true" type="matrixref">&amp;S</fnarg>
	<fnarg optional="true" type="matrixref">&amp;P</fnarg>
	<fnarg optional="true" type="matrixref">&amp;G</fnarg>
      </fnargs>
      <description>
	<para>
	  Richiede che sia definito un filtro di Kalman. Effettua il
	  passaggio in avanti del filtro e restituisce il valore 0 se
	  il comando è andato a buon fine oppure 1 se si è verificato
	  qualche problema numerico.
	</para>
	<para>
	  Gli argomenti opzionali vengono usati per recuperare le
	  seguenti informazioni: <argname>E</argname> dà la matrice
	  degli errori di previsione a un passo in avanti e
	  <argname>V</argname> la loro matrice di covarianze;
	  <argname>S</argname> contiene le stime dei valori del
	  vettore di stato e <argname>P</argname> la loro matrice di
	  covarianze; <argname>G</argname> contiene il guadagno
	  (Kalman gain).  Tutte queste matrici hanno <math>T</math>
	  righe, corrispondenti alle <math>T</math> osservazioni.  Per
	  le dimensioni colonna e altri dettagli, si veda <guideref
	  targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <cmdref targ="kalman"/>
	    <fncref targ="ksmooth"/>
	    <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="ksimul" section="filters" output="matrix">
      <fnargs>
	<fnarg type="matrix">v</fnarg>
	<fnarg type="matrix">w</fnarg>
	<fnarg optional="true" type="matrixref">&amp;S</fnarg>
      </fnargs>
      <description>
	<para>
	  Richiede che sia stato definito un filtro di Kalman.  Effettua una simulazione
	  e produce una matrice contenente i valori simulati delle 
	  variabili osservabili.
	</para>
	<para>
	  L'argomento <argname>v</argname> fornisce i disturbi simulati
	  per l'equazione di transizione di stato e <argname>w</argname> fornisce
	  i disturbi per l'equazione delle osservazioni, se applicabile.  L'argomento
	  opzionale <argname>S</argname> può essere utilizzato per recuperare
	  il vettore simulato degli stati.  Per dettagli si veda <guideref
	    targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <cmdref targ="kalman"/>
	    <fncref targ="kfilter"/>
	    <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="ksmooth" section="filters" output="matrix">
      <fnargs>
	<fnarg optional="true" type="matrixref">&amp;P</fnarg>
      </fnargs>
      <description>
	<para>
	  Richiede che sia definito un filtro di Kalman.  Effettua un
	  passaggio all'indietro (smoothing) e ritorna una matrice con
	  le stime smussate (smoothed) del vettore di stato.  Per
	  ottenere il MSE dello stato smussato, si può usare
	  l'argomento opzionale <argname>P</argname>. Per ulteriori
	  dettagli, si veda <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <cmdref targ="kalman"/>
	    <fncref targ="kfilter"/>
	    <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce il coefficiente di curtosi (in eccesso) della
	  variabile <argname>x</argname>, calcolato non considerando i
	  valori mancanti.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="series-or-list">y</fnarg>
	<fnarg type="bool" optional="true">bylag</fnarg>
      </fnargs>
      <description>
	<para>
	  Genera i ritardi da 1 a <argname>p</argname> della serie
	  <argname>y</argname>, o se <argname>y</argname> è una lista, di tutte le variabili
	  nella lista.  Se <argname>p</argname> = 0, il numero massimo di ritardi
	  è scelto sulla base della periodicità dei dati; altrimenti 
	  <argname>p</argname> deve essere positivo.
	</para>
	<para> 
	  Alle variabili così generate è automaticamente attribuito un
	  nome sulla base del formato
	  <repl>varname</repl><lit>_</lit><repl>i</repl> dove
	  <repl>varname</repl> è il nome della variabile originale e
	  <repl>i</repl> è il valore del ritardo.  La parte originale
	  del nome è troncata se necessario, e può essere aggiustata
	  in caso di ripetizioni nell'insieme dei nomi delle variabili
	  così costruite.
	</para>
	<para>
	  Quando <argname>y</argname> è una lista e l'ordine di ritardo è
	  maggiore di 1, l'ordinamento di default dei termini della lista
	  che ne risulta è per variabile: tutti i ritardi della prima variabile
	  nella lista in input sono seguiti da tutti i ritardi della seconda variabile,
	  e così via. Il terzo argomento (opzionale) può essere utilizzato
	  per cambiare tale impostazione: se <argname>bylag</argname> è diverso da zero
	  i termini sono ordinati per ritardo: il primo ritardo di tutte le variabili in input,
	  poi il secondo ritardo, e così via.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Ultimo valore non-mancante per la variabile
	  <argname>y</argname>. Si noti che se si sta operando su un
	  sottocampione ristretto, il valore prodotto può essere
	  maggiore della variabile dollaro <fncref targ="$t2"/>.
	  <seelist>
	    <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce il logaritmo naturale del determinante di <math>A</math>,
	  calcolato attraverso la fattorizzazione LU.
	  <seelist> 
	    <fncref targ="det"/>
	    <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le differenze logaritmiche; i valori iniziali sono posti uguali a
	  <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola una nuova variabile ottenuta come combinazione
	  lineare delle variabili nella lista <argname>L</argname>.  I
	  coefficienti sono dati dal vettore <argname>b</argname>, che
	  deve avere lunghezza uguale al numero di variabili in
	  <argname>L</argname>.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la statistica Q di Ljung&ndash;Box per la serie y
	  <argname>y</argname> usando <argname>p</argname> ritardi e
	  il campione definito al momento. Il parametro
	  <argname>p</argname> deve essere maggiore o uguale a 1 e
	  minore del numero di osservazioni disponibili.
	</para>
	<para>
	  Questa statistica può essere confrontata alla chi-quadro con
	  <argname>p</argname> gradi di libertà per sottoporre a test
	  l'ipotesi che la variabile <argname>y</argname> sia
	  serialmente incorrelata.
	  <seelist>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Logaritmo della funzione gamma di <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Logaritmo naturale; produce <lit>NA</lit> per valori non
	  positivi. Nota: <lit>ln</lit> può anche essere usato invece
	  di <lit>log</lit>.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Logaritmo in base 10; produce <lit>NA</lit> per valori
	  non positivi.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Logaritmo in base 2; produce <lit>NA</lit> per valori
	  non positivi.
	</para>
      </description>
    </function>

    <function name="loess" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robust</fnarg>
      </fnargs>
      <description>
	<para>
	  Effettua una regressione polinomiale ponderata localmente e
	  ritorna una serie coi valori previsti di
	  <argname>y</argname> per ogni elemento non mancante di
	  <argname>x</argname>.  Viene usato il metodo descritto in
	  <cite key="cleveland79">William Cleveland (1979)</cite>.
	</para>
	<para>
	  Gli argomenti opzionali <argname>d</argname> e
	  <argname>q</argname> specificano rispettivamente l'ordine
	  del polinomio in <argname>x</argname> e la proporzione di
	  punti da usarsi nella stima locale.  I valori predefiniti
	  sono <argname>d</argname> = 1 e <argname>q</argname> =
	  0.5. Gli altri valori consentiti per <argname>d</argname>
	  sono 0 e 2. Con <argname>d</argname> = 0 la regressione
	  locale si riduce a una forma di media mobile. Il valore di
	  <argname>q</argname> dev'essere compreso fra 0 e 1; più
	  grande è il valore, più liscia sarà la stima.
	</para>
	<para>
	  Dano all'argomento <argname>robust</argname> un valore
	  non-zero, le regressioni locali sono effettuate due volte,
	  con pesi modificati sulla base dei residui dell'iterazione
	  precedente per ridurre l'effetto degli outlier.
	</para>
	<para>
	  Si veda anche <fncref targ="nadarwat"/>, e pure <guideref
	  targ="chap-nonparam"/> per dettagli sui metodi
	  nonparametrici.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Restituisce la funzione logistica calcolata nell'argomento
	  <argname>x</argname>: $\Lambda(x) = e^x/(1+e^x)$. Se
	  <argname>x</argname> è una matrice, la funzione è applicata
	  elemento per elemento.
	</para>
	<para context="notex">
	  Restituisce la funzione logistica calcolata nell'argomento
	  <argname>x</argname>: <math>e</math><sup>x</sup>/(1 +
	  <math>e</math><sup>x</sup>).  Se <argname>x</argname> è una
	  matrice, la funzione è applicata elemento per elemento.
	</para>
      </description>
    </function>

    <function name="lower" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce una matrice <by r="n" c="n"/> triangolare inferiore: gli elementi
	  sulla diagonale o sotto di essa sono uguali al valore corrispondente in 
	  <argname>A</argname>; i restanti valori sono pari a zero.
	</para>
	<para context="tex">
	  Restituisce una matrice $n\times n$ triangolare inferiore <math>B</math>
	  tale che $B_{ij} = A_{ij}$ se $i \ge j$, e 0 altrimenti.
	</para>
	<para>
	  <seelist>
	    <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrvar" section="filters" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la varianza di lungo periodo di
	  <argname>y</argname>, calcolata utilizzando il kernel di
	  Bartlett con dimensione della finestra pari a
	  <argname>k</argname>.
	</para>
	<para context="tex">
	  In formule: 
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \bar{X}) (y_{t-i} - \bar{Y})
	  \right] \] 
	  con 
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se l'argomento <argname>y</argname> è una variabile,
	  restituisce il massimo valore (scalare) tra le osservazioni
	  non-mancanti della serie.  Se l'argomento è una lista,
	  restituisce una variabile i cui elementi corrispondono al
	  massimo dei valori delle variabili nella lista per ciascuna
	  osservazione.
	</para>
	<para>
	  <seelist>
	    <fncref targ="min"/>
	    <fncref targ="xmax"/>
	    <fncref targ="xmin"/>
	  </seelist>
	</para>	
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce i massimi per colonna di <argname>X</argname>.
	  <seelist>
	    <fncref targ="imaxc"/>
	    <fncref targ="maxr"/>
	    <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce i massimi per riga di <argname>X</argname>. 
	  <seelist>
	    <fncref targ="imaxr"/>
	    <fncref targ="maxc"/> 
	    <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la matrice di correlazione trattando ogni colonna di 
	  <argname>X</argname> come una variabile.
	  <seelist> 
	    <fncref targ="corr"/>
	    <fncref targ="cov"/>
	    <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la matrice di varianza e covarianza trattando ogni colonna di 
	  <argname>X</argname> come una variabile. 
	  <seelist> 
	    <fncref targ="corr"/>
	    <fncref targ="cov"/>
	    <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para> 
	  Restituisce la matrice covariogramma corrispondente a una
	  matrice <by r="T" c="k"/> <argname>X</argname> (tipicamente
	  contenente regressori), un vettore (opzionale)
	  <math>T</math>-variato <argname>u</argname> (tipicamente
	  contenente i residui), un vettore (opzionale) di dimensione
	  (<math>p</math>+1) di pesi <argname>w</argname>, e uno
	  scalare ordine di ritardo <argname>p</argname>, che deve
	  essere maggiore o uguale a 0.
	</para>
	<para context="tex">
	  La matrice prodotta è data da
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t' u_t
	  u_{t-j} X_{t-j})\]
	</para>
	<para context="notex">
	  La matrice prodotta è data da
	</para>
	<para context="notex">	
	  sum_{j=-p}^p sum_j w_{|j|} (X_t' u_t u_{t-j} X_{t-j})
	</para>
	<para>
	  Se <argname>u</argname> è specificato pari a <lit>null</lit>
	  il termine <math>u</math> è omesso, e se
	  <argname>w</argname> è dato da <lit>null</lit> tutti i pesi
	  sono considerati pari a 1.0.
	</para>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> è una variabile, restituisce la
	  media campionaria (scalare), calcolata non considerando le
	  osservazioni mancanti (se presenti).
	</para>
	<para>
	  Se <argname>x</argname> è una lista, produce una serie
	  <math>y</math> tale che <math>y</math><sub>t</sub> è la
	  media dei valori delle variabili nella lista per
	  l'osservazione <math>t</math>, o <lit>NA</lit> se ci sono
	  valori mancanti in <math>t</math>.
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le medie per colonna di <argname>X</argname>. 
	  <seelist>
	    <fncref targ="meanr"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le medie per riga di <argname>X</argname>. 
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la mediana delle osservazioni non mancanti di una variabile
	  <argname>y</argname>. 
	  <seelist>
	    <fncref targ="quantile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola l'esponenziale della matrice <argname>A</argname>, usando
	  l'algoritmo 11.3.1 di Golub e Val Loan (1996).).
	</para>
	<para context="tex">
	  Esponenziale di una matrice,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\] 
	  (La convergenza di questa serie è garantita.) La funzione 
	  usa l'algoritmo 11.3.1 di Gloub e Van Loan (1996).
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se l'argomento <argname>y</argname> è una variabile, calcola
	  il minimo (scalare) delle osservazioni non mancanti della variabile.
	  Se l'argomento è una lista, restituisce una variabile i cui elementi
	  sono il minimo dei valori delle variabili incluse nella lista
	  in corrispondenza di ciascuna osservazione.
	</para>
	<para>
	  <seelist>
	    <fncref targ="max"/>
	    <fncref targ="xmax"/>
	    <fncref targ="xmin"/>
	  </seelist>
	</para>	
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola il minimo per colonna di <argname>X</argname>.
	  <seelist>
	    <fncref targ="iminc"/>
	    <fncref targ="maxc"/> 
	    <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola il minimo per riga di <argname>X</argname>. 
	  <seelist>
	    <fncref targ="iminr"/>
	    <fncref targ="maxr"/> 
	    <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Crea una variabile binaria uguale a 1 se
	  <argname>x</argname> è <lit>NA</lit>. Se
	  <argname>x</argname> è una serie, il confronto viene
	  effettuato elemento per elemento; se <argname>x</argname> è
	  una lista di variabili, il risultato è una variabile con
	  elementi pari a 1 per le osservazioni per le quali almeno
	  una delle variabili incluse nella lista ha valore mancante,
	  e 0 altrimenti.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="misszero"/>
	    <fncref targ="ok"/>
	    <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converte gli <lit>NA</lit> in zeri. Se <argname>x</argname>
	  è una serie la conversione è effettuata elemento per
	  elemento.
	  <seelist>
	    <fncref targ="missing"/>
	    <fncref targ="ok"/>
	    <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Sposta in alto o in basso le righe di <argname>X</argname>. Se
	  <argname>p</argname> è uno scalare positivo, calcola una matrice
	  nella quale le colonne di <argname>X</argname> sono spostate verso
	  il basso di <argname>p</argname> righe e le prime 
	  <argname>p</argname> righe sono riempite con il valore 
	  <argname>m</argname>. Se <argname>p</argname> è un numero negativo, 
	  <argname>X</argname> è spostata verso l'alto e le ultime righe
	  sono riempite con il valore <argname>m</argname>. Se
	  <argname>m</argname> viene omesso, al suo posto si utilizza un
	  valore nullo.
	</para>
	<para context="tex">
	  Sposta in alto o in basso le righe di <argname>X</argname>. Se
	  $p$ è uno scalare positivo, il risultato è una matrice $Y$ di elementi
	  $Y_{i,j} = X_{i-p,j}$ per $i \ge p$ e zero altrimenti. In
	  altre parole, le colonne di 
	  <argname>X</argname> vengono spostate verso il basso di 
	  <argname>p</argname> righe e le prime <argname>p</argname>
	  righe sono riempite con il valore <argname>m</argname>. Se 
	  <argname>p</argname> è un numero negativo,
	  <argname>X</argname> viene spostata verso l'alto e le ultime righe 
	  sono riempite con il valore <argname>m</argname>. Se 
	  <argname>m</argname> è omesso, al suo posto si utilizza
	  lo zero.
	</para>
	<para context="notex">
	  Se <argname>p</argname> è un vettore, l'operazione precedente
	  è svolta per ciascun elemento di <argname>p</argname>,
	  unendo le matrici così ottenute in senso orizzontale.
	</para>
	<para context="tex">
	  Se $p$ è un vettore, l'operazione precedente è svolta
	  per ciascun elemento di $p$, unendo le matrici così ottenute
	  in senso orizzontale.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice di <argname>r</argname> righe e
	  <argname>c</argname> colonne, contenene numeri pseudocasuali
	  estratti da una normale standardizzata.
	  <seelist> 
	    <fncref targ="normal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice <by r="k" c="n"/> di stime di
	  parametri ottenute con la regressione dei minimi quadrati
	  ordinari della matrice <by r="T" c="n"/>
	  <argname>Y</argname> sulla matrice <by r="T" c="k"/>
	  <argname>X</argname>.
	</para>
	<para>
	  Se il terzo argomento non è <lit>null</lit>, la matrice <by
	  r="T" c="n"/> <argname>U</argname> conterrà i residui. Se
	  l'ultimo argomento viene indicato e non è <lit>null</lit>,
	  la matrice <by r="k" c="k"/> <argname>V</argname> conterrà
	  (a) la matrice di covarianza delle stime dei parametri, se
	  <argname>Y</argname> ha una sola colonna, o (b)
	  <math>X'X</math><sup>-1</sup> se <argname>Y</argname> ha più
	  colonne.
	</para>
	<para>
	  Di default, le stime sono ottenute usando una scomposizione
	  di Cholesky, ricorrendo alla scomposizione QR se le colonne
	  di <argname>X</argname> sono quasi collineari.  E' possibile
	  imporre l'uso della scomposizione SVD usando il comando
	  <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="mpols"/>
	    <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">mese</fnarg>
	<fnarg type="int">anno</fnarg>
	<fnarg type="int">gioset</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di giorni (rilevanti) in un dato mese
	  ed anno; l'argomento <argname>gioset</argname> può essere
	  5, 6 o 7, e indica il numero di giorni nella settimana da
	  contare (il 6 omette le domeniche, il 5 anche i sabati).
	</para>
      </description>
    </function>

    <function name="movavg" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  A seconda del parametro 
	  <argname>p</argname>, calcola una media mobile semplice o con pesi 
	  esponenziali della variabile indicata in input
	  <argname>x</argname>.
	</para>
	<para context="notex">
	  Se <argname>p</argname> &gt; 1, viene calcolata una media
	  mobile semplice a <argname>p</argname>-termini; in altre
	  parole, la media aritmetica da x(t) a x(t+p-1). Se viene
	  indicato un valore non nullo per il parametro opzionale
	  <argname>control</argname> la media mobile è centrata, in
	  caso contrario è <quote>retrospettiva</quote> (usa solo
	  l'osservazione corrente e quelle passate, ma non quelle
	  future).
	</para>
	<para context="tex">
	  Se $p&gt;1$, viene calcolata una media mobile semplice a
	  <argname>p</argname> termini, in altre parole $\frac{1}{p}
	  \sum_{i=0}^{p-1} x_{t-i}$. Se viene indicato un valore non
	  nullo per il parametro opzionale <argname>control</argname>
	  la media mobile è centrata, altrimenti è
	  <quote>retrospettiva</quote> (usa solo l'osservazione
	  corrente e quelle passate, ma non quelle future).
	</para>
	<para context="notex">
	  Se <argname>p</argname> è una frazione positiva viene
	  calcolata una media mobile esponenziale: y(t) = p*x(t) +
	  (1-p)*y(t-1). Di default la variabile calcolata, y, è
	  inizializzata usando il primo valore valido di
	  <argname>x</argname>, ma il parametro
	  <argname>control</argname> può essere usato per specificare
	  il numero di osservazioni iniziali che dovrebbero essere
	  incluse nella media usata per calcolare y(0).  Un valore
	  nullo di <argname>control</argname> indica che dovrebbero
	  essere usate tutte le osservazioni.
	</para>
	<para context="tex">
	  Se $0 &lt; p &lt; 1$, viene calcolata una media mobile
	  esponenziale: $y_t = p x_t + (1-p)y_{t-1}$. Di default la
	  variabile calcolata, $y$, è inizializzata usando il primo
	  valore valido di $x$, ma il parametro
	  <argname>control</argname> può essere usato per specificare
	  il numero di osservazioni iniziali che dovrebbero essere
	  incluse nella media usata per calcolare $y_0$.  Un valore
	  nullo di <argname>control</argname> indica che devono essere
	  usate tutte le osservazioni.
	  </para>	
    </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funziona esattamente come <fncref targ="mols"/>, tranne che i calcoli
	  sono effettuati in precisione multipla usando la libreria GMP.
	</para>
	<para>
	  Di default GMP usa 256 bit per ogni numero a virgola mobile, ma
	  questa convenzione può essere modificata usando la variabile d'ambiente
	  <lit>GRETL_MP_BITS</lit>, &eg; <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">rows</fnarg>
	<fnarg type="int">cols</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
      </examples>
      <description>
	<para>
	  Funziona come <fncref targ="randgen"/> tranne che il valore
	  calcolato è una matrice anzichè una variabile. Gli argomenti
	  iniziali di questa funzione sono come quelli descritti per
	  <lit>randgen</lit>, ma devono essere seguiti da due interi
	  per specificare il numero di righe (<argname>r</argname>) e
	  colonne (<argname>c</argname>) della matrice casuale
	  desiderata.
	</para>
	<para>
	  Il primo esempio fornito sopra calcola un vettore colonna
	  casuale uniforme di 50 elementi, mentre il secondo specifica
	  una matrice casuale <by r="20" c="20"/> con elementi tratti
	  dalla distribuzione <math>t</math> con 14 gradi di libertà.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mnormal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Legge una matrice da un file di testo. La stringa 
	  <argname>fname</argname> deve contenere il nome del file da cui
	  deve essere letta la matrice. Se questo nome ha estensione 
	  <quote><lit>.gz</lit></quote>, si assume che il file sia stato creato
	  con compressione gzip.
	</para>
	<para>
	  Il file in questione può iniziare con un numero
	  di commenti qualsiasi, definiti come linee che iniziano 
	  con il carattere <lit>#</lit>; queste linee sono ignorate. 
	  A parte questo, il contenuto deve rispettare le regole seguenti:
	</para>
	<ilist>
	  <li>
	    <para>
	      La prima riga non commentata deve contenere due interi,
	      separati da uno spazio o un tabulatore, che indicano
	      rispettivamente il numero di righe e di colonne.
	    </para>
	  </li>
	  <li>
	    <para>
	      Le colonne devono essere separate da spazi o caratteri.
	    </para>
	  </li>
	  <li>
	    <para>
	      Il separatore decimale deve essere il punto, 
	      <quote><lit>.</lit></quote>.
	    </para>
	  </li>
	</ilist>
	<para>
	  Se viene indicato un valore non nullo per l'argomento
	  opzionale <argname>import</argname>, la ricerca del file di
	  input avviene all'interno della directory <quote>dot</quote>
	  dell'utente. Questa funzione è pensata per essere usata in
	  combinazione con le funzioni che esportano matrici
	  illustrate nel contesto del comando <cmdref
	  targ="foreign"/>.  In questo caso l'argomento
	  <argname>fname</argname> dovrebbe essere semplicemente un
	  nome di file, senza una componente che ne indica il
	  percorso.
	</para>
	<para>
	  Se dovesse verificarsi un errore (per esempio dovuto al
	  fatto che il file è inaccessibile o mal formattato) la
	  funzione restituisce una matrice vuota.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice contenente le righe di
	  <argname>X</argname> in ordine inverso. Per ottenere una
	  matrice in cui le colonne di <argname>X</argname> appaiano
	  in ordine inverso si usi:
	</para>
	<code>
	  matrix Y = mreverse(X')'
	</code>
      </description>
    </function>  

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Minimi quadrati vincolati: calcola una matrice <by r="k" c="n"/> 
	  di stime dei parametri ottenute regredendo con il metodo dei minimi quadrati
	  la matrice <by r="T" c="n"/> <argname>Y</argname> sulla matrice 
	  <by r="T" c="k"/> m<argname>X</argname> sotto i vincoli lineari 
	  <math>RB</math> = <math>q</math>, dove 
	  <math>B</math> indica il vettore dei coefficienti incolonnati.
	  <argname>R</argname> deve avere <math>k</math> *
	  <math>n</math> colonne; ogni riga della matrice rappresenta 
	  un vincolo lineare. Il numero di righe di <argname>q</argname>
	  deve essere pari al numero di righe di <argname>R</argname>.
	</para>
	<para>
	  Se il quinto argomento non è <lit>null</lit>, la matrice <by r="T"
	  c="n"/> <argname>U</argname> conterrà i residui. Se viene indicato 
	  l'ultimo argomento e non è 
	  <lit>null</lit>, la matrice <by r="k" c="k"/> 
	  <argname>V</argname> conterrà la versione vincolata della matrice  
	  <math>X'X</math><sup>-1</sup>. La matrice di varianza delle stime
	  dell'equazione <math>i</math> può essere costruita moltiplicando
	  la sottomatrice opportuna di 
	  <argname>V</argname> per una stima della varianza dell'errore di quell'equazione.
	</para>
      </description>
    </function>  

    <function name="mshape" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Riorganizza gli elementi di <argname>X</argname> in una matrice con 
	  <argname>r</argname> righe e <argname>c</argname> colonne. Gli elementi vengono
	  letti da <argname>X</argname> e inseriti nel risultato della funzione 
	  in ordine di colonna. Se <argname>X</argname> contiene meno di 
	  <math>k</math> = <math>rc</math> elementi, questi ultimi vengono 
	  ripetuti ciclicamente; in caso contrario, se 
	  <argname>X</argname> ha più elementi ne vengono usati solo i 
	  primi <math>k</math>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="cols"/>
	    <fncref targ="rows"/> 
	    <fncref targ="unvech"/>
	    <fncref targ="vec"/> 
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice nella quale le righe di <argname>X</argname>
	  sono riordinate per valore crescente degli elementi nella
	  colonna <argname>j</argname>. Il riordinamento è stabile:
	  le righe che contengono lo stesso valore nella colonna <argname>j</argname>
	  mantengono l'ordinamento relativo preesistente.
	</para>
      </description>
    </function>

    <function name="muniform" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice di <argname>r</argname> righe e
	  <argname>c</argname> colonne, contenene numeri pseudocasuali
	  estratti da una uniforme (0,1). Nota: per generare uno
	  scalare pseudocasuale uniforme, è consigliabile usare la
	  funzione <fncref targ="randgen1"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mnormal"/>
	    <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Copia la matrice <argname>X</argname> in un file di testo di nome 
	  <argname>fname</argname>. Nelle prima linea il file contiene 
	  due interi separati da un tabulatore corrispondenti ai numeri di 
	  riga e di colonna; nelle righe seguenti sono indicati gli elementi
	  della matrice in notazione scientifica, separati da tabulatori
	  (una riga per ciascuna linea).
	</para>
	<para>
	  Se il file <argname>fname</argname> esiste già verrà sovrasccritto.
	  Il valore restituito è 0 in caso venga portata a termine
	  correttamente l'esecuzione; se si verifica un errore, per esempio dovuto al
	  fatto che il file non può essere sovrascritto, il valore restituito sarà non nullo.
	</para>
	<para>
	  Se viene indicato un valore non nullo per l'argomento 
	  <argname>export</argname>, il file di output sarà salvato nella 
	  directory <quote>dot</quote> dell'utente, e ad esso per default sarà possibile 
	  accedere usando le funzioni che caricano matrici contenute nel 
	  contesto del comando <cmdref targ="foreign"/>. In questo caso è necessario
	  indicare come secondo argomento il nome del  file privo del percorso.
	</para>
	<para>
	  Le matrici memorizzate usando il comando <lit>mwrite</lit> possono essere
	  facilmente lette da altri programmi; v. <guideref targ="chap:matrices"/> per 
	  ulteriori dettagli.
	</para>
	<para>
	  E' disponibile un'estensione del comportamento base di questa
	  funzione: se <argname>fname</argname> ha estensione 
	  <quote><lit>.gz</lit></quote>, il file viene salvato usando la 
	  compressione gzip.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mread"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice contenente una tabella a doppia entrata dei valori
	  contenuti in <argname>x</argname> (nel senso delle righe) e 
	  <argname>y</argname> (nel senso delle colonne). I due argomenti devono
	  essere dello stesso tipo (entrambe variabili e entrambi vettori
	  colonna), e visto l'uso che tipicamente viene fatto di questa funzione
	  si assume che contengano solo valori interi.
	</para>
	<para>
	  <seelist>
	    <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Stima nonparametrica della media condizionale di
	  <argname>y</argname> dato <argname>x</argname> col metodo di
	  Nadaraya&ndash;Watson. Restituisce una serie contenente la stima
	  nonparametrica di
	  <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  per ogni elemento non-missing della serie
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[
	  m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i -
	  x_j)} {\sum_{j=1}^{n} K_h(x_i - x_j)}
	  \]
	  dove la funzione kernel <math>K_h(\cdot)</math> è data da
	  \[
	  K_h(x) = \exp\left(-\frac{x^2}{2h}\right)
	  \]
	  per $|x| &lt; \tau$ e 0 altrimenti.
	</para>
	<para context="notex">
	  La funzione kernel <math>K</math> è data da <math>K =
	  exp(-x</math><sup>2</sup><math> / 2h)</math> per <math>|x|
	  &lt; T</math> e 0 altrimenti.
	</para>
	<para context="tex">
	  L'argomento <argname>h</argname>, noto come \emph{ampiezza
	  di banda}, è un parametro (reale positivo) indicato
	  dall'utente. Normalmente, è un numero piccolo: valori grandi
	  di $h$ rendono $m(x)$ più liscia; una scelta molto comune è
	  $n^{-0.2}$. Per maggiori dettagli, si veda <guideref
	  targ="sec:nadarwat"/>.
	</para>
	<para context="notex">
	  L'argomento <argname>h</argname>, noto come ampiezza di
	  banda, è un parametro (reale positivo) indicato
	  dall'utente. Normalmente, è un numero piccolo: valori grandi
	  di <argname>h</argname> rendono <math>m(x)</math> più
	  liscia; una scelta molto comune è
	  <math>n</math><sup>-0.2</sup>. Per maggiori dettagli, si veda
	  <guideref targ="sec:nadarwat"/>.
	</para>
	<para context="tex">
	  Lo scalare $\tau$ viene usato per prevenire problemi
	  numerici che si verificano quando la funzione kernel è
	  calcolata troppo lontano dallo zero e viene detto il
	  parametro di taglio.
	</para>
	<para context="notex">
	  Lo scalare <math>T</math> viene usato per prevenire problemi
	  numerici che si verificano quando la funzione kernel è
	  calcolata troppo lontano dallo zero e viene detto il
	  parametro di taglio.
	</para>
        <para>
	  Quest'ultimo può essere tarato a piacere via il comando
	  <lit>set nadarwat_trim</lit>; è espresso come multiplo di
	  <argname>h</argname>, e il valore di default è 4.
        </para>
	<para>
	  L'utente può indicare un valore negativo per l'ampiezza di
	  banda: ciò viene interpretato come una sintassi
	  comvenzionale per la cosiddetta variante
	  <quote>leave-one-out</quote> dello stimatore, ossia una
	  variante che non usa la <math>i</math>-esima osservazione
	  per calcolare
	  <math>m(x</math><sub>i</sub><math>)</math>. Questa variante
	  rende il procedimento numericamente più robusto e il suo uso
	  è sovente consigliato quando lo stimatore è usato a fini
	  inferenziali. Ovviamente, l'ampiezza di banda effettivamente
	  usata è il valore assoluto di <argname>h</argname>.
	</para>
	  <para context="tex">
	    In formule, lo stimatore ``leave-one-out'' è
	    \[
	    m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i -
	    x_j)} {\sum_{j \ne i} K_h(x_i - x_j)}
	    \]
	  </para>

      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di elementi nella lista
	  <argname>L</argname>.
	</para>
      </description>
    </function>

    <function name="ngetenv" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Se è stata definita una variabile d'ambiente chiamata 
	  <argname>s</argname> e le è stato assegnato un valore numerico,
	  restituisce tale valore; in caso contrario restituisce NA. V anche <fncref
	  targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di osservazioni non mancanti
	  per la variabile 
	  <argname>y</argname> nella selezione corrente del campione.
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Genera una sequenza di numeri pseudo-casuali tratti dalla distribuzione normale
	  di media &mu; e deviazione standard &sigma;. Se non vengono forniti gli argomenti
	  vengono generate realizzazioni tratte dalla distribuzione <math>N</math>(0,1).
	</para>
	<para>
	  <seelist>
	    <fncref targ="randgen"/>
	    <fncref targ="normal"/>
	    <fncref targ="genpois"/>
	    <fncref targ="mnormal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il Valore Attuale Netto (VAN) di
	  <argname>x</argname>, considerato come una sequenza di
	  esborsi (se negativi) e introiti (se positivi), valutati a
	  un tasso d'interesse annuo <argname>r</argname>;
	  <argname>r</argname> dev'essere espresso in numeri, non
	  percentuali, (5<lit>%</lit> = 0.05).  Il primo valore è considerato
	  come riferito al periodo <quote>presente</quote> e non viene
	  scontato.  Per emulare una funzione che calcola il VAN
	  scontando anche il primo valore, inserite uno zero
	  all'inizio della sequenza degli input.
	</para>
	<para>
	  La funzione può gestire frequenze di osservazione
	  annuali, trimestrali, mensili e prive di data (le osservazioni
	  prive di data sono considerate annuali).
	</para>
	<para>
	  <seelist>
	    <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Massimizzazione numerica mediante il metodo di Newton&ndash;Raphson. Il
	  vettore <argname>b</argname> deve contenere i valori iniziali 
	  dei parametri, e l'argomento 
	  <argname>f</argname> deve specificare una funzione che calcola
	  il criterio (scalare) da massimizzare, dati i valori correnti dei
	  parametri e altre informazioni rilevanti. Se l'obiettivo è di minimizzare
	  il criterio, la funzione deve restituire il criterio cambiato di segno.
	  Se l'esecuzione viene completata con successo, <lit>NRmax</lit> 
	  restituisce il valore massimizzato del criterio e
	  <argname>b</argname> contiene i valori dei parametri corrispondenti al massimo.
	</para>
	<para>
	  Gli argomenti opzionali in terza e in quarta posizione permettono
	  di specificare rispettivamente le derivate analitiche e una matrice Hessiana 
	  analitica (negativa). Le funzioni indicate come <argname>g</argname> e 
	  <argname>h</argname> devono assumere come primo argomento una matrice
	  predefinita con le stesse dimensioni rispettivamente del gradiente e
	  dell'Hessiana, indicati sotto forma di puntatore. Devono inoltre 
	  accettare il vettore dei parametri come argomento (sotto forma di puntatore 
	  o altro). Gli altri argomenti sono opzionali. Se si omette uno o entrambi 
	  gli argomenti opzionali viene utilizzata un'approssimazione numerica.
	</para>
	<para>
	  Per maggiori dettagli ed esempi si veda il capitolo
	  relativo ai metodi numerici in <guideref targ="chap-numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
	    <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola lo spazio nullo a destra di <argname>A</argname>,
	  usando la scomposizione a valori singolari (SVD); il
	  risultato è una matrice <math>B</math> tale che il prodotto
	  <math>AB</math> è una matrice nulla, tranne quando
	  <argname>A</argname> è di rango colonna pieno, caso in cui
	  viene restituita una matrice vuota. In caso contrario,
	  <argname>A</argname> è <by r="m" c="n"/>, <math>B</math>
	  sarà <math>n</math> per (<math>n</math> &minus;
	  <math>r</math>), dove <math>r</math> è il rango di
	  <argname>A</argname>.
	</para>
	<para context="tex">
	  Calcola lo spazio nullo a destra di <argname>A</argname>,
	  usando la scomposizione a valori singolari: il risultato è
	  una matrice $B$ tale che $AB=[0]$, tranne quando $A$ è di
	  rango colonna pieno, caso in cui viene restituita una
	  matrice vuota. In caso contrario, se $A$ è $m \times n$, $B$
	  sarà una matrice $n \times (n-r)$, dove $r$ è il rango di
	  $A$.
	</para>
	<para>
	  <seelist>
	    <fncref targ="rank"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Restituisce una serie di interi consecutivi, partendo da 1 in
	  corrispondenza con l'inizio del dataset. Si noti che il
	  risultato è indipendente dal sottocampionamento. Questa
	  funzione è particolarmente utile con dataset di serie
	  storiche. Nota: la funzione <lit>t</lit> è un sinonimo
	  perfetto di <lit>obs</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'etichetta per la <argname>t</argname>-esima
	  osservazione, dove <argname>t</argname> è un indice che
	  parte da 1.  La funzione inversa è <fncref targ="obsnum"/>.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un intero corrispondente all'osservazione
	  specificata dalla stringa <math>s</math>. Si noti che il
	  risultato è invariante al sottocampionamento. Questa
	  funzione è particolarmente utile con campioni di serie
	  storiche. Ad esempio, il codice
	</para>
	<code>
	  open denmark 
	  k = obsnum(1980:1)
	</code>
	<para>
	  produce <lit>k = 25</lit>, ciò che indica che il primo
	  trimestre 1980 è la venticinquesima osservazione nel dataset
	  <lit>denmark</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="obs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> è uno scalare, la funzione
	  restituisce 1 se <argname>x</argname> non è <lit>NA</lit>,
	  altrimenti 0. Se <argname>x</argname> è una serie, la
	  funzione restituisce una serie contenente valore 1 per le
	  osservazioni non mancanti e zero altrimenti.  Se
	  <argname>x</argname> è una lista, il risultato è una
	  variabile con zero in corrispondenza delle osservazioni per
	  le quali almeno una variabile nella lista ha un valore
	  mancante e 1 altrimenti.
	</para>
	<para>
	  Se <argname>x</argname> è una matrice il comportamento è
	  leggermente diverso, dato che le matrici non possono
	  contenere <lit>NA</lit>: la funzione restituisce una matrice
	  delle stesse dimensioni di <argname>x</argname>, con
	  elementi pari a 1 nelle posizioni corrispondenti a elementi
	  di <argname>x</argname> finiti, e 0 di quelli non finiti (o
	  infiniti o not-a-number, in conformità con lo standard IEEE
	  754).
	</para>
	<para>
	  <seelist>
	    <fncref targ="missing"/>
	    <fncref targ="misszero"/>
	    <fncref targ="zeromiss"/>
	  </seelist>
	  Notare che queste funzioni non possono essere applicate a matrici.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce la norma-1 della matrice <argname>X</argname>;
	  in altre parole, il massimo fra le colonne di
	  <argname>X</argname> della somma dei valori assoluti degli
	  elementi della colonna.
	</para>
	<para context="tex">
	  Restituisce la norma-1 della matrice $r \times c$ 
	  <argname>X</argname>: 
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="infnorm"/>
	    <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice con <math>r</math> righe e <math>c</math>
	  colonne con elementi tutti pari a 1.
	</para>
	<para>
	  <seelist>
	    <fncref targ="seq"/>
	    <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  La funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola le deviazioni ortogonali in avanti
	  della variabile <argname>y</argname>.
	</para>
	<para context="tex">
	  La funzione è applicabile solo se il dataset corrente ha una
	  struttura panel. Calcola le deviazioni ortogonali in avanti
	  della variabile <argname>y</argname>; in altre parole, 
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t + 1}{T_i - t}} \left( y_{i,t} -
	  \frac{1}{T_i - t - 1} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  Talvolta questa trasformazione viene utilizzata al posto delle
	  differenze prime per rimuovere gli effetti individuali da dati panel.
	  <seelist>
	    <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, shape, scale, y)</example>
      </examples>
      <description>
	<para>
	  Calcola funzioni di densità o di probabilità. Restituisce la
	  densità (se continue) o la probabilità (se discrete)
	  <argname>x</argname> della distribzion identificata dal
	  carattere <argname>c</argname>.  Si veda <fncref targ="cdf"/>
	  per dettagli sugli argomenti.  Le distribuzioni supportate
	  dalla funzione <lit>pdf</lit> sono la normale,
	  <math>t</math> di Student, chi-quadro, <math>F</math>,
	  gamma, Weibull, Generalized Error, binomiale and Poisson. Si
	  noti che per la binomiale e la Poisson ciò che viene
	  calcolato è in effetti la probabilità nel punto specificato.
	</para>
	<para>
	  Per la normale, si veda anche la funzione <fncref
	  targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">bandwidth</fnarg>
      </fnargs>
      <description>
	<para>
	  Se viene fornito solo il primo argomento la funzione calcola 
	  il periodogramma campionario per la variabile o il vettore indicati. 
	  Se viene fornito anche il secondo argomento, la funzione calcola 
	  una stima dello spettro di <argname>x</argname> usando una finestra
	  di ritardi di Bartlett con la banda indicata, fino a un massimo pari alla 
	  metà delle osservazioni (<math>T</math>/2).
	</para>
	<para>
	  Restituisce una matrice con due colonne e <math>T</math>/2 righe:
	  la prima colonna contiene la frequenza, &omega;, da 2&pi;/<math>T</math>
	  a &pi;, ae la seconda la densità spettrale corrispondente.
	</para>
      </description>
    </function>

    <function name="pmax" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione può essere applicata solo se il dataset corrente
	  ha struttura panel. Restituisce una variabile contenente i massimi
	  della variabile 
	  <argname>y</argname> per ciascuna unità cross-section (ripetuti
	  per tutti i periodi temporali).
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  per le quali il valore di <argname>mask</argname> è nullo vengono 
	  ignorate.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pmin"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pxsum"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente
	  ha struttura panel. Calcola la media per ciascuna unità della 
	  variabile 
	  <argname>y</argname>; in altre parole, la somma delle osservazioni
	  valide relative a ciascuna unità divisa per il loro numero.
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la media per ciascuna unità della 
	  variabile 
	  <argname>y</argname>; in altre parole, 
	  \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\] 
	  dove $T_i$ è il numero di osservazioni valide per l'unità $i$.
	</para>
	<para>
	  Se viene indicato il secondo parametro opzionale le
	  osservazioni corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="psd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente i minimi della 
	  variabile 
	  <argname>y</argname> per ciascuna unità della cross-section (replicati 
	  per ogni periodo temporale).
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni 
		corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>	
	<para>
	  <seelist> 
	    <fncref targ="pmax"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente il numero
	  di osservazioni valide della variabile <argname>y</argname> per 
	  ciascuna unità della cross-section (replicato per ogni periodo
	  temporale).
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni 
		corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pmax"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pmean"/>
	    <fncref targ="psd"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le radici di un polinomio. Se il polinomio è
	  di grado 
	  <math>p</math>, il vettore  <argname>a</argname> deve contenere 
	  <math>p</math> + 1 coefficienti in ordine crescente, &ie; partendo 
	  dalla costante e terminando con il coefficiente di 
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  Se tutte le radici sono reali vengono restituite in un vettore colonna
	  di lunghezza <math>p</math>; in caso contrario viene restituita una
	  matrice <by r="p" c="2"/> con la parte reale delle radici nella prima colonna
	  e la parte immaginaria nella seconda.
	</para>
      </description>
    </function>

    <function name="polyfit" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Interpola con il metodo dei polinomi ortogonali un trend
	  polinomiale di ordine <argname>q</argname> alla variabile <argname>y</argname> 
	  in input. La variabile contiene i valori interpolati.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">covmat</fnarg>
      </fnargs>
      <description>
	<para>
	  Sia data una matrice <argname>X</argname> sia <by r="T"
	  c="k"/> e contenente <math>T</math> osservazioni su
	  <math>k</math> variabili. L'argomento <argname>p</argname>
	  deve essere un intero positivo inferiore o uguale a
	  <math>k</math>. Questa funzione restituisce una matrice <by
	  r="T" c="p"/> <math>P</math>, contenente le prime
	  <math>p</math> componenti principali di
	  <argname>X</argname>.
	</para>
	<para>
	  Il terzo parametro è opzionale e ha l'effetto di una condizione logica:
	  se non nullo le componenti principali vengono calcolate
	  sulla base della matrice di covarianza delle colonne di <argname>X</argname>
	  (il default è usare la matrice di correlazione).
	</para>
	<para context="notex">
	  Gli elementi di <math>P</math> sono calcolati come la somma
	  da <math>i</math> a <math>k</math> di <math>Z</math><sub>ti</sub>
	  per <math>v</math><sub>ji</sub>, dove
	  <math>Z</math><sub>ti</sub> è il valore standardizzato della variabile 
	  <math>i</math> all'osservazione <math>t</math> e 
	  <math>v</math><sub>ji</sub> è l'autovettore <math>j</math> della
	  matrice di correlazione (o covarianza) delle <math>X</math><sub>i</sub>, 
	  con autovettori ordinati in ordine decrescente degli autovalori
	  corrispondenti.
	</para>
	<para context="tex">
	  Gli elementi di $P$ sono calcolati come 
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \] 
	  dove $Z_{ti}$ è il valore standardizzato della variabile 
	  $i$ all'osservazione $t$, $Z_{ti} = (X_{ti} -
	  \bar{X}_i) / \hat{\sigma}_i$, e $v^{(j)}$ è l'autovettore $j$
	  della matrice di correlazione (o covarianza) delle 
	  $X_i$, con autovettori ordinati in senso decrescente 
	  degli autovalori corrispondenti.
	</para>	
	<para>
	  <seelist>
	    <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il prodotto degli elementi di <argname>X</argname>,
	  per colonna.
	  <seelist>
	    <fncref targ="prodr"/>
	    <fncref targ="meanc"/>
	    <fncref targ="sdc"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il prodotto degli elementi di <argname>X</argname>,
	  per riga.
	  <seelist>
	    <fncref targ="prodc"/>
	    <fncref targ="meanr"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la deviazione standard campionaria per ciascuna
	  unità della cross-section della variabile <math>y</math>. Il denominatore
	  utilizzato è la numerosità campionaria per ciascuna unità meno 1, a meno
	  che il numero di osservazioni valide per l'unità in questione sia 1
	  (nel qual caso viene restituito uno zero) o 0 (nel qual caso viene 
	  <lit>NA</lit>).
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la deviazione standard campionaria per ciascuna
	  unità della cross-section della variabile <math>y</math>; in altre parole, 
	  \[ \sigma_i = \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} 
	  (y_{i,t} - \bar{y}_i)^2 } \]. La formula precedente
	  vale per $T_i\ge 2$, dove $T_i$ è il numero di osservazioni
	  valide per l'unità $i$; se $T_i = 0$, la funzione restituisce 
	  <lit>NA</lit>; se $T_i = 1$, la funzione restituisce 0.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni 
		corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  Nota: questa funzione rende possibile controllare se 
	  una certa variabile (per esempio <lit>X</lit>) è costante nel tempo usando la condizione
	  <lit>max(psd(X)) = 0</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola una variante generalizzata della scomposizione di
	  Cholesky della matrice <argname>A</argname>, che deve essere
	  semidefinita positiva (ma può essere singolare). Se la
	  matrice in input non è quadrata la funzione genera un
	  messaggio d'errore, ma la simmetria viene data per scontata,
	  e non viene verificata; la funzione legge solo il triangolo
	  inferiore di <argname>A</argname>.  Il risultato è una
	  matrice triangolare inferiore <math>L</math> che soddisfa la
	  condizione <equation status="inline" ascii="A = LL'" tex="$A
	  = LL'$"/>. Gli elementi indeterminati della soluzione
	  vengono posti pari a zero.
	</para>
	<para>
	  Nel caso in cui <argname>A</argname> sia definita positiva, v. 
	  <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce un vettore colonna 
	  contenente la prima osservazione valide della serie <argname>y</argname> 
	  per ciascuna unità in cross-section del panel all'interno
	  dell'intervallo campionario corrente. Le unità che non hanno nessuna 
	  osservazione valida per la serie in input vengono ignorate.
	</para>
	<para>
	  Questa funzione permette di compattare le variabili
	  create da funzioni come <fncref targ="pmax"/> e
	  <fncref targ="pmean"/>, che replicano per tutti i periodi temporali
	  un valore relativo a ogni unità della cross-section.
	</para>
      </description>
    </function>

    <function name="psum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente la somma
	  rispetto al tempo della variabile <argname>y</argname> per ogni unità
	  della cross-section, replicando per tutti i periodi i valori così ottenuti.
	  Nel calcolo delle somme le osservazioni mancanti vengono ignorate.
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la somma rispetto al tempo della
	  variabile <argname>y</argname> per ogni unità della cross-section;
	  in altre parole, 
	  \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\] 
	  dove $T_i$ è il numero di osservazioni valide per l'unità $i$.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni 
		corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pmax"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pxsum"/>
	    <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs> 
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  Calcola un <math>P</math>-value. Restituisce 
	  <equation status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>,
	  dove la distribuzione <math>X</math> è determinata dal carattere 
	  <argname>c</argname>. Fra gli argomenti 
	  <argname>c</argname> e <argname>x</argname> è necessario indicare 
	  zero o più argomenti aggiuntivi per specificare i parametri della 
	  distribuzione; v. <fncref targ="cdf"/> per ulteriori dettagli. 
	  Le distribuzioni che la funzione <lit>pval</lit> può gestire sono 
	  la normale standard, <math>t</math>, Chi quadrato, <math>F</math>,
	  gamma, binomiale e Poisson.
	</para>
	<para>
	  <seelist>
	    <fncref targ="critical"/>
	    <fncref targ="invcdf"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxsum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente 
	  la somma dei valori di <argname>y</argname> rispetto alle unità della
	  cross-section in ciascun periodo, replicando i valori
	  così ottenuti per ciascuna unità.
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la somma in cross-section della variabile
	  <argname>y</argname> in ciascun periodo; in altre parole, 
	  \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] 
	  dove $N$ è il numero di unità in cross-section.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni 
		corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  Si noti che questa funzione lavora lungo
	  una dimensione diversa da quella utilizzata dalla funzione 
	  <fncref targ="pmean"/>.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la forma quadratica <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>. L'uso di questa
	  funzione al posto della consueta moltiplicazione matriciale
	  garantisce maggiore velocità e accuratezza. Se le dimensioni
	  di <argname>x</argname> e <argname>A</argname> non sono
	  compatibili, o se <argname>A</argname> non è simmetrica
	  viene restituito un messaggio d'errore.
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce i quantili della normale standardizzata. Se
	  <argname>x</argname> non è fra 0 e 1, restituisce <lit>NA</lit>. 
	  <seelist>
	    <fncref targ="cnorm"/>
	    <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la scomposizione QR di una matrice <by r="m" c="n"/>
	  <argname>X</argname>, in altre parole <math>X = QR</math>
	  dove <math>Q</math> è una matrice ortogonale <by r="m"
	  c="n"/> e <math>R</math> è una matrice triangolare superiore
	  <by r="n" c="n"/>. La matrice <math>Q</math> viene
	  restituita direttamente, mentre <math>R</math> può essere
	  recuperata usando il secondo argomento opzionale.
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigengen"/>
	    <fncref targ="eigensym"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">type</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice <by r="n" c="2"/> da usare per la
	  quadratura di Gauss (integrazione numerica). La prima
	  colonna contiene i nodi o ascisse, la seconda colonna
	  contiene i pesi.
	</para>
	<para>
	  Il primo argomento specifica il numero dei punti (righe) da
	  calcolare. Il secondo argomento specifica il codice del tipo
	  di quadratura da utilizzare: 1 Gauss&ndash;Hermite
	  (predefinita); 2 Gauss&ndash;Legendre; 3
	  Gauss&ndash;Laguerre. Il significato dei parametri opzionali
	  <argname>a</argname> e <argname>b</argname> dipende dal
	  <argname>tipo</argname> selezionato, come spiegato sotto.
	</para>
	<para context="notex">
	  La quadratura di Gauss è un metodo per l'approssimazione
	  numerica di un integrale definito di una qualche funzione di
	  interesse. Si rappresenti la funzione come il prodotto
	  <math>f(x)W(x)</math>. I diversi tipi di quadratura
	  differiscono nella specificazione della componente
	  <math>W(x)</math>: nel caso di Hermite questa è uguale a
	  exp(&minus;<math>x</math><sup>2</sup>); nel caso di
	  Laguerre, è data da exp(&minus;<math>x</math>); infine, nel
	  caso di Legendre, si ha semplicemente <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  La quadratura di Gauss è un metodo di approssimazione
	  numerica di un integrale definito di una qualche funzione di
	  interesse. Si rappresenti la funzione come il prodotto
	  $f(x)W(x)$. I diversi tipi di quadratura differiscono nella
	  specificazione della componente $W(x)$: nel caso di Hermite
	  abbiamo $W(x) = \exp(-x^2)$; nel caso di Laguerre, $W(x) =
	  \exp(-x)$; nel caso di Legendre, semplicemente $W(x) = 1$.
	</para>
	<para context="notex">
	  Per ciascuna specificazione di <math>W</math>, si può
	  calcolare un insieme di nodi, <math>x</math><sub>i</sub>, e
	  pesi, <math>w</math><sub>i</sub>, tali che la somma da
	  <math>i</math>=1 a <math>n</math> di
	  <math>w</math><sub>i</sub><math>f</math>(<math>x</math><sub>i</sub>)
	  approssima l'integrale desiderato. È usato il metodo di
	  <cite key="golub69">Golub and Welsch (1969)</cite>.
	</para>
	<para context="tex">
	  Per ciascuna specificazione di $W(x)$, si può calcolare un
	  insieme di nodi, $x_i$, e pesi, $w_i$, tali che
	  $\sum_{i=1}^n f(x_i) w_i$ approssima l'integrale
	  desiderato. È usato il metodo di <cite key="golub69">Golub
	  and Welsch (1969)</cite>.
	</para>
	<para context="notex">
	  Quando si seleziona il metodo di Gauss&ndash;Legendre, gli
	  argomenti opzionali <argname>a</argname> e
	  <argname>b</argname> possono essere utilizzati per
	  controllare i limiti, inferiore e superiore, di
	  integrazione, i valori predefiniti sono &minus;1 e
	  1. (Nella quadratura di Hermite i limiti sono fissati a meno
	  e più infinito, mentre in quella di Laguerre sono fissati a
	  0 e infinito.)
	</para>
	<para context="tex">
	  Quando si seleziona il metodo di Gauss&ndash;Legendre, gli
	  argomenti opzionali <argname>a</argname> e
	  <argname>b</argname> possono essere utilizzati per
	  controllare i limiti, inferiore e superiore, di
	  integrazione, i valori predefiniti sono $-1$ e 1. (Nella
	  quadratura di Hermite i limiti sono fissati a $-\infty$ e
	  $+\infty$, mentre in quella di Laguerre sono fissati a 0 e
	  $\infty$.)
	</para>
	<para context="notex">
	  Nella quadratura di Hermite <argname>a</argname> e
	  <argname>b</argname> svolgono un ruolo differente: possono
	  essere utilizzati per sostituire la forma predefinita di
	  <math>W</math>(<math>x</math>) con la distribuzione normale
	  (strettamente associata) con media <argname>a</argname> e
	  deviazione standard <argname>b</argname>. Per esempio,
	  fornire valori 0 e 1 per questi parametri ha l'effetto di
	  trasformare <math>W</math>(<math>x</math>) nella funzione di
	  densità di una normale standard, il che è equivalente a
	  moltiplicare i nodi predefiniti per la radice quadrata di 2
	  e dividere i pesi per la radice quadrata di &pi;.
	</para>
	<para context="tex">
	  Nella quadratura di Hermite <argname>a</argname> e
	  <argname>b</argname> svolgono un ruolo differente: possono
	  essere utilizzati per sostituire la forma predefinita di
	  $W(x)$ con la distribuzione normale (strettamente associata)
	  con media <argname>a</argname> e deviazione standard
	  <argname>b</argname>. Per esempio, fornire valori 0 e 1 per
	  questi parametri ha l'effetto di trasformare $W(x)$ nella
	  funzione di densità di una normale standard, il che è
	  equivalente a moltiplicare i valori predefiniti $x_i$ per
	  $\sqrt{2}$ e dividere i pesi $w_i$ predefiniti per
	  $\sqrt{\pi}$.
	</para>
      </description>
    </function>    

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="pscalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>y</argname> è una serie, restituisce il suo
	  <argname>p</argname>-esimo quantile. Ad esempio, se
	  <math>p</math> = 0.5, si avrà la mediana. 
	</para>
	<para>
	  Se l'argomento è invece una matrice, restituisce un vettore riga
	  contenente i <argname>p</argname>-esimi quantili per le
	  colonne di <argname>y</argname>; in pratica, ogni colonna è
	  trattata come se fosse una serie.
	</para>
	<para>
	  Inoltre, se <argname>y</argname> è una matrice, si può usare
	  una forma alternativa del secondo argomento:
	  <argname>p</argname> può essere un vettore. In tal caso, il
	  valore restituito è una matrice <by r="m" c="n"/>, dove
	  <repl>m</repl> è il numero di elementi in
	  <argname>p</argname> e <repl>n</repl> il numero di colonne
	  di <argname>y</argname>.
	</para>
	<para context="tex">
	  Per una serie di lunghezza $n$, il $p$-quantile, $q$, è
	  definito come: \[q = y_{[k]} + [(n+1) \cdot p - k] (y_{[k+1]} -
	  y_{[k]})\] dove $k$ è la parte intera di $(n+1) \cdot p$ e
	  $y_{[i]}$ è l'elemento $i$-esimo della serie ordinata in
	  senso crescente.
	</para>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-series">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  Generatore di numeri casuali. L'argomento
	  <argname>d</argname> è una stringa (nella maggior parte dei
	  casi semplicemente un singolo carattere) che specifica la
	  distribuzione da cui i numeri pseudo-casuali sono
	  estratti. Gli argomenti da <argname>p1</argname> a
	  <argname>p3</argname> specificano i parametri della
	  distribuzione selezionata. Il numero di tali parametri
	  dipende dalla distribuzione. Per le distribuzioni diverse
	  dalla beta-binomiale, i parametri <argname>p1</argname> e
	  (se applicabile) <argname>p2</argname> devono essere scalari
	  o serie: se sono scalari, la serie generata è identicamente
	  distribuita; se al contrario almeno uno dei due parametri in
	  ingresso è una serie, per ciascuna osservazione la
	  distribuzione è condizionata al valore dei parametri
	  corrispondenti. Nel caso della beta-binomiale tutti i
	  parametri devono essere scalari.
	</para>
	<para>
	  Le specifiche sono fornite sotto: il codice stringa per ogni
	  distribuzione è mostrato fra parentesi, seguito
	  dall'interpretazione dell'argomento <argname>p1</argname> e,
	  laddove applicabile, <argname>p2</argname> e
	  <argname>p3</argname>.
	</para>
	  
	<ilist context="notex">
	  <li>
	    <para>
	      Uniforme (continua) (u o U): minimo, massimo
	    </para>
	  </li>
	  <li>
	    <para>
	      Uniforme (discreta) (i): minimo, massimo
	    </para>
	  </li>
	  <li>
	    <para>
	      Normale (z, n, o N): media, deviazione standard
	    </para>
	  </li>
	  <li>
	    <para>
	      t di Student (t): gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      Chi quadro (c, x, o X): gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      F di Snedecor (f o F): gradi di libertà (num.), gradi di libertà (den.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Gamma (g o G): forma, scala
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Binomiale (b o B): probabilità, numero di prove
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Poisson (p o P): media
	    </para>
	  </li>	
	  <li>
	    <para>
	      Weibull (w o W): forma, scala
	    </para>
	  </li>	
	  <li>
	    <para>
	      Generalized Error (E): forma
	    </para>
	  </li>
	  <li>
	    <para>
	      Beta (beta): parametro 1, parametro 2
	    </para>
	  </li>
	  <li>
	    <para>
	      Beta-Binomiale (bb): prove, parametro 1, parametro 2
	    </para>
	  </li>
	</ilist>
	<para context="tex">
	  \begin{center}
	  \begin{tabular}{lllll}
	  \textbf{Distribuzione} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniforme (continua) &amp; \texttt{u} o \texttt{U} &amp; minimo &amp; massimo &amp; --\\
	  Uniforme (discreta) &amp; \texttt{i} &amp; minimo &amp; massimo &amp; --\\
	  Normale &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp; media &amp; deviazione standard &amp; --\\
	  $t$ di Student &amp; \texttt{t} &amp; gradi di libertà &amp; -- &amp; --\\
	  Chi quadro &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp; gradi di libertà &amp; -- &amp; --\\
	  $F$ di Snedecor &amp; \texttt{f} o \texttt{F} &amp; gradi di libertà (num.) &amp; gradi di libertà (den.) &amp; --\\
	  Gamma &amp; \texttt{g} o \texttt{G} &amp; forma &amp; scala &amp; --\\
	  Binomiale &amp; \texttt{b} o \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} o \texttt{P} &amp; media &amp; --  &amp; --\\
	  Weibull &amp; \texttt{w} o \texttt{W} &amp; forma &amp; scala &amp; --\\
	  Generalized Error &amp; \texttt{e} o \texttt{E} &amp; forma &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; parametro 1 &amp; parametro 2 &amp; --\\
	  Beta-Binomiale &amp; \texttt{bb} &amp; $n$ &amp; parametro 1 &amp; parametro 2
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  <seelist>
	    <fncref targ="normal"/>
	    <fncref targ="uniform"/> 
	    <fncref targ="mrandgen"/>
	    <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Funziona come <fncref targ="randgen"/> eccetto per il fatto
	  che il valore restituito è uno scalare invece di una serie.
	</para>
	<para>
	  Il primo esempio sopra restituisce un valore da una
	  distribuzione normale standard, mentre il secondo
	  restituisce un valore estratto da una distribuzione Gamma
	  con parametro di forma 3 e parametro di scala 2.5.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un numero intero pseudo-casuale nell'intervallo
	  chiuso [<argname>min</argname>, <argname>max</argname>].
	  <seelist>
	  <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il rango di <argname>X</argname>, calcolato per
	  via numerica attraverso la decomposizione ai valori
	  singolari (SVD).
	  <seelist> 
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una serie con i ranghi di <math>y</math>. Il
	  rango di un'osservazione <math>i</math> è pari al numero di
	  elementi della serie minori di <math>y</math><sub>i</sub>
	  più un mezzo il numero di elementi della serie uguali a
	  <math>y</math><sub>i</sub>. (Intuitivamente, è possibile
	  pensare al punteggio negli scacchi, dove per ogni vittoria
	  si assegna un punto, mentre per ogni patta si assegna mezzo
	  punto.) Al numero così calcolato si aggiunge uno, cosicché
	  al rango più basso è associato 1 invece di 0.
	</para>
	<para context="tex">
	  In termini formali, 
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[ 
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \] 
	  dove $I$ è la funzione indicatrice.
	</para>
	<para>
	  <seelist>
	    <fncref targ="sort"/>
	    <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il reciproco del numero di condizionamento
	  rispetto alla norma-1 di <argname>A</argname>, che deve
	  essere simmetrica e definita positiva. In molte circostanze,
	  questa è una misura migliore del determinante circa la
	  sensibilità di <argname>A</argname> a operazioni numeriche
	  come l'inversione.
	</para>
	<para context="notex">
	  Il valore è calcolato come il reciproco del prodotto della
	  norma-1 di <argname>A</argname> per la norma-1 dell'inversa
	  di <argname>A</argname>.
	</para>
	<para context="tex">
	  Poiché <math>A</math> è invertibile, è possibile definire 
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\] 
	  Questa funzione restituisce $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
	    <fncref targ="det"/>
	    <fncref targ="ldet"/>
	    <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg type="string" optional="true">codeset</fnarg>
      </fnargs>    
      <description>
	<para>
	  Se un file di nome <argname>fname</argname> esiste ed è
	  leggibile, restituisce una stringa con il contenuto del
	  file. In caso contrario restituisce un errore.
	</para>
	<para>
	  Nel caso in cui <argname>fname</argname> inizia con
	  l'identificatore di un protocollo internet supportato
	  (<lit>http://</lit>, <lit>ftp://</lit>,
	  <lit>https://</lit>), la funzione richiama libcurl per
	  scaricare la risorsa.
	</para>
	<para>
	  Se il testo da leggere non ha una codifica UTF-8, gretl
	  cerca di ricodificarlo a partire dalla codifica locale, nel
	  caso non sia UTF-8, o da ISO-8859-15 in caso contrario. Se
	  questo comportamento predefinito non si adatta alle vostre
	  esigenze, è possibile utilizzare il secondo argomento
	  opzionale per specificare la codifica. Per esempio, nel caso
	  si vuole leggere un testo nella codifica Microsoft codepage
	  1251, e questo non è il sistema in uso in locale, è
	  possibile fornire come secondo argomento
	  <lit>"cp1251"</lit>.
	</para>
	<para>
	  Si vedano anche le funzioni <fncref targ="sscanf"/> e
	  <fncref targ="getline"/>.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">match</fnarg>
	<fnarg type="string">repl</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui tutte
	  le occorrenze del tipo <argname>match</argname> sono
	  sostituite con <argname>repl</argname>. Gli argomenti
	  <argname>match</argname> e <argname>repl</argname> sono
	  interpretati come espressioni regolari in stile Perl.
	</para>
	<para>
	  Si veda anche <fncref targ="strsub"/> per semplici
	  sostituzioni di stringhe letterali.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>    
      <description>
	<para>
	  Se il file <argname>fname</argname> esiste e l'utente ha i
	  permessi di scrittura, lo cancella. Restituisce 0 se il comando
	  è andato a buon fine, non-zero se il file non esiste o non
	  può essere cancellato.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">find</fnarg>
	<fnarg type="scalar-or-vec">subst</fnarg>
      </fnargs>    
      <description>
	<para>
	  Sostituisce ogni elemento di <argname>x</argname> uguale
	  all'<math>i</math>-esimo elemento di <argname>find</argname>
	  con il corrispondente elemento di <argname>subst</argname>.
	</para>
	<para>
	  Se <argname>find</argname> è uno scalare, anche
	  <argname>subst</argname> deve essere uno scalare. Se
	  <argname>find</argname> e <argname>subst</argname> sono
	  entrambi vettori, devono avere lo stesso numero di
	  elementi. Se infine <argname>find</argname> è un vettore e
	  <argname>subst</argname> uno scalare, tutte le
	  corrispondenze saranno sostituite con
	  <argname>subst</argname>.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  find = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, find, subst)
	  print a b
	</code>
	<para>
	  genera
	</para>
	<code>
          a (2 x 3)
           
            1   2   3 
            3   4   5 
           
          b (2 x 3)
           
            -1    2   -8 
            -8    0    5 
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">b</fnarg>
      </fnargs>    
      <description>
	<para>
	  Ricampiona da <argname>x</argname> con reintroduzione. Nel
	  caso in cui l'argomento sia una serie, ciascun valore della
	  serie restituita, <math>y</math><sub>t</sub>, è estratto da
	  tutti i valori di <math>x</math><sub>t</sub> con uguale
	  probabilità. Quando l'argomento è una matrice, ciascuna riga
	  della matrice restituita è estratta dalle righe di
	  <argname>x</argname> con uguale probabilità.
	</para>
	<para>
	  L'argomento opzionale <argname>b</argname>, che deve essere
	  un numero intero maggiore o uguale a 2, indica la lunghezza
	  del blocco nel ricampionamento a blocchi mobili (moving
	  blocks). L'effetto è che l'output generato è il risultato di
	  un'estrazione casuale con reintroduzione dall'insieme di
	  tutte le possibili sequenze contigue di lunghezza
	  <argname>b</argname> nell'input. (Nel caso l'input sia una
	  matrice, i blocchi estratti sono sequenze contigue di righe
	  della matrice.) Se la lunghezza dei dati non è un multiplo
	  della lunghezza del blocco, l'ultimo blocco estratto è
	  troncato per adattarlo.
	</para>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Approssima all'intero più vicino. Si noti che, quando
	  <math>x</math> si trova esattamente nel mezzo tra due numeri
	  interi, la funzione restituisce l'intero più distante da
	  zero. Così, per esempio, 2.5 è approssimato a 3, ma
	  <lit>round(-3.5)</lit> restituisce &minus;4. Questa è la
	  convenzione di solito seguita nei fogli di calcolo, anche se
	  altri programmi possono seguire convenzioni diverse.
	  <seelist>
	    <fncref targ="ceil"/>
	    <fncref targ="floor"/>
	    <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rownames" section="matbuild" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="list-or-string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Attribuisce dei nomi alle righe della matrice
	  <argname>M</argname>. Se <argname>s</argname> è una lista, i
	  nomi sono copiati da quelli delle variabili; la lista deve
	  avere tanti elementi quante sono le righe di
	  <argname>M</argname>. Se <argname>s</argname> è una stringa,
	  deve contenere un numero appropriato di sub-stringhe
	  separate da spazi.  Restituisce 0 se la funzione è andata a
	  buon fine, non-zero altrimenti. Si veda anche <fncref
	  targ="colnames"/>.
	</para>
	<para>
	  Esempio:
	</para>
    <code>
      matrix M = {1,2;2,1;4,1} 
      rownames(M, "Row1 Row2 Row3")
      print M      
    </code>
	  </description>
    </function>

    <function name="rows" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di righe della matrice
	  <argname>X</argname>.
	  <seelist>
	    <fncref targ="cols"/>
	    <fncref targ="mshape"/>
	    <fncref targ="unvech"/> 
	    <fncref targ="vec"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Se <argname>x</argname> è una serie, restituisce l'errore
	  quadratico medio campionario (scalare), saltando i valori
	  mancanti.
	</para>
	<para>
	  Se, invece, <argname>x</argname> è una lista, restituisce
	  una serie <math>y</math> tale per cui
	  <math>y</math><sub>t</sub> l'errore quadratico medio delle
	  variabili nella lista all'osservazione <math>t</math>, o
	  <lit>NA</lit> se ci sono dei valori mancanti <math>t</math>.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce le deviazioni standard delle colonne di
	  <argname>X</argname>. Se <argname>df</argname> è positivo, è
	  utilizzato come divisore nel calcolo delle varianze delle
	  colonne, in caso contrario il divisore utilizzato è il
	  numero di righe di <argname>X</argname> (e quindi, non viene
	  applicata nessuna correzione per i gradi di libertà).
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>   
      <description>
	<para>
	  Calcola le differenze stagionali: <equation status="inline"
	  ascii="y(t) - y(t-k)" tex="$y_t - y_{t-k}$"/>, dove
	  <math>k</math> è la periodicità del dataset corrente (si
	  veda <fncref targ="$pd"/>). I valori iniziali sono fissati a
	  <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="selifc" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>   
      <description>
	<para>
	  Seleziona da <argname>A</argname> solo le colonne per le
	  quali l'elemento corrispondente di <argname>b</argname> è
	  non-zero. <argname>b</argname> deve essere un vettore riga
	  con lo stesso numero di colonne di <argname>A</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>   
      <description>
	<para>
	  Seleziona da <argname>A</argname> solo le righe per le quali
	  l'elemento corrispondente di <argname>b</argname> è
	  non-zero. <argname>b</argname> deve essere un vettore
	  colonna con lo stesso numero di righe di
	  <argname>A</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matbuild" output="rvec">
      <fnargs>
	<fnarg type="int">a</fnarg>
	<fnarg type="int">b</fnarg>
	<fnarg optional="true" type="int">k</fnarg>
      </fnargs>   
      <description>
	<para>
	  Con due soli argomenti, restituisce un vettore riga pieno di
	  interi consecutivi, con <argname>a</argname> come primo
	  elemento e <argname>b</argname> come ultimo. Se
	  <argname>a</argname> è maggiore di <argname>b</argname>, la
	  sequenza sarà decrescente. L'eventuale parte non intera
	  viene ignorata per entrambi gli argomenti.
	</para>
	<para>
	  In caso sia presente il terzo argomento, la funzione
	  restituisce un vettore riga contenente una sequenza di
	  interi che inizia con <argname>a</argname> ed è incrementata
	  (o diminuita, nel caso in cui <argname>a</argname> sia
	  maggiore di <argname>b</argname>) di <argname>k</argname> in
	  ciascun passaggio. Il valore finale è il più grande elemento
	  della sequenza minore o uguale a <argname>b</argname> (o
	  mutatis mutandis, nel caso in cui <argname>a</argname> sia
	  maggiore di <argname>b</argname>). L'argomento
	  <argname>k</argname> deve essere positivo; nel caso non sia
	  un intero la parte decimale è ignorata.
	</para>
	<para>
	  <seelist>
	    <fncref targ="ones"/>
	    <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
	<fnarg type="string">note</fnarg>
      </fnargs>   
      <description>
	<para>
	  Imposta una nota descrittiva per l'oggetto identificato
	  dalla chiave <argname>key</argname> nel bundle
	  <argname>b</argname>.  Essa verrà mostrata quando il comando
	  <lit>print</lit> viene applicato al bundle. Questa funzione
	  restituisce 0 se è andata a buon fine e non-zero in caso
	  contrario (ad esempio, se nel bundle <argname>b</argname> la
	  chiave <argname>key</argname> non c'è).
	</para>
      </description>
    </function>    

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Implementa il simulated annealing (letteralmente "ricottura
	  simulata", che prende il nome dal processo di ricottura
	  utilizzato per migliorare le caratteristiche delle leghe
	  metalliche), che può essere utile nel migliorare
	  l'inizializzazione nei problemi di ottimizzazione numerica.
	</para>
	<para>
	  Il primo argomento deve contenere il valore iniziale di un
	  vettore di parametri. Il secondo argomento specifica la
	  funzione da chiamare e che restituisce il valore (scalare)
	  da massimizzare. Il terzo argomento, opzionale, specifica il
	  massimo numero di iterazioni (il valore predefinito è
	  1024). In caso di successo, <lit>simann</lit> restituisce il
	  valore finale del massimando.
	</para>
	<para>
	  Per maggiori dettagli ed esempi si veda il capitolo sui
	  metodi numerici in <guideref targ="chap-numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
	    <fncref targ="NRmax"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>       
      <description>
	<para>
	  Funzione seno.  
	  <seelist>
	    <fncref targ="cos"/>
	    <fncref targ="tan"/>
	    <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il seno iperbolico di <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="asinh"/>
	    <fncref targ="cosh"/>
	    <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il valore di asimmetria per la serie
	  <argname>x</argname>, non considerando le osservazioni
	  mancanti.
	</para>
      </description>
    </function>

    <function name="sort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Ordina <argname>x</argname> in senso crescente, non
	  considerando le osservazioni mancanti nel caso in cui
	  <math>x</math> sia una serie.
	  <seelist>
	    <fncref targ="dsort"/>
	    <fncref targ="values"/>
	  </seelist>
	  In particolare, per le matrici si veda <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>     
      <description>
	<para>
	  Restituisce una serie contenente gli elementi di
	  <argname>y2</argname> ordinati per valore crescente del
	  primo argomento, <argname>y1</argname>.
	  <seelist>
	    <fncref targ="sort"/>
	    <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Radice quadrata di <argname>x</argname>; genera
	  <lit>NA</lit> in caso di valori negativi.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string">src</fnarg>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>  
      <description>
      <para>
        Analizza una <repl>stringa</repl> seguendo il
        <repl>formato</repl> indicato, assegnando zero o più valori
        agli <repl>argomenti</repl> indicati. È una versione
        semplificata della funzione <lit>sscanf</lit> del linguaggio
        di programmazione C, e restituisce il numero di valori assegnati.
      </para>
      <para>
        La <repl>stringa</repl> può essere una stringa vera e propria,
	racchiusa tra virgolette doppie, o il nome di una variabile stringa
	predefinita. Il <repl>formato</repl> è definito in modo simile alla
	stringa di formato del comando <cmdref targ="printf"/> (si veda
	oltre). Gli <repl>argomenti</repl> sono una lista separata da virgole
	che contiene i nomi di variabili predefinite che verranno assegnate a
	seconda dei valori letti dalla <repl>stringa</repl>. Per chi conosce
	il C: è possibile prefissare con <lit>&amp;</lit> i nomi delle
	variabili numeriche, ma non è richiesto.
      </para>
      <para>
	Le regole specificate nel <repl>formato</repl> vengono usate per
        analizzare la <repl>stringa</repl>. Le specifiche iniziano con un
        carattere <lit>%</lit>, e comprendono
        <lit>%f</lit>, <lit>%g</lit> o <lit>%lf</lit> per i numeri a virgola
        mobile; <lit>%d</lit> per gli interi; <lit>%s</lit> per le stringhe, e
	<lit>%m</lit> per le matrici. È possibile inserire un numero intero
        positivo dopo il carattere percento, per impostare il numero massimo di
        caratteri da leggere per ogni tipo di specifica (o il massimo numero di
        righe nel caso di conversione in matrici). In alternativa è possibile
        inserire un carattere <lit>*</lit> dopo il percento per sopprimere la
        conversione di un certo numero di caratteri della stringa. Ad esempio,
	<lit>%3d</lit> converte i 3 caratteri successivi della <repl>stringa</repl>
        in un numero intero, se possibile; <lit>%*g</lit> salta tutti i caratteri
        nella <repl>stringa</repl> che potrebbero essere convertiti in un numero
        a virgola mobile.
      </para>
      <para>
	La conversione in matrici funziona nel modo seguente: viene letta ogni
        riga dell'input e vengono contati i campi numerici (separati da spazi o
        tab). In questo modo viene definito il numero di colonne della matrice.
        Vengono quindi lette tutte le righe seguenti che contengono lo stesso
        numero di colonne numeriche; è anche possibile limitare il numero
        massimo di righe da leggere.
      </para>
      <para>
        Oltre alla conversione <lit>%s</lit> per le stringhe, è disponibile
        anche una versione semplificata del formato C
        <lit>%</lit><repl>N</repl><lit>[</lit><repl>caratteri</repl><lit>]</lit>.
        In questo formato, <repl>N</repl> è il numero massimo di caratteri da
        leggere, e <repl>caratteri</repl> è un insieme di caratteri accettabili,
        racchiusi tra parentesi quadre; la lettura si ferma se si raggiunge il
        limite di <repl>N</repl> o se si incontra un carattere non compreso
        nell'insieme ammissibile. La funzione dell'insieme
	<repl>caratteri</repl> può essere invertita specificando un accento
        circonflesso <lit>^</lit> come primo carattere dell'insieme; in questo
        caso, la lettura si ferma se si incontra un carattere dell'insieme
        specificato. Al contrario del C, il carattere trattino non ha alcuna
        funzione speciale in questo contesto.
      </para>
      <para>
	Se la stringa non corrisponde esattamente al formato specificato, il
        numero di conversioni effettuate può risultare diverso dal numero di
        argomenti indicati. Per gretl questo non è necessariamente un errore,
        tuttavia può essere utile voler controllare questa corrispondenza; è
        possibile farlo usando la variabile scalare interna
	<lit>$nscan</lit>, il cui valore viene aggiornato ogni volta che si
        usa <lit>sscanf</lit>. In caso di uso interattivo viene mostrato anche
        il numero di conversioni effettuate.
      </para>
      <para>
	Ecco alcuni esempi:
      </para>
	<code>
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)

	  sprintf S, "1 2 3 4\n5 6 7 8"
	  S
	  matrix m
	  sscanf(S, "%m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>  
      <description>
	<para>
	  Somma dei quadrati degli scarti dalla media per le
	  osservazioni valide nella serie <argname>y</argname>.
	  <seelist> 
	    <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce il numero di caratteri in
	  <argname>s</argname>. Si note che questo può non coincidere
	  col numero di byte, se ne lla stringa siano presenti
	  caratteri al di fuori del campo ASCII stampabile (ad
	  esempio, lettere accentate).
	</para>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>  
      <description>
	<para>
	  Compara le due stringhe fornite come argomenti e restituisce
	  un intero minore, uguale, o maggiore di zero se
	  <argname>s1</argname> risulta, rispettivamente, essere
	  minore, combaciare, o essere maggiore di
	  <argname>s2</argname>, fino ai primi <argname>n</argname>
	  caratteri.  Se <argname>n</argname> è omesso, la
	  comparazione procede fin dove possibile.
	</para>
	<para> 
	  Si noti che, nel caso in cui si voglia comparare due
	  stringhe per verificarne l'uguaglianza, questo può essere
	  fatto senza utilizzare alcuna funzione, come in <lit>if (s1
	  == s2) ...</lit>
	</para>
      </description>
    </function>
    <function name="strsplit" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="int">i</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce l'elemento separato da spazio
	  <argname>i</argname>-esimo della stringa
	  <argname>s</argname>. L'indice <argname>i</argname> è a base
	  1, e la funzione genera un errore se <argname>i</argname> è
	  minore di 1. Nel caso in cui <argname>s</argname> non
	  contenga spazi e <argname>i</argname> è uguale ad 1, la
	  funzione restituisce una copia dell'intera stringa in
	  ingresso. Nel caso in cui <argname>i</argname> eccede il
	  numero degli elementi separati da spazio la funzione
	  restituisce una stringa vuota.
	</para>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>  
      <description>
	<para>
	  Ricerca <argname>s1</argname> per trovare un'occorrenza
	  della stringa <argname>s2</argname>.  Nel caso venga trovata
	  una corrispondenza, la funzione restituisce una copia della
	  porzione di <argname>s1</argname> che inizia con
	  <argname>s2</argname>; in caso contrario, la funzione
	  restituisce una stringa vuota.
	</para>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce una copia dell'argomento <argname>s</argname> da
	  cui sono stati rimossi gli spazi bianchi iniziali e finali.
	</para>
      </description>
    </function>

    <function name="strsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">find</fnarg>
	<fnarg type="string">subst</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui tutte
	  le occorrenze di <argname>find</argname> sono sostituite con
	  <argname>subst</argname>.
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="int">ini</fnarg>
	<fnarg type="int">fin</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce una sottostringa di <argname>s</argname>, dal
	  carattere <argname>ini</argname> al carattere
	  <argname>fin</argname>, compresi. L'indicizzazione è su base
	  1.
	</para>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Se <argname>x</argname> è una serie, restituisce la somma
	  (scalare) delle osservazioni valide nella serie
	  <argname>x</argname>. Si veda anche <fncref targ="sumall"/>.
	</para>
	<para>
	  Se <argname>x</argname> è una matrice, restituisce la somma
	  degli elementi della matrice.
	</para>	
	<para>
	  Se <argname>x</argname> è una lista, restituisce una serie
	  <math>y</math> tale che <math>y</math><sub>t</sub> è la
	  somma dei valori delle variabili nella lista
	  all'osservazione <math>t</math>, o <lit>NA</lit> se ci sono
	  valori mancanti a <math>t</math>.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Restituisce la somma delle osservazioni di
	  <argname>x</argname> nel campione corrente, o <lit>NA</lit>
	  se ci sono valori mancanti.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>     
      <description>
	<para>
	  Restituisce le somme per colonna di <argname>X</argname>.
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce le somme per riga di <argname>X</argname>.
	  <seelist> 
	    <fncref targ="meanr"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Esegue la scomposizione a valori singolari (SVD) della
	  matrice <argname>X</argname>.
	</para>
	<para context="tex">
	  Esegue la scomposizione a valori singolari (SVD) della
	  matrice $r \times c$ $X$:
	  \[ X = U \left[
	  \begin{array}{cccc} 
	  \sigma_1 \\ 
	  &amp; \sigma_2 \\ 
	  &amp; &amp; \ddots \\ 
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \] 
	  dove $n = \min(r,c)$. $U$ è $r \times n$ e $V$ è $n \times c$, con $U'U = I$ e $VV' = I$.
	</para>
	<para>
	  I valori singolari sono restituiti in un vettore riga.  I
	  vettori singolari sinistri e/o destri <math>U</math> e
	  <math>V</math> possono essere ottenuti fornendo valori
	  non-nulli per, rispettivamente, gli argomenti 2 e 3. Per una
	  matrice <lit>A</lit>, il codice
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V) 
	  B = (U .* s) * V
	</code>
	<para>
	  dovrebbe generare <lit>B</lit> identica ad <lit>A</lit> (precisione numerica a parte).
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigengen"/>
	    <fncref targ="eigensym"/>
	    <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione tangente
	  <seelist>
	    <fncref targ="atan"/>
	    <fncref targ="cos"/>
	    <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la tangente iperbolica di <argname>x</argname>. 
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="atanh"/>
	    <fncref targ="cosh"/>
	    <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Risolve un sistema di Toeplitz di equazioni lineari, cioè
	  <math>Tx = b</math> dove <math>T</math> è una matrice
	  quadrata il cui elemento <math>T</math><sub>i,j</sub> è
	  uguale a <math>c</math><sub>i-j</sub> per <equation
	  status="inline" ascii="i&gt;=j" tex="$i\ge j$"/> e a
	  <math>r</math><sub>j-i</sub> per <equation status="inline"
	  ascii="i&lt;=j" tex="$i\le j$"/>. Si noti che i primi
	  elementi di <math>c</math> e <math>r</math> devono essere
	  uguali. In caso contrario la funzione restituisce un
	  errore. In caso di successo, la funzione restituisce il
	  vettore <math>x</math>.
	</para>
	<para>
	  L'algoritmo usato sfrutta la speciale struttura della
	  matrice <math>T</math>, che lo rende molto più efficiente di
	  altri algoritmi meno specifici, specialmente per sistemi di
	  grandi dimensioni. Attenzione: in certi casi, la funzione
	  può restituire un errore di singolarità anche se la matrice
	  <math>T</math> non sia effettivamente singolare; questo
	  problema tuttavia non si presenta quando <math>T</math> è
	  definita positiva.
	</para>
      </description>
    </function>

    <function name="tolower" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui ogni
	  lettera maiuscola è convertita in minuscola.
	</para>
      </description>
    </function>

    <function name="toupper" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui ogni
	  lettera minuscola è convertita in maiuscola.
	</para>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce la traccia della matrice <argname>A</argname>,
	  ovvero la somma degli elementi lungo la diagonale.
	  <seelist> 
	    <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>      
      <description>
	<para>
	  Trasposizione di matrice. Si noti che, al fine di ottenere
	  la trasposta di una matrice, nella maggior parte dei casi è
	  possibile utilizzare l'operatore apice: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trimr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">ttop</fnarg>
	<fnarg type="int">tbot</fnarg>
      </fnargs>   
      <description>
	<para>
	  Restituisce una matrice che è una copia di
	  <argname>X</argname> con <argname>ttop</argname> righe
	  eliminate partendo dall'alto e <argname>tbot</argname> righe
	  eliminate partendo dal basso. Gli ultimi due argomenti
	  devono essere non-negativi e la somma dei due deve essere
	  minore del numero totale di righe di <argname>X</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">typecode</fnarg>
      </fnargs>      
      <description>
	<para>
	  Restituisce il nome del tipo di dati di gretl corrispondente
	  a <argname>typecode</argname>. È utilizzata insieme alla
	  funzione <fncref targ="inbundle"/>. Il valore restituito è:
	  <quote>scalar</quote>, <quote>series</quote>,
	  <quote>matrix</quote>, <quote>string</quote>,
	  <quote>bundle</quote> o <quote>null</quote>.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>     
      <description>
	<para>
	  Genera una serie di numeri pseudo-casuali uniformi
	  nell'intervallo (<argname>a</argname>,
	  <argname>b</argname>), oppure, in assenza di argomenti,
	  nell'intervallo (0,1). L'algoritmo usato è il Mersenne
	  Twister di Matsumoto e Nishimura (1998).
	</para>
	<para>
	  <seelist>
	    <fncref targ="randgen"/>
	    <fncref targ="normal"/>
	    <fncref targ="genpois"/>
	    <fncref targ="mnormal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Restituisce un vettore che contiene gli elementi distinti di
	  <argname>x</argname>, non ordinati ma nell'ordine in cui
	  compaiono. Si veda <fncref targ="values"/> per una variante
	  che ordina gli elementi.
	</para>
      </description>
    </function>

    <function name="unvech" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>      
      <description>
	<para>
	  Restituisce una matrice simmetrica <by r="n" c="n"/>
	  ottenuta riordinando gli elementi di <math>v</math>. Il
	  numero di elementi in <math>v</math> deve essere un intero
	  triangolare, ossia un numero <math>k</math> che può essere
	  scritto come <equation status="inline" ascii="k = n(n+1)/2"
	  tex="$k = n(n+1)/2$"/>. con <math>n</math> intero. Questa
	  funzione è l'inversa della funzione <fncref targ="vech"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mshape"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>  
      <description>
	<para context="notex">
	  Restituisce una matrice triangolare superiore <by r="n"
	  c="n"/>: gli elementi sulla e sopra la diagonale sono uguali
	  ai corrispondenti elementi di <argname>A</argname>; i
	  restanti elementi sono zero.
	</para>
	<para context="tex">
	  Restituisce una matrice triangolare superiore $n\times n$
	  <math>B</math> per cui $B_{ij} = A_{ij}$ se $i \le j$ e 0
	  altrimenti.
	</para>
	<para>
	  <seelist>
	    <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-value della statistica test dal test Dickey&ndash;Fuller per radici unitarie e del test Engle&ndash;Granger di cointegrazione, come in <cite key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  Gli argomenti sono i seguenti: <argname>tau</argname> indica
	  la statistica test; <argname>n</argname> è il numero di
	  osservazioni (o 0 per il risultato asintotico);
	  <argname>niv</argname> è il numero di variabili
	  potenzialmente cointegrate nel test di cointegrazione (o 1
	  per il test univariato di radici unitarie);
	  <argname>itv</argname> è il codice di specificazione del
	  modello: 1 per il modello senza costante, 2 per il modello
	  con costante inclusa, 3 per il modello con costante e trend
	  lineare, 4 per il modello con costante e trend quadratico.
	</para>
	<para>
	  Si noti che se il test è <quote>aumentato</quote> con i
	  ritardi della variabile dipendente, si deve fornire un
	  valore 0 all'argomento <argname>n</argname> per ottenere il
	  risultato asintotico.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Restituisce un vettore contenente gli elementi distinti di
	  <argname>x</argname> ordinati in senso crescente. Si noti
	  che <argname>x</argname> si assume contenga solo valori
	  interi. In caso contrario, la parte decimale è troncata,
	  cosicché <lit>values(x)</lit> produce un risultato identico
	  a <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="dsort"/>
	    <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Se <argname>x</argname> è una serie, restituisce la sua varianza campionaria (uno scalare), saltando i valori mancanti.
	</para>
	<para>
	  Se <argname>x</argname> è una lista, restituisce una serie
	  <math>y</math> tale che <math>y</math><sub>t</sub> è la
	  varianza campionaria dei valori delle variabili nella lista
	  all'osservazione <math>t</math>, o <lit>NA</lit> se ci sono
	  valori mancanti a <math>t</math>.
	</para>
	<para>
	  In ogni caso, la somma delle deviazioni al quadrato dalla
	  media è divisa per (<math>n</math> &minus; 1) se
	  <math>n</math> &gt; 1. In caso contrario, la varianza
	  restituita è zero se <math>n</math> = 1, o <lit>NA</lit> se
	  <math>n</math> = 0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>     
      <description>
	<para>
	  Se l'argomento è uno scalare, restituisce il nome della
	  variabile con numero ID <argname>v</argname>, o genera un
	  errore nel caso in cui una tale variabile non esista.
	</para>
	<para>
	  Se l'argomento è una lista, restituisce una stringa
	  contenente i nomi delle variabili nella lista, separati da
	  una virgola. Se la lista fornita è vuota, la stringa
	  restituita sarà vuota.
	</para>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">varname</fnarg>
      </fnargs>     
      <description>
	<para>
	  Restituisce il numero ID della variabile chiamata <argname>varname</argname>, o NA se una tale variabile non esiste.
	</para>
      </description>
    </function>

    <function name="varsimul" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Simula un VAR di ordine <math>p</math> con <math>n</math> variabili, cioè 
	  <equation status="inline"
	  ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)." 
	  tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
	  La matrice dei coefficienti <argname>A</argname> è formata
	  incolonnando orizzontalmente le matrici
	  <math>A</math><sub>i</sub>. Si tratta di una matrice <by
	  r="n" c="np"/>, con una riga per ogni equazione. Corrisponde
	  alle prime <math>n</math> righe della matrice
	  <lit>$compan</lit> fornita dai comandi <lit>var</lit> e
	  <lit>vecm</lit> di gretl.
	</para>
	<para>
	  Gli <math>u_t</math> vettori sono contenuti (come righe)
	  nella matrice <argname>U</argname> (<by r="T" c="n"/>). I
	  valori iniziali sono in <argname>y0</argname> (<by r="p"
	  c="n"/>).
	</para>
	<para>
	  Se il VAR contiene termini deterministici e/o regressori
	  esogeni, questi possono essere gestiti racchiudendoli nella
	  matrice <argname>U</argname>: ciascuna riga di
	  <argname>U</argname> diventa allora
	  <equation status="inline"
	  ascii="u(t) = B' x(t) + e(t)." 
	  tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  La matrice in uscita ha<math>T</math> + <math>p</math> righe
	  e <math>n</math> colonne; contiene i <math>p</math> valori
	  iniziali delle variabili endogene più i <math>T</math>
	  valori simulati.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="$compan"/>
	    <cmdref targ="var"/>
	    <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>     
      <description>
	<para>
	  Restituisce le colonne di <argname>X</argname> una sotto
	  l'altra in un vettore colonna.
	  <seelist>
	    <fncref targ="mshape"/>
	    <fncref targ="unvech"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce, sotto forma di vettore colonna, gli elementi di
	  <argname>A</argname> sulla diagonale e al di sopra di
	  essa. L'uso tipico di questa funzione è con matrici
	  simmetriche, nel qual caso la sua funzione inversa è <fncref
	  targ="unvech"/>.
	  <seelist> 
	    <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">anno</fnarg>
	<fnarg type="int">mese</fnarg>
	<fnarg type="int">giorno</fnarg>
      </fnargs>    
      <description>
	<para>
	  Fornisce il giorno della settimana (Domenica = 0, Lunedì =
	  1, ecc.) corrispondente alla data specificata dai tre
	  argomenti, o <lit>NA</lit> se la data non è valida.
	</para>
      </description>
    </function>

    <function name="wmean" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce una serie <math>y</math> tale che
	  <math>y</math><sub>t</sub> sia la media ponderata dei valori
	  delle serie nella lista <argname>Y</argname>
	  all'osservazione <math>t</math>; i rispettivi pesi devono
	  essere contenuti nella lista <argname>W</argname>, e quindi
	  possono essere variabili nel tempo. Le due liste
	  <argname>Y</argname> e <argname>W</argname> devono avere lo
	  stesso numero di elementi ed i pesi devono essere
	  non-negativi.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="wsd"/>
	    <fncref targ="wvar"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="wsd" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce una serie <math>y</math> tale che
	  <math>y</math><sub>t</sub> sia l'errore quadratico medio
	  ponderato dei valori delle serie nella lista
	  <argname>Y</argname> all'osservazione <math>t</math>; i
	  rispettivi pesi devono essere contenuti nella lista
	  <argname>W</argname>, e quindi possono essere variabili nel
	  tempo. Le due liste <argname>Y</argname> e
	  <argname>W</argname> devono avere lo stesso numero di
	  elementi ed i pesi devono essere non-negativi.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="wmean"/>
	    <fncref targ="wvar"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="wvar" section="stats" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce una serie <math>y</math> tale che
	  <math>y</math><sub>t</sub> sia la varianza campionaria
	  ponderata dei valori delle serie nella lista
	  <argname>Y</argname> all'osservazione <math>t</math>; i
	  rispettivi pesi devono essere contenuti nella lista
	  <argname>W</argname>, e quindi possono essere variabili nel
	  tempo. Le due liste <argname>Y</argname> e
	  <argname>W</argname> devono avere lo stesso numero di
	  elementi ed i pesi devono essere non-negativi.
	</para>
	<para context="tex">
	  La varianza ponderata è calcolata come 
	  \[ 
	  s^2_w = \frac{n'}{n'-1} \, 
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} 
	  \] 
	  dove $n'$ è il numero di pesi non nulli e $\bar{x}_w$ è la
	  media ponderata.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="wmean"/>
	    <fncref targ="wsd"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="xmax" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>     
      <description>
	<para>
	  Fornisce il massimo di <argname>x</argname> e
	  <argname>y</argname>, o <lit>NA</lit> se uno dei due valori 
	  è mancante.  
	</para>
	<para>
	  <seelist> 
	    <fncref targ="xmin"/>
	    <fncref targ="max"/>
	    <fncref targ="min"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="xmin" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>     
      <description>
	<para>
	  Fornisce il minimo di <argname>x</argname> e
	  <argname>y</argname>, o <lit>NA</lit> se uno dei due valori
      è mancante.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="xmax"/>
	    <fncref targ="max"/>
	    <fncref targ="min"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="xpx" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>     
      <description>
	<para>
          Fornisce una lista che contiene i quadrati e i prodotti
          incrociati delle variabili elencate in <argname>L</argname>.
          Ai quadrati viene assegnato il nome secondo lo schema
          <lit>sq_</lit><repl>varname</repl>, mentre per i prodotti
          incrociati si utilizza
          <repl>var1</repl><lit>_</lit><repl>var2</repl>.  I nomi
          delle variabili in input sono troncati se necessario, e il
          nome delle variabili in output possono essere cambiati in
          caso di duplicazione dei nomi nella lista fornita.
	</para>
      </description>
    </function>

    <function name="zeromiss" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Converte gli zeri in <lit>NA</lit>s. Se <argname>x</argname>
	  è una variabile, la conversione viene fatta elemento per
	  elemento.
	  <seelist>
	    <fncref targ="missing"/>
	    <fncref targ="misszero"/>
	    <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs> 
      <description>
	<para>
	  Produce una matrice di zeri con <math>r</math> righe e 
	  <math>c</math> colonne. 
	  <seelist> 
	    <fncref targ="ones"/>
	    <fncref targ="seq"/>
	  </seelist>
	</para>
      </description>
    </function>

  </funclist>
</funcref>
