<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE funcref SYSTEM "gretl_functions.dtd">

<funcref language="english">

  <funclist name="Accessors" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
	  Must follow the estimation of a fixed-effects or
	  random-effects panel data model.  Returns a series
	  containing the estimates of the individual effects.
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Returns the Akaike Information Criterion for the last estimated
	  model, if available. See <guideref targ="chap:criteria"/> for
	  details of the calculation.
	</para>
      </description>
    </function>

    <function name="$allprobs" section="access" output="matrix">
      <description>
	<para>
	  Must follow estimation via ordered probit or logit, or
	  multinomial logit. Returns an <by r="n" c="j"/> matrix,
	  where <math>n</math> is the number of observations used and
	  <math>j</math> is the number of possible outcomes, holding
	  the estimated probability of each outcome at each
	  observation.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Returns Schwarz's Bayesian Information Criterion for the
	  last estimated model, if available. See <guideref
	  targ="chap:criteria"/> for details of the calculation.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Returns the overall chi-square statistic from the last estimated
	  model, if available.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  With no arguments, <lit>$coeff</lit> returns a column vector
	  containing the estimated coefficients for the last model. With
	  the optional string argument it returns a scalar, namely the
	  estimated parameter named <argname>s</argname>.
	  <seelist>
            <fncref targ="$stderr"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Example:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg
	  b = $coeff               # gets a vector
	  macoef = $coeff(theta_1) # gets a scalar
	</code>
	<para>
	  If the <quote>model</quote> in question is actually a system,
	  the result depends on the characteristics of the system: for
	  VARs and VECMs the value returned is a matrix with one column
	  per equation, otherwise it is a column vector containing the
	  coefficients from the first equation followed by those from the
	  second equation, and so on.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Must follow the estimation of a model; returns the command
	  word, for example <lit>ols</lit> or <lit>probit</lit>.
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VAR or a VECM; returns the
	  companion matrix.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Returns an integer value representing the sort of dataset that
	  is currently loaded: 0 = no data; 1 = cross-sectional (undated)
	  data; 2 = time-series data; 3 = panel data.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Must follow the estimation of a single-equation model;
	  returns the name of the dependent variable.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Returns the degrees of freedom of the last estimated
	  model. If the last model was in fact a system of equations,
	  the value returned is the degrees of freedom per equation;
	  if this differs across the equations then the value given is
	  the number of observations minus the mean number of
	  coefficients per equation (rounded up to the nearest
	  integer).
	</para>
      </description>
    </function>

    <function name="$diagpval" section="access" output="scalar">
      <description>
	<para>
	  Must follow estimation of a system of equations. Returns the
	  <math>P</math>-value associated with the <fncref
	  targ="$diagtest"/> statistic.
	</para>
      </description>
    </function>

    <function name="$diagtest" section="access" output="scalar">
      <description>
	<para>
	  Must follow estimation of a system of equations. Returns the
	  test statistic for the null hypothesis that the
	  cross-equation covariance matrix is diagonal. This is the
	  Breusch&ndash;Pagan test except when the estimator is
	  (unrestricted) iterated SUR, in which case it is a Likelihood
	  Ratio test. See <guideref targ="chap:system"/> for
	  details; see also <fncref targ="$diagpval"/>.
	</para>
      </description>
    </function>

    <function name="$dotdir" section="access" output="string">
      <description>
	<para>
	  This accessor returns the path where gretl stores temporary
	  files, for example when using the <fncref targ="mwrite"/>
	  function with a non-zero third argument.
	</para>
      </description>
    </function>

    <function name="$dw" section="access" output="scalar">
      <description>
	<para>
	  Returns the Durbin&ndash;Watson statistic for first-order
	  serial correlation from the model last estimated (if available).
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Returns the CDF of the Durbin&ndash;Watson distribution
	  evaluated at the DW statistic for the model last estimated
	  (if available), computed using the <cite
	  key="imhof61">Imhof</cite> procedure. This is the p-value
	  for a one-sided test with an alternative of positive
	  first-order autocorrelation. If you want the p-value for
	  a two-sided test, take 2<math>P</math> if DW &lt; 2 or
	  2(1 &minus; <math>P</math>) if DW &gt; 2, where <math>P</math>
	  is the value returned by the accessor.
	</para>
	<para>
	  Due to the limited precision of digital arithmetic, the
	  Imhof integral can go negative when the Durbin&ndash;Watson
	  statistic is close to its lower bound. In that case the
	  accessor returns <lit>NA</lit>. Since any other failure mode
	  results in an error being flagged it is probably safe to
	  assume that an NA value means the true p-value is
	  <quote>very small</quote>, although we are unable to
	  quantify it.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM; returns a matrix containing
	  the error correction terms.  The number of rows equals the number
	  of observations used and the number of columns equals the
	  cointegration rank of the system.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Returns the program's internal error code, which will be
	  non-zero in case an error has occurred but has been trapped
	  using <cmdref targ="catch"/>. Note that using this accessor
	  causes the internal error code to be reset to zero. If you
	  want to get the error message associated with a given
	  <lit>$error</lit> you need to store the value in a temporary
	  variable, as in
	</para>
	<code>
	  err = $error
	  if (err)
	      printf "Got error %d (%s)\n", err, errmsg(err)
	  endif
	</code>
	<para>
	  <seelist>
            <cmdref targ="catch"/>
            <fncref targ="errmsg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Returns the error sum of squares of the last estimated model,
	  if available.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM; returns a vector
	  containing the eigenvalues that are used in computing
	  the trace test for cointegration.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Must follow the <cmdref targ="fcast"/> forecasting command;
	  returns the forecast values as a matrix. If the model on
	  which the forecast was based is a system of equations the
	  returned matrix will have one column per equation, otherwise
	  it is a column vector.
	</para>
      </description>
    </function>

    <function name="$fcse" section="access" output="matrix">
      <description>
	<para>
	  Must follow the <cmdref targ="fcast"/> forecasting command;
	  returns the standard errors of the forecasts, if available, as a
	  matrix. If the model on which the forecast was based is a system
	  of equations the returned matrix will have one column per
	  equation, otherwise it is a column vector.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Must follow estimation of a VAR. Returns a matrix containing
	  the forecast error variance decomposition (FEVD). This
	  matrix has <math>h</math> rows where <math>h</math> is the
	  forecast horizon, which can be chosen using <lit>set
	  horizon</lit> or otherwise is set automatically based on the
	  frequency of the data.
	</para>
	<para>
	  For a VAR with <math>p</math> variables, the matrix has
	  <math>p</math><sup>2</sup> columns: the first <math>p</math>
	  columns contain the FEVD for the first variable in the VAR;
	  the second <math>p</math> columns the FEVD for the second
	  variable; and so on.  The (decimal) fraction of the forecast
	  error for variable <math>i</math> attributable to innovation
	  in variable <math>j</math> is therefore found in column
	  (<math>i</math> &minus; 1)<math>p</math> + <math>j</math>.
	</para>
	<para>
	  For a more flexible variant of this functionality, see the
	  <fncref targ="fevd"/> function.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Returns the overall F-statistic from the last estimated model,
	  if available.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Must follow a <lit>gmm</lit> block. Returns the value of the
	  GMM objective function at its minimum.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Must follow a <lit>garch</lit> command. Returns the estimated
	  conditional variance series.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Must follow estimation of a model via either <lit>tsls</lit> or
	  <lit>panel</lit> with the random effects option. Returns a <by
          r="1" c="3"/> vector containing the value of the
	  Hausman test statistic, the corresponding degrees of freedom and
	  the p-value for the test, in that order.
	</para>
     </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Returns the Hannan-Quinn Information Criterion for the last
	  estimated model, if available.  See <guideref
	  targ="chap:criteria"/> for details of the calculation.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Returns a very large positive number. By default this is 1.0E100,
	  but the value can be changed using the <cmdref targ="set"/> command.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM, and returns the loadings
	  matrix. It has as many rows as variables in the VECM and as many
	  columns as the cointegration rank.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM, and returns the
	  cointegration matrix. It has as many rows as variables in the
	  VECM (plus the number of exogenous variables that are restricted
	  to the cointegration space, if any), and as many columns as the
	  cointegration rank.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Must follow the estimation of a VECM, and returns the estimated
	  covariance matrix for the elements of the cointegration vectors.
	</para>
	<para>
	  In the case of unrestricted estimation, this matrix has a number of
	  rows equal to the unrestricted elements of the cointegration space
	  after the Phillips normalization. If, however, a restricted system
	  is estimated via the <lit>restrict</lit> command with the
	  <lit>--full</lit> option, a singular matrix with <math>(n+m)r</math>
	  rows will be returned (<math>n</math> being the number of endogenous
	  variables, <math>m</math> the number of exogenous variables that are
	  restricted to the cointegration space, and <math>r</math> the
	  cointegration rank).
	</para>
	<para>
	  Example: the code
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	    b[1,1] = 1
	    b[1,2] = -1
	    b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  produces the following output.
	</para>
	<code>
	  s0 (4 x 4)

          0.019751     0.029816  -0.00044837   -0.12227
          0.029816     0.31005   -0.45823      -0.18526
         -0.00044837  -0.45823    1.2169       -0.035437
         -0.12227     -0.18526   -0.035437      0.76062

	  s1 (5 x 5)

	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000      0.27398     -0.27398    -0.019059
	  0.0000       0.0000     -0.27398      0.27398     0.019059
	  0.0000       0.0000    -0.019059     0.019059    0.0014180
	</code>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  For selected models estimated via Maximum Likelihood,
	  returns the series of per-observation log-likelihood
	  values. At present this is supported only for binary logit
	  and probit, tobit and heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Returns the log-likelihood for the last estimated model (where
	  applicable).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Returns the value of <quote>machine epsilon</quote>, which
	  gives an upper bound on the relative error due to rounding
	  in double-precision floating point arithmetic.
	</para>
      </description>
    </function>

    <function name="$mapfile" section="access" output="string">
      <description>
	<para>
	  If data from a GeoJSON file or ESRI shapefile have been
	  loaded, returns the name of the file that should be opened
	  to obtain the map polygons, otherwise returns an empty
	  string.  This is designed for use with the <fncref
	  targ="geoplot"/> function.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Following estimation of a multinomial logit model (only),
	  retrieves a matrix holding the estimated probabilities of
	  each possible outcome at each observation in the model's
	  sample range. Each row represents an observation and each
	  column an outcome. As of gretl 2023a this accessor is
	  deprecated: please use <fncref targ="$allprobs"/> instead.
	</para>
      </description>
    </function>

    <function name="$model" section="access" output="bundle">
      <description>
	<para>
	  Must follow estimation of a single-equation model; returns a
	  bundle containing many items of data pertaining to the
	  model. All the regular model accessors are included: these
	  are referenced by keys that are the same as the regular
	  accessor names, minus the leading dollar sign. So for
	  example the residuals appear under the key <lit>uhat</lit>
	  and the error sum of squares under <lit>ess</lit>.
	</para>
	<para>
	  Depending on the estimator, additional information may be
	  available; the keys for such information should hopefully be
	  fairly self-explanatory. To see what's available you can get
	  a copy of the bundle and print its content, as in
	</para>
	<code>
	  ols y 0 x
	  bundle b = $model
	  print b
	</code>
      </description>
    </function>

    <function name="$mpirank" section="access" output="int">
      <description>
	<para>
	  If gretl is built with MPI support, and the program is
	  running in MPI mode, returns the 0-based <quote>rank</quote>
	  or ID number of the current process. Otherwise returns
	  &minus;1.
	</para>
      </description>
    </function>

    <function name="$mpisize" section="access" output="int">
      <description>
	<para>
	  If gretl is built with MPI support, and the program is
	  running in MPI mode, returns the number of MPI processes
	  currently running. Otherwise returns 0.
	</para>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Returns the total number of coefficients estimated in the last
	  model.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" output="int">
      <description>
	<para>
	  Returns the number of observations in the currently selected
	  sample. Related: <fncref targ="$tmax"/>.
	</para>
	<para>
	  In the case of panel data the value returned is the number
	  of pooled observations (number of units times number of
	  observations per unit). If you want the time-series length
	  of a panel use <fncref targ="$pd"/>, and the number of
	  included units can be found as <lit>$nobs</lit> divided by
	  <lit>$pd</lit>.
	</para>
      </description>
    </function>

    <function name="$now" section="access" output="vector">
      <description>
	<para>
	  Returns a 2-vector: its first element is the number of
	  seconds elapsed since 1970-01-01 00:00:00 +0000 (UTC, or
	  Coordinated Universal Time), which is widely used in the
	  computing world to represent the current time, and the
	  second is the current date in ISO 8601 <quote>basic</quote>
	  format, <lit>YYYYMMDD</lit>. The <fncref targ="strftime"/>
	  function may be used to process the first element, and
	  <fncref targ="epochday"/> may be used to process the second.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Returns the number of series in the dataset (including the
	  constant). Since <lit>const</lit> is always present in
	  any dataset a return value of 0 indicates that no
	  dataset is in place. Note that if this accessor is used
	  within a function, the number of series currently accessible
	  may well fall short of that given by <lit>$nvars</lit>.
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Applicable when the current dataset is time-series with
	  annual, quarterly, monthly or decennial frequency, or is
	  dated daily or weekly, or when the dataset is a panel with
	  time-series information set appropriately (see the <cmdref
	  targ="setobs"/> command).  The returned series holds 8-digit
	  numbers on the pattern <lit>YYYYMMDD</lit> (ISO 8601
	  <quote>basic</quote> date format), which correspond to the
	  day of the observation, or the first day of the observation
	  period in case of a time-series frequency less than daily.
	</para>
	<para>
	  Such a series can be helpful when using the <cmdref
	  targ="join"/> command.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  Returns a series holding the <quote>major</quote> or
	  low-frequency component of each observation. This means the
	  year for annual, quarterly or monthly time series; the day
	  for hourly data; or the individual in the case of panel
	  data. If the data are cross-sectional the series returned is
	  just a 1-based index of the observations.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsminor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  Applicable when the observations in the current dataset have
	  a major:minor:micro structure, as in dated daily time series
	  (year:month:day).  Returns a series holding the micro or
	  highest-frequency component of each observation (for
	  example, the day).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  Applicable when the observations in the current dataset have
	  a major:minor structure, as in quarterly time series
	  (year:quarter), monthly time series (year:month), hourly
	  data (day:hour) and panel data (individual:period).  Returns
	  a series holding the minor or high-frequency component of
	  each observation (for example, the month).
	</para>
	<para>
	  In the case of dated daily data, <lit>$obsminor</lit> gets
	  the month of each observation.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$panelpd" section="access" output="int">
      <description>
	<para>
	  Specific to panel data, returns the time-series periodicity
	  (e.g. 4 for quarterly data).  If the periodicity is not set
	  in the active panel dataset, returns 1 in analogy to <fncref
	  targ="$pd"/> for cross-sectional or undated data. If the
	  dataset is not a panel NA is returned.
	</para>
	<para>
	  <seelist>
            <fncref targ="$pd"/>
            <fncref targ="$datatype"/>
            <cmdref targ="setobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$parnames" section="access" output="strings">
      <description>
	<para>
	  Following estimation of a single-equation model, returns
	  an array of strings holding the names of the model's
	  parameters. The number of names matches the number of
	  elements in the <fncref targ="$coeff"/> vector.
	</para>
	<para>
	  For models specified via a list of regressors the result
	  will be the same as that of
	</para>
	<code>
	  varnames($xlist)
	</code>
	<para>
	  (see <fncref targ="varnames"/>), but <lit>$parnames</lit> is
	  more general; it also works for models with no regressor
	  list (<cmdref targ="nls"/>, <cmdref targ="mle"/>, <cmdref
	  targ="gmm"/>).
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Returns the frequency or periodicity of the data (e.g. 4 for
	  quarterly data).  In the case of panel data the value returned
	  is the total time-series length.
	</para>
	<para>
	  <seelist>
            <fncref targ="$panelpd"/>
	  </seelist>
	  </para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Returns the value of &pi; in double precision.
	</para>
      </description>
    </function>

    <function name="$pkgdir" section="access" output="string">
      <description>
	<para>
	  A special facility for use by authors of function
	  packages. Returns an empty string unless a packaged function
	  is executing, in which case it returns the full (platform
	  dependent) path under which the package is installed. For
	  instance the return value might be
	</para>
	<code>
	  /usr/share/gretl/functions/foo
	</code>
	<para>
	  if that's the directory in which <lit>foo.gfn</lit> is
	  located. This enables package writers to access resources
	  such as matrix files that they have included in their
	  package.
	</para>
      </description>
    </function>

    <function name="$pmanteau" section="access" output="matrix">
      <description>
	<para>
          Available after estimation of a vector autoregression.
          Returns a row vector holding the results of the multivariate
          portmanteau test for autocorrelation of the residuals, as
          discussed on pages 21&ndash;22 in <cite
          key="johansen95">Johansen (1995)</cite>. The elements are,
          in order, the Ljung&ndash;Box statistic, the maximum lag
          considered, the degrees of freedom for the (chi-square)
          test, and the p-value of the test.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Returns the p-value of the test statistic that was generated
	  by the last explicit hypothesis-testing command, if any (for
	  example, <lit>chow</lit>).  See <guideref targ="chap:genr"/>
	  for details.
	</para>
	<para>
	  In most cases the return value is a scalar but sometimes it
	  is a matrix (for example, the trace and lambda-max p-values
	  from the Johansen cointegration test); in that case the
	  values in the matrix are laid out in the same pattern as the
	  printed results.
	</para>
	<para>
	  <seelist>
            <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$qlrbreak" section="access" output="scalar">
      <description>
	<para>
	  Must follow an invocation of the <cmdref targ="qlrtest"/>
	  command (the QLR test for a structural break at an unknown
	  point). The value returned is the 1-based index of the
	  observation at which the test statistic is maximized.
	</para>
      </description>
    </function>

    <function name="$result" section="access" output="matrix-or-bundle">
      <description>
	<para>
	  Provides stored information following certain commands that
	  do not have specific accessors. The commands in question
	  include <cmdref targ="bds"/>, <cmdref targ="bkw"/>,
	  <cmdref targ="corr"/>, <cmdref targ="fractint"/>,
	  <cmdref targ="freq"/>, <cmdref targ="hurst"/>, <cmdref targ="leverage"/>,
	  <cmdref targ="summary"/>, <cmdref targ="vif"/> and <cmdref targ="xtab"/>
	  (in which cases the result is a matrix), plus <cmdref targ="pkg"/>
	  (which optionally stores a bundle result).
	</para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Without arguments, returns the first-order autoregressive
	  coefficient for the residuals of the last model. After
	  estimating a model via the <lit>ar</lit> command, the syntax
	  <lit>$rho(n)</lit> returns the corresponding estimate of
	  &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rlnl" section="access" output="scalar">
      <description>
	<para>
          Following estimation of a restricted VECM, returns the
          log-likelihood for the restricted model. See also
          <fncref targ="$lnl"/>, and <guideref targ="chap:vecm"/> for
          examples of usage.
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Returns the unadjusted <math>R</math><sup>2</sup> from the
	  last estimated model, if available. Usually this will be the
	  regular (centered) <math>R</math><sup>2</sup> but if the
	  specification contains no constant (and no set of regressors
	  that <quote>add up to</quote> a constant) it will be the
	  uncentered version. In that case the centered version can
	  be accessed as <lit>$model.centered_R2</lit>.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Must follow estimation of a single-equation model.  Returns a dummy
	  series with value 1 for observations used in estimation, 0 for
	  observations within the currently defined sample range but not used
	  (presumably because of missing values), and NA for observations
	  outside of the current range.
	</para>
	<para>
	  If you wish to compute statistics based on the sample that was
	  used for a given model, you can do, for example:
	</para>
	<code>
	  ols y 0 xlist
	  series sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Must follow a <lit>tsls</lit> command. Returns a <by r="1"
	  c="3"/> vector, containing the value of the Sargan
	  over-identification test statistic, the corresponding
	  degrees of freedom and p-value, in that order. If the model is
	  exactly identified, the statistic is unavailable, and trying to
	  access it provokes an error.
	</para>
      </description>
    </function>

    <function name="$seed" section="access" output="scalar">
      <description>
	<para>
	  Returns the value with which gretl's random number generator
	  was seeded. If you set the seed yourself there's no need to
	  use this accessor, but it may be of interest if the seed was
	  set automatically (based on the time that execution of the
	  program started).
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Requires that a model has been estimated.  If the last model was
	  a single equation, returns the (scalar) Standard Error of the
	  Regression (or in other words, the standard deviation of the
	  residuals, with an appropriate degrees of freedom correction).
	  If the last model was a system of equations, returns the
	  cross-equation covariance matrix of the residuals.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  With no arguments, <lit>$stderr</lit> returns a column vector
	  containing the standard error of the coefficients for the last
	  model.  With the optional string argument it returns a scalar,
	  namely the standard error of the parameter named
	  <argname>s</argname>.
	</para>
	<para>
	  If the <quote>model</quote> in question is actually a system,
	  the result depends on the characteristics of the system: for
	  VARs and VECMs the value returned is a matrix with one column
	  per equation, otherwise it is a column vector containing the
	  coefficients from the first equation followed by those from the
	  second equation, and so on.
	</para>
	<para>
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Must be preceded by <lit>set stopwatch</lit>, which activates the
	  measurement of CPU time.  The first use of this accessor yields the
	  seconds of CPU time that have elapsed since the <lit>set
          stopwatch</lit> command.  At each access the clock is reset, so
	  subsequent uses of <lit>$stopwatch</lit> yield the seconds of CPU
	  time since the previous access.
	</para>
	<para>
	  When a user-defined function is executing, the <lit>set
	  stopwatch</lit> command and <lit>$stopwatch</lit> accessor are
	  specific to that function&mdash;that is, timing within a
	  function does not disrupt any <quote>global</quote> timing
	  that may be going on in the main script.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Must follow estimation of a simultaneous equations system.
	  Returns the matrix of coefficients on the lagged endogenous
	  variables, if any, in the structural form of the system.  See
	  the <cmdref targ="system"/> command.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Must follow estimation of a simultaneous equations system.
	  Returns the matrix of coefficients on the exogenous variables in
	  the structural form of the system.  See the <cmdref
	  targ="system"/> command.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Must follow estimation of a simultaneous equations system.
	  Returns the matrix of coefficients on the contemporaneous
	  endogenous variables in the structural form of the system.
	  See the <cmdref targ="system"/> command.
	</para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
	<para>
	  Returns a bundle containing information on the capabilities
	  of the gretl build and the system on which gretl is
	  running. The members of the bundle are as follows:
	</para>
	<ilist>
	  <li>
	    <para>
	      <lit>gui_mode</lit>: integer, equals 1 if libgretl is
	      being called by the GUI program, otherwise 0.
	    </para>
	  </li>
	  <li>
            <para>
              <lit>mpi</lit>: integer, equals 1 if the system supports
              MPI (Message Passing Interface), otherwise 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>omp</lit>: integer, equals 1 if gretl is built with
              support for Open MP, otherwise 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>ncores</lit>: integer, the number of physical processor
              cores available.
            </para>
	  </li>
	  <li>
            <para>
              <lit>nproc</lit>: integer, the number of processors
              available, which will be greater than <lit>ncores</lit>
              if hyper-threading is enabled.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mpimax</lit>: integer, the maximum number of MPI
              processes that can be run in parallel. This is zero if
              MPI is not supported, otherwise it equals the local
              <lit>nproc</lit> value unless an MPI hosts file has been
              specified, in which case it is the sum of the number of
              processors or <quote>slots</quote> across all the
              machines referenced in that file.
            </para>
	  </li>
	  <li>
            <para>
              <lit>wordlen</lit>: integer, either 32 or 64 for
              32- and 64-bit systems respectively.
            </para>
	  </li>
	  <li>
            <para>
              <lit>os</lit>: string representing the operating system,
              either <lit>linux</lit>, <lit>macos</lit>,
              <lit>windows</lit> or <lit>other</lit>. Note that
              versions of gretl prior to 2021e gave the string
              <lit>osx</lit> for the Mac operating system; a
              version-independent test for Mac is therefore
	      <lit>instring($sysinfo.os, "os")</lit>
            </para>
	  </li>
	  <li>
            <para>
              <lit>hostname</lit>: the name of the host machine on
              which the current gretl process is running (with a
              fallback of <lit>localhost</lit> in case the name
              cannot be determined).
            </para>
	  </li>
	  <li>
            <para>
              <lit>mem</lit>: a 2-vector holding total physical memory
	      and free or available memory, expressed in MB. This
	      information may not be available on all systems but
	      should be on Windows, macOS and Linux.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>blas</lit>: string identifying the supplier of the
              BLAS (Basic Linear Algebra Subprograms) library in use
              by gretl.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>blas_version</lit>: string identifying the version
	      number of the blas library in use.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>blascore</lit>: (if applicable) a string
              identifying the CPU type for which the current blas
              library is optimized.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>compiler</lit>: a string identifying the compiler
              used when building libgretl.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>cpuid</lit>: a string identifying the vendor and
              model of the CPU on which libgretl is running.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>gnuplot</lit>: a string identifying the version of
              gnuplot available to gretl for plotting, in the form of
              three dot-separated numbers giving major version, minor
              version and patchlevel.
            </para>
	  </li>
	  <li>
            <para>
              <lit>foreign</lit>: a sub-bundle containing 0/1
              indicators for the presence on the host system of each
              of the <quote>foreign</quote> programs supported by
              gretl, under the keys <lit>julia</lit>,
              <lit>octave</lit>, <lit>ox</lit>, <lit>python</lit>,
              <lit>Rbin</lit>, <lit>Rlib</lit> and <lit>stata</lit>.
              The two keys pertaining to R represent the R executable
              and shared library, respectively.
            </para>
	  </li>
	</ilist>
	<para>
	  Note that individual elements in the bundle can be accessed
	  using <quote>dot</quote> notation without any need to copy the
	  whole bundle under a user-specified name. For example,
	</para>
	<code>
	  if $sysinfo.os == "linux"
	      # do something linux-specific
	  endif
	</code>
      </description>
    </function>

    <function name="$system" section="access" output="bundle">
      <description>
	<para>
	  Must follow estimation of a system of equations via one of
	  the commands <cmdref targ="system"/>, <cmdref targ="var"/>
	  or <cmdref targ="vecm"/>; returns a bundle containing many
	  items of data pertaining to the system. All the relevant
	  regular system accessors are included: these are referenced
	  by keys that are the same as the regular accessor names,
	  minus the leading dollar sign. So for example the residuals
	  appear under the key <lit>uhat</lit> and the coefficients
	  under <lit>coeff</lit>. (Exceptions are the keys
	  <lit>A</lit>, <lit>B</lit>, and <lit>Gamma</lit>, which
	  correspond to the regular dollar accessors <fncref
	  targ="sysA"/>, <fncref targ="sysB"/>, and <fncref
	  targ="sysGamma"/>.) The keys for additional information
	  should hopefully be fairly self-explanatory. To see what's
	  available you can get a copy of the bundle and print its
	  content, as in
	</para>
	<code>
	  var 4 y1 y2 y2
	  bundle b = $system
	  print b
	</code>
	<para>
	  A bundle obtained in this way can be passed as the final,
	  optional argument to the functions <fncref targ="fevd"/>
	  and <fncref targ="irf"/>.
	</para>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Returns the number of observations used in estimating the
	  last model.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Returns the 1-based index of the first observation in the currently
	  selected sample.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Returns the 1-based index of the last observation in the currently
	  selected sample.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Returns the value of the test statistic that was generated
	  by the last explicit hypothesis-testing command, if any
	  (&eg; <lit>chow</lit>). See <guideref targ="chap:genr"/> for
	  details.
	</para>
	<para>
	  In most cases the return value is a scalar but sometimes it
	  is a matrix (for example, the trace and lambda-max
	  statistics from the Johansen cointegration test); in that
	  case the values in the matrix are laid out in the same
	  pattern as the printed results.
	</para>
	<para>
	  <seelist>
            <fncref targ="$pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$time" section="access" output="series">
      <description>
	<para>
	  For time-series or panel data, creates a 1-based index of
	  the time period. In the panel case the sequence of values
	  repeats for each cross-sectional unit.
	</para>
	<para>
	  The command <quote><lit>genr time</lit></quote> is an
	  alternative, with the difference that the <lit>genr</lit>
	  variant automatically creates a series called
	  <lit>time</lit> while the naming of the series is up to the
	  caller when using <lit>$time</lit>, as in
	</para>
	<code>
	  series trend = $time
	</code>
	<para>
	  This accessor is not available for cross-sectional data.
	</para>
      </description>
    </function>

    <function name="$tmax" section="access" output="int">
      <description>
	<para>
	  Returns the maximum legal setting for the end of the sample
	  range via the <cmdref targ="smpl"/> command. In most cases
	  this will equal the number of observations in the dataset
	  but within a hansl function the <lit>$tmax</lit> value may
	  be smaller, since in general data access within functions is
	  limited to the sample range set by the caller.
	</para>
	<para>
	  Note that <lit>$tmax</lit> does not in general equal <fncref
	  targ="$nobs"/>, which gives the number of observations in
	  the current sample range.
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Returns <math>TR</math><sup>2</sup> (sample size times
	  R-squared) from the last model, if available.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Returns the residuals from the last model. This may have
	  different meanings for different estimators. For example, after
	  an ARMA estimation <lit>$uhat</lit> will contain the
	  one-step-ahead forecast error; after a probit model, it will
	  contain the generalized residuals.
	</para>
	<para>
	  If the <quote>model</quote> in question is actually a system
	  (a VAR or VECM, or system of simultaneous equations),
	  <lit>$uhat</lit> retrieves the matrix of residuals, one
	  column per equation.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Valid for panel datasets only.  Returns a series with
	  value 1 for all observations on the first unit or group,
	  2 for observations on the second unit, and so on.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s1</fnarg>
	<fnarg optional="true" type="coeffname">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  With no arguments, <lit>$vcv</lit> returns a square matrix
	  containing the estimated covariance matrix for the coefficients of
	  the last model.  If the last model was a single equation, then you
	  may supply the names of two parameters in parentheses to retrieve
	  the estimated covariance between the parameters named
	  <argname>s1</argname> and <argname>s2</argname>.
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  This accessor is not available for VARs or VECMs; for models of that
	  sort see <fncref targ="$sigma"/> and <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM; returns a matrix in
	  which the Gamma matrices (coefficients on the lagged differences
	  of the cointegrated variables) are stacked side by side.
	  Each row represents an equation; for a VECM of lag order
	  <math>p</math> there are <math>p</math> &minus; 1 sub-matrices.
	</para>
      </description>
    </function>

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Returns an integer value that codes for the program
	  version. The current gretl version string takes the form of
	  a 4-digit year followed by a letter from a to j representing
	  the sequence of releases within the year (for example,
	  2015d).  The return value from this accessor is formed as 10
	  times the year plus the zero-based lexical order of the
	  letter, so 2015d translates to 20153.
	</para>
	<para>
	  Prior to gretl 2015d, version identifiers took the form
	  x.y.z (three integers separated by dots), and in that case
	  the accessor value was calculated as <lit>10000*x + 100*y +
	  z</lit>, so that for example 1.10.2 (the last release under
	  the old scheme) translates as 11002. Numerical order of
	  <lit>$version</lit> values is therefore preserved across the
	  change in versioning scheme.
	</para>
      </description>
    </function>

    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VAR or a VECM; returns a
	  matrix containing the VMA representation up to the order
	  specified via the <lit>set horizon</lit> command. See
	  <guideref targ="chap:var"/> for details.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Returns 1 if gretl is running on MS Windows, otherwise 0. By
	  conditioning on the value of this variable you can write shell
	  calls that are portable across different operating systems.
	</para>
	<para>
	  Also see the <cmdref targ="shell"/> command.
	</para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  If the last model was a single equation, returns the list of
	  regressors. If the last model was a system of equations,
	  returns the <quote>global</quote> list of exogenous
	  variables (in the same order in which they
	  appear in <fncref targ="$sysB"/>). If the last model was a
	  VAR, returns the list of exogenous regressors, if any,
	  except for standard deterministic terms (constant, trend,
	  seasonals).
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Following estimation of a VAR or VECM (only), returns
	  <math>X'X</math><sup>-1</sup>, where <math>X</math> is the
	  common matrix of regressors used in each of the equations.
	  While this accessor is available for a VECM estimated with a
	  restriction imposed on &agr; (the <quote>loadings</quote>
	  matrix), it should be borne in mind that in that case not
	  all coefficients of the regressors are freely varying.
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Returns the fitted values from the last regression.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  If the last model estimated was a VAR, VECM or simultaneous
	  system, returns the associated list of endogenous variables.
	  If the last model was a single equation, this accessor gives
	  a list with a single element, the dependent variable. In the
	  special case of the biprobit model the list contains two
	  elements.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Built-in strings" ref="string_constants">

    <function name="$dotdir" section="straccess" output="string">
      <description>
        <para>
	  Yields the full path of the directory gretl uses for
	  temporary files. To use it in string-substitution mode,
	  prepend the at-sign (<lit>@dotdir</lit>).
        </para>
        </description>
    </function>

    <function name="$gnuplot" section="straccess" output="string">
        <description>
        <para>
          Yields the path to the <lit>gnuplot</lit> executable. To use
          it in string-substitution mode, prepend the at-sign
          (<lit>@gnuplot</lit>).
        </para>
        </description>
    </function>

    <function name="$gretldir" section="straccess" output="string">
        <description>
        <para>
          Yields the full path of the gretl installation directory. To
          use it in string-substitution mode, prepend the at-sign
          (<lit>@gretldir</lit>).
        </para>
        </description>
    </function>

    <function name="$lang" section="access" output="string">
      <description>
	<para>
	  Returns a string representing the national language in force
	  currently, if this can be determined. The string is composed
	  of a two-letter ISO 639-1 language code (for example,
	  <lit>en</lit> for English, <lit>jp</lit> for Japanese,
	  <lit>el</lit> for Greek) followed by an underscore plus a
	  two-letter ISO 3166-1 country code.  Thus for example
	  Portuguese in Portugal gives <lit>pt_PT</lit> while
	  Portuguese in Brazil gives <lit>pt_BR</lit>.
	</para>
	<para>
	  If the national language cannot be determined, the string
	  <quote><lit>unknown</lit></quote> is returned.
	</para>
      </description>
    </function>

    <function name="$seats" section="straccess" output="string">
        <description>
        <para>
          Yields the path to the <lit>seats</lit> executable, which
          accompanies <lit>tramo</lit>. To use it in
          string-substitution mode, prepend the at-sign
          (<lit>@seats</lit>).
        </para>
        </description>
    </function>

    <function name="$tramo" section="straccess" output="string">
        <description>
        <para>
          Yields the path to the <lit>tramo</lit> executable. To use
          it in string-substitution mode, prepend the at-sign
          (<lit>@tramo</lit>).
        </para>
        </description>
    </function>

    <function name="$tramodir" section="straccess" output="string">
        <description>
        <para>
         Yields the path string of the <lit>tramo</lit> data
         directory. To use it in string-substitution mode, prepend the
         at-sign (<lit>@tramodir</lit>).
        </para>
        </description>
    </function>

    <function name="$workdir" section="access" output="string">
      <description>
	<para>
	  Yields the path which gretl reads from and writes to by
	  default. A fuller discussion is provided in the Command
	  Reference under <cmdref targ="workdir"/>. Note that this
	  string can be set by the user via the <cmdref targ="set"/>
	  command.  To use it in string-substitution mode, prepend the
	  at-sign (<lit>@workdir</lit>).
        </para>
      </description>
    </function>

    <function name="$x12a" section="straccess" output="string">
        <description>
        <para>
          Yields the path to the <lit>x-12-arima</lit> (or
          <lit>x-13arima</lit>) executable. To use it in
          string-substitution mode, prepend the at-sign
          (<lit>@x12a</lit>).
        </para>
        </description>
    </function>

    <function name="$x12adir" section="straccess" output="string">
        <description>
        <para>
          Yields the path of the <lit>x-12-arima</lit> (or
          <lit>x-13arima</lit>) data directory. To use it in
          string-substitution mode, prepend the at-sign
          (<lit>@x12adir</lit>).
        </para>
        </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the absolute value of <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the arc cosine of <argname>x</argname>, that is, the value
	  whose cosine is <argname>x</argname>.  The result is in radians; the
	  input should be in the range &minus;1 to 1.
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse hyperbolic cosine of <argname>x</argname>
	  (positive solution). <argname>x</argname> should be greater than 1;
	  otherwise, NA is returned.
	  <seelist>
            <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-list-or-mat">x</fnarg>
	<fnarg type="series-list-or-mat">byvar</fnarg>
	<fnarg type="string" optional="true">funcname</fnarg>
      </fnargs>
      <description>
	<para>
	  Most of the following assumes that the first two arguments
	  to this function take the form of series or lists, but see
	  <quote>Matrix input</quote> below for alternative usage.
	</para>
	<para>
	  In the simplest usage <argname>x</argname> is set to
	  <lit>null</lit>, <argname>byvar</argname> is a single series
	  and the third argument is omitted or set to
	  <lit>null</lit>. The return value is then a matrix with two
	  columns holding, respectively, the distinct values of
	  <argname>byvar</argname> sorted in ascending order, and the
	  count of observations at which <argname>byvar</argname>
	  takes on each of these values. For example,
	</para>
	<code>
	  open data4-1
	  eval aggregate(null, bedrms)
	</code>
	<para>
	  will show that the series <lit>bedrms</lit> has values
	  3 (with count 5) and 4 (with count 9).
	</para>
	<para>
	  More generally, if <argname>byvar</argname> is a list with
	  <math>n</math> members then the first <math>n</math> columns
	  of the returned matrix hold the combinations of the distinct
	  values of each of the <math>n</math> series, and the count
	  column holds the number of observations at which each
	  combination is realized. (The count column can always be
	  found at the position <lit>nelem(byvar)+1</lit>).
	</para>
	<subhead>Specifying an aggregation function</subhead>
	<para>
	  If the third argument is given then <argname>x</argname>
	  must not be <lit>null</lit>, and the rightmost
	  <math>m</math> columns hold the values of the statistic
	  specified by <argname>funcname</argname> for each of the
	  variables in <argname>x</argname>. (So <math>m</math> is
	  equal to 1 if <argname>x</argname> is a single series and
	  equal to <lit>nelem(x)</lit> if <argname>x</argname> is a
	  list.)  The specified statistic is calculated on the
	  sub-samples defined by the combinations in
	  <argname>byvar</argname> (in ascending order); these
	  combinations are shown in the first <math>n</math> column(s)
	  of the returned matrix.
	</para>
	<para>
	  So, if both <argname>x</argname> and
	  <argname>byvar</argname> are individual series, the return
	  value is a matrix with three columns holding the distinct
	  values of <argname>byvar</argname> sorted in ascending
	  order; the count of observations at which
	  <argname>byvar</argname> takes on each of these values; and
	  the values of the statistic specified by
	  <argname>funcname</argname> calculated on series
	  <argname>x</argname>, using just those observations at which
	  <argname>byvar</argname> takes on the value given in the
	  first column.
	</para>
	<para>
	  The following values of <argname>funcname</argname> are
	  supported <quote>natively</quote>: <fncref targ="sum"/>,
	  <fncref targ="sumall"/>, <fncref targ="mean"/>, <fncref
	  targ="sd"/>, <fncref targ="var"/>, <fncref targ="sst"/>,
	  <fncref targ="skewness"/>, <fncref targ="kurtosis"/>,
	  <fncref targ="min"/>, <fncref targ="max"/>, <fncref
	  targ="median"/>, <fncref targ="nobs"/>, <fncref
	  targ="gini"/>, <fncref targ="isconst"/> and <fncref
	  targ="isdummy"/>. Each of these functions takes a series
	  argument and returns a scalar value, and in that sense can
	  be said to <quote>aggregate</quote> the series in some way.
	  If none of these built-in functions does what you need, you
	  can give the name of a user-defined function as the
	  aggregator. Like the built-ins, such a function must take a
	  single series argument and return a scalar value.
	</para>
	<para>
	  Note that although a count of cases is provided
	  automatically the <lit>nobs</lit> function is not redundant
	  as an aggregator, since it gives the number of valid
	  (non-missing) observations on <argname>x</argname> at
	  each <argname>byvar</argname> combination.
	</para>
        <subhead>Some examples</subhead>
	<para>
	  First, suppose that <lit>region</lit> represents a coding of
	  geographical region using integer values 1 to
	  <math>n</math>, and <lit>income</lit> represents household
	  income. Then the following would produce an <by r="n"
	  c="3"/> matrix holding the region codes, the count of
	  observations in each region, and mean household income for
	  each of the regions:
	</para>
	<code>
	  matrix m = aggregate(income, region, mean)
	</code>
	<para>
	  For an example using lists, let <lit>gender</lit> be a
	  male/female dummy variable, let <lit>race</lit> be a
	  categorical variable with three values, and consider
	  the following:
	</para>
	<code>
	  list BY = gender race
	  list X = income age
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  The <lit>aggregate</lit> call here will produce a <by r="6"
	  c="5"/> matrix. The first two columns hold the 6 distinct
	  combinations of gender and race values; the middle column
	  holds the count for each of these combinations; and the
	  rightmost two columns contain the sample standard deviations
	  of <lit>income</lit> and <lit>age</lit>.
	</para>
	<para>
	  If <argname>byvar</argname> is a list, some combinations of
	  the <argname>byvar</argname> values may not be present in
	  the data (giving a count of zero). In that case the value of
	  the statistics for <argname>x</argname> are recorded as
	  <lit>NaN</lit> (not a number).  To cut out such cases you
	  can use the <fncref targ="selifr"/> function to select only
	  those rows that have a non-zero count. The column to test is
	  one place to the right of the number of
	  <argname>byvar</argname> variables, so we can do:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
	<subhead>Matrix input</subhead>
	<para>
	  Instead of series or lists, <argname>x</argname> and
	  <argname>byvar</argname> may be given in matrix
	  form. However, if both arguments are provided they must
	  match in type (you cannot give a series or list for one
	  argument and a matrix for the other) and two matrix
	  arguments must have the same number of rows.  In this
	  context matrix columns are treated as if they were series,
	  so the aggregation function must follow the pattern
	  described above, taking a series argument and returning a
	  scalar.
	</para>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string" optional="true">default</fnarg>
      </fnargs>
      <description>
	<para>
	  For <argname>s</argname> the name of a parameter to a
	  user-defined function, returns the name of the corresponding
	  argument, if the argument had a name at the caller level. If
	  the argument was anonymous, an empty string is returned
	  unless the optional <argname>default</argname> argument is
	  provided, in which case its value is used as a fallback.
	</para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  The basic <quote>constructor</quote> function for a new
	  array variable. In using this function you must specify a
	  type (in plural form) for the array: <lit>strings</lit>,
	  <lit>matrices</lit>, <lit>bundles</lit>, <lit>lists</lit> or
	  <lit>arrays</lit>.  The return value is an array of the
	  specified type with <argname>n</argname> elements, each of
	  which is initialized as <quote>empty</quote> (&eg;
	  zero-length string, null matrix). Examples of usage:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  See also <fncref targ="defarray"/>.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the arc sine of <argname>x</argname>, that is, the value
	  whose sine is <argname>x</argname>.  The result is in radians; the
	  input should be in the range &minus;1 to 1.
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse hyperbolic sine of <argname>x</argname>.
	  <seelist>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="asort" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="array">a</fnarg>
	<fnarg type="string">fname</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs an in-place sort of the elements of
	  <argname>a</argname>, using a comparator function specified
	  by the caller under the control of the quicksort routine.
	</para>
	<para>
	  The argument <argname>a</argname> can be of any of the types
	  supported for a gretl array, namely <lit>strings</lit>,
	  <lit>matrices</lit>, <lit>bundles</lit>, <lit>lists</lit> or
	  <lit>arrays</lit>. The <argname>fname</argname> argument
	  must be the name of a function which takes two
	  <lit>const</lit> arguments, whose type matches that of the
	  elements of <argname>a</argname>. This function must return
	  an integer value on the following pattern: 0 if the two
	  arguments have the same sort order, negative if the first
	  argument sorts before the second, or positive if the second
	  sorts before the first. (The exact values do not matter.)
	</para>
	<para>
	  For example, suppose one wants to sort an array of bundles,
	  each of which contains a scalar named <lit>crit</lit>, by
	  increasing value of <lit>crit</lit>. Then the following
	  function would be suitable for passing to <lit>asort</lit>:
	</para>
	<code>
	  function scalar my_bsort (const bundle b1, const bundle b2)
	     return sgn(b1.crit - b2.crit)
	  end function
	</code>
	<para>
	  If you want to preserve the unsorted array, make a copy of
	  it before passing it to <lit>asort</lit>. The return value
	  from this function is a nominal 0 on success.
	</para>
	<para>
	  See also <fncref targ="sort"/> for simple sorting of an
	  array of strings.
	</para>
      </description>
    </function>

    <function name="assert" section="programming" output="scalar">
      <fnargs>
	<fnarg type="scalar">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  This function is intended for testing or debugging of hansl
	  code. The argument should be an expression which evaluates
	  to a scalar. The return value is 1 if
	  <argname>expr</argname> evaluates to a non-zero value
	  (boolean <quote>true</quote>, or <quote>success</quote>) or
	  0 if it evaluates to zero (boolean <quote>false</quote>, or
	  <quote>failure</quote>).
	</para>
	<para>
	  By default there are no consequences of a call to
	  <lit>assert</lit> failing other than the return value being
	  zero. However, the <cmdref targ="set"/> command can be used
	  to make failure of an assertion more consequential. There
	  are three levels:
	</para>
	<code>
	  # print a warning message but continue execution
	  set assert warn
	  # print an error message and stop script execution
	  set assert stop
	  # print a message to stderr and abort the program
	  set assert fatal
	</code>
	<para>
	  In most cases <lit>stop</lit> is sufficient to terminate a
	  script but in certain special cases (such as within a
	  function called from a command block such as <cmdref
	  targ="mle"/>) it may be necessary to use the
	  <lit>fatal</lit> setting to get a clear indication of the
	  failing assertion. Note, however, that in this case the
	  message will go to standard error output.
	</para>
	<para>
	  The default behavior can be restored via
	</para>
	<code>
	  set assert off
	</code>
	<para>
	  By way of a simple example, if at a certain point in a hansl
	  script a scalar <lit>x</lit> ought to be non-negative, the
	  following will flag an error if that is not the case:
	</para>
	<code>
	  set assert stop
	  assert(x >= 0)
	</code>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the arc tangent of <argname>x</argname>, that is, the value
	  whose tangent is <argname>x</argname>.  The result is in radians.
	</para>
	<para>
	  <seelist>
	    <fncref targ="tan"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the principal value of the arc tangent of
	  <argname>y</argname>/<argname>x</argname>, using the signs
	  of the two arguments to determine the quadrant of the
	  result. The return value is in radians, in the range
	  [&minus;&pi;, &pi;].
	</para>
	<para>
	  If the two arguments differ in type, the type of the result
	  is the <quote>higher</quote> of the two, where the ordering
	  is matrix &gt; series &gt; scalar. For example, if
	  <argname>y</argname> is a scalar and <argname>x</argname> an
	  <math>n</math>-vector (or vice versa) the result is an
	  <math>n</math>-vector. Note that matrix arguments must be
	  vectors, and if neither argument is a scalar the two
	  arguments must be of the same length.
	</para>
	<para>
	  <seelist>
            <fncref targ="tan"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse hyperbolic tangent of <argname>x</argname>.
	  <seelist>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Closely related to the C library function of the same name.
	  Returns the result of converting the string
	  <argname>s</argname> (or the leading portion thereof, after
	  discarding any initial white space) to a floating-point
	  number.  Unlike <lit>atof</lit> in C, however, the decimal
	  character is always assumed (for reasons of portability) to
	  be <quote><lit>.</lit></quote>. Any characters that follow
	  the portion of <argname>s</argname> that converts to a
	  floating-point number under this assumption are ignored.
	</para>
	<para>
	  If none of <argname>s</argname> (following any discarded
	  white space) is convertible under the stated assumption,
	  <lit>NA</lit> is returned.
	</para>
	<code>
	  # examples
	  x = atof("1.234") # gives x = 1.234
	  x = atof("1,234") # gives x = 1
	  x = atof("1.2y")  # gives x = 1.2
	  x = atof("y")     # gives x = NA
	  x = atof(",234")  # gives x = NA
	</code>
	<para>
	  See also <fncref targ="sscanf"/> for more flexible string to
	  numeric conversion.
	</para>
      </description>
    </function>

    <function name="bcheck" section="programming" output="scalar">
      <fnargs>
	<fnarg type="bundleref">target</fnarg>
	<fnarg type="bundle" optional="true">input</fnarg>
	<fnarg type="strings" optional="true">required-keys</fnarg>
      </fnargs>
      <description>
	<para>
	  Primarily intended for use by writers of function
	  packages. Here is the context in which <lit>bcheck</lit> may
	  be useful: you have a function which accepts a bundle
	  argument whereby the caller can make various choices.
	  Some elements of the bundle may have default values&mdash;so
	  the caller is not obliged to make an explicit
	  choice&mdash;while other elements may be required. You want
	  to determine whether the argument you get is valid. The
          main text below assumes that an <argname>input</argname>
          bundle is supplied by the caller of your function, but see
          the section headed <quote>No input bundle</quote> for
          the contrary case.
	</para>
	<para>
	  To use <lit>bcheck</lit> you construct a template bundle
	  containing all the supported keys, with values that
	  exemplify the type associated with each key, and pass this
	  in pointer form as <argname>target</argname>. For the second
	  argument, <argname>input</argname>, pass the bundle you get
	  from the caller. This function then checks the following:
	</para>
	<ilist>
	  <li>
	    <para>
	      Does <argname>input</argname> contain any keys not
	      present in <argname>target</argname>? If so,
	      <lit>bcheck</lit> returns a non-zero value, indicating
	      that <argname>input</argname> is erroneous. (Most
	      likely, the key in question is misspelled.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Does <argname>input</argname> contain under any given
	      key an object whose type does not match that in
	      <argname>target</argname>? If so, a non-zero value is
	      returned.
	    </para>
	  </li>
	  <li>
	    <para>
	      If some elements in <argname>target</argname> require
	      input from the caller (so the value you supply is not a
	      default value, just a placeholder to indicate the
	      required type), you should supply a third argument to
	      <lit>bcheck</lit>: an array of strings holding the keys
	      for which input is not optional. Then the return value
	      will be non-zero if any required elements are missing
	      from <argname>input</argname>.
	    </para>
	  </li>
	</ilist>
	<para>
	  In addition to the above you may wish to impose lower and/or
	  upper bounds on the value of one or more scalar members of
	  the bundle argument. If so, add a bundle named
	  <lit>bounds</lit> to your template bundle. Each member of
	  this secondary bundle should have a <i>key</i> that
	  identifies a member of the template bundle; its <i>value</i>
	  should be a 2-vector holding lower and upper limits.  Put
	  <lit>NA</lit> in place of one of the limits if it is
	  unbounded. So, for example, the following code will check
	  that if <lit>x1</lit> is given in the caller's input it is
	  between 1 and 5, and if <lit>x2</lit> is given it is
	  non-negative:
	</para>
	<code>
	  template.bounds = _(x1={1,5}, x2={0,NA})
	</code>
	<para>
	  If no errors are detected on any of these points, values
	  supplied in <argname>input</argname> are copied to
	  <argname>target</argname> (defaults being replaced by valid
	  selections on the caller's part). If errors are found a
	  message will be printed indicating what is wrong with
	  <argname>input</argname>.
	</para>
	<para>
	  To give a simple example, suppose your function's argument
	  bundle supports a matrix <lit>X</lit> (required), a
	  non-negative scalar <lit>z</lit> with default value 0, and a
	  string <lit>s</lit> with default value
	  <quote><lit>display</lit></quote>. Then the following code
	  fragment would be suitable for checking a bundle named
	  <lit>uservals</lit> supplied by the caller:
	</para>
	<code>
	  bundle target = _(X={}, z=0, s="display")
	  target.bounds = _(z={0,NA})
	  strings req = defarray("X")
	  err = bcheck(&amp;target, uservals, req)
	  if err
	     # react appropriately
	  else
	     # proceed, using the values in target
	  endif
	</code>
        <subhead>No input bundle</subhead>
        <para>
          If the <argname>input</argname> bundle is not supplied to
          <lit>bcheck</lit>, it behaves as follows. If the
          <argname>required-keys</argname> argument is not given, it returns
          zero (since none of the error conditions mentioned above can
          occur), and <argname>target</argname> is not modified.  Otherwise
          it returns non-zero since it's clear that one or more
          specifications must be missing. This means that it's safe to pass
          a null <argname>input</argname> to <lit>bcheck</lit>.
        </para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">type</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes one of the Bessel function variants for order
	  <argname>v</argname> and argument <argname>x</argname>.  The return
	  value is of the same type as <argname>x</argname>. The specific
	  function is selected by the first argument, which must be
	  <lit>J</lit>, <lit>Y</lit>, <lit>I</lit>, or <lit>K</lit>.  A good
	  discussion of the Bessel functions can be found on Wikipedia; here
	  we give a brief account.
	</para>
	<para>
	  case <lit>J</lit>: Bessel function of the first kind.  Resembles a
	  damped sine wave.  Defined for real <argname>v</argname> and
	  <argname>x</argname>, but if <argname>x</argname> is negative
	  then <argname>v</argname> must be an integer.
	</para>
	<para>
	  case <lit>Y</lit>: Bessel function of the second kind.  Defined
	  for real <argname>v</argname> and <argname>x</argname> but has
	  a singularity at <argname>x</argname> = 0.
	</para>
	<para>
	  case <lit>I</lit>: Modified Bessel function of the first kind.
	  An exponentially growing function.  Acceptable arguments are
	  as for case <lit>J</lit>.
	</para>
	<para>
	  case <lit>K</lit>: Modified Bessel function of the second kind.  An
	  exponentially decaying function.  Diverges at <argname>x</argname> =
	  0 and is not defined for negative <argname>x</argname>.  Symmetric
	  around <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Numerical maximization via the method of Broyden, Fletcher,
	  Goldfarb and Shanno. On input the vector
	  <argname>b</argname> should hold the initial values of a set
	  of parameters, and the argument <argname>f</argname> should
	  specify a call to a function that calculates the (scalar)
	  criterion to be maximized, given the current parameter
	  values and any other relevant data. If the object is in fact
	  minimization, this function should return the negative of
	  the criterion.  On successful completion, <lit>BFGSmax</lit>
	  returns the maximized value of the criterion, and
	  <argname>b</argname> holds the parameter values which
	  produce the maximum.
	</para>
	<para>
	  The optional third argument provides a means of supplying
	  analytical derivatives (otherwise the gradient is computed
	  numerically).  The gradient function call
	  <argname>g</argname> must have as its first argument a
	  predefined matrix that is of the correct size to contain
	  the gradient, given in pointer form. It also must take the
	  parameter vector as an argument (in pointer form or
	  otherwise).  Other arguments are optional.
	</para>
	<para>
	  For more details and examples see <guideref
	  targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGScmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGSmin" section="numerical" output="scalar">
      <description>
	<para>
	  An alias for <fncref targ="BFGSmax"/>; if called under this
	  name the function acts as a minimizer.
	</para>
      </description>
    </function>

    <function name="BFGScmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="matrix">bounds</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Constrained numerical maximization using L-BFGS-B (limited
	  memory BFGS, see <cite key="byrd-etal95">Byrd, Lu, Nocedal
	  and Zhu, 1995</cite>).  On input the vector
	  <argname>b</argname> should hold the initial values of a set
	  of parameters, <argname>bounds</argname> should hold bounds
	  on the parameter values (see below), and
	  <argname>f</argname> should specify a call to a function
	  that calculates the (scalar) criterion to be maximized,
	  given the current parameter values and any other relevant
	  data. If the object is in fact minimization, this function
	  should return the negative of the criterion.  On successful
	  completion, <lit>BFGScmax</lit> returns the maximized value
	  of the criterion, subject to the constraints in
	  <argname>bounds</argname>, and <argname>b</argname> holds
	  the parameter values which produce the maximum.
	</para>
        <subhead>Bounds on parameters</subhead>
	<para>
	  The <argname>bounds</argname> matrix must have 3 columns and
	  as many rows as there are constrained elements in the
	  parameter vector. The first element on a given row is the
	  (1-based) index of the constrained parameter; the second and
	  third are the lower and upper bounds, respectively. The
	  values <lit>-$huge</lit> and <lit>$huge</lit> should be used
	  to indicate that the parameter is unconstrained downward or
	  upward, respectively. For example, the following is the way
	  to specify that the second element of the parameter vector
	  must be non-negative:
	</para>
	<code>
	  matrix bounds = {2, 0, $huge}
	</code>
        <subhead>Analytical derivatives</subhead>
	<para>
	  The optional fourth argument provides a means of supplying
	  analytical derivatives (otherwise the gradient is computed
	  numerically).  The gradient function call
	  <argname>g</argname> must have as its first argument a
	  predefined matrix that is of the correct size to contain
	  the gradient, given in pointer form. It also must take the
	  parameter vector as an argument (in pointer form or
	  otherwise).  Other arguments are optional.
	</para>
	<para>
	  For more details and examples see <guideref
	  targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGScmin" section="numerical" output="scalar">
      <description>
	<para>
	  An alias for <fncref targ="BFGScmax"/>; if called under this
	  name the function acts as a minimizer.
	</para>
      </description>
    </function>

    <function name="bin2dec" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a matrix <argname>B</argname> containing only zeros
	  and ones, this function interprets each row as the binary
	  representation of a 32-bit unsigned integer, and returns a
	  column vector with the decimal representation of those
	  integers. The argument cannot have more than 32 columns
	  otherwise an error is flagged.
	</para>
	<para>
	  Note that the least significant bit comes in the first
	  column. So column 1 corresponds to
	  <math>2</math><sup>0</sup>, column 2 to
	  <math>2</math><sup>1</sup>, and so on. For example, the
	  expression
	</para>
	<code>
	  scalar x = bin2dec({1,0,1})
	</code>
	<para>
	  stores the value 5 into <math>x</math>.
	</para>
	<para>
	  The <fncref targ="dec2bin"/> function performs the inverse
	  transformation.
	</para>
      </description>
    </function>

    <function name="bincoeff" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">n</fnarg>
	<fnarg type="anyfloat">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the binomial coefficient, that is the number of ways
	  in which <argname>k</argname> items can be chosen from
	  <argname>n</argname> items without repetition, irrespective
	  of ordering. This is also equal to the coefficient of the
	  (<math>k</math>+1)-th term in the polynomial expansion of
	  the binomial power <equation status="inline" ascii="(1+x)^n"
	  tex="$(1+x)^n$"/>.
	</para>
	<para context="tex">
	  For integer arguments the result is
	  $n!/(k!(n-k)!)$ but the function also accepts
	  noninteger arguments, and the formula above generalizes to
	  $\frac{\Gamma(n+1)}{\Gamma(k+1) \Gamma(n-k+1)}$.
	</para>
	<para context="notex">
	  For integer arguments the result is
	  <math>n!/(k!(n-k)!)</math> but the function also accepts
	  noninteger arguments, and the formula above
	  generalizes to (<math>n</math>+1)/((<math>k</math>+1)
	  &times; (<math>n-k</math>+1)).
	</para>
	<para>
	  When <argname>k</argname> &gt; <argname>n</argname> or
	  <argname>k</argname> &lt; 0 no valid answer exists and an
	  error is flagged.
	</para>
	<para>
	  If the two arguments differ in type, the type of the result
	  is the <quote>higher</quote> of the two, where the ordering
	  is matrix &gt; series &gt; scalar. For example, if
	  <argname>n</argname> is a scalar and <argname>k</argname> an
	  <math>r</math>-vector (or vice versa) the result is an
	  <math>r</math>-vector. Note that matrix arguments must be
	  vectors, and if neither argument is a scalar the two
	  arguments must be of the same length.
	</para>
	<para>
	  See also <fncref targ="gammafun"/> and <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="binperms" section="math" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Binary permutations: returns a <by r="p" c="n"/> matrix,
	  each of whose rows holds a distinct arrangement of
	  <math>k</math> ones and <math>n</math> &minus;
	  <math>k</math> zeros (in lexicographic order). The maximum
	  supported value of <math>n</math> is 64, <math>n</math> and
	  <math>k</math> must be non-negative, and <math>k</math> must
	  be no greater than <math>n</math>; otherwise an error is
	  flagged. In case <math>n</math> = <math>k</math> = 0 an
	  empty matrix is returned.
	</para>
	<para>
	  For example, with <math>n</math> = 4 and <math>k</math> = 2,
	  the result is
	</para>
	<code>
	  0   0   1   1
	  0   1   0   1
	  0   1   1   0
	  1   0   0   1
	  1   0   1   0
	  1   1   0   0
	</code>
	<para>
	  <emphasis>Warning:</emphasis> the number of permutations,
	  <math>p</math>, is a steeply increasing function of
	  <math>n</math> and is greatest when <math>k</math> is about
	  half of <math>n</math>. You may want to check in advance the
	  size of the matrix that <lit>binperms</lit> will attempt to
	  allocate. The <fncref targ="bincoeff"/> function returns
	  <math>p</math>, and the size of the resulting matrix in
	  megabytes can be calculated as
	</para>
	<code>
	  MB = 8 * n * bincoeff(n, k) / 10^6
	</code>
	<para>
	  For <math>n</math> = 30, this gives about 34 MB when
	  <math>k</math> = 25, 7211 MB if <math>k</math> =
	  20, and 20758 MB if <math>k</math> = 18.
	</para>
      </description>
    </function>

    <function name="bkfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the result from application of the Baxter&ndash;King
	  bandpass filter to the series <argname>y</argname>.  The
	  optional parameters <argname>f1</argname> and
	  <argname>f2</argname> represent, respectively, the lower and
	  upper bounds of the range of frequencies to extract, while
	  <argname>k</argname> is the approximation order to be
	  used.
	</para>
	<para>
	  If these arguments are not supplied then the default values
	  depend on the periodicity of the dataset. For yearly data
	  the defaults for <argname>f1</argname>,
	  <argname>f2</argname> and <argname>k</argname> are 2, 8 and
	  3, respectively; for quarterly data, 6, 32 and 12; for
	  monthly data, 18, 96 and 36. These values are chosen to
	  match the most common choice among practitioners, that is to
	  use this filter for extracting the <quote>business
	  cycle</quote> frequency component; this, in turn, is
	  commonly defined as being between 18 months and 8 years. The
	  filter, per default choice, spans 3 years of data.
	</para>
	<para>
	  If <argname>f2</argname> is greater than or equal to the
	  number of available observations, then the
	  <quote>low-pass</quote> version of the filter will be run
	  and the resulting series should be taken as an estimate of
	  the trend component, rather than the cycle.
	  <seelist>
            <fncref targ="bwfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bkw" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">V</fnarg>
	<fnarg optional="true" type="strings">parnames</fnarg>
	<fnarg optional="true" type="bool">verbose</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes BKW collinearity diagnostics (see <cite
	  key="belsley-etal80">Belsley, Kuh and Welsch (1980)</cite>)
	  given a covariance matrix of parameter estimates,
	  <argname>V</argname>. The optional second argument, which
	  can be an array of strings or a string containing
	  comma-separated names, is used to label the columns showing
	  the variance proportions; the number of names should match
	  the dimension of <argname>V</argname>.  After estimation of
	  a model in gretl, suitable arguments can be obtained via the
	  <fncref targ="$vcv"/> and <fncref targ="$parnames"/>
	  accessors.
	</para>
	<para>
	  By default this function operates silently, just returning
	  the BKW table as a matrix, but if a non-zero value is given
	  for the third argument the table is printed along with some
	  analysis.
	</para>
	<para>
	  There is also a command form of this facility, <cmdref
	  targ="bkw"/>, which automatically references the last model
	  and requires no arguments.
	</para>
      </description>
    </function>

    <function name="boxcox" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the Box&ndash;Cox transformation with parameter
	  <argname>d</argname> for the positive series
	  <argname>y</argname> (or the columns of matrix
	  <argname>y</argname>).
	</para>
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  The result is (<math>y</math><sup>d</sup> -
	  1)/<math>d</math> for <math>d</math> not equal to zero, or
	  log(<math>y</math>) for <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Reads a bundle from the file specified by the
	  <argname>fname</argname> argument. By default the bundle is
	  assumed to be represented in XML, and to be gzip-compressed
	  if <argname>fname</argname> has extension
	  <lit>.gz</lit>. But if the extension is <lit>.json</lit> or
	  <lit>.geojson</lit> the content is assumed to be JSON.
	</para>
	<para>
	  In the XML case the file must contain a
	  <lit>gretl-bundle</lit> element, which is used to store zero
	  or more <lit>bundled-item</lit> elements. For example,
	</para>
	<code>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;gretl-bundle name="temp"&gt;
          &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
          &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
	  &lt;/gretl-bundle&gt;
	</code>
	<para>
	  As you might expect, files suitable for reading via
	  <lit>bread</lit> are generated by the companion function
	  <fncref targ="bwrite"/>.
	</para>
	<para>
	  If the file name does not contain a full path specification,
	  it will be looked for in several <quote>likely</quote>
	  locations, beginning with the currently set <cmdref
	  targ="workdir"/>. However, if a non-zero value is given for
	  the optional <argname>import</argname> argument, the input
	  file is taken to be in the user's <quote>dot</quote>
	  directory. In that case <argname>fname</argname> should be a
	  plain file name, without any path component.
	</para>
	<para>
	  Should an error occur (such as the file being badly
	  formatted or inaccessible), an error is returned via the
	  <fncref targ="$error"/> accessor.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
            <fncref targ="bwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="brename" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">oldkey</fnarg>
	<fnarg type="string">newkey</fnarg>
      </fnargs>
      <description>
	<para>
	  If the bundle <argname>B</argname> contains a member under
	  the key <argname>oldkey</argname>, its key is changed to
	  <argname>newkey</argname>, otherwise an error is
	  flagged. Returns 0 on successful renaming.
	</para>
	<para>
	  Changing the key of a bundle member is not a common task but
	  it can arise in the context of functions that work with
	  bundles, and <lit>brename</lit> is an efficient tool for the
	  job. Example:
	</para>
	<code>
	  # set up a bundle holding a big matrix
	  bundle b
	  b.X = mnormal(1000, 1000)
	  if 0
	      # change the key manually
	      Xcopy = b.X
	      delete b.X
	      b.Y = Xcopy
	      delete Xcopy
	  else
	      # versus: change it efficiently
	      brename(b, "X", "Y")
	  endif
	</code>
	<para>
	  The first method requires that the big matrix be copied
	  twice, out of the bundle then back into it under a different
	  key; the efficient method changes the key directly.
	</para>
      </description>
    </function>

    <function name="bwfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the result from application of a low-pass
	  Butterworth filter with order <argname>n</argname> and
	  frequency cutoff <argname>omega</argname> to the series
	  <argname>y</argname>. The cutoff is expressed in degrees and
	  must be greater than 0 and less than 180. Smaller cutoff
	  values restrict the pass-band to lower frequencies and hence
	  produce a smoother trend. Higher values of
	  <argname>n</argname> produce a sharper cutoff, at the cost
	  of possible numerical instability.
	</para>
	<para>
	  Inspecting the periodogram of the target series is a
	  useful preliminary when you wish to apply this function.
	  See <guideref targ="chap:tsfilter"/> for details.
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Writes the bundle <argname>B</argname> to file, serialized
	  in XML or, if <argname>fname</argname> has extension
	  <lit>.json</lit> or <lit>.geojson</lit>, as JSON. See
	  <fncref targ="bread"/> for a description of the format when
	  XML is used. If <argname>fname</argname> already exists, it
	  will be overwritten. The nominal return value is 0 on
	  successful completion; if writing fails an error is flagged.
	</para>
	<para>
	  The output file will be written in the currently set <cmdref
	  targ="workdir"/>, unless <repl>fname</repl> contains a full
	  path specification. However, if a non-zero value is given
	  for the <argname>export</argname> argument, the file will be
	  written into the user's <quote>dot</quote> directory. In
	  that case a plain file name, without any path component,
	  should be given for the second argument.
	</para>
	<para>
	  In the case of XML output (only), the option of gzip
	  compression is available; this is applied if
	  <argname>fname</argname> has the extension <lit>.gz</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="carg" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="m" c="n"/> real matrix holding the complex
	  <quote>argument</quote> of each element of the <by r="m"
	  c="n"/> complex matrix <argname>C</argname>. The argument of
	  the complex number <math>z</math> = <math>x</math> + <math>yi</math>
	  can also be computed as <lit>atan2(y, x)</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="abs"/>
	    <fncref targ="cmod"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">standardize</fnarg>
	<fnarg type="bool" optional="true">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Centers the columns of matrix <argname>X</argname> around
	  their means. If the optional second argument has a non-zero
	  value then in addition the centered values are divided by
	  the column standard deviations (which are calculated using
	  <math>n</math> &minus; 1 as divisor, where <math>n</math>
	  is the number of rows of <argname>X</argname>).
	</para>
	<para>
	  If a non-zero value is supplied for
	  <argname>skip_na</argname> missing values are ignored,
	  otherwise if a column of <argname>X</argname> contains any
	  missing values the corresponding column in the output is all
	  missing.
	</para>
	<para>
	  Note that <fncref targ="stdize"/> provides more flexible
	  functionality.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Cumulative distribution function calculator. Returns
	  <equation status="inline" ascii="P(X &le; x)" tex="$P(X \le
	  x)$"/>, where the distribution of <math>X</math> is
	  determined by the string <argname>d</argname>. Between
	  the arguments <argname>d</argname> and <argname>x</argname>,
	  zero or more additional scalar arguments are required to
	  specify the parameters of the distribution, as follows (but
	  note that the normal distribution has its own convenience
	  function, <fncref targ="cnorm"/>).
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Standard normal (d = z, n, or N): no extra arguments
            </para>
	  </li>
	  <li>
            <para>
              Bivariate normal (D): correlation coefficient
            </para>
	  </li>
	  <li>
            <para>
              Logistic (lgt or s): no extra arguments
            </para>
	  </li>
	  <li>
            <para>
              Student's t (t): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x, or X): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Snedecor's F (f or F): df (num.); df (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g or G): shape; scale
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): 2 shape parameters
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b or B): probability; number of trials
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p or P): mean
            </para>
	  </li>
	  <li>
            <para>
              Exponential (exp): scale
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w or W): shape; scale
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l or L): mean; scale
            </para>
	  </li>
	  <li>
            <para>
              Generalized Error (E): shape
            </para>
	  </li>
	  <li>
	    <para>
	      Non-central chi square (ncX): df, non-centrality parameter
	    </para>
	  </li>
	  <li>
	    <para>
	      Non-central F (ncF): df (num.), df (den.),
	      non-centrality parameter
	    </para>
	  </li>
	  <li>
	    <para>
	      Non-central t (nct): df, non-centrality parameter
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribution} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Standard normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Bivariate normal &amp; \texttt{D} &amp;
	  $\rho$ &amp; -- &amp; --\\
	  Logistic &amp; \texttt{lgt} &amp;
	  -- &amp; -- &amp; --\\
	  Student's $t$ (central) &amp; \texttt{t} &amp;
	  df &amp; -- &amp; --\\
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp;
	  df &amp; -- &amp; --\\
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp;
	  df (num.) &amp; df (den.) &amp; --\\
	  Gamma &amp; \texttt{g} or \texttt{G} &amp;
	  shape &amp; scale &amp; --\\
	  Binomial &amp; \texttt{b} or \texttt{B} &amp;
	  probability &amp; trials &amp; --\\
	  Poisson &amp; \texttt{p} or \texttt{P} &amp;
	  mean &amp; -- &amp; --\\
	  Exponential &amp; \texttt{exp} &amp;
	  scale &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} or \texttt{W} &amp;
	  shape &amp; scale &amp; --\\
	  Laplace &amp; \texttt{l} or \texttt{L} &amp;
	  mean &amp; scale &amp; --\\
	  Generalized Error &amp; \texttt{E} &amp;
	  shape &amp; -- &amp; --\\
	  Non-central $\chi^2$ &amp; \texttt{ncX} &amp;
	  df &amp; non-centrality &amp; -- \\
	  Non-central $F$ &amp; \texttt{ncF} &amp;
	  df (num.) &amp; df (den.) &amp; non-centrality \\
	  Non-central $t$ &amp; \texttt{nct} &amp;
	  df &amp; non-centrality &amp; -- \\
	</tabular>
	<para>
	  Note that most cases have aliases to help memorizing the codes.
	  The bivariate normal case is special: the syntax is <lit>x =
          cdf(D, rho, z1, z2)</lit> where <lit>rho</lit> is the
	  correlation between the variables <lit>z1</lit> and
	  <lit>z2</lit>.
	</para>
	<para context="tex">
	  The parametrization gretl uses for the Gamma random variate
	  implies that its density function can be written as
	  \[
	  f(x; k, \theta) = \frac{x^{k-1}}{\theta^k} \frac{e^{-x/\theta}}{\Gamma(k)}
	  \]
	  where $k&gt;0$ is the shape parameter and $\theta&gt;0$ is the scale
	  parameter.
	</para>
	<para>
	  <seelist>
            <fncref targ="pdf"/>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  This is a legacy function, predating gretl's native support
	  for complex matrices.
	</para>
	<para>
	  Complex division. The two arguments must have the same number of
	  rows, <math>n</math>, and either one or two columns.  The first
	  column contains the real part and the second (if present) the
	  imaginary part.  The return value is an <by r="n" c="2"/>
	  matrix or, if the result has no imaginary part, an
	  <math>n</math>-vector.
	  <seelist>
            <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  This function returns a list in which each series in
	  <argname>L</argname> that has the <quote>coded</quote>
	  attribute is replaced by a set of dummy variables
	  representing each of its coded values, with the least
	  value omitted. If <argname>L</argname> contains no
	  coded series the return value will be identical to
	  <argname>L</argname>.
	</para>
	<para>
	  The generated dummy variables, if any, are named on the
	  pattern
	  <lit>D</lit><repl>varname</repl><lit>_</lit><repl>vi</repl>
	  where <repl>vi</repl> is the <repl>i</repl><sup>th</sup>
	  represented value of the coded variable. In case any
	  values are negative, <quote>m</quote> is inserted before
	  the (absolute) value of <repl>vi</repl>.
	</para>
	<para>
	  For example, suppose <argname>L</argname> contains a coded
	  series named <lit>C1</lit> with values &minus;9, &minus;7,
	  0, 1 and 2.  Then the generated dummies will be
	  <lit>DC1_m7</lit> (coding for C1 = &minus;7),
	  <lit>DC1_0</lit> (coding for C1 = 0), and so on.
	</para>
	<para>
	  <seelist>
            <fncref targ="dummify"/>
	    <fncref targ="getinfo"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ceiling function: returns the smallest integer greater than or
	  equal to <argname>x</argname>.
	  <seelist>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a Cholesky decomposition of
	  <argname>A</argname>. If <argname>A</argname> is real it
	  must be symmetric and positive definite; if so, the result
	  is a lower-triangular matrix <math>L</math> which satisfies
	  <equation status="inline" ascii="A = LL'" tex="$A = LL'$"/>.
	  If <argname>A</argname> is complex it must be Hermitian and
	  positive definite, and the result is a lower-triangular
	  complex matrix such that <equation status="inline" ascii="A
	  = LL^H" tex="$A = LL^{\mathrm H}$"/>. Otherwise, the
	  function will return an error.
	</para>
	<para>
	  For the real case, see also <fncref targ="psdroot"/> and
	  <fncref targ="Lsolve"/>.
	</para>
      </description>
    </function>

    <function name="chowlin" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">xfac</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  We no longer recommend use of this function; please use
	  <fncref targ="tdisagg"/> instead.
	</para>
	<para>
	  Expands the input data, <argname>Y</argname>, to a higher
	  frequency, using the method of <cite key="chowlin71">Chow
	  and Lin (1971)</cite>. It is assumed that the columns of
	  <argname>Y</argname> represent data series; the returned
	  matrix has as many columns as <argname>Y</argname> and
	  <argname>xfac</argname> times as many rows. It is also
	  assumed that each low-frequency value should be treated as
	  the average of <argname>xfac</argname> high-frequency
	  values.
	</para>
	<para>
	  The <argname>xfac</argname> value should be 3 for quarterly
	  to monthly, 4 for annual to quarterly or 12 for annual to
	  monthly. The optional third argument may be used to provide
	  a matrix of covariates at the higher (target) frequency.
	</para>
	<para>
	  The regressors used by default are a constant and trend.  If
	  <argname>X</argname> is provided, its columns are used as
	  additional regressors; it is an error if the number of rows
	  in <argname>X</argname> does not equal
	  <argname>xfac</argname> times the number of rows in
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmod" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="m" c="n"/> real matrix holding the complex
	  modulus of each element of the <by r="m" c="n"/> complex
	  matrix <argname>C</argname>. The modulus of the complex
	  number <math>z</math> = <math>x</math> + <math>yi</math>
	  equals the square root of <math>x</math><sup>2</sup>
	  + <math>y</math><sup>2</sup>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="abs"/>
	    <fncref targ="carg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cmult" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  This is a legacy function, predating gretl's native support
	  for complex matrices.
	</para>
	<para>
	  Complex multiplication. The two arguments must have the same
	  number of rows, <math>n</math>, and either one or two columns.
	  The first column contains the real part and the second (if
	  present) the imaginary part.  The return value is an
	  <by r="n" c="2"/> matrix, or, if the result has no imaginary
	  part, an <math>n</math>-vector.
	  <seelist>
            <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the cumulative distribution function for a standard
	  normal.
	  <seelist>
            <fncref targ="dnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnumber" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the condition number of the <by r="n" c="k"/> matrix
	  <argname>X</argname>, as defined in <cite
	  key="belsley-etal80">Belsley, Kuh and Welsch
	  (1980)</cite>. If the columns of <argname>X</argname> are
	  mutually orthogonal the condition number of
	  <argname>X</argname> is unity. Conversely, a large value of
	  the condition number is an indicator of multicollinearity;
	  <quote>large</quote> is often taken to mean 50 or greater
	  (sometimes 30 or greater).
	</para>
	<para>
	  The steps in the calculation are: (1) form a matrix
	  <math>Z</math> whose columns are the columns of
	  <argname>X</argname> divided by their respective Euclidean
	  norms; (2) form <math>Z'Z</math> and obtain its eigenvalues;
	  and (3) compute the square root of the ratio of the largest
	  to the smallest eigenvalue.
	</para>

	<para>
	  <seelist>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">col</fnarg>
      </fnargs>
      <description>
	<para>
	  If the <argname>col</argname> argument is given, retrieves
	  the name for column <argname>col</argname> of matrix
	  <argname>M</argname>. If <argname>M</argname> has no column
	  names attached the value returned is an empty string; if
	  <argname>col</argname> is out of bounds for the given matrix
	  an error is flagged.
	</para>
	<para>
	  If no second argument is given, retrieves an array of
	  strings holding the column names from <argname>M</argname>,
	  or an empty array if <argname>M</argname> does not have
	  column names attached.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  cnameset(A, "Col_A Col_B Col_C")
	  string name = cnameget(A, 3)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="cnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameset" section="matrix" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Attaches names to the columns of the <by r="T" c="k"/>
	  matrix <argname>M</argname>. If <argname>S</argname> is a
	  named list, the names are taken from the names of the listed
	  series; the list must have <math>k</math> members. If
	  <argname>S</argname> is an array of strings, it should
	  contain <math>k</math> elements.  A single string is also
	  acceptable as the second argument; in that case it should
	  contain <math>k</math> space-separated substrings. As a
	  special case, passing an empty string as the second argument
	  has the effect of removing any existing column names.
	</para>
	<para>
	  The nominal return value is 0 on successful completion; in
	  case of failure an error is flagged.  See also <fncref
	  targ="rnameset"/>.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(2)
	  S[1] = "Col1"
	  S[2] = "Col2"
	  cnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of columns of <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="commute" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
	<fnarg optional="true" type="int">post</fnarg>
	<fnarg optional="true" type="int">add_id</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the matrix <argname>A</argname> premultiplied by the
	  commutation matrix <math>K</math><sub>m,n</sub> (using an
	  algorithm that is more efficient than explicit
	  multiplication).  Each column of <argname>A</argname> is
	  assumed to come from a vec operation on a <math>m x n</math>
	  matrix. In particular,
	</para>
	<code>
	  commute(vec(B), rows(B), cols(B))
	</code>
	<para>
	  gives vec(<math>B'</math>). In order to compute the
	  commutation matrix proper, just apply the function to an
	  appropriately sized identity matrix. For example:
	</para>
	<code>
	  K_32 = commute(I(6), 3, 2)
	</code>
	<para>
	  The optional argument <argname>n</argname> defaults to
	  <argname>m</argname>.  If the optional argument
	  <argname>post</argname> is non-zero, then
	  post-multiplication is performed instead of
	  pre-multiplication; the optional Boolean switch
	  <argname>add_id</argname> will premultiply
	  <argname>A</argname> by <math>I + K</math><sub>m,n</sub>
	  instead of <math>K</math><sub>m,n</sub>.
	</para>
      </description>
    </function>

    <function name="complex" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="scalar-or-matrix">A</fnarg>
	<fnarg optional="true" type="scalar-or-matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a complex matrix, where <argname>A</argname> is
	  taken to supply the real part and <argname>B</argname> the
	  imaginary part. If <argname>A</argname> is <by r="m" c="n"/>
	  and <argname>B</argname> is a scalar the result is <by r="m"
	  c="n"/> with a constant imaginary part&mdash;and similarly
	  in the converse case but with a constant real part. If both
	  arguments are matrices they must be of the same dimensions.
	  If the second argument is omitted the imaginary part
	  defaults to zero.  <seelist><fncref
	  targ="cswitch"/></seelist>
	</para>
      </description>
    </function>

    <function name="conj" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="m" c="n"/> complex matrix holding the
	  complex conjugate of each element of the <by r="m" c="n"/>
	  complex matrix <argname>C</argname>. The conjugate of the
	  complex number <math>z</math> = <math>x</math> +
	  <math>yi</math> equals <math>x</math> &minus;
	  <math>yi</math>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="carg"/>
	    <fncref targ="abs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="contains" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
	<fnarg type="matrix">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Provides a means of determining whether the numerical
	  object <argname>x</argname> contains any of the elements of
	  <argname>S</argname>, a matrix which plays the role of a
	  set.
	</para>
	<para>
	  The return value is an object of the same size as
	  <argname>x</argname> containing 1s in positions where
	  a value of <argname>x</argname> matches any element of
	  <argname>S</argname> and zeros elsewhere.
	  For example, the code
	</para>
	<code>
	  matrix A = mshape(seq(1,9), 3, 3)
	  matrix C = contains(A, {1, 5, 9})
	</code>
	<para>
	  gives
	</para>
	<code>
	  A (3 x 3)

	  1   4   7
	  2   5   8
	  3   6   9

	  C (3 x 3)

	  1   0   0
	  0   1   0
	  0   0   1
	</code>
	<para>
	  This function may be particularly useful when
	  <argname>x</argname> is a series that contains a
	  fine-grained encoding for a qualitative characteristic, and
	  you wish to reduce this to a smaller number of
	  categories. You can pack into <argname>S</argname> a set of
	  values to be consolidated, and obtain a dummy variable with
	  value 1 for observations matching this set, 0 otherwise.
	</para>
	<para>
	  Since <argname>S</argname> serves as a set, for greatest
	  efficiency it should be a vector with no repeated values,
	  however an arbitrary matrix is accepted.
	</para>
      </description>
    </function>

    <function name="conv2d" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the 2-dimensional convolution of the matrices
	  <argname>A</argname> and <argname>B</argname>. If
	  <argname>A</argname> is <by r="r" c="c"/> and
	  <argname>B</argname> is <by r="m" c="n"/> then the returned
	  matrix will have <math>r+m-1</math> rows and
	  <math>c+n-1</math> columns.
	</para>
	<para context="tex">
	    The 2-D convolution of <argname>A</argname> and
	    <argname>B</argname> is defined as
	    \[
	    C_{i,j} =
	    \sum_{k=1}^r\sum_{l=1}^c A_{k,l} B_{i-k+1,j-l+1},
	    \]
	    where the summations include just those values of $k$ and
	    $l$ for which the subscripts of $B$ are within bounds.
	</para>
	<para>
	  <seelist>
            <fncref targ="fft"/>
            <fncref targ="filter"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cquad" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">Z</fnarg>
      </fnargs>
      <description>
	<para>
	  Given an <by r="m" c="n"/> complex matrix
	  <argname>Z</argname>, returns an <by r="m" c="n"/> real
	  matrix holding the quadrance of the elements of
	  <argname>Z</argname>. The quadrance of the complex number
	  <math>z</math> = <math>a</math> + <math>bi</math> is
	  <math>a</math><sup>2</sup> + <math>b</math><sup>2</sup>. It
	  therefore equals the squared modulus of <math>z</math> and
	  also equals <math>z</math> multiplied by its complex
	  conjugate, but the direct calculation carried out by
	  <lit>cquad</lit> is considerably faster than either of the
	  alternative approaches.
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the correlation coefficient between <argname>y1</argname>
	  and <argname>y2</argname>. The arguments should be either
	  two series, or two vectors of the same length.
	  <seelist>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	    <fncref targ="npcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corresp" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">a</fnarg>
	<fnarg type="series-or-vec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  On the basis of a cross-tabulation of <argname>a</argname>
	  and <argname>b</argname>, returns an integer code
	  indicating the sort of correspondence between the two
	  variables, as follows.
	</para>
	<ilist>
	  <li>
	    <para>
	      Code = 2: theres a 1-to-1 relationship.
	    </para>
	  </li>
	  <li>
	    <para>
	      Code = 1: theres a 1-to-n relationship
	      (<argname>a</argname> <quote>nests</quote>
	      <argname>b</argname>, can be interpreted as a function
	      of <argname>b</argname> in the mathematical sense).
	    </para>
	  </li>
	  <li>
	    <para>
	      Code = &minus;1: theres an n-to-1 relationship
	      (<argname>b</argname> <quote>nests</quote>
	      <argname>a</argname>, can be interpreted as a function
	      of <argname>a</argname>).
	    </para>
	  </li>
	  <li>
	    <para>
	    Code = 0: theres no relationship.
	    </para>
	  </li>
	</ilist>
	<para>
	  Note that these codes are based solely on the sample values
	  of the two arguments. In case <argname>b</argname> is the
	  square of <argname>a</argname>, for example, the result will
	  differ depending on whether <argname>a</argname> contains
	  some pairs of values that differ only by sign (code =
	  &minus;1), or not (code = 2).
	</para>
	<para>
	  One possible use case is to check whether two discrete
	  series encode the same information. For example, the
	  following:
	</para>
	<code>
	  open grunfeld.gdt
	  c = corresp($unit, firm)
	</code>
	<para>
	  gives <lit>c</lit> = 2, indicating that the series
	  <lit>firm</lit> is in fact a unique identifier for the
	  cross-sectional units in this panel dataset.
	</para>
	<para>
	  See also <fncref targ="mxtab"/>.
	</para>
      </description>
    </function>

    <function name="corrgm" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  If only the first two arguments are given, computes the
	  correlogram for <argname>x</argname> for lags 1 to
	  <argname>p</argname>.  Let <math>k</math> represent the
	  number of elements in <argname>x</argname> (1 if
	  <argname>x</argname> is a series, the number of columns if
	  <argname>x</argname> is a matrix, or the number of
	  list-members if <argname>x</argname> is a list).  The return
	  value is a matrix with <argname>p</argname> rows and
	  2<math>k</math> columns, the first <math>k</math> columns
	  holding the respective autocorrelations and the remainder
	  the respective partial autocorrelations.
	</para>
	<para>
	  If a third argument is given, this function computes the
	  cross-correlogram for each of the <math>k</math> elements in
	  <argname>x</argname> and <argname>y</argname>, from lead
	  <argname>p</argname> to lag <argname>p</argname>. The
	  returned matrix has 2<math>p</math> + 1 rows and
	  <math>k</math> columns.  If <argname>x</argname> is series
	  or list and <argname>y</argname> is a vector, the vector
	  must have just as many rows as there are observations in the
	  current sample range.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the cosine of <argname>x</argname>.
	  <seelist>
            <fncref targ="sin"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the hyperbolic cosine of <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="acosh"/>
            <fncref targ="sinh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the covariance between <argname>y1</argname> and
	  <argname>y2</argname>. The arguments should be either
	  two series, or two vectors of the same length.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Critical value calculator. Returns <math>x</math> such that
	  <equation status="inline" ascii="P(X &gt; x) = p"
		    tex="$P(X &gt; x) = p$"/>, where the distribution <math>X</math> is
	  determined by the character <argname>c</argname>. Between the
	  arguments <argname>c</argname> and <argname>p</argname>, zero or
	  more additional scalar arguments are required to specify the
	  parameters of the distribution, as follows.
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Standard normal (c = z, n, or N): no extra arguments
            </para>
	  </li>
	  <li>
            <para>
              Student's t (t): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x, or X): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Snedecor's F (f or F): df (num.); df (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b or B): probability; trials
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p or P): mean
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l or L): mean; scale
            </para>
	  </li>
	  <li>
            <para>
              Standardized GED (E): shape
            </para>
	  </li>
	</ilist>
	<tabular colspec="llll">
	  \textit{Distribution} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Standard normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
	  -- &amp; -- \\
	  Student's $t$ (central) &amp; \texttt{t} &amp;
	  degrees of freedom &amp; -- \\
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp;
	  degrees of freedom &amp; -- \\
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp;
	  df (num.) &amp; df (den.) \\
	  Binomial &amp; \texttt{b} or \texttt{B} &amp;
	  $p$ &amp; $n$ \\
	  Poisson &amp; \texttt{p} or \texttt{P} &amp;
	  $\lambda$ &amp; -- \\
	  Laplace &amp; \texttt{l} or \texttt{L} &amp;
	  mean &amp; scale \\
	  Standardized GED &amp; \texttt{E} &amp;
	  shape &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cswitch" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="scalar">mode</fnarg>
      </fnargs>
      <description>
	<para>
	  Reinterprets a real matrix as holding complex values or vice
	  versa. The precise action depends on <argname>mode</argname>
	  (which must have value 1, 2, 3 or 4) as follows:
	</para>
	<para>
	  mode 1: <argname>A</argname> must be a real matrix with an
	  even number of columns. Returns a complex matrix with half
	  as many columns, the odd-numbered columns of
	  <argname>A</argname> supplying the real parts and the
	  even-numbered columns the imaginary parts.
	</para>
	<para>
	  mode 2: Performs the inverse operation of mode
	  1. <argname>A</argname> must be a complex matrix and the
	  return value is a real matrix with twice as many columns
	  as <argname>A</argname>.
	</para>
	<para>
	  mode 3: <argname>A</argname> must be a real matrix with an
	  even number of rows. Returns a complex matrix with half as
	  many rows, the odd-numbered rows of <argname>A</argname>
	  supplying the real parts and the even-numbered rows the
	  imaginary parts.
	</para>
	<para>
	  mode 4: Performs the inverse operation of mode
	  3. <argname>A</argname> must be a complex matrix and the
	  return value is a real matrix with twice as many rows as
	  <argname>A</argname>.
	</para>
	<para>
	  <seelist><fncref targ="complex"/></seelist>
	</para>
      </description>
    </function>

    <function name="ctrans" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="n" c="m"/> complex matrix holding the
	  conjugate transpose of the <by r="m" c="n"/> complex matrix
	  <argname>C</argname>. The <lit>&apos;</lit> (prime) operator also
	  performs conjugate transposition for complex matrices. The
	  <fncref targ="transp"/> function can be used on complex
	  matrices but it performs <quote>straight</quote>
	  transposition (not conjugated).
	</para>
      </description>
    </function>

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Cumulates <argname>x</argname> (that is, creates a running
	  sum). When <argname>x</argname> is a series, produces a
	  series <math>y</math> each of whose elements is the sum of
	  the values of <argname>x</argname> to date; the starting
	  point of the summation is the first non-missing observation
	  in the currently selected sample.  If any missing values are
	  encountered in <math>x</math>, subsequent values of
	  <math>y</math> will be set to missing.  When
	  <argname>x</argname> is a matrix, its elements are cumulated
	  by columns.
	</para>
	<para context="tex">
	  Cumulates <argname>x</argname>. When <math>x</math> is a series,
	  produces a series $y_t = \sum_{s=m}^t x_s$; the starting point of
	  the summation, <math>m</math>, is the first non-missing observation
	  of the currently selected sample.  If any missing values are
	  encountered in <math>x</math>, subsequent values of <math>y</math>
	  will be set to missing. When <argname>x</argname> is a matrix, its
	  elements are cumulated by columns.
	</para>
	<para>
	  In the case of panel data cumulation is in the time
	  dimension, starting anew for each panel unit.
	</para>
	<para>
	  If you want cumulation to ignore missing values (that is, to
	  treat them as if they were zeros), you can apply <fncref
	  targ="misszero"/> to the argument, as in
	</para>
	<code>
	  series cx = cum(misszero(x))
	</code>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Provides a somewhat flexible means of obtaining a text
	  buffer containing data from an internet server, using
	  libcurl. On input the bundle <argname>b</argname> must
	  contain a string named <lit>URL</lit> which gives the full
	  address of the resource on the target host. Other optional
	  elements are as follows.
	</para>
	<ilist>
	  <li>
	    <para>
	      <quote><lit>header</lit></quote>: a string specifying
	      an HTTP header to be sent to the host.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>include</lit></quote>: a scalar: if nonzero,
	      the header received from the host is included with the
	      output body.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>nobody</lit></quote>: a scalar: if nonzero,
	      the function will <i>not</i> download the body of the
	      requested URL.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>postdata</lit></quote>: a string holding
	      data to be sent to the host.
	    </para>
	  </li>
	</ilist>
	<para>
	  The <lit>header</lit> and <lit>postdata</lit> fields are
	  intended for use with an HTTP <lit>POST</lit> request; if
	  <lit>postdata</lit> is present the <lit>POST</lit> method is
	  implicit. Otherwise the <lit>GET</lit> or <lit>HEAD</lit>
	  methods are implicit, depending on the value of the
	  <lit>nobody</lit> key. (But note that for straightforward
	  <lit>GET</lit> requests <fncref targ="readfile"/> offers a
	  simpler interface.)
	</para>
	<para>
	  On completion of the request, the text received from the
	  server is added to the bundle under the key
	  <quote><lit>output</lit></quote>, and the HTTP status code
	  is stored under the key <quote><lit>http_code</lit></quote>.
	</para>
	<para>
	  If an error occurs in formulating the request (for example
	  there's no <lit>URL</lit> on input) the function fails,
	  otherwise it returns 0 if the request succeeds or non-zero
	  if it fails, in which case the error message from libcurl is
	  added to the bundle under the key
	  <quote><lit>errmsg</lit></quote>.  Note that
	  <quote>success</quote> in this sense does not necessarily
	  mean you got the data you wanted; all it means is that some
	  response was received from the server.  A quick way of
	  checking is to inspect the HTTP status code: the most
	  commonly used ones are 200 (success) or 404 (page not
	  found). See
	  <url>https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</url>
	  for the full list. Alternatively, you can check the content
	  of the output buffer (which may in fact be a message such as
	  <quote>Page not found</quote>).
	</para>
	<para>
	  Here is an example of use: downloading some data from the
	  US Bureau of Labor Statistics site, which requires sending
	  a JSON query. Note the use of <fncref targ="sprintf"/> to
	  embed double-quotes in the <lit>POST</lit> data.
       </para>
       <code>
	 bundle req
	 req.URL = "https://api.bls.gov/publicAPI/v1/timeseries/data/"
	 req.include = 1
	 eq.header = "Content-Type: application/json"
	 string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	 req.postdata = s
	 err = curl(&amp;req)
	 if err == 0
	    s = req.output
	    string line
	    loop while getline(s, &amp;line)
	       printf "%s\n", line
	    endloop
	 endif
       </code>
       <para>
	 As a second example, the code below checks if a particular
	 version of the <quote>Global Macro Database</quote> dataset
	 is available, and downloads it only if so.
       </para>
       <code>
	 string base_URL = "https://www.globalmacrodata.com"
	 string filename = "GMD_2025_03.csv"

	 bundle req
	 req.URL = base_URL ~ "/" ~ filename
	 req.nobody = 1
	 err = curl(&amp;req)

	 if err || (req.http_code != 200)
	    printf "Oh, oh. It seems %s is unavailable\n", filename
	 else
	    # actual request
	    bundle req = empty
	    req.URL = base_URL ~ "/" ~ filename
	    err = curl(&amp;req)
	    print req
	 endif
       </code>
       <para>
	 See also the functions <fncref targ="jsonget"/> and <fncref
	 targ="xmlget"/> for means of processing JSON and XML data
	 received, respectively.
       </para>
     </description>
    </function>

    <function name="dayspan" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">ed1</fnarg>
	<fnarg type="int">ed2</fnarg>
	<fnarg type="int">weeklen</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of (relevant) days between the epoch days
	  <argname>ed1</argname> and <argname>ed2</argname>,
	  inclusive. The <argname>weeklen</argname>, which must equal
	  5, 6 or 7, gives the number of days in the week that should
	  be counted (a value of 6 omits Sundays, and a value of 5
	  omits both Saturdays and Sundays).
	</para>
	<para>
	  To obtain epoch days from the more familiar form of dates,
	  see <fncref targ="epochday"/>. Related: see <fncref
	  targ="smplspan"/>.
	</para>
      </description>
    </function>

    <function name="dec2bin" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  This function returns the binary representation of the
	  numbers contained in the column vector <argname>x</argname>,
	  by storing each binary digit into a column of the returned
	  matrix, which always has 32 columns. Each element of
	  <argname>x</argname> must be an integer between 0 and
	  <math>2</math><sup>32</sup><math>-1</math>. Otherwise, an
	  error is flagged.
	</para>
	<para>
	  Note that the least significant bit comes in the first
	  column. So column 1 corresponds to
	  <math>2</math><sup>0</sup>, column 2 to
	  <math>2</math><sup>1</sup>, and so on. For example, the
	  expression
	</para>
	<code>
	  matrix B = dec2bin(5)
	</code>
	<para>
	  produces a row vector full of zeros except for positions 1
	  and 3.
	</para>
	<para>
	  The <fncref targ="bin2dec"/> function performs the inverse
	  transformation.
	</para>
      </description>
    </function>

   <function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Enables the definition of an array variable <emphasis>in
	  extenso</emphasis>, by providing one or more elements.  In
	  using this function you must specify a type (in plural form)
	  for the array: <lit>strings</lit>, <lit>matrices</lit>,
	  <lit>bundles</lit> or <lit>lists</lit>. Each of the
	  arguments must evaluate to an object of the specified
	  type. On successful completion, the return value is an array
	  of <math>n</math> elements, where <math>n</math> is the
	  number of arguments.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  See also <fncref targ="array"/>.
	</para>
      </description>
    </function>

    <function name="defbundle" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Enables the initialization of a bundle variable <emphasis>in
	  extenso</emphasis>, by providing zero or more pairs of the
	  form <repl>key</repl>, <repl>member</repl>. If we count the
	  arguments from 1, every odd-numbered argument must evaluate
	  to a string (key) and every even-numbered argument must
	  evaluate to an object of a type that can be included in a
	  bundle.
	</para>
	<para>
	  A couple of simple examples:
	</para>
	<code>
	  bundle b1 = defbundle("s", "Sample string", "m", I(3))
	  bundle b2 = defbundle("yn", normal(), "x", 5)
	</code>
	<para>
	  The first example creates a bundle with members a string and
	  a matrix; the second, a bundle with a series member and a
	  scalar member. Note that you cannot specify a type for each
	  argument when using this function, so you must accept the
	  <quote>natural</quote> type of the argument in question.  If
	  you wanted to add a series with constant value 5 to a bundle
	  named <lit>b1</lit> it would be necessary to do something
	  like the following (after declaring <lit>b1</lit>):
	</para>
	<code>
	  series b1.s5 = 5
	</code>
	<para>
	  If no arguments are given to this function it is
	  equivalent to creating an empty bundle (or to emptying an
	  existing bundle of its content), as could also be done
	  via
	</para>
	<code>
	  bundle b = null
	</code>
	<subhead>Variant syntax</subhead>
	<para>
	  Two alternative forms of syntax are available for defining
	  bundles. In each case the keyword <lit>defbundle</lit> is
	  replaced by a single underscore. In the first variant the
	  comma-separated arguments take the form
	  <lit>key=value</lit>, where the key is taken to be a literal
	  string and does not require quotation. Here is an example:
	</para>
	<code>
	  bundle b = _(x=5, strval="some string", m=I(3))
	</code>
	<para>
	  This form is particularly convenient for constructing an
	  anonymous bundle on the fly as a function argument, as in
	</para>
	<code>
	  b = regls(ys, LX, _(lfrac=0.35, stdize=0))
	</code>
	<para>
	  where the <lit>regls</lit> function takes an optional bundle
	  argument holding various parameters.
	</para>
	<para>
	  The second variant is designed for the case where you wish to
	  pack several pre-existing named objects into a bundle: you
	  just give their names, unquoted:
	</para>
	<code>
	  bundle b = _(x, y, z)
	</code>
	<para>
	  Here the object <lit>x</lit> is copied into the bundle under
	  the key <quote><lit>x</lit></quote>, and similarly for
	  <lit>y</lit> and <lit>z</lit>.
	</para>
	<para>
	  These alternative forms involve less typing than the full
	  <lit>defbundle()</lit> version and are likely to be more
	  convenient in many cases, but note that they are less
	  flexible. Only the full version can handle keys given as
	  string variables rather than literal strings.
	</para>
      </description>
    </function>

    <function name="deflist" section="data-utils" output="list">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Defines a list (of named series), given one or more suitable
	  arguments. Each argument must be a named series (given by
	  name or integer ID number), an existing named list, or an
	  expression which evaluates to a list (including a vector
	  which can be interpreted as a set of series ID numbers).
	</para>
	<para>
	  One point to note: this function simply concatenates its
	  arguments to produce the list that it returns. If the intent
	  is that the return value does not contain duplicates (does
	  not reference any given series more than once), it is up to
	  the caller to ensure that requirement is satisfied.
	</para>
      </description>
    </function>

    <function name="deseas" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="bundle">opts</fnarg>
      </fnargs>
      <description>
	<para>
	  The primary purpose of this function is to produce a
	  deseasonalized version of the (quarterly or monthly) input
	  series <argname>x</argname>, using X-13ARIMA-SEATS; it is
	  available only if X-13ARIMA-SEATS is installed. If the
	  second, optional argument is omitted, seasonal adjustment is
	  carried out with all X-13ARIMA options at their default
	  values (fully automatic procedure). When
	  <argname>opts</argname> is supplied, it may contain any of
	  the following option specifications.
	</para>
	<ilist>
	  <li>
	    <para>
	      <lit>verbose</lit>: what to print? 0 = nothing (the
	      default); 1 = confirmation of the options selected;
	      2 = confirmation of options plus the output from
	      X-13ARIMA.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>seats</lit>: 1 to use the SEATS algorithm in place
	      of the default X11 algorithm for seasonal adjustment, or
	      0.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>airline</lit>: 1 to use the <quote>airline</quote>
	      ARIMA model specification (0,1,1)(0,1,1) in place of the
	      default automatic model selection, or 0.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>arima</lit>: can be used to impose a chosen ARIMA
	      specification, in the form of a 6-vector holding small
	      non-negative integers. These are given the (p,d,q,P,D,Q)
	      interpretation, in traditional time-series notation: the
	      first three terms represent the non-seasonal AR,
	      Integration and MA orders, and the last three the
	      seasonal counterparts. If both <lit>airline</lit> and
	      <lit>arima</lit> are given, <lit>arima</lit> takes
	      precedence.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>outliers</lit>: enable detection and correction for
	      outliers (choices 1 through 7), or 0 (the default) to
	      omit this feature. The three available outlier types
	      with their numerical codes are: 1 = additive outlier
	      (ao), 2 = level shift (ls), 4 = temporary change
	      (tc). To combine options you add the codes, for example
	      1 + 2 + 4 = 7 to activate all three. Note that the
	      choice 3 = 1 + 2 (ao and ls) is the default within
	      X-13ARIMA-SEATS, and is selected via the outlier tickbox
	      in gretl's dialog window for seasonal adjustment via
	      X13.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>critical</lit>: a positive scalar, the critical
	      value for defining outliers, the default being
	      automatic, dependent on the sample size. Relevant only
	      when <lit>outliers</lit> is specified.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>logtrans</lit>: should the input series be put in
	      log form? 0 = no, 1 = yes, 2 = automatically selected
	      (the default). Note that it is not recommended to pass
	      the input series in log form; if you want the log to be
	      used, pass the <quote>raw</quote> level but specify
	      <lit>logtrans=1</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>trading_days</lit>: should trading-day effects be
	      included?  0 = no, 1 = yes, 2 = automatic (the default).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>working_days</lit>: a simpler version of
	      <lit>trading_days</lit> with a single distinction
	      between weekdays and weekends rather than individual day
	      effects. 0 = no (the default), 1 = yes, 2 = automatic.
	      Use only one of <lit>trading_days</lit> and
	      <lit>working_days</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>easter</lit>: 1 to allow for an easter effect, as a
	      supplement to either <lit>trading_days</lit> or
	      <lit>working_days</lit>, or 0 (the default).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>output</lit>: a string to select the type of the
	      output series, <lit>"sa"</lit> for deseasonalized (the
	      default), <lit>"trend"</lit> for the estimated trend, or
	      <lit>"irreg"</lit> for the irregular component.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>save_spc</lit>: boolean flag, default 0; see below.
	    </para>
	  </li>
	</ilist>
	<subhead>Augmented results</subhead>
	<para>
	  In some cases one may wish to obtain all three of the
	  results available from X-13ARIMA via a single call to
	  <lit>deseas</lit>. This is supported as follows. Pass the
	  <argname>opts</argname> bundle in pointer form, and give the
	  string <lit>"all"</lit> under the <lit>output</lit> key.
	  The direct return value is then the seasonally adjusted
	  series, but on successful completion <argname>opts</argname>
	  will contain a matrix named <lit>results</lit> with three
	  columns: seasonally adjusted, trend and irregular. Here's an
	  illustration (where the direct return value is discarded).
	</para>
	<code>
	  bundle b = _(output="all")
	  deseas(y, &amp;b)
	  series y_dseas = b.results[,1]
	  series y_trend = b.results[,2]
	  series y_irreg = b.results[,3]
	</code>
	<subhead>Saving the X-13ARIMA specification</subhead>
	<para>
	  The <lit>save_spc</lit> flag can be used to save the content
	  of the X-13ARIMA input file written by gretl. The options
	  bundle should be passed in pointer form and the
	  specification (as a string) can be found under the key
	  <lit>x13a_spc</lit>. The following code illustrates saving
	  this to file under the name <lit>myspec.spc</lit> in the
	  user's working directory. (Note that the <lit>.spc</lit>
	  extension is required by X-13ARIMA.)
	</para>
	<code>
	  bundle b = _(save_spc=1)
	  deseas(y, &amp;b)
	  outfile myspec.spc
	     print b.x13a_spc
	  end outfile
	</code>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the determinant of <argname>A</argname>, computed via the
	  LU factorization. If what you actually want is the log
	  determinant you should call <fncref targ="ldet"/> instead.
	  <seelist>
            <fncref targ="rcond"/>
	    <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diag" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the principal diagonal of <argname>X</argname> in a
	  column vector. Note: if <argname>X</argname> is an
	  <by r="m" c="n"/> matrix, the number of elements
	  of the output vector is min(<math>m</math>, <math>n</math>).
	  <seelist>
            <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the direct sum of <argname>A</argname> and
	  <argname>B</argname>, that is a matrix holding
	  <argname>A</argname> in its north-west corner and
	  <argname>B</argname> in its south-east corner. If both
	  <argname>A</argname> and <argname>B</argname> are square,
	  the resulting matrix is block-diagonal.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes first differences.  If <argname>y</argname> is a series, or
	  a list of series, starting values are set to <lit>NA</lit>.  If
	  <argname>y</argname> is a matrix, differencing is done by columns
	  and starting values are set to 0.
	</para>
	<para>
	  When a list is returned, the individual variables are
	  automatically named according to the template
	  <lit>d_</lit>
	  <repl>varname</repl> where <repl>varname</repl> is the
	  name of the original series.  The name is truncated if necessary,
	  and may be adjusted in case of non-uniqueness in the set of names
	  thus constructed.
	</para>
	<para>
	  <seelist>
            <fncref targ="cum"/>
            <fncref targ="ldiff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns the digamma (or Psi) function of
	  <argname>x</argname>, that is the derivative of the log of
	  the Gamma function.
	</para>
	<para context="tex">
	  Returns the digamma (or Psi) function of $x$, that is
	  $\frac {\mathrm{d}} {\mathrm{d} x}\, \log \Gamma(x)$.
	</para>
	<para>
	  <seelist>
            <fncref targ="lngamma"/>
            <fncref targ="trigamma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="distance" section="math" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="string">metric</fnarg>
	<fnarg optional="true" type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes distances between points on a metric that can be
	  <lit>euclidean</lit> (the default), <lit>manhattan</lit>,
	  <lit>hamming</lit>, <lit>chebyshev</lit>, <lit>cosine</lit>
	  or <lit>mahalanobis</lit>. The string identifying the metric
	  can be given as an unambiguous truncation. The additional
	  metrics correlation, standardized Euclidean are supported
	  via simple transformations of the inputs; see below.
	</para>
	<para>
	  Each row of the <by r="m" c="n"/> matrix
	  <argname>X</argname> is treated as a point in an
	  <math>n</math>-dimensional space; in an econometric context
	  this is likely to represent a single observation comprising
	  the values of <math>n</math> variables.
	</para>
	<subhead>Standard cases</subhead>
	<para>
	  This section applies to all metrics except the Mahalanobis
	  distance, for which the syntax is slightly different (see
	  below).
	</para>
	<para>
	  If <argname>Y</argname> is not given, the return value is a
	  column vector of length <math>m</math>(<math>m</math>
	  &minus; 1)/2 comprising the non-redundant subset of all
	  pairwise distances between the <math>m</math> points (rows
	  of <argname>X</argname>). Given such a vector named
	  <lit>d</lit>, the full symmetric matrix of inter-point
	  distances (with zeros on the principal diagonal) can be
	  constructed via
	</para>
	<code>
	  D = unvech(d, 0)
	</code>
	<para>
	  since <lit>d</lit> is akin to the vech of <lit>D</lit>, with
	  diagonal elements omitted. The optional second argument to
	  <fncref targ="unvech"/> says that the diagonal should be
	  filled with zeros.
	</para>
	<para>
	  If <argname>Y</argname> is given, it must be a <by r="p"
	  c="n"/> matrix, each row of which is again treated as a
	  point in <math>n</math>-space. In this case the return value
	  is an <by r="m" c="p"/> matrix whose <math>i,j</math>
	  element holds the distance between row <math>i</math> of
	  <argname>X</argname> and row <math>j</math> of
	  <argname>Y</argname>.
	</para>
	<para>
	  To obtain the distances from a given reference point (for
	  example, the centroid) to each of <math>n</math>
	  data-points, give <argname>Y</argname> as a single row.
	</para>
	<subhead>Definitions of the supported metrics</subhead>
	<ilist>
	  <li>
	    <para>
	      <lit>euclidean</lit>: the square root of the sum of
	      squared deviations in each of the dimensions.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>manhattan</lit>: the sum of the absolute deviations
	      in each of the dimensions.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>hamming</lit>: the proportion of the dimensions in
	      which the deviation is non-zero (so bounded by 0 and 1).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>chebyshev</lit>: the greatest absolute deviation in
	      any dimension.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>cosine</lit>: 1 minus the cosine of the angle
	      between the <quote>points</quote>, considered as vectors.
	    </para>
	  </li>
	</ilist>
	<subhead>Mahalanobis distance</subhead>
	<para>
	  Mahalanobis distances are defined as the Euclidean distances
	  between the points in question (rows of
	  <argname>X</argname>) and a given centroid, scaled by the
	  inverse of a covariance matrix. In the simplest case the
	  centroid is constituted by the sample means of the variables
	  (columns of <argname>X</argname>) and the covariance matrix
	  is their sample covariance.
        </para>
        <para>
	  These can be obtained by supplying as second argument the
	  string <quote>mahalanobis</quote> or any unambiguous
	  abbreviation, as in
	</para>
	<code>
	  dmahal = distance(X, "mahal")
	</code>
	<para>
          In this case the third argument <argname>Y</argname> is not
          supported, and the return value is a column vector of length
          <math>m</math> with the Mahalanobis distances from the
          centroid of <argname>X</argname> (that is, its sample
          mean). In practice, the output matrix in this case is the
          same you get by executing the <cmdref targ="mahal"/> command
          on a list of series corresponding to the columns of
          <argname>X</argname>.
	</para>
	<para>
	  To obtain Mahalanobis distances using a different centroid,
	  <lit>mu</lit>, and/or inverse covariance matrix,
	  <lit>ICV</lit>, the following syntax can be used:
	</para>
	<code>
	  dmahal = distance(X*cholesky(ICV), "euc", mu)
	</code>
	<subhead>Other metrics</subhead>
	<para>
	  Standardized Euclidean distances and correlation distances
	  can be obtained as follows:
	</para>
	<code>
	  # standardized euclidean
	  dseu = distance(stdize(X), "eu")
	  # correlation (based on cosine)
	  dcor = distance(stdize(X', -1)', "cos")
	</code>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the density of the standard normal distribution at
	  <argname>x</argname>.  To get the density for a non-standard
	  normal distribution at <math>x</math>, pass the
	  <math>z</math>-score of <math>x</math> to the <lit>dnorm</lit>
	  function and multiply the result by the Jacobian of the
	  <math>z</math> transformation, namely 1 over &sigma;, as
	  illustrated below:
	</para>
	<code>
	  mu = 100
	  sigma = 5
	  x = 109
	  fx = (1/sigma) * dnorm((x-mu)/sigma)
	</code>
	<para>
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a list with the same elements as
	  <argname>X</argname>, but for the collinear
	  series. Therefore, if all the series in <argname>X</argname>
	  are linearly independent, the output list is just a copy of
	  <argname>X</argname>.
	</para>
	<para>
	  The algorithm uses the QR decomposition (Householder
	  transformation), so it is subject to finite precision
	  error. In order to gauge the sensitivity of the algorithm, a
	  second optional parameter <argname>epsilon</argname> may be
	  specified to make the collinearity test more or less strict,
	  as desired. The default value for <argname>epsilon</argname>
	  is 1.0e-8. Setting <argname>epsilon</argname> to a larger
	  value increases the probability of a series to be dropped.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # set epsilon to a ridiculously small value
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produces
	</para>
	<code>
	  ? list print X
	  foo bar foobar
	  ? list print Y
	  foo bar
	  ? list Y = dropcoll(X, 1.0e-30)
	  Replaced list Y
	  ? list print Y
	  foo bar foobar
	</code>
      </description>
    </function>

    <function name="dsort" section="matrix" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Sorts <argname>x</argname> in descending order, skipping
	  observations with missing values when <argname>x</argname> is a
	  series.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>x</argname> should be a discrete
	  series. This function creates a set of dummy variables
	  coding for the distinct values in the series.  By default
	  the smallest value is taken as the omitted category and is
	  not explicitly represented.
	</para>
	<para>
	  The optional second argument represents the value of
	  <argname>x</argname> which should be treated as the omitted
	  category. The effect when a single argument is given is
	  equivalent to <lit>dummify(x, min(x))</lit>.  To produce a
	  full set of dummies, with no omitted category, use
	  <lit>dummify(x, NA)</lit>.
	</para>
	<para>
	  The generated variables are automatically named according to
	  the template
	  <lit>D</lit><repl>varname</repl><lit>_</lit><repl>i</repl>
	  where <repl>varname</repl> is the name of the original
	  series and <repl>i</repl> is a 1-based index.  The original
	  portion of the name is truncated if necessary, and may be
	  adjusted in case of non-uniqueness in the set of names thus
	  constructed.
	</para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Given the year in argument <argname>y</argname>, returns the
	  date of Easter on the Gregorian calendar as <math>month +
	  day/100</math>. For example, in 2014 the date of Easter
	  was April 20, which is represented under this convention
	  as 4.2. (Note that April 2 would be returned as 4.02.)
	  The following code shows how month and day can be extracted
	  from the return value.
	</para>
	<code>
	  scalar e = easterday(2014)
	  scalar m = floor(e)
	  scalar d = round(100*(e-m))
	</code>
      </description>
    </function>

    <function name="ecdf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calculates the empirical CDF of <argname>y</argname>. This
	  is returned in a matrix with two columns: the first holds
	  the sorted unique values of <argname>y</argname> and the
	  second holds the cumulative relative frequency, that is
	  the count of observations whose value is less than
	  or equal to the value in the first column, divided by
	  the total number of observations.
	</para>
	<para context="tex">
	  Calculates the empirical CDF of <argname>y</argname>. This
	  is returned in a matrix with two columns: the first holds
	  the sorted unique values of <argname>y</argname> and the
	  second holds the cumulative relative frequency,
	  \[ F(y) =
	  \frac{1}{n} \sum_{i=1}^n I(y_i \leq y)
	  \]
	  where $n$ is total number of observations and $I()$ denotes
	  the indicator function.
	</para>
      </description>
    </function>

    <function name="eigen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
	<fnarg type="matrixref" optional="true">&amp;W</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the eigenvalues, and optionally the right and/or
	  left eigenvectors, of the <by r="n" c="n"/> matrix
	  <argname>A</argname>, which may be real or complex. The
	  eigenvalues are returned in a complex column vector. To
	  obtain the norm of the eigenvalues, you can use the <fncref
	  targ="abs"/> function, which accepts complex arguments.
	</para>
	<para>
	  If you wish to retrieve the right eigenvectors (as an <by
	  r="n" c="n"/> complex matrix), supply the name of an
	  existing matrix, preceded by <lit>&amp;</lit> to indicate
	  the <quote>address</quote> of the matrix in question, as the
	  second argument. Otherwise this argument can be omitted.
	</para>
	<para>
	  To retrieve the left eigenvectors (again, as a complex
	  matrix), supply a matrix-address as the third argument.
	  Note that if you want the left eigenvectors but not the
	  right ones, you should use the keyword <lit>null</lit>
	  as a placeholder for the second argument.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Works mostly as <fncref targ="eigen"/> except that the
	  argument <argname>A</argname> must be symmetric (in which
	  case less calculation is required), and the eigenvalues are
	  returned in ascending order. If you want to get the
	  eigenvalues in descending order (and have the eigenvectors
	  reordered correspondingly) you can do the following:
	</para>
	<code>
	  matrix U
	  e = eigensym(A, &amp;U)
	  Tmp = msortby((-e' | U)',1)'
	  e = -Tmp[1,]'
	  U = Tmp[2:,]
	  # now largest to smallest eigenvalues
	  print e U
	</code>
	<para>
	  Note: if you're interested in the eigen-decomposition of a
	  matrix of the form <math>X'X</math> it's preferable to
	  compute the argument via the prime operator <lit>X'X</lit>
	  rather than using the more general syntax
	  <lit>X'*X</lit>. The former expression uses a specialized
	  algorithm which offers greater computational efficiency as
	  well as ensuring that the result is exactly symmetric.
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Solves the generalized eigenvalue problem |<math>A</math>
	  &minus; &lgr;<math>B</math>| = 0, where both <math>A</math>
	  and <math>B</math> are symmetric and <math>B</math> is
	  positive definite. The eigenvalues are returned directly,
	  arranged in ascending order. If the optional third argument
	  is given it should be the name of an existing matrix
	  preceded by <lit>&amp;</lit>; in that case the generalized
	  eigenvectors are written to the named matrix.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">year</fnarg>
	<fnarg type="scalar-or-series">month</fnarg>
	<fnarg type="scalar-or-series">day</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of the day in the current epoch specified
	  by year, month and day. The epoch day equals 1 for the first
	  of January in the year 1 AD on the proleptic Gregorian
	  calendar; it stood at 733786 on 2010-01-01. If any of the
	  arguments are given as series the value returned is a
	  series, otherwise it is a scalar.
	</para>
	<para>
	  By default the <argname>year</argname>,
	  <argname>month</argname> and <argname>day</argname> values
	  are assumed to be given relative to the Gregorian calendar,
	  but if the year is a negative value the interpretation
	  switches to the Julian calendar.
	</para>
	<para>
	  An alternative call is also supported: if a single argument
	  is given, it is taken to be a date (or series of dates) in
	  ISO 8601 <quote>basic</quote> numeric format,
	  <lit>YYYYMMDD</lit>. So the following two calls produce the
	  same result, namely 700115.
	</para>
	<code>
	  eval epochday(1917, 11, 7)
	  eval epochday(19171107)
	</code>
	<para>
	  For the inverse function, see <fncref targ="isodate"/> and
	  also (for the Julian calendar) <fncref targ="juldate"/>. For
	  another means of converting dates to epoch days see <fncref
	  targ="strpday"/>.
	</para>
      </description>
    </function>

    <function name="errmsg" section="programming" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Retrieves the gretl error message associated with
	  <argname>errno</argname>. See also <fncref
	  targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="errorif" section="programming" output="scalar">
      <fnargs>
	<fnarg type="bool">condition</fnarg>
	<fnarg type="string">msg</fnarg>
      </fnargs>
      <description>
	<para>
	  Applicable only in the context of a user-defined function,
	  or within an <cmdref targ="mpi"/> block.  If
	  <argname>condition</argname> evaluates as non-zero, it
	  causes execution of the current function to terminate with
	  an error condition flagged; the <argname>msg</argname>
	  argument is then printed as part of the message shown to the
	  caller of the function in question.
	</para>
	<para>
	  The return value from this function (1) is purely nominal.
	</para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns non-zero if <argname>name</argname>, which should be
	  valid as a gretl identifier, names a currently defined
	  object, be it a scalar, a series, a matrix, list, string,
	  bundle or array; otherwise returns 0.
	</para>
	<para>
	  Intended usage is for the case where a user-defined function
	  has an optional parameter with a <lit>null</lit>
	  default. The function writer can use <lit>exists()</lit>,
	  passing the parameter name, to check whether or not the
	  caller supplied an argument. But please note, lists are an
	  exception in this respect: if a list parameter has a
	  <lit>null</lit> default and the caller doesn't supply an
	  argument, the function gets an empty list rather than no
	  list; therefore <lit>exists</lit> will always return
	  non-zero. To check for emptiness of a list argument, use
	  <fncref targ="nelem"/>.
	</para>
	<para>
	  For related checks, see <fncref targ="typeof"/> and <fncref
	  targ="inbundle"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns <math>e</math><sup>x</sup>. Note that in case of
	  matrix input the function acts element by element. For the
	  matrix exponential function, see <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-list-or-mat">f</fnarg>
	<fnarg optional="true" type="bool">U2</fnarg>
      </fnargs>
      <description>
	<para>
	  Produces a matrix holding several statistics which serve to
	  evaluate <argname>f</argname> as a forecast of the observed
	  data <argname>y</argname>.
	</para>
	<para>
	  If <argname>f</argname> is a series or vector the output is
	  a column vector; if <argname>f</argname> is a list with
	  <math>k</math> members or a <by r="T" c="k"/> matrix the
	  output has <math>k</math> columns, each of which holds
	  statistics for the corresponding element (series or column)
	  of the input as a forecast of <argname>y</argname>.
	</para>
	<para>
	  In all cases the <quote>vertical</quote> dimension of the
	  input (for a series or list the length of the current
	  sample range, for a matrix the number of rows) must match
	  across the two arguments.
	</para>
	<para>
	  The rows of the returned matrix are as follows:
	</para>
	<code>
	  1  Mean Error (ME)
	  2  Root Mean Squared Error (RMSE)
	  3  Mean Absolute Error (MAE)
	  4  Mean Percentage Error (MPE)
	  5  Mean Absolute Percentage Error (MAPE)
	  6  Theil's U (U1 or U2)
	  7  Bias proportion, UM
	  8  Regression proportion, UR
	  9  Disturbance proportion, UD
	</code>
	<para>
	  The variant of Theil's U shown by default depends on the
	  nature of the data: if they are known to be time series then
	  U2 is shown, otherwise U1 is produced. But this choice can
	  be forced via the optional trailing argument: give a
	  non-zero value to force U2, or zero to force U1.
	</para>
	<para>
	  For details on the calculation of these statistics, and the
	  interpretation of the <math>U</math> values, please see
	  <guideref targ="chap:forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Calculates a numerical approximation to the Jacobian
	  associated with the <math>n</math>-vector
	  <argname>b</argname> and the transformation function
	  specified by the argument <argname>fcall</argname>.  The
	  function call should take <argname>b</argname> as its first
	  argument (either straight or in pointer form), followed by
	  any additional arguments that may be needed, and it should
	  return an <by r="m" c="1"/> matrix. On successful completion
	  <lit>fdjac</lit> returns an <by r="m" c="n"/> matrix holding
	  the Jacobian.
	</para>
	<para>
	  The optional third argument can be used to set the step size
	  <math>h</math> used in the approximation mechanism (see
	  below); if this argument is omitted the step size is
	  determined automatically.
	</para>
	<para>
	  Here is an example of usage:
	</para>
	<code>
	  matrix J = fdjac(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  The function can use three different methods: simple
	  forward-difference, bilateral difference or 4-nodes
	  Richardson extrapolation. Respectively:
	</para>
	<para context="tex">
	  \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
	</para>
	<para context="tex">
	  \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
	</para>
	<para context="tex">
	  \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
	</para>
	<para context="notex">
	  <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>2</sub>  = <math>[8(f(x+h) - f(x-h)) -
	  (f(x+2h) - f(x-2h))] /12h</math>
	</para>
	<para>
	  The three alternatives above provide, generally, a trade-off
	  between accuracy and speed. You can choose among methods via
	  the <cmdref targ="set"/> command: specify a value of 0, 1 or
	  2 for the <lit>fdjac_quality</lit> variable. The default is
	  0.
	</para>
	<para>
	  For more details and examples <guideref
	  targ="chap:numerical"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	    <fncref targ="numhess"/>
            <cmdref targ="set"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="feval" section="programming" output="seebelow">
      <fnargs>
	<fnarg type="string">funcname</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Primarily useful for writers of functions. The first
	  argument should be the name of a function; the remaining
	  arguments will be passed to the specified function. This
	  permits treating the function identified by
	  <argname>funcname</argname> as itself a variable. The return
	  value is whatever the named function returns given the
	  specified arguments.
	</para>
	<para>
	  The example below illustrates some possible uses.
	</para>
	<code>
	  function scalar utility (scalar c, scalar sigma)
	      return (c^(1-sigma)-1)/(1-sigma)
	  end function

	  strings S = defarray("log", "utility")

	  # call a 1-argument built-in function
	  x = feval(S[1], 2.5)
	  # call a user-defined function
	  x = feval(S[2], 5, 0.5)
	  # a 2-argument built-in function
	  func = "zeros"
	  m = feval(func, 5-2, sqrt(4))
	  print m
	  # a 3-argument built-in
	  x = feval("monthlen", 12, 1980, 5)
	</code>
	<para>
	  There's a weak analogy between <lit>feval</lit> and <fncref
	  targ="genseries"/>: both functions render variable a
	  syntactic element that is usually fixed at the time a script
	  is composed.
	</para>
	<para>
	  <seelist>
            <fncref targ="fevalb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fevalb" section="programming" output="seebelow">
      <fnargs>
	<fnarg type="string">funcname</fnarg>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  This is a variant of <fncref targ="feval"/> which meets
	  a case that may be encountered by function writers, where
	  the number and types of the arguments to be passed to the
	  named function are not known in advance. Instead of the
	  arguments being passed individually, they are passed as
	  members of the bundle argument <argname>b</argname>.
	</para>
	<para>
	  Since the order of the members in a gretl bundle is
	  indeterminate, some mechanism is required to ensure that
	  they are passed to the function in question in the right
	  order. This is automatically ensured if the lexicographic
	  order of the keys in the bundle gives the argument
	  order. For examples, the keys could be <lit>arg1</lit>,
	  <lit>arg2</lit> and so on (or <lit>arg01</lit>,
	  <lit>arg02</lit> and so on in the unlikely event that the
	  function takes more than nine arguments).  Alternatively,
	  the bundle may contain an array of strings under the
	  reserved key <lit>arglist</lit>. This array must hold
	  exactly the keys in <argname>b</argname>, except for
	  <lit>arglist</lit> itself, in the desired order.
	</para>
	<para>
	  The examples below illustrate both approaches, as applied to
	  the <fncref targ="monthlen"/> function.
	</para>
	<code>
	  # using lexicographic order
	  bundle b = _(arg1=12, arg2=1980, arg3=5)
	  n = feval("monthlen", b)

	  # using arglist
	  bundle b = _(month=12, year=1980, wkdays=5)
	  b.arglist = defarray("month", "year", "wkdays")
	  n = feval("monthlen", b)
	</code>
	<para>
	  <seelist>
            <fncref targ="feval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fevd" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  This function provides a more flexible alternative to the
	  accessor <fncref targ="$fevd"/> for obtaining a forecast
	  error variance decomposition (FEVD) matrix following
	  estimation of a VAR or VECM. Without the final optional
	  argument, it is available only when the last model estimated
	  was a VAR or VECM. Alternatively, information on such a
	  system can be stored in a bundle via the <fncref
	  targ="$system"/> accessor and subsequently passed to
	  <lit>fevd</lit>.
	</para>
	<para>
	  The <argname>target</argname> and <argname>shock</argname>
	  arguments take the form of 1-based indices of the endogenous
	  variables in the system, with 0 taken to mean
	  <quote>all</quote>. The following code fragment illustrates
	  usage. In the first example the matrix <lit>fe1</lit> holds
	  the shares of the FEVD for <lit>y1</lit> due to each of
	  <lit>y1</lit>, <lit>y2</lit> and <lit>y3</lit> (the rows
	  therefore summing to 1). In the second, <lit>fe2</lit> holds
	  the contribution of <lit>y2</lit> to the forecast error
	  variance of all three variables (so the rows do not sum to
	  1). In the third case the return value is a column vector
	  showing the <quote>own share</quote> of the FEVD for
	  <lit>y1</lit>.
	</para>
	<code>
	  var 4 y1 y2 y3
	  bundle vb = $system
	  matrix fe1 = fevd(1, 0, vb)
	  matrix fe2 = fevd(0, 2, vb)
	  matrix fe3 = fevd(1, 1, vb)
	</code>
	<para>
	  The number of periods (rows) over which the decomposition is
	  traced is determined automatically based on the frequency of
	  the data, but this can be overridden via the
	  <lit>horizon</lit> argument to the <cmdref targ="set"/>
	  command, as in <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="irf"/></seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Discrete Fourier transform. The input matrix
	  <argname>X</argname> may be real or complex. The output is a
	  complex matrix of the same dimensions as
	  <argname>X</argname>.
	</para>
	<para>
	  Should it be necessary to compute the Fourier transform on
	  several vectors with the same number of elements, it is more
	  efficient to group them into a matrix rather than invoking
	  <lit>fft</lit> for each vector separately.
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Inverse discrete Fourier transform. It is assumed that
	  <argname>X</argname> contains <math>n</math> complex column
	  vectors. A matrix with <math>n</math> columns is returned.
	</para>
	<para>
	  Should it be necessary to compute the inverse Fourier
	  transform on several vectors with the same number of
	  elements, it is more efficient to group them into a matrix
	  rather than invoking <lit>ffti</lit> for each vector
	  separately.
	  <seelist>
            <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="timeseries" output="seebelow">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
	<fnarg optional="true" type="scalar-or-vec">x0</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes an ARMA-like filtering of the argument
	  <argname>x</argname>. The transformation can be written as
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> =
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub><math>y</math><sub>t-p</sub>
	</para>
	<para>
	  If argument <argname>x</argname> is a series, the result
	  will be itself a series. Otherwise, if <argname>x</argname>
	  is a matrix with <math>T</math> rows and <math>k</math>
	  columns, the result will be a matrix of the same size, in
	  which the filtering is performed column by column.
	</para>
	<para>
	  The two arguments <argname>a</argname> and
	  <argname>b</argname> are optional. They may be scalars,
	  vectors or the keyword <lit>null</lit>.
	</para>
	<para>
	  If <argname>a</argname> is a scalar, this is used as
	  <math>a</math><sub>0</sub> and implies <math>q=0</math>; if
	  it is a vector of <math>q+1</math> elements, they contain
	  the coefficients from <math>a</math><sub>0</sub> to
	  <math>a</math><sub>q</sub>. If <argname>a</argname> is
	  <lit>null</lit> or omitted, this is equivalent to setting
	  <math>a</math><sub>0</sub> <math>=1</math> and
	  <math>q=0</math>.
	</para>
	<para>
	  If <argname>b</argname> is a scalar, this is used as
	  <math>b</math><sub>1</sub> and implies <math>p=1</math>; if
	  it is a vector of <math>p</math> elements, they contain the
	  coefficients from <math>b</math><sub>1</sub> to
	  <math>b</math><sub>p</sub>. If <argname>b</argname> is
	  <lit>null</lit> or omitted, this is equivalent to setting
	  <math>B(L)=1</math>.
	</para>
	<para>
	  The optional scalar argument <argname>y0</argname> is taken
	  to represent all values of <math>y</math> prior to the
	  beginning of sample (used only when <math>p &gt; 0</math>). If
	  omitted, it is understood to be 0. Similarly, the optional
	  argument <argname>x0</argname> may be used to specify one or
	  more pre-sample values of <math>x</math>, information that
	  is relevant only when <math>q &gt; 0</math>.  Otherwise
	  pre-sample values of <math>x</math> are assumed to be zero.
	</para>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
            <fncref targ="fracdiff"/>
            <fncref targ="hpfilt"/>
            <fncref targ="movavg"/>
            <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Example:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produces
	</para>
	<code>
          index            y

          1            1     -0.40000
          2            2      1.36000
          3            3      0.27600
          4            4      1.75160
          5            5      0.92356

          x (5 x 2)

          1   1
          2   0
          3   0
          4   0
          5   0

          w (5 x 2)

          -0.40000     -0.40000
           1.3600       0.36000
           0.27600     -0.32400
           1.7516       0.29160
           0.92356     -0.26244
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">insample</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the 1-based index of the first non-missing
	  observation for the series <argname>y</argname>. By default
	  the whole data range is examined, so if subsampling is in
	  effect the value returned may be smaller than the accessor
	  <fncref targ="$t1"/>. But if a non-zero value is given for
	  <argname>insample</argname> only the current sample range is
	  considered.
	  <seelist>
            <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">rawname</fnarg>
	<fnarg type="bool" optional="true">underscore</fnarg>
      </fnargs>
      <description>
	<para>
	  Primarily intended for use in connection with the <cmdref
	  targ="join"/> command.  Returns the result of converting
	  <argname>rawname</argname> to a valid gretl identifier,
	  which must start with a letter, contain nothing but (ASCII)
	  letters, digits and the underscore character, and must not
	  exceed 31 characters. The rules used in conversion are:
	</para>
	<para>
	  1. Skip any leading non-letters.
	</para>
	<para>
	  2. Until the 31-character limit is reached or the input is
	  exhausted: transcribe <quote>legal</quote> characters; skip
	  <quote>illegal</quote> characters apart from spaces; and
	  replace one or more consecutive spaces with an underscore,
	  unless the previous character transcribed is an underscore in
	  which case space is skipped.
	</para>
	<para>
	  If you are confident that the input is not too long (and
	  hence subject to truncation), you may wish to have sequences
	  of one or more illegal characters replaced with an
	  underscore rather than just being deleted; this may produce
	  a more readable identifier. To get this effect, supply a
	  nonzero value for the optional second argument. But this is
	  not advisable in the context of the <cmdref targ="join"/>
	  command, since the automatically <quote>fixed</quote> name
	  will not use underscores in this way.
	</para>
      </description>
    </function>

    <function name="flatten" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="matrices-or-strings">A</fnarg>
	<fnarg optional="true" type="int-or-string">alt</fnarg>
      </fnargs>
      <description>
	<para>
	  <quote>Flattens</quote> either an array of matrices into a
	  single matrix or an array of strings into a single string.
	</para>
        <subhead>Matrices</subhead>
	<para>
	  In the matrix case, the way the matrices in
	  <argname>A</argname> are joined together depends on the the
	  <argname>alt</argname> argument, which should have value 0
	  (horizontal), 1 (vertical) or 2 (<quote>vec-wise</quote>).
	  The best way to explain the difference between the three
	  alternatives is by example: the code
	</para>
	<code>
	  X = {1,3,5; 2,4,6}
	  A = defarray(X, X+6)
	  U = flatten(A,0) # = A[1] ~ A[2]
	  V = flatten(A,1) # = A[1] | A[2]
	  W = flatten(A,2) # = vec(A[1]) ~ vec(A[2])
	</code>
	<para>
	  produces the following three matrices:
	</para>
	<code>
	  U (2 x 6)

	  1    3    5    7    9   11
	  2    4    6    8   10   12

	  V (4 x 3)

	  1    3    5
	  2    4    6
	  7    9   11
	  8   10   12

	  W (6 x 2)

	  1    7
	  2    8
	  3    9
	  4   10
	  5   11
	  6   12
	</code>
	<para>
	  An error is flagged if the matrices in the array are not
	  conformable for the operation. See <fncref targ="msplitby"/>
	  for the inverse operation.
	</para>
        <subhead>Strings</subhead>
	<para>
	  In the string case the result holds the strings in
	  <argname>A</argname>, arranged one per line by default. If a
	  non-zero numerical value is given for <argname>alt</argname>
	  the strings are separated by spaces rather than newlines,
	  but an alternative usage of <argname>alt</argname> is
	  supported: you may give a specific string to use as the
	  separator. The inverse function for the string case is
	  <fncref targ="strsplit"/>.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the greatest integer less than or equal to
	  <argname>x</argname>. Note: <fncref targ="int"/> and
	  <lit>floor</lit> differ in their effect for negative
	  arguments: <lit>int(-3.5)</lit> gives &minus;3, while
	  <lit>floor(-3.5)</lit> gives &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns the fractional difference of order <argname>d</argname>
	  for the series <argname>y</argname>.
	</para>
	<para context="tex">
          \[
          \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
          \]
	  where
          \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Note that in theory fractional differentiation is an
	  infinitely long filter. In practice, presample values of
	  <math>y</math><sub>t</sub> are assumed to be zero.
	</para>
	<para>
	  A negative value of <argname>d</argname> can be given, in
	  which case fractional integration is performed.
	</para>
      </description>
    </function>

    <function name="fzero" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar-or-vec">init</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Attempts to find a single root of a continuous (typically
	  nonlinear) function <math>f</math>&mdash;that is, a value of
	  the scalar variable <math>x</math> such that
	  <math>f</math>(<math>x</math>) = 0.  The
	  <argname>fcall</argname> argument should provide a call to
	  the function in question; <argname>fcall</argname> may
	  include an arbitrary number of arguments but the first one
	  must be the scalar playing the role of <math>x</math>.  On
	  successful completion the value of the root is returned.
	</para>
	<para>
	  The method used is that of <cite key="ridders79">Ridders
	  (1979)</cite>. This requires an initial bracket
	  &lbr;<math>x</math><sub>0</sub>,
	  <math>x</math><sub>1</sub>&rbr; such that both
	  <math>x</math> values lie in the domain of the function and
	  the respective function values are of opposite sign. Best
	  results are likely to be obtained if the user can supply,
	  via the second argument, a 2-vector holding suitable
	  end-points for the bracket.  Failing that, one can supply a
	  single scalar value and <lit>fzero</lit> will try to find a
	  counterpart. If the second argument is omitted,
	  <math>x</math><sub>0</sub> is initialized to a small
	  positive value and we search for a suitable
	  <math>x</math><sub>1</sub>.
	</para>
	<para>
	  The optional <argname>toler</argname> argument can be used
	  to adjust the maximum acceptable absolute difference of
	  <math>f</math>(<math>x</math>) from zero, the default being
	  1.0e&minus;14.
	</para>
	<para>
	  By default this function operates silently, but the progress
	  of the iterative method can be exposed by executing the
	  command <quote><lit>set max_verbose on</lit></quote> before
	  calling <lit>fzero</lit>.
	</para>
	<para>
	  Some simple examples follow.
	</para>
	<code>
	  # Approximate pi by finding a zero for sin() in the
	  # bracket 2.8 to 3.2
	  x = fzero(sin(x), {2.8, 3.2})
	  printf "\nx = %.12f vs pi = %.12f\n\n", x, $pi

	  # Approximate the 'Omega constant' starting from x = 0.5
	  function scalar f(scalar x)
	      return log(x) + x
	  end function
	  x = fzero(f(x), 0.5)
	  printf "x = %.12f f(x) = %.15f\n", x, f(x)
	</code>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the gamma function of <argname>x</argname>.
	</para>
	<para>
	  See also <fncref targ="bincoeff"/> and <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="genseries" section="programming" output="scalar">
      <fnargs>
	<fnarg type="string">varname</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>
      <description>
	<para>
	  Provides the script writer with a convenient means of
	  generating series whose names are not known in advance,
	  and/or creating a series and appending it to a list in a
	  single operation.
	</para>
	<para>
	  The first argument gives the name of the series to create
	  (or modify); this can be a string literal, a string
	  variable, or an expression that evaluates to a string.  The
	  second argument, <argname>rhs</argname> (<quote>right-hand
	  side</quote>), defines the source series: this can be the
	  name of an existing series or an expression that evaluates
	  to a series, as would appear to the right of the equals sign
	  when defining a series in the usual way.
	</para>
	<para>
	  The return value from this function is the ID number of the
	  series in the dataset, a value suitable for inclusion in a
	  list (or &minus;1 on failure).
	</para>
	<para>
	  For example, suppose you want to add <math>n</math> random
	  normal series to the dataset and put them all into a named
	  list. The following will do the job:
	</para>
	<code>
	  nulldata 10
	  list Normals = null
	  scalar n = 3
	  loop i = 1 .. n
	      Normals += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  On completion <lit>Normals</lit> will contain the series
	  <lit>norm1</lit>, <lit>norm2</lit> and <lit>norm3</lit> .
	</para>
	<para>
	  Those who find <lit>genseries</lit> useful may also like to
	  explore <fncref targ="feval"/>.
	</para>
      </description>
    </function>

    <function name="geoplot" section="data-utils" output="none">
      <fnargs>
	<fnarg type="string">mapfile</fnarg>
	<fnarg optional="true" type="series">payload</fnarg>
	<fnarg optional="true" type="bundle">options</fnarg>
      </fnargs>
      <description>
	<para>
	  Calls for production of a map, when suitable geographical
	  data are present. In most cases the
	  <argname>mapfile</argname> argument should be given as
	  <fncref targ="$mapfile"/>, an accessor that retrieves the
	  name of the relevant GeoJSON file or ESRI shapefile. The
	  optional <argname>payload</argname> argument is used to give
	  the name of a series with which to colorize the regions of
	  the map. And the final bundle argument enables you to set
	  numerous options.
	</para>
	<para>
	  See the geoplot documentation, <doc>geoplot.pdf</doc>, for
	  full details and examples. This explains all the settings
	  configurable via the <argname>options</argname> argument.
	</para>
      </description>
    </function>

    <function name="getenv" section="programming" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  If an environment variable by the name of
	  <argname>s</argname> is defined, returns the string value of
	  that variable, otherwise returns an empty string.
	  See also <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getinfo" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns information on the specified series, which may be
	  given by name or ID number. The returned bundle contains all
	  the attributes which can be set via the <cmdref
	  targ="setinfo"/> command. It also contains additional
	  information relevant for series that have been created as
	  transformations of primary data (lags, logs, etc.): this
	  includes the gretl command word for the transformation under
	  the key <quote>transform</quote> and the name of the
	  associated primary series under <quote>parent</quote>. For
	  lagged series, the specific lag number can be found under
	  the key <quote>lag</quote>.
	</para>
	<para>
	  Here is an example of usage:
	</para>
	<code>
	  open data9-7
	  lags QNC
	  bundle b = getinfo(QNC_2)
	  print b
	</code>
	<para>
	  On executing the above we see:
	</para>
	<code>
	  has_string_table = 0
	  lag = 2
	  parent = QNC
	  name = QNC_2
	  graph_name =
	  coded = 0
	  discrete = 0
	  transform = lags
	  description = = QNC(t - 2)
	</code>
	<para>
	  To test whether series 5 in a dataset is a lagged term one can
	  do this sort of thing:
	</para>
	<code>
	  if getinfo(5).lag != 0
	     printf "series 5 is a lag of %s\n", getinfo(5).parent
	  endif
	</code>
	<para>
	  Note that the dot notation to access bundle members can be
	  used even when the bundle is <quote>anonymous</quote> (not
	  saved under its own name).
	</para>
      </description>
    </function>

    <function name="getkeys" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an array of strings holding the keys identifying the
	  contents of <argname>b</argname>. If the bundle is empty an
	  empty array is returned.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">source</fnarg>
	<fnarg type="stringref">&amp;target</fnarg>
      </fnargs>
      <description>
	<para>
	  This function is used to read successive lines from
	  <argname>source</argname>, which should be a named string
	  variable. On each call a line from the source is written to
	  <argname>target</argname> (which must also be a named string
	  variable, given in pointer form), with the newline character
	  stripped off. The valued returned is 1 if there was anything
	  to be read (including blank lines), 0 if the source has been
	  exhausted.
	</para>
	<para>
	  Here is an example in which the content of a text file is
	  broken into lines:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, &amp;line)
	      printf "line %d = '%s'\n", i++, line
	  endloop
	</code>
	<para>
	  In this example we can be sure that the source is exhausted
	  when the loop terminates. If the source might not be
	  exhausted you should follow your regular call(s) to
	  <lit>getline</lit> with a <quote>clean up</quote> call, in which
	  <argname>target</argname> is replaced by <lit>null</lit> (or
	  omitted altogether) as in
	</para>
	<code>
	  getline(s, &amp;line) # get a single line
	  getline(s, null) # clean up
	</code>
	<para>
	  Note that although the reading position advances at each call
	  to <lit>getline</lit>, <argname>source</argname> is not modified
	  by this function, only <argname>target</argname>.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;dP</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the GHK (Geweke, Hajivassiliou, Keane) approximation to the
	  multivariate normal distribution function; see for example <cite
	  key="geweke91">Geweke (1991)</cite>. The value returned is an <by
	  r="n" c="1"/> vector of probabilities.
	</para>
	<para>
	  The argument <argname>C</argname> (<by r="m" c="m"/>) should give
	  the Cholesky factor (lower triangular) of the covariance
	  matrix of <math>m</math> normal variates.  The arguments
	  <argname>A</argname> and <argname>B</argname> should both be <by
	  r="n" c="m"/>, giving respectively the lower and upper bounds
	  applying to the variates at each of <math>n</math>
	  observations. Where variates are unbounded, this should be indicated
	  using the built-in constant <fncref targ="$huge"/> or its negative.
	</para>
	<para>
	  The matrix <argname>U</argname> should be <by r="m" c="r"/>, with
	  <math>r</math> the number of pseudo-random draws from the uniform
	  distribution; suitable functions for creating <argname>U</argname>
	  are <fncref targ="muniform"/> and <fncref targ="halton"/>.
	</para>
	<para>
	  We illustrate below with a relatively simple case where the
	  multivariate probabilities can be calculated
	  analytically. The series <lit>P</lit> and <lit>Q</lit>
	  should be numerically very similar to one another,
	  <lit>P</lit> being the <quote>true</quote> probability and
	  <lit>Q</lit> its GHK approximation:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = halton(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
	<para>
	  The optional <argname>dP</argname> argument can be used to
	  retrieve the <by r="n" c="k"/> matrix of analytical
	  derivatives of the probabilities, where <math>k</math>
	  equals 2<math>m</math> + <math>m</math>(<math>m</math> +
	  1)/2. The first <math>m</math> columns hold the derivatives
	  with respect to the lower bounds, the next <math>m</math>
	  those with respect to the upper bounds, and the remainder
	  the derivatives with respect to the unique elements of the
	  <math>C</math> matrix in <quote>vech</quote> order.
	</para>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns Gini's inequality index for the (non-negative)
	  series or vector <argname>y</argname>. A Gini value of zero
	  indicates perfect equality. The maximum Gini value for a
	  series with <math>n</math> members is (<math>n</math>
	  &minus; 1)/<math>n</math>, occurring when only one member
	  has a positive value; a Gini of 1.0 is therefore the limit
	  approached by a large series with maximal inequality.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="scalar" optional="true">tol</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns <math>A</math><sup>+</sup>, the Moore&ndash;Penrose
	  or generalized inverse of the <by r="r" c="c"/>
	  matrix <argname>A</argname>, computed via the singular value
	  decomposition.
	</para>
	<para>
	  The result of this operation depends on the number of
	  singular values of <argname>A</argname> that are found to be
	  numerically 0. The <argname>tol</argname> optional parameter
	  can be used for tweaking this aspect. Singular values are
	  considered to be 0 if they are less than <math>m &times; tol
	  &times; s</math>, where <math>m</math> is the greater of
	  <math>r</math> and <math>c</math> and <math>s</math> is the
	  largest singular value. If the second argument is omitted
	  <argname>tol</argname> is set to machine epsilon (see
	  <fncref targ="$macheps"/>). In some cases, you may want to
	  set <argname>tol</argname> to a larger value (eg 1.0e-9) in
	  order to avoid overestimating the rank of
	  <argname>A</argname>, which may lead to numerically unstable
	  results.
	</para>
	<para context="notex">
	  This matrix has the properties <math>A</math>
	  <math>A</math><sup>+</sup> <math>A</math> = <math>A</math>
	  and <math>A</math><sup>+</sup> <math>A</math>
	  <math>A</math><sup>+</sup> = <math>A</math><sup>+</sup>.
	  Moreover, the products <math>A</math>
	  <math>A</math><sup>+</sup> and <math>A</math><sup>+</sup>
	  <math>A</math> are symmetric by construction.
	</para>
	<para context="tex">
	  This matrix has the properties
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+
	  \end{eqnarray*}
	  Moreover, the products $A^+ A$ and $A A^+$ are
	  symmetric by construction.
	</para>
	<para>
	  <seelist>
            <fncref targ="inv"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="GSSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  One-dimensional maximization via the Golden Section Search
	  method. The matrix <argname>b</argname> should be a
	  3-vector. On input the first element is ignored while the
	  second and third elements set the lower and upper bounds on
	  the search. The <argname>fncall</argname> argument should
	  specify a call to a function that returns the value of the
	  maximand; element 1 of <argname>b</argname>, which will hold
	  the current value of the adjustable parameter when the
	  function is called, should be given as its first argument;
	  any other required arguments may then follow. The function
	  in question should be unimodal (should have no local maxima
	  other than the global maximum) over the stipulated range, or
	  GSS is not sure to find the maximum.
	</para>
	<para>
	  On successful completion <lit>GSSmax</lit> returns the
	  optimum value of the maximand, while <argname>b</argname>
	  holds the optimal parameter value along with the limits of
	  its bracket.
	</para>
	<para>
	  The optional third argument may be used to set the tolerance
	  for convergence, that is, the maximum acceptable width of
	  the final bracket for the parameter. If this argument is not
	  given a value of 0.0001 is used.
	</para>
	<para>
	  If the object is in fact minimization, either the function
	  call should return the negative of the criterion or
	  alternatively <lit>GSSmax</lit> may be called under the
	  alias <lit>GSSmin</lit>.
	</para>
	<para>
	  Here is a simple example of usage:
	</para>
	<code>
	  function scalar trigfunc (scalar theta)
	      return 4 * sin(theta) * (1 + cos(theta))
	  end function

	  matrix m = {0, 0, $pi/2}
	  eval GSSmax(&amp;m, trigfunc(m[1]))
	  printf "\n%10.7f", m
	</code>
      </description>
    </function>

    <function name="GSSmin" section="numerical" output="scalar">
      <description>
	<para>
	  An alias for <fncref targ="GSSmax"/>; if called under this
	  name the function acts as a minimizer.
	</para>
      </description>
    </function>

    <function name="halton" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="m" c="r"/> matrix containing
	  <math>m</math> Halton sequences of length <math>r</math>.
	  The sequences are constructed using the first <math>m</math>
	  primes. By default the first 10 elements of each sequence
	  are discarded, but this figure can be adjusted via the
	  optional <argname>offset</argname> argument, which should be
	  a non-negative integer. See <cite key="halton64">Halton and
	  Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Horizontal direct product. The two arguments must have the
	  same number of rows, <math>r</math>. The return value is a
	  matrix with <math>r</math> rows, in which the
	  <math>i</math>-th row is the Kronecker product of the
	  corresponding rows of <argname>X</argname> and
	  <argname>Y</argname>. If <argname>Y</argname> is omitted,
	  the <quote>shorthand</quote> syntax applies (see below).
	</para>
	<para context="tex">
	  If $X$ is an $r \times k$ matrix, $Y$ is an $r \times m$
	  matrix and $Z$ is the result matrix of the horizontal direct
	  product of $X$ times $Y$, then $Z$ will have $r$ rows and
	  $k\cdot m$ columns; moreover, \[ Z_{in} = X_{ij} Y_{il} \]
	  where $n = (j-1) m + l$.
	</para>
	<para context="notex">
	  If <argname>X</argname> is an <math>r x k</math> matrix and
	  <argname>Y</argname> is an <math>r x m</math> matrix, the
	  result will be a matrix with <math>r</math> rows and
	  <math>km</math> columns.
	</para>
	<para>
	  This operation is called <quote>horizontal direct
	  product</quote> in conformity to its implementation in the
	  GAUSS programming language. Its equivalent in standard
	  matrix algebra would be called the row-wise Khatri-Rao
	  product, or <quote>face-splitting</quote> product in the
	  signal processing literature.
	</para>
	<para>
	  Example: the code
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produces the following matrix:
	</para>
	<code>
          0    1    0    2    0    3
         -4    4   -5    5   -6    6
	</code>
	<subhead>Shorthand syntax</subhead>
	<para>
	  If <argname>X</argname> and <argname>Y</argname> are the
	  same matrix, then each row of the result is the
	  vectorization of a symmetric matrix. In these cases, the
	  second argument may be omitted; however, the returned matrix
	  will only contain the non-redundant columns, and will
	  therefore have <math>k(k+1)/2</math> columns.  For example,
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  C = hdprod(A)
	</code>
	<para>
	  produces
	</para>
	<code>
	  1    2    3    4    6    9
	  16   20   24   25   30   36
	</code>
	<para context="tex">
	  Note that the $i$-th row of $C$ is $\mathrm{vech}(a_i
	  a_i')$, where $a_i$  is the $i$-th row of $A$.
	</para>
	<para context="notex">
	  Note that the <math>i</math>-th row of <math>C</math> is
	  <math>vech(a</math><sub>i</sub>
	  <math>a</math><sub>i</sub><math>')</math>, where
	  <math>a</math><sub>i</sub> is the <math>i</math>-th row of
	  <math>A</math>.
	</para>
	<para>
	  When using the shorthand syntax with complex matrices, the
	  implicit second argument will be the <i>conjugate</i> of the
	  first one, so as to make each row of the result the
	  symmetric vectorization of a Hermitian matrix.
	</para>
      </description>
    </function>

    <function name="hfdiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplier</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a <cmdref targ="MIDAS_list"/>, produces a list of the
	  same length holding high-frequency first differences. The
	  second argument is optional and defaults to unity: it can be
	  used to multiply the differences by some constant.
	</para>
      </description>
    </function>

    <function name="hfldiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplier</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a <cmdref targ="MIDAS_list"/>, produces a list of the
	  same length holding high-frequency log-differences. The
	  second argument is optional and defaults to unity: it can be
	  used to multiply the differences by some constant, for
	  example one might give a value of 100 to produce
	  (approximate) percentage changes.
	</para>
      </description>
    </function>

    <function name="hflags" section="midas" output="list">
      <fnargs>
	<fnarg type="int">minlag</fnarg>
	<fnarg type="int">maxlag</fnarg>
	<fnarg type="list">hfvars</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a <cmdref targ="MIDAS_list"/>, <repl>hfvars</repl>,
	  produces a list holding high-frequency lags
	  <repl>minlag</repl> to <repl>maxlag</repl>. Use positive
	  values for actual lags, negative for leads. For example, if
	  <repl>minlag</repl> is &minus;3 and <repl>maxlag</repl> is 5
	  then the returned list will hold 9 series: 3 leads, the
	  contemporary value, and 5 lags.
	</para>
	<para>
	  Note that high-frequency lag 0 corresponds to the first
	  high frequency period within a low frequency period, for
	  example the first month of a quarter or the first day of
	  a month.
	</para>
      </description>
    </function>

    <function name="hflist" section="midas" output="list">
      <fnargs>
	<fnarg type="vector">x</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg type="string">prefix</fnarg>
      </fnargs>
      <description>
	<para>
	  Produces from the vector <repl>x</repl> a <cmdref
	  targ="MIDAS_list"/> of <repl>m</repl> series, where
	  <repl>m</repl> is the ratio of the frequency of observation
	  for the variable in <repl>x</repl> to the base frequency of
	  the current dataset. The value of <repl>m</repl> must be at
	  least 3 and the length of <repl>x</repl> must be
	  <repl>m</repl> times the length of the current sample range.
	</para>
	<para>
	  The names of the series in the returned list are constructed
	  from the given <repl>prefix</repl> (which must be an ASCII
	  string of 24 characters or less, and valid as a gretl
	  identifier), plus one or more digits representing the
	  sub-period of the observation. An error is flagged if any of
	  these names duplicate names of existing objects.
	</para>
      </description>
    </function>

    <function name="hpfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
	<fnarg type="bool" optional="true">one-sided</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the cycle component from application of the
	  Hodrick&ndash;Prescott filter to series <argname>y</argname>. If the
	  smoothing parameter, <argname>lambda</argname>, is not supplied then
	  a data-based default is used, namely 100 times the square of the
	  periodicity (100 for annual data, 1600 for quarterly data, and so
	  on).
	</para>
	<para>
	  By default the filter is the usual two-sided version, but if
	  the optional third argument is given with a non-zero
	  value a one-sided variant (with no look-ahead) is computed
	  in the manner of <cite key="stock-watson1999">Stock and
	  Watson (1999)</cite>.
	</para>
	<para>
	  The most common use of the HP filter is detrending, but if
	  it's the trend you are interested in that is easily obtained
	  by subtraction, as in
	</para>
	<code>
	  series hptrend = y - hpfilt(y)
	</code>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="hyp2f1" section="math" output="scalar-or-matrix">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg type="scalar">c</fnarg>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns the Gaussian hypergeometric function for the real
	  argument <argname>x</argname>. Valid values for
	  <argname>x</argname> are in the closed interval [&minus;1, 1].
	  This function is very general, and reduces to a
	  simpler function in some special cases, such as for example
	  <math>-</math>log(<math>1-x</math>)/<math>x</math> for
	  <math>a=b=1</math> and <math>c=2</math>. See
	  <url>https://en.wikipedia.org/wiki/Hypergeometric_function</url>
	  for more details.
	</para>
	<para context="tex">
	  Returns the Gaussian hypergeometric function
	  <math>{}_2F_1(a,b;c;z) = \sum_{n=0}^\infty \frac{(a)_n
	  (b)_n}{(c)_n} \frac{z^n}{n!}</math> for real argument
	  <argname>x</argname>. Valid values for <argname>x</argname>
	  are in the closed interval [&minus;1, 1]. This function
	  is very general, and reduces to a simpler function in some
	  special cases, such as for example
	  <math>-\frac{\log(1-x)}{x}</math> for <math>a=b=1</math> and
	  <math>c=2</math>. See
	  <url>https://en.wikipedia.org/wiki/Hypergeometric_function</url>
	  for more details.
	</para>
	<para>
	  If <argname>x</argname> is a scalar, the return value will
	  be scalar; otherwise, it will be a matrix the same size as
	  <argname>x</argname>. For example,
	</para>
	<code>
	  a = hyp2f1(1, 1, 2, {-1, 0, 0.5})
	  print a
	</code>
	<para>
	  produces the following output:
	</para>
	<code>
	  a (1 x 3)

	  0.69315       1.0000       1.3863
	</code>
      </description>
    </function>

    <function name="I" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg optional="true" type="int">m</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>m</argname> is omitted, returns an identity
	  matrix of order <argname>n</argname>. Otherwise returns an
	  <by r="n" c="m"/> matrix with ones on the main diagonal and
	  zeros elsewhere.
	</para>
      </description>
    </function>

    <function name="Im" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a real matrix of the same dimensions as
	  <argname>C</argname>, holding the imaginary part of the
	  input matrix. See also <fncref targ="Re"/>.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the row indices of the maxima of the columns of
	  <argname>X</argname>. For columns containing <lit>NA</lit>s
	  the result is also set to <lit>NA</lit>, unless the optional
	  argument <argname>skip_na</argname> is nonzero, in which
	  case the index for the maximum valid entry will be returned.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the column indices of the maxima of the columns of
	  <argname>X</argname>. For rows containing <lit>NA</lit>s the
	  result is also set to <lit>NA</lit>, unless the optional
	  argument <argname>skip_na</argname> is nonzero, in which
	  case the index for the maximum valid entry will be returned.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes Prob(<math>u'Au</math> &lt; <math>x</math>) for a quadratic
	  form in standard normal variates, <math>u</math>, using the procedure
	  developed by <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Computes ${\rm Prob}(u'Au &lt; x)$ for a quadratic form in standard
	  normal variates, $u$, using the procedure developed by
	  <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  If the first argument, <argname>M</argname>, is a square matrix it
	  is taken to specify <math>A</math>, otherwise if it's a column
	  vector it is taken to be the precomputed eigenvalues of
	  <math>A</math>, otherwise an error is flagged.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the row indices of the minima of the columns of
	  <math>X</math>. For columns containing <lit>NA</lit>s
	  the result is also set to <lit>NA</lit>, unless the optional
	  argument <argname>skip_na</argname> is nonzero, in which
	  case the index for the minimum valid entry will be returned.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="imaxc"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the column indices of the minima of the rows of
	  <math>X</math>. For rows containing <lit>NA</lit>s
	  the result is also set to <lit>NA</lit>, unless the optional
	  argument <argname>skip_na</argname> is nonzero, in which
	  case the index for the minimum valid entry will be returned.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="imaxr"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
      </fnargs>
      <description>
	<para>
	  Checks whether bundle <argname>b</argname> contains a
	  data-item with name <argname>key</argname>. The value
	  returned is an integer code for the type of the item: 0 for
	  no match, 1 for scalar, 2 for series, 3 for matrix, 4 for
	  string, 5 for bundle, 6 for array and 7 for list. The
	  function <fncref targ="typestr"/> may be used to get the
	  string corresponding to this code.
	</para>
      </description>
    </function>

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns the infinity-norm of <argname>X</argname>, that is,
	  the maximum across the rows of <argname>X</argname> of
	  the sum of absolute values of the row elements.
	</para>
	<para context="tex">
	  Returns the $\infty$-norm of the $r\times c$ matrix
	  <argname>X</argname>, namely,
          \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the (1-based) position of <argname>y</argname> in
	  list <argname>L</argname>, or 0 if <argname>y</argname>
	  is not present in <argname>L</argname>.
	</para>
	<para>
	  The second argument may be given as the name of a series or
	  alternatively as an integer ID number. If you know that a
	  series of a certain name (say <lit>foo</lit>) exists, then
	  you can call this function as, for example,
	</para>
	<code>
	  pos = inlist(L, foo)
	</code>
	<para>
	  Here you are, in effect, asking <quote>Give me the position
	  of series <lit>foo</lit> in list <lit>L</lit> (or 0 if it is
	  not included in L).</quote> However, if you are unsure
	  whether a series of the given name exists, you should place
	  the name in quotes:
	</para>
	<code>
	  pos = inlist(L, "foo")
	</code>
	<para>
	  In this case you are asking, <quote>If there's a series
	  named <lit>foo</lit> in <lit>L</lit> give me its position,
	  otherwise return 0.</quote>
	</para>
      </description>
    </function>

    <function name="instring" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="bool">ign_case</fnarg>
      </fnargs>
      <description>
	<para>
	  This is a boolean relative of <fncref targ="strstr"/>: it
	  returns 1 if <argname>s1</argname> contains
	  <argname>s2</argname>, 0 otherwise. So the conditional
	  expression
	</para>
	<code>
	  if instring("cattle", "cat")
	</code>
	<para>
	  is logically equivalent to, but more efficient than,
	</para>
	<code>
	  if strlen(strstr("cattle", "cat")) &gt; 0
	</code>
	<para>
	  If the optional argument <argname>ign_case</argname> is nonzero, the
	  search is case-insensitive. For example,
	</para>
	<code>
	  instring("Cattle", "cat")
	</code>
	<para>
	  returns 0, but
	</para>
	<code>
	  instring("Cattle", "cat", 1)
	</code>
	<para>
	  returns 1.
	</para>
      </description>
    </function>

    <function name="instrings" section="strings" output="seebelow">
      <fnargs>
	<fnarg type="strings">S</fnarg>
	<fnarg type="string">test</fnarg>
	<fnarg type="bool" optional="true">simple</fnarg>
      </fnargs>
      <description>
	<para>
	  Checks the elements of the strings array
	  <argname>S</argname> for equality with
	  <argname>test</argname>. By default, returns a column vector
	  of length equal to the number of matches, holding the
	  positions of the matches within the array&mdash;or an empty
	  matrix in case of no matches.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  strings S = defarray("A", "B", "C", "B")
	  eval instrings(S, "B")
	  2
	  4
	</code>
	<para>
	  If a non-zero value is given for the optional
	  <argname>simple</argname> argument, the return value is a
	  scalar: 1 if <argname>test</argname> is found in
	  <argname>S</argname>, 0 otherwise. In this case the
	  implementation is able to take a shortcut, so it's more
	  efficient if you just want a boolean answer.
	</para>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the integer part of <argname>x</argname>, truncating
	  the fractional part, or <lit>NA</lit> if the result cannot be
	  represented as a 32-bit signed integer (does not lie in
	  the interval [&minus;2147483648, 2147483647]).
	</para>
	<para>
	  Note: <lit>int</lit> and <fncref targ="floor"/> differ in
	  their effect for negative arguments: <lit>int(-3.5)</lit>
	  gives &minus;3, while <lit>floor(-3.5)</lit> gives &minus;4.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="round"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="interpol" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a series in which missing values in
	  <argname>x</argname> are imputed via linear interpolation,
	  for time series data or in the time dimension of a panel
	  dataset. Extrapolation is not performed; missing values are
	  replaced only if they are both preceded and followed by
	  valid observations.
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse of <argname>A</argname>. If
	  <argname>A</argname> is singular or not square, an error message
	  is produced and nothing is returned. Note that gretl checks
	  automatically the structure of <argname>A</argname> and uses the
	  most efficient numerical procedure to perform the inversion.
	</para>
	<para>
	  The matrix types gretl checks for are: identity; diagonal;
	  symmetric and positive definite; symmetric but not positive
	  definite; and triangular.
	</para>
	<para>
	  Note: it makes sense to use this function only if you plan
	  to use the inverse of <argname>A</argname> more than
	  once. If you just need to compute an expression of the form
	  <math>A</math><sup>-1</sup><math>B</math>, you'll be much
	  better off using the <quote>division</quote> operators
	  <lit>\</lit> and <lit>/</lit>. See <guideref
	  targ="chap:matrices"/> for details.
	</para>
	<para>
	  <seelist>
            <fncref targ="ginv"/>
            <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">u</fnarg>
      </fnargs>
      <description>
	<para>
	  Inverse cumulative distribution function calculator. For a
	  continuous distribution, returns <math>x</math> such that
	  <equation status="inline" ascii="P(X &le; x) = u" tex="$P(X
	  \le x) = u$"/>, for <argname>u</argname> in the interval 0
	  to 1. For a discrete distribution (Binomial or Poisson),
	  returns the smallest <math>x</math> such that <equation
	  status="inline" ascii="P(X &le; x) &ge; u" tex="$P(X \le x)
	  \ge u$"/>.
	</para>
	<para>
	  The distribution of <math>X</math> is determined by the
	  string <argname>d</argname>.  Between the arguments
	  <argname>d</argname> and <argname>u</argname>, zero or more
	  additional scalar arguments are required to specify the
	  parameters of the distribution, as follows.
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Standard normal (c = z, n, or N): no extra arguments
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g or G): shape; scale
            </para>
	  </li>
	  <li>
            <para>
              Student's t (t): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x, or X): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Snedecor's F (f or F): df (num.); df (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b or B): probability; trials
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p or P): mean
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l or L): mean; scale
            </para>
	  </li>
	  <li>
            <para>
              Standardized GED (E): shape
            </para>
	  </li>
	  <li>
	    <para>
	      Non-central chi square (ncX): df, non-centrality parameter
	    </para>
	  </li>
	  <li>
	    <para>
	      Non-central F (ncF): df (num.), df (den.),
	      non-centrality parameter
	    </para>
	  </li>
	  <li>
	    <para>
	      Non-central t (nct): df, non-centrality parameter
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribution} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Standard normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
	  -- &amp; --  &amp; -- \\
	  Gamma &amp; \texttt{g} or \texttt{G} &amp;
	  shape &amp; scale  &amp; -- \\
	  Student's $t$ (central) &amp; \texttt{t} &amp;
	  degrees of freedom &amp; --  &amp; -- \\
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp;
	  degrees of freedom &amp; --  &amp; -- \\
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp;
	  df (num.) &amp; df (den.)  &amp; -- \\
	  Binomial &amp; \texttt{b} or \texttt{B} &amp;
	  $p$ &amp; $n$  &amp; -- \\
	  Poisson &amp; \texttt{p} or \texttt{P} &amp;
          $\lambda$ &amp; --  &amp; -- \\
	  Laplace &amp; \texttt{l} or \texttt{L} &amp;
          mean &amp; scale  &amp; -- \\
	  Standardized GED &amp; \texttt{E} &amp; shape &amp; --
	  &amp; -- \\
	  Non-central $\chi^2$ &amp; \texttt{ncX} &amp;
	  df &amp; non-centrality &amp; -- \\
	  Non-central $F$ &amp; \texttt{ncF} &amp;
	  df (num.) &amp; df (den.) &amp; non-centrality \\
	  Non-central $t$ &amp; \texttt{nct} &amp;
	  df &amp; non-centrality &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="critical"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse Mills ratio at <argname>x</argname>, that is
	  the ratio between the standard normal density and the complement
	  to the standard normal distribution function, both evaluated at
	  <argname>x</argname>.
	</para>
	<para>
	  This function uses a dedicated algorithm which yields greater
	  accuracy compared to calculation using <fncref targ="dnorm"/>
	  and <fncref targ="cnorm"/>, but the difference between the two
	  methods is appreciable only for very large negative values of
	  <argname>x</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
	<fnarg optional="true" type="scalarref">&amp;logdet</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse of the symmetric, positive definite matrix
	  <argname>A</argname>.   This function is slightly faster than
	  <fncref targ="inv"/> for large matrices, since no check for
	  symmetry is performed; for that reason it should be used with
	  care.
	</para>
	<para>
	  If the optional argument <argname>&amp;logdet</argname> is
	  present, the corresponding scalar will contain on successful
	  exit the log determinant of <argname>A</argname>. This may
	  be convenient to have in some cases, for example in the
	  context of the evaluation of a Gaussian log-likelihood,
	  because the log determinant is a by-product of the inversion
	  algorithm and retrieving it via the
	  <argname>&amp;logdet</argname> argument avoids extra
	  computations.
	</para>
	<para>
	  Note: if you're interested in the inversion of a matrix of
	  the form <math>X'X</math>, where <math>X</math> is a large
	  matrix, it is preferable to compute it via the prime
	  operator <lit>X'X</lit> rather than using the more general
	  syntax <lit>X'*X</lit>. The former expression uses a
	  specialized algorithm which has the double advantage of
	  being more efficient computationally and of ensuring that
	  the result will be free by construction of machine precision
	  artifacts that may render it numerically non-symmetric.
	</para>
      </description>
    </function>

    <function name="irf" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="pscalar" optional="true">alpha</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Provides estimated impulse response functions pertaining to
	  a VAR or VECM, traced out over a certain forecast
	  horizon. Without the final optional argument, this function
	  works only when the last model estimated was a VAR or
	  VECM. Alternatively, information on such a system can be
	  saved as a bundle via the <fncref targ="$system"/> accessor
	  and subsequently passed to <lit>irf</lit>.
	</para>
	<para>
	  The <argname>target</argname> and <argname>shock</argname>
	  arguments take the form of 1-based indices of the endogenous
	  variables in the system, with 0 taken to mean
	  <quote>all</quote>. The responses (expressed in the units of
	  the <argname>target</argname> variable) are to an innovation
	  of one standard deviation in the <argname>shock</argname>
	  variable.  If <argname>alpha</argname> is given a suitable
	  positive value the estimates include a 1 &minus; &agr;
	  confidence interval (so, for example, give 0.1 for a 90
	  percent interval).
	</para>
	<para>
	  The following code fragment illustrates usage. In the first
	  example the matrix <lit>ir1</lit> holds the responses of
	  <lit>y1</lit> to innovations in each of <lit>y1</lit>,
	  <lit>y2</lit> and <lit>y3</lit> (point estimates only since
	  <argname>alpha</argname> is omitted).  In the second,
	  <lit>ir2</lit> holds the responses of all targets to an
	  innovation in <lit>y2</lit>, with 90 percent confidence
	  intervals. In this case the returned matrix will have 9
	  columns: each response path occupies 3 adjacent columns
	  giving point estimate, lower bound and upper bound.  The
	  last example produces a matrix with 27 columns: 3 per
	  response for each target times each shock.
	</para>
	<code>
	  var 4 y1 y2 y3
	  matrix ir1 = irf(1, 0)
	  matrix ir2 = irf(0, 2, 0.1)
	  matrix ir3 = irf(0, 0, 0.1)
	</code>
	<para>
	  The number of periods (rows) over which the response is
	  traced is determined automatically based on the frequency
	  of the data, but this can be overridden via the <cmdref
	  targ="set"/> command, as in <lit>set horizon 10</lit>.
	</para>
	<para>
	  When confidence intervals are produced they are derived via
	  bootstrapping, with resampling of the original residuals.
	  It is assumed that the lag order of the VAR or VECM is
	  sufficient to eliminate serial correlation of the
	  residuals. By default the number of bootstrap replications
	  is 1999, but that can be adjusted via <cmdref targ="set"/>,
	  as in
	</para>
	<code>
	  set boot_iters 2999
	</code>
	<para>
	  <seelist>
	    <fncref targ="fevd"/>
	    <fncref targ="vma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the Internal Rate of Return for <argname>x</argname>,
	  considered as a sequence of payments (negative) and receipts
	  (positive).
	  <seelist>
            <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iscomplex" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Tests whether <argname>name</argname> is the identifier for
	  a complex matrix. The return value is one of the following:
	</para>
	<para>
	  <lit>NA</lit>: <argname>name</argname> does not identify a
	  matrix.
	</para>
	<para>
	  <lit>0</lit>: <argname>name</argname> identifies a real
	  matrix, composed entirely of regular floating-point numbers
	  (<quote>doubles</quote>, in C parlance).
	</para>
	<para>
	  <lit>1</lit>: <argname>name</argname> identifies a
	  <quote>nominally</quote> complex matrix, composed of numbers
	  with both a real and an imaginary part, but in which all
	  imaginary parts are zero.
	</para>
	<para>
	  <lit>2</lit>: the matrix in question holds at least one
	  <quote>genuinely</quote> complex value, with a non-zero
	  imaginary part.
	</para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">panel-code</fnarg>
      </fnargs>
      <description>
	<para>
	  Without the optional second argument, returns 1 if
	  <argname>y</argname> has a constant value over the current
	  sample range (or over its entire length if
	  <argname>y</argname> is a vector), otherwise 0.
	</para>
	<para>
	  The second argument is accepted only if the current dataset
	  is a panel and <argname>y</argname> is a series.  In that
	  case a <argname>panel-code</argname> value of 0 calls for a
	  check for time-invariance, while a value of 1 means check
	  for cross-sectional invariance (that is, in each time period
	  the value of <argname>y</argname> is the same for all
	  groups).
	</para>
	<para>
	  If <argname>y</argname> is a series, missing values are
	  ignored in checking for constancy.
	</para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>name</argname> is the identifier for a currently
	  defined series, returns 1 if the series is marked as
	  discrete-valued, otherwise 0. If <argname>name</argname>
	  does not identify a series, returns <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If all the values contained in <argname>x</argname> are 0 or
	  1 (or missing), returns the number of ones, otherwise 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a scalar argument, returns 1 if <argname>x</argname>
	  is <quote>Not a Number</quote> (NaN), otherwise 0. Given a
	  matrix argument, returns a matrix of the same dimensions
	  with 1s in positions where the corresponding element of the
	  input is NaN and 0s elsewhere.
	</para>
      </description>
    </function>

    <function name="isoconv" section="calendar" output="int">
      <fnargs>
	<fnarg type="series">date</fnarg>
	<fnarg type="seriesref">&amp;year</fnarg>
	<fnarg type="seriesref">&amp;month</fnarg>
	<fnarg type="seriesref" optional="true">&amp;day</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a series <argname>date</argname> holding dates in
	  ISO 8601 <quote>basic</quote> format (<lit>YYYYMMDD</lit>),
	  this function writes the year, month and (optionally)
	  day components into the series named by the second and
	  subsequent arguments. An example call, assuming the
	  series <lit>dates</lit> contains suitable 8-digit values:
	</para>
	<code>
	  series y, m, d
	  isoconv(dates, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  The nominal return value is 0 on successful completion;
	  in case of failure an error is flagged.
	</para>
      </description>
    </function>

    <function name="isocountry" section="strings" output="asinput">
      <fnargs>
	<fnarg type="string-or-strings">source</fnarg>
	<fnarg type="int" optional="true">output</fnarg>
      </fnargs>
      <description>
	<para>
	  This function maps between the four designations for
	  countries present in ISO 3166, namely
	</para>
	<nlist>
	  <li><para>
	    Country name
	  </para></li>
	  <li><para>
	    Alpha-2 code (two uppercase letters)
	  </para></li>
	  <li><para>
	    Alpha-3 code (three uppercase letters)
	  </para></li>
	  <li><para>
	    Numeric code (3 digits)
	  </para></li>
	</nlist>
	<para>
	  Given a country's designation in one form, the return value
	  is its designation in the form (1 to 4) selected by the
	  optional <argname>output</argname> argument or, if this
	  argument is omitted, a default conversion as follows: when
	  <argname>source</argname> is a country name the return value
	  is the country's 2-letter code; otherwise the return value
	  is the country name. Various valid calls are illustrated
	  below in interactive form.
	</para>
	<code>
	  ? eval isocountry("Bolivia")
	  BO
	  ? eval isocountry("Bolivia", 3)
	  BOL
	  ? eval isocountry("GB")
	  United Kingdom of Great Britain and Northern Ireland
	  ? eval isocountry("GB", 3)
	  GBR
	  ? strings S = defarray("ES", "DE", "SD")
	  ? strings C = isocountry(S)
	  ? print C
	  Array of strings, length 3
	  [1] "Spain"
	  [2] "Germany"
	  [3] "Sudan"
	  ? matrix m = {4, 840}
	  ? C = isocountry(m)
	  ? print C
	  Array of strings, length 2
	  [1] "Afghanistan"
	  [2] "United States of America"
	</code>
	<para>
	  When <argname>source</argname> is in form 4 (numeric code)
	  this can be given as a string or array of strings (for
	  example, <quote>032</quote> for Argentina) or in numeric
	  form. In the latter case <argname>source</argname> may be
	  given as a series or vector, though an error will be flagged
	  if any of the numbers are out of the range 0 to 999.
	</para>
	<para>
	  In all cases (even when output form 4 is selected) a string,
	  or array of strings, is returned; if numeric values are
	  required these may be obtained using <fncref targ="atof"/>.
	  If <argname>source</argname> is not matched by any entry in
	  the ISO 3166 table the return value is an empty string, in
	  which case a warning is printed.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>ed</argname> is interpreted as an
	  epoch day, which equals 1 for the first of January in the
	  year 1 AD on the proleptic Gregorian calendar. The default
	  return value (of the same type as <argname>ed</argname>) is
	  an 8-digit number, or a series of such numbers, on the
	  pattern <lit>YYYYMMDD</lit> (ISO 8601 <quote>basic</quote>
	  format), giving the Gregorian calendar date corresponding to
	  the epoch day.
	</para>
	<para>
          If the optional second argument <argname>as-string</argname>
          is non-zero, the return value is not numeric but rather a
          string on the pattern <lit>YYYY-MM-DD</lit> (ISO 8601
          <quote>extended</quote> format), or a string-valued series
          if <argname>ed</argname> is a series, or an array of strings
          if <argname>ed</argname> is a vector.  For a more flexible
          means of obtaining string representations of epoch days, see
          <fncref targ="strfday"/>.
	</para>
	<para>
	  For the inverse function, see <fncref targ="epochday"/>;
	  also see <fncref targ="juldate"/>.
	</para>
      </description>
    </function>

    <function name="isoweek" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">year</fnarg>
	<fnarg type="scalar-or-series">month</fnarg>
	<fnarg type="scalar-or-series">day</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the ISO 8601 week number corresponding to the
	  date(s) specified by the three arguments, or <lit>NA</lit>
	  if the date is invalid. Note that all three arguments must
	  be of the same type, either scalars (integers) or series.
	</para>
	<para>
	  ISO weeks are numbered from 01 to 53; most years have 52
	  weeks but on average 71 out of 400 years have 53 weeks.  The
	  ISO 8601 definition for week 01 is the week containing the
	  year's first Thursday on the Gregorian calendar. For a full
	  account see
	  <url>https://en.wikipedia.org/wiki/ISO_week_date</url>.
	</para>
	<para>
	  An alternative call is also supported: if a single argument
	  is given, it is taken to be a date (or series of dates) in
	  ISO 8601 <quote>basic</quote> numeric format,
	  <lit>YYYYMMDD</lit>. So the following two calls produce the
	  same result, namely 13.
	</para>
	<code>
	  eval isoweek(2022, 4, 1)
	  eval isoweek(20220401)
	</code>
      </description>
    </function>

    <function name="iwishart" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Given <argname>S</argname> (a positive definite <by r="p"
	  c="p"/> scale matrix), returns a drawing from the Inverse
	  Wishart distribution with <argname>v</argname> degrees of
	  freedom, where <argname>v</argname> must not be smaller than
	  <math>p</math>. The returned matrix is also <by r="p"
	  c="p"/>.  The algorithm of <cite
	  key="odell-feiveson66">Odell and Feiveson (1966)</cite> is
	  used.
	</para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">path</fnarg>
	<fnarg optional="true" type="scalarref">&amp;nread</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>buf</argname> should be a JSON
	  buffer, as may be retrieved from a suitable website via the
	  <fncref targ="curl"/> function, and the
	  <argname>path</argname> argument should be a JsonPath
	  specification.
	</para>
	<para>
	  This function returns a string representing the data found
	  in the buffer at the specified path. Data types of double
	  (floating-point), int (integer) and string are supported. In
	  the case of doubles or ints, their string representation is
	  returned (using the <quote>C</quote> locale for doubles).
	  If the object to which <argname>path</argname> refers is an
	  array, the members are printed one per line in the returned
	  string.
	</para>
	<para>
	  By default an error is flagged if <argname>path</argname> is
	  not matched in the JSON buffer, but this behavior is
	  modified if you pass the third, optional argument: in that
	  case the argument retrieves a count of the matches and an
	  empty string is returned if there are none. Example call:
	</para>
	<code>
	  ngot = 0
	  ret = jsonget(jbuf, "$.some.thing", &amp;ngot)
	</code>
	<para>
	  However, an error is still flagged in case of a malformed
	  query.
	</para>
	<para>
	  An accurate account of JsonPath syntax can be found at
	  <url>http://goessner.net/articles/JsonPath/</url>. However,
	  please note that the back-end for <lit>jsonget</lit> is
	  provided by <lit>json-glib</lit>, which does not necessarily
	  support all elements of JsonPath. Moreover, the exact
	  functionality of <lit>json-glib</lit> may differ depending
	  on the version you have on your system. See
	  <url>https://wiki.gnome.org/Projects/JsonGlib</url> if you
	  need details.
	</para>
	<para>
	  That said, the following operators should be available
	  to <lit>jsonget</lit>:
	</para>
	  <ilist>
	    <li>
              <para>
		root node, via the <lit>$</lit> character
              </para>
	    </li>
	    <li>
              <para>
		recursive descent operator: <lit>..</lit>
              </para>
	    </li>
	    <li>
              <para>
		wildcard operator: <lit>*</lit>
              </para>
	    </li>
	    <li>
              <para>
		subscript operator: <lit>[]</lit>
              </para>
	    </li>
	    <li>
              <para>
		set notation operator, for example <lit>[i,j]</lit>
              </para>
	    </li>
	    <li>
              <para>
		slice operator: <lit>[start:end:step]</lit>
              </para>
	    </li>
	  </ilist>
      </description>
    </function>

    <function name="jsongetb" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string" optional="true">path</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>buf</argname> should be a JSON buffer,
	  as may be retrieved from a suitable website via the <fncref
	  targ="curl"/> function. The specification and effect of the
	  optional <argname>path</argname> argument are described
	  below.
	</para>
	<para>
	  The return value is a bundle whose structure basically
	  mirrors that of the input: JSON objects become gretl bundles
	  and JSON arrays become gretl arrays, each of which can hold
	  strings, bundles or arrays. JSON <quote>value</quote> nodes
	  become either members of bundles or elements of arrays; in
	  the latter case numerical values are converted to strings
	  using <lit>sprintf</lit>. Note that although the JSON
	  specification allows arrays of mixed type these cannot be
	  handled by <lit>jsongetb</lit> since gretl arrays must
	  be of a single type.
	</para>
	<para>
	  The <argname>path</argname> argument can be used to limit
	  the JSON elements included in the returned bundle.  This is
	  not a <quote>JsonPath</quote> as described in the help for
	  <fncref targ="jsonget"/>; it is a simple construct subject
	  to the following specification.
	</para>
	<ilist>
	  <li>
	    <para>
	      <argname>path</argname> is a slash-separated array of
	      elements where slash (<quote>/</quote>) indicates moving
	      to one level <quote>deeper</quote> in the JSON tree
	      represented by <argname>buf</argname>. A leading slash
	      is allowed but not required; implicitly the path always
	      starts at the root. No extraneous white-space characters
	      should be included.
	    </para>
	  </li>
	  <li>
	    <para>
	      Each slash-separated element must take one of the
	      following forms: (a) a single name, in which case only a
	      JSON element whose name matches at the given structural
	      level will be included; or (b) <quote>*</quote>
	      (asterisk), in which case all elements at the given
	      level are included; or (c) an array of comma-separated
	      names, enclosed in braces (<quote>{</quote> and
	      <quote>}</quote>), in which case only JSON elements
	      whose names match one of the given names will be
	      included.
	    </para>
	  </li>
	</ilist>
	<para>
	  See also the string-oriented <fncref targ="jsonget"/>;
	  depending on your purpose one of these functions may be more
	  helpful than the other.
	</para>
      </description>
    </function>

    <function name="juldate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
          This function works just like <fncref targ="isodate"/>
          except that on output the dates are relative to the
          Julian calendar rather than the Gregorian.
        </para>
      </description>
    </function>

    <function name="kdensity" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-list-or-mat">x</fnarg>
	<fnarg type="scalar" optional="true">scale</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a kernel density estimate (or set of estimates) for
	  the argument <argname>x</argname>, which may be a single
	  series or vector or a list or matrix with more than
	  column. The returned matrix has <math>k</math> + 1 columns,
	  where <math>k</math> is the number of elements (series or
	  columns) in <argname>x</argname>. The first column holds a
	  set of evenly spaced abscissae and the rest hold the
	  estimated density or densities at each of these points.
	</para>
	<para>
	  The formula used to compute the estimated density at each
	  reference point, <math>x</math>, is
	  <equation status="display"
             tex="\[f(x)=(1/nh) \sum_{t-1}^{n} k\left((x-x_t)/h\right)\]"
             ascii="f(x) = (1/nh) sum(t=1 to n) k((x - x(t)) / h)"
             graphic="kernel1"/>
	  where <math>n</math> denotes the number of data
	  points, <math>h</math> is a <quote>bandwidth</quote>
	  parameter, and <math>k</math>() is the kernel function.
	  The larger the value of the bandwidth parameter, the smoother
	  the estimated density.
	</para>
	<para>
	  The optional <argname>scale</argname> parameter can be used
	  to adjust the bandwidth relative to the default of 1.0,
	  which corresponds to the rule of thumb proposed by <cite
	  key="silverman86">Silverman (1986)</cite>, namely
	  <equation status="display"
	     tex="\[h=0.9 {\rm min}(s, {\rm IQR}/1.349) n^{-1/5}\]"
	     ascii="h = 0.9 min(s, IQR/1.349) n^{-1/5}"
	     graphic="kernel2"/>
	  where <math>s</math> denotes the standard deviation of the
	  data and IQR is the inter-quartile range.  The
	  <argname>control</argname> parameter acts as a boolean: 0
	  (the default) means that the Gaussian kernel is used; a
	  non-zero value switches to the Epanechnikov kernel.
	</para>
	<para>
	  A plot of the results may be obtained using the <cmdref
	  targ="gnuplot"/> command, as illustrated below. Note that
	  the column containing the abscissae should come last for
	  plotting.
	</para>
	<code>
	  matrix d = kdensity(x)
	  # if x has a single element
	  gnuplot 2 1 --matrix=d --with-lines --fit=none
	  # if x has two elements
	  gnuplot 2 3 1 --matrix=d --with-lines --fit=none
	</code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs disturbance smoothing for a Kalman bundle
	  previously set up by means of <fncref targ="ksetup"/> and
	  returns 0 on successful completion or non-zero if numerical
	  problems are encountered. The return value should be checked
	  before making using of results.
	</para>
	<para>
	  On successful completion, the smoothed disturbances will be
	  available as <lit>kb.smdist</lit>.
	</para>
	<para>
	  The optional <argname>MSE</argname> argument determines the
	  contents of the <lit>kb.smdisterr</lit> key. If 0 or
	  omitted, this matrix will contain the unconditional standard
	  errors of the smoothed disturbances, which are normally used
	  to compute the so-called <emphasis>auxiliary
	  residuals</emphasis>. Otherwise, <lit>kb.smdisterr</lit>
	  will contain the estimated root mean square deviations of
	  the auxiliary residuals from their true value.
	</para>
	<para>
	  For more details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a forward, filtering pass on a Kalman bundle
	  previously set up by means of <fncref targ="ksetup"/>
	  and returns 0 on successful completion or 1 if numerical
	  problems are encountered.
	</para>
	<para>
	  On successful completion, the one-step-ahead prediction
	  errors will be available as <lit>kb.prederr</lit> and the
	  sequence of their covariance matrices as
	  <lit>kb.pevar</lit>. Moreover, the key <lit>kb.llt</lit>
	  gives access to a <math>T</math>-vector containing the
	  log-likelihood by observation.
	</para>
	<para>
	  For more details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kmeier" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a sample of duration data, <argname>d</argname>,
	  possibly accompanied by a record of censoring status,
	  <argname>cens</argname>, computes the Kaplan&ndash;Meier
	  nonparametric estimator of the survival function (<cite
	  key="kaplan-meier">Kaplan and Meier, 1958</cite>). The
	  returned matrix has three columns holding, respectively, the
	  sorted unique values in <argname>d</argname>, the estimated
	  survival function corresponding to the duration value in
	  column 1 and the (large sample) standard error of the
	  estimator, calculated via the method of <cite
	  key="greenwood26">Greenwood (1926)</cite>.
	</para>
	<para>
	  If the <argname>cens</argname> series is given, the value 0
	  is taken to indicate an uncensored observation while a value
	  of 1 indicates a right-censored observation (that is, the
	  period of observation of the individual in question has
	  ended before the duration or spell has been recorded as
	  terminated). If <argname>cens</argname> is not given, it is
	  assumed that all observations are uncensored. (Note: the
	  semantics of <argname>cens</argname> may be extended at some
	  point to cover other types of censoring.)
	</para>
	<para>
	  <seelist>
            <fncref targ="naalen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">trend</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a row vector containing critical values at the 10, 5
	  and 1 percent levels for the KPSS test for stationarity of a
	  time series. <argname>T</argname> should give the number of
	  observations and <argname>trend</argname> should be 1 if
	  the test includes a trend, 0 otherwise.
	</para>
	<para>
	  The critical values given are based on response surfaces
	  estimated in the manner set out by <cite
	  key="sephton95">Sephton (Economics Letters,
	  1995)</cite>. See also the <cmdref targ="kpss"/> command.
 	</para>
      </description>
    </function>

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">Z</fnarg>
	<fnarg type="scalar-or-matrix">T</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">R</fnarg>
      </fnargs>
      <description>
	<para>
	  Sets up a Kalman bundle, that is an object which contains
	  all the information needed to define a linear state space
	  model of the form
	  <equation status="display"
		    tex="\[y_t=Z\alpha_t + u_t\]"
		    ascii="y(t) = Za(t) + u(t)"
		    graphic="kalman1"/>
	  where Var<math>(u) = R</math>, and state
	  transition equation
	  <equation status="display"
		    tex="\[\alpha_{t+1}=T \alpha_t + v_t\]"
		    ascii="a(t+1) = T a(t) + v(t)"
		    graphic="kalman2"/>
	  where Var<math>(v) = Q</math>.
	</para>
	<para>
	  Objects created via this function can be later used via the
	  dedicated functions <fncref targ="kfilter"/> for filtering,
	  <fncref targ="ksmooth"/> and <fncref targ="kdsmooth"/> for
	  smoothing and <fncref targ="ksimul"/> for performing
	  simulations.
	</para>
	<para>
	  The class of models that gretl can handle is in fact much
	  wider than the one implied by the representation above: it
	  is possible to have time-varying models, models with diffuse
	  priors and exogenous variable in the measurement equation
	  and models with cross-correlated innovations. For further
	  details, see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksimul" section="sspace" output="matrix">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="bool" optional="true">extra</fnarg>
      </fnargs>
      <description>
	<para>
	  Uses a Kalman bundle previously set up by means of <fncref
	  targ="ksetup"/> to perform simulation, the disturbances
	  being taken from the matrix <argname>U</argname>. By default
	  the returned matrix (which will have as many rows as
	  <argname>U</argname>) contains simulated values of the
	  observable(s), but if a non-zero value is given for
	  <argname>extra</argname> the simulated state is also
	  included. In the latter case each row holds the state first,
	  then the observable(s).
	</para>
	<para>
	  For details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksmooth" section="sspace" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a fixed-point smoothing (backward) pass on a Kalman
	  bundle previously set up by means of <fncref targ="ksetup"/>
	  and returns 0 on successful completion or non-zero if
	  numerical problems are encountered.  The return value should
	  be checked before making using of results.
	</para>
	<para>
	  On successful completion, the smoothed states will be
	  available as <lit>kb.state</lit> and the sequence of their
	  covariance matrices as <lit>kb.stvar</lit>.  For more
	  details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="ksetup"/>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the excess kurtosis of the series <argname>x</argname>,
	  skipping any missing observations.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list-or-mat">
      <fnargs>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="series-list-or-mat">y</fnarg>
	<fnarg type="bool" optional="true">bylag</fnarg>
      </fnargs>
      <description>
	<para>
	  If the first argument is a scalar, generates lags 1 to
	  <argname>p</argname> of the series <argname>y</argname>, or
	  if <argname>y</argname> is a list, of all series in the
	  list, or if <argname>y</argname> is a matrix, of all columns
	  in the matrix.  If <argname>p</argname> = 0 and
	  <argname>y</argname> is a series or list, the maximum lag
	  defaults to the periodicity of the data; otherwise
	  <argname>p</argname> must be positive.
	</para>
	<para>
	  If a vector is given as the first argument, the lags
	  generated are those specified in the vector. Common usage
	  in this case would be to give <argname>p</argname> as, for
	  example, <lit>seq(3,7)</lit>, hence omitting the first and
	  second lags. However, it is OK to give a vector with gaps,
	  as in <lit>{3,5,7}</lit>, although the lags should always
	  be given in ascending order.
	</para>
	<para>
	  In the case of list output, the generated variables are
	  automatically named according to the template
	  <repl>varname</repl> <lit>_</lit> <repl>i</repl> where
	  <repl>varname</repl> is the name of the original series and
	  <repl>i</repl> is the specific lag.  The original portion of
	  the name is truncated if necessary, and may be adjusted in
	  case of non-uniqueness in the set of names thus constructed.
	</para>
	<para>
	  When <argname>y</argname> is a list, or a matrix with more
	  than one column, and the lag order is greater than 1, the
	  default ordering of the terms in the return value is by
	  variable: all lags of the first input series or column
	  followed by all lags of the second, and so on. The
	  optional third argument can be used to change this: if
	  <argname>bylag</argname> is non-zero then the terms are
	  ordered by lag: lag 1 of all the input series or columns,
	  then lag 2 of all the series or columns, and so on.
	</para>
	<para>
	  See also <fncref targ="mlag"/> for use with matrices.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">insample</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the 1-based index of the last non-missing
	  observation for the series <argname>y</argname>. By default
	  the whole data range is examined, so if subsampling is in
	  effect the value returned may be larger than the accessor
	  <fncref targ="$t2"/>. But if a non-zero value is given for
	  <argname>insample</argname> only the current sample range is
	  considered.
	  <seelist>
            <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the natural log of the determinant of
	  <math>A</math>, computed via the LU factorization. Note that
	  this is more efficient than calling <fncref targ="det"/> and
	  taking the log of the result. Moreover, in some cases
	  <lit>ldet</lit> is able to return a valid result even if the
	  determinant of <math>A</math> is numerically
	  <quote>infinite</quote> (exceeds the C library's maximum
	  double-precision number).
	  <seelist>
            <fncref targ="rcond"/>
	    <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes log differences; starting values are set to
	  <lit>NA</lit>.
	</para>
	<para>
	  When a list is returned, the individual variables are
	  automatically named according to the template
	  <lit>ld_</lit><repl>varname</repl> where
	  <repl>varname</repl> is the name of the original series.
	  The name is truncated if necessary, and may be adjusted in
	  case of non-uniqueness in the set of names thus constructed.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a new series as a linear combination of the series in the
	  list <argname>L</argname>.  The coefficients are given by the vector
	  <argname>b</argname>, which must have length equal to the number of
	  series in <argname>L</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="linearize" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Depends on having TRAMO installed. Returns a
	  <quote>linearized</quote> version of the input series; that
	  is, a series in which any missing values are replaced by
	  interpolated values and outliers are adjusted. TRAMO's fully
	  automatic mechanism is used; consult the TRAMO documentation
	  for details.
	</para>
	<para>
	  Note that if the input series has no missing values and no
	  values that TRAMO regards as outliers, this function will
	  return a copy of the original series.
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the Ljung&ndash;Box Q' statistic for the series
	  <argname>y</argname> using lag order <argname>p</argname>,
	  over the currently defined sample range.  The lag order must
	  be greater than or equal to 1 and less than the number of
	  available observations.
	</para>
	<para>
	  This statistic may be referred to the chi-square
	  distribution with <argname>p</argname> degrees of freedom as
	  a test of the null hypothesis that the series
	  <argname>y</argname> is not serially correlated.
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the log of the gamma function of <argname>x</argname>.
	</para>
	<para>
	  See also <fncref targ="bincoeff"/> and <fncref targ="gammafun"/>.
	</para>
      </description>
    </function>

    <function name="loess" section="nonparam" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robust</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs locally-weighted polynomial regression and returns
	  a series holding predicted values of <argname>y</argname>
	  for each non-missing value of <argname>x</argname>.  The
	  method is as described by <cite key="cleveland79">William
	  Cleveland (1979)</cite>.
	</para>
	<para>
	  The optional arguments <argname>d</argname> and
	  <argname>q</argname> specify the order of the polynomial in
	  <argname>x</argname> and the proportion of the data points
	  to be used in local estimation, respectively.  The default
	  values are <argname>d</argname> = 1 and <argname>q</argname>
	  = 0.5. The other acceptable values for <argname>d</argname>
	  are 0 and 2. Setting <argname>d</argname> = 0 reduces the
	  local regression to a form of moving average. The value
	  of <argname>q</argname> must be greater than 0 and cannot
	  exceed 1; larger values produce a smoother outcome.
	</para>
	<para>
	  If a non-zero value is given for the <argname>robust</argname>
	  argument the local regressions are iterated twice, with the
	  weights being modified based on the residuals from the previous
	  iteration so as to give less influence to outliers.
	</para>
	<para>
	  See also <fncref targ="nadarwat"/>, and in addition see
	  <guideref targ="chap:nonparam"/> for details on
	  nonparametric methods.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the natural logarithm of <argname>x</argname>; produces
	  <lit>NA</lit> for non-positive values. Note: <lit>ln</lit> is an
	  acceptable alias for <lit>log</lit>.
	</para>
	<para>
	  When a list is returned, the individual variables are
	  automatically named according to the template
	  <lit>l_</lit><repl>varname</repl> where <repl>varname</repl>
	  is the name of the original series.  The name is truncated
	  if necessary, and may be adjusted in case of non-uniqueness
	  in the set of names thus constructed.
	</para>
	<para>
	  Note that in case of matrix input the function acts element
	  by element. For the matrix logarithm function, see <fncref
	  targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the base-10 logarithm of <argname>x</argname>; produces
	  <lit>NA</lit> for non-positive values.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the base-2 logarithm of <argname>x</argname>; produces
	  <lit>NA</lit> for non-positive values.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Returns the logistic CDF of the argument <argname>x</argname>,
	  that is, $\Lambda(x) = 1/(1+e^{-x})$. If <argname>x</argname> is a
	  matrix, the function is applied element by element.
	</para>
	<para context="notex">
	  Returns the logistic CDF of the argument
	  <argname>x</argname>, that is, 1/(1 +
	  <math>e</math><sup>&minus;x</sup>).  If <argname>x</argname>
	  is a matrix, the function is applied element by element.
	</para>
      </description>
    </function>

    <function name="lpsolve" section="math" output="bundle">
      <fnargs>
	<fnarg type="bundle">specs</fnarg>
      </fnargs>
      <description>
	<para>
	  Solves a linear programming problem using the lpsolve
	  library. See <doc>gretl-lpsolve.pdf</doc> for
	  details and examples of usage.
	</para>
      </description>
    </function>

    <function name="lower" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns an <by r="n" c="n"/> lower triangular matrix: the elements
	  on and below the diagonal are equal to the corresponding elements of
	  <argname>A</argname>; the remaining elements are zero.
	</para>
	<para context="tex">
	  Returns an $n\times n$ lower triangular matrix <math>B</math>
	  for which $B_{ij} = A_{ij}$ if $i \ge j$, and 0 otherwise.
	</para>
	<para>
	  <seelist>
            <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrcovar" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="bool" optional="true">demean</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the long-run variance-covariance matrix of the
	  columns of <argname>A</argname>. The data are first demeaned
	  unless the second (optional) argument is set to zero.  The
	  kernel type and lag truncation parameter (window size) can
	  be chosen before calling this function with the HAC-related
	  options that the <cmdref targ="set"/> command offers, such
	  as <lit>hac_kernel</lit>, <lit>hac_lag</lit>,
	  <lit>hac_prewhiten</lit>. See also the section on Time
	  series data and HAC covariance matrices in <guideref
	  targ="chap:robust_vcv"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="lrvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrvar" section="timeseries" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
	<fnarg type="scalar" optional="true">mu</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the long-run variance of <argname>y</argname>,
	  calculated using a Bartlett kernel with window size
	  <argname>k</argname>. If the second argument is omitted, or
	  given a negative value, the window size defaults to
	  the integer part of the cube root of the sample size.
	</para>
	<para context="tex">
	  In formulae:
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \mu) (y_{t-i} - \bar{Y})
	  \right] \]
	  with
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
	<para>
	  For the variance calculation, the series
	  <argname>y</argname> is centered around the optional
	  parameter <argname>mu</argname>; if this is omitted or
	  <lit>NA</lit>, the sample mean is used.
	</para>
	<para>
	  For a multivariate counterpart, see <fncref targ="lrcovar"/>.
	</para>
      </description>
    </function>

    <function name="Lsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">L</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Solves for <math>x</math> in <math>AX = B</math>, where
	  <argname>L</argname> is the lower triangular Cholesky factor
	  of the positive definite matrix <math>A</math>, satisfying
	  <math>LL' = A</math>. Suitable <argname>L</argname> can be
	  obtained using the <fncref targ="cholesky"/> function with
	  <math>A</math> as argument.
	</para>
	<para>
	  The following two calculations should produce the same
	  result (up to machine precision), but the first variant
	  allows for reuse of a precomputed Cholesky factor and so
	  should be substantially faster if you are solving repeatedly
	  for given <math>A</math> and several values of
	  <math>B</math>. The speed-up will be greater, the greater
	  the dimension of <math>A</math>.
	</para>
	<code>
	  # variant 1
	  matrix L = cholesky(A)
	  matrix X = Lsolve(L, B)
	  # variant 2
	  matrix X = A \ B
	</code>
      </description>
    </function>

    <function name="mat2list" section="data-utils" output="list">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="string">prefix</fnarg>
      </fnargs>
      <description>
	<para>
	  A convenience function for making a list of series using the
	  columns of a suitable matrix as input. The row dimension of
	  <argname>X</argname> must equal either the length of the
	  current dataset or the number of observations in the current
	  sample range.
	</para>
	<para>
	  The naming of the series in the returned list proceeds as
	  follows. First, if the optional <argname>prefix</argname>
	  argument is supplied, the series created from column
	  <math>i</math> of <argname>X</argname> is named by appending
	  <math>i</math> to the given string, as in
	  <lit>myprefix1</lit>, <lit>myprefix2</lit> and so on.
	  Otherwise, if <argname>X</argname> has column names set (see
	  <fncref targ="cnameset"/>) these names are used.  Finally,
	  if neither of the above conditions is satisfied, the names
	  are <lit>column1</lit>, <lit>column2</lit> and so on. Note
	  that this policy may result in overwriting existing series;
	  if you don't want that to happen, take charge of naming the
	  columns explicitly via <lit>cnameset</lit>, or supply
	  <argname>prefix</argname>.
	</para>
	<para>
	  Here is an illustrative example of usage:
	</para>
	<code>
	  matrix X = mnormal($nobs, 8)
	  list L = mat2list(X, "xnorm")
	  # or alternatively, if you don't need X as such
	  list L = mat2list(mnormal($nobs, 8), "xnorm")
	</code>
	<para>
	  This will add to the dataset eight full-length series named
	  <lit>xnorm1</lit>, <lit>xnorm2</lit> and so on.
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="depends">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
        <fnarg optional="true" type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
          This function has two primary modes plus a special case.
        </para>
        <para>
          The first mode is activated if a single argument of type
          scalar, series or matrix is given: the return value is a
          scalar, the maximum valid value <quote>within</quote> the
          argument: if <argname>x</argname> is a series, its maximum
          value within the current sample range, or if
          <argname>x</argname> is a matrix, its greatest element,
          missing values being ignored. The case of a scalar argument is
          supported for the sake of completeness; you just get its value
          back.
        </para>
        <para>
          The second mode is activated if two arguments are given. The
          arguments <argname>x</argname> and <argname>y</argname> must
          be of the same type, and must be scalars, series or matrices
          (and if they are matrices, they must be of the same
          dimensions). The return value is an object of the same type as
          the arguments, holding the <quote>between</quote> or
          <quote>cross</quote> maximum or maxima. If the arguments are
          scalars you get the greater of the two; if they're series you
          get a series holding the greater of the values of the two
          series at each observation in the current sample range; if
          they're matrices you get a matrix holding the greater of their
          elements in each row and column. For each of the pairwise
          comparisons if either term is missing the result is also a
          missing value.
        </para>
        <subhead>The special case</subhead>
        <para>
          This arises if a single list argument is given. The return
          value is a series, containing at each observation in the
          current sample range the greatest of the values of the series
          in the list at that observation.
        </para>
	<para>
	  <seelist>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a row vector containing the maxima of the columns of
	  <argname>X</argname>. For columns containing <lit>NA</lit>s
	  the result is also set to <lit>NA</lit>, unless the optional
	  argument <argname>skip_na</argname> is nonzero, in which
	  case the maximum valid entry will be returned.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a column vector containing the maxima of the rows of
	  <argname>X</argname>. For rows containing <lit>NA</lit>s
	  the result is also set to <lit>NA</lit>, unless the optional
	  argument <argname>skip_na</argname> is nonzero, in which
	  case the maximum valid entry will be returned.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a (Pearson) correlation matrix treating each column
	  of <argname>X</argname> as a variable.
	</para>
	<para>
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int" optional="true">dfcorr</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a covariance matrix treating each column of
	  <argname>X</argname> as a variable. The divisor is
	  <math>n</math> &minus; 1, where <math>n</math> is the number
	  of rows of <argname>X</argname>, unless the optional second
	  argument is supplied, in which case <math>n</math> &minus;
	  <argname>dfcorr</argname> is used.
	</para>
	<para>
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the matrix covariogram for a <by r="T" c="k"/> matrix
	  <argname>X</argname> (typically containing regressors), an
	  (optional) <math>T
	  </math>-vector <argname>u</argname> (typically
	  containing residuals), an (optional) (<math>p</math>+1)-vector
	  of weights <argname>w</argname>, and a lag order
	  <argname>p</argname>, which must be greater than or equal to 0.
	</para>
	<para context="tex">
	  The returned matrix is given by
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t u_t
	  u_{t-j} X_{t-j}')\]
	</para>
	<para context="notex">
	  The returned matrix is the sum for <math>j</math> from
	  <math>-p</math> to <math>p</math> of <math>w(|j|) *
	  X(t)X(t-j)' * u(t)u(t-j)</math>, where <math>X(t)'</math> is
	  the <math>t</math>-th row of <argname>X</argname>.
	</para>
	<para>
	  If <argname>u</argname> is given as <lit>null</lit> the
	  <math>u</math> terms are omitted, and if
	  <argname>w</argname> is given as <lit>null</lit> all the
	  weights are taken to be 1.0.
	</para>
	<para>
	  For example, the following piece of code
	</para>
	<code>
	  set seed 123
	  X = mnormal(6,2)
	  Lag = mlag(X,1)
	  Lead = mlag(X,-1)
	  print X Lag Lead
	  eval X'X
	  eval mcovg(X, , , 0)
	  eval X'(X + Lag + Lead)
	  eval mcovg(X, , , 1)
	</code>
	<para>
	  produces this output:
	</para>
	<code>
	  ? print X Lag Lead
	  X (6 x 2)

	    -0.76587      -1.0600
	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498
	     0.28855     -0.55251

	  Lag (6 x 2)

	      0.0000       0.0000
	    -0.76587      -1.0600
	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498

	  Lead (6 x 2)

	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498
	     0.28855     -0.55251
	      0.0000       0.0000

	  ? eval X'X
	      1.8295       1.4201
	      1.4201       8.7596

	  ? eval mcovg(X,,, 0)
	      1.8295       1.4201
	      1.4201       8.7596

	  ? eval X'(X + Lag + Lead)
	      3.0585       2.5603
	      2.5603       10.004

	  ? eval mcovg(X,,, 1)
	      3.0585       2.5603
	      2.5603       10.004
	</code>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar)
	  sample mean, skipping any missing observations.
	</para>
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  mean of the values of the variables in the list at
	  observation <math>t</math>. By default the mean is recorded
	  as <lit>NA</lit> if there are any missing values at
	  <math>t</math>, but if you pass a non-zero value for
	  <argname>partial</argname> any non-missing values will be
	  used to form the statistic.
	</para>
	<para>
	  The following example illustrates the working of the function
	</para>
	<code>
		open denmark.gdt
		eval mean(LRM)
		list L = dataset
		eval mean(L)
	</code>
	<para>
	  The first call will return the scalar mean value (scalar) of the
	  series <lit>LRM</lit>, and the second one returns a
	  series.
	</para>
	<para>
	  <seelist>
            <fncref targ="median"/>
            <fncref targ="sum"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
            <fncref targ="sd"/>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the means of the columns of <argname>X</argname>.
	  If a non-zero value is given for the optional second
	  argument missing values are ignored, otherwise the result is
	  <lit>NA</lit> for any columns that contain missing values.
	</para>
	<para>
	  For example, the following piece of code
	</para>
	<code>
		matrix m = mnormal(5, 2)
		m[1,2] = NA
		print m
		eval meanc(m)
	</code>
	<para>
	  produces this output:
	</para>
	<code>
		? print m
		m (5 x 2)

	   -0.098299          nan
	      1.1829      -1.2817
	     0.46037     -0.92947
	      1.4896     -0.91970
	     0.91918      0.47748

		? eval meanc(m)
	     0.79075          nan
	</code>
	<para>
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
            <fncref targ="maxc"/>
            <fncref targ="minc"/>
            <fncref targ="sdc"/>
            <fncref targ="prodc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the means of the rows of <argname>X</argname>.  If a
	  non-zero value is given for the optional second argument
	  missing values are ignored, otherwise the result is
	  <lit>NA</lit> for any rows that contain missing values.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar)
	  sample median, skipping any missing observations.
	</para>
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  median of the values of the variables in the list at
	  observation <math>t</math>, or <lit>NA</lit> if there are
	  any missing values at <math>t</math>.
	</para>
	<para>
	  The following example illustrates the working of the function
	</para>
	<code>
	  set verbose off
	  open denmark.gdt
	  eval median(LRM)
	  list L = dataset
	  series m = median(L)
	</code>
	<para>
	  The first call will return the scalar median value (scalar)
	  of the series <lit>LRM</lit>, and the second one returns a
	  series.
	</para>
	<para>
	  <seelist>
            <fncref targ="mean"/>
            <fncref targ="sum"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
            <fncref targ="sd"/>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the matrix exponential of <argname>A</argname>.  If
	  <argname>A</argname> is a real matrix, algorithm 11.3.1 from
	  <cite key="golub96">Golub and Van Loan (1996)</cite> is
	  used. If <argname>A</argname> is complex the algorithm uses
	  eigendecomposition and <argname>A</argname> must be
	  diagonalizable.
	</para>
	<para context="tex">
	  Computes the matrix exponential,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\]
	  (This series is sure to converge.) If <argname>A</argname>
	  is a real matrix algorithm used is 11.3.1 from <cite
	  key="golub96">Golub and Van Loan (1996)</cite> is used. If
	  <argname>A</argname> is complex the algorithm uses
	  eigendecomposition and <argname>A</argname> must be
	  diagonalizable.
	</para>
	<para>
	  See also <fncref targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="mgradient" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">type</fnarg>
      </fnargs>
      <description>
	<para>
	  Analytical derivatives for MIDAS weights.  Let
	  <math>k</math> denote the number of elements in the vector
	  of hyper-parameters, <repl>theta</repl>.  This function
	  returns a <by r="p" c="k"/> matrix holding the gradient of
	  the vector of weights (as calculated by <fncref
	  targ="mweights"/>) with respect to the elements of
	  <repl>theta</repl>. The first argument represents the
	  desired lag order and the last argument specifies the type
	  of parameterization.  See <lit>mweights</lit> for an account
	  of the acceptable <repl>type</repl> values.
	</para>
	<para>
	  <seelist>
	    <fncref targ="midasmult"/>
	    <fncref targ="mlincomb"/>
            <fncref targ="mweights"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="midasmult" section="midas" output="matrix">
      <fnargs>
	<fnarg type="bundle">mod</fnarg>
	<fnarg type="bool">cumulate</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes MIDAS multipliers.  The <argname>mod</argname>
	  argument must be a bundle containing a MIDAS model, as the
	  one produced by the <cmdref targ="midasreg"/> command and
	  accessible via the <fncref targ="$model"/> keyword. The
	  function returns a matrix with the implicit MIDAS
	  multipliers for variable <argname>v</argname> in its first
	  column and the corresponding standard errors in the second
	  one. If the <argname>cumulate</argname> argument is nonzero,
	  the multipliers are cumulated.
	</para>
	<para>
	  Note that the returned matrix is automatically endowed with
	  appropriate row labels, so it is suitable to be used as the
	  first argument to the <cmdref targ="modprint"/> command. For
	  example, the code
	</para>
	<code>
	  open gdp_midas.gdt
	  list dIP = ld_indpro*
	  smpl 1985:1 ;
	  midasreg ld_qgdp 0 ; mds(dIP, 0, 6, 2)
	  matrix ip_m = midasmult($model, 0, 1)
	  modprint ip_m
	</code>
	<para>
	  produces the following output:
	</para>
	<code>
             coefficient   std. error      z       p-value
  ---------------------------------------------------------
  dIP_0      0.343146      0.0957752     3.583     0.0003   ***
  dIP_1      0.402547      0.0834904     4.821     1.43e-06 ***
  dIP_2      0.176437      0.0673776     2.619     0.0088   ***
  dIP_3      0.0601876     0.0621927     0.9678    0.3332
  dIP_4      0.0131263     0.0259137     0.5065    0.6125
  dIP_5      0.000965260   0.00346703    0.2784    0.7807
  dIP_6      0.00000       0.00000      NA        NA
	</code>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
            <fncref targ="mweights"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="depends">
      <fnargs>
        <fnarg type="anyfloat">x</fnarg>
        <fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
          Please see the help for <fncref targ="max"/>; this function
          works in exactly the same way except that it returns a
          minimum or minima.
	</para>
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the minima of the columns of
	  <argname>X</argname>. For columns containing <lit>NA</lit>s
	  the result is also set to <lit>NA</lit>, unless the optional
	  argument <argname>skip_na</argname> is nonzero, in which
	  case the minimum valid entry will be returned.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the minima of the rows of <argname>X</argname>. For
	  rows containing <lit>NA</lit>s the result is also set to
	  <lit>NA</lit>, unless the optional argument
	  <argname>skip_na</argname> is nonzero, in which case the
	  minimum valid entry will be returned.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a binary variable holding 1 if <argname>x</argname> is
	  <lit>NA</lit>. If <argname>x</argname> is a series, the comparison
	  is done element by element; if <argname>x</argname> is a list of
	  series, the output is a series with 1 at observations for which
	  at least one series in the list has a missing value, and 0
	  otherwise. For example, the following code
	</para>
	<code>
		nulldata 3
		series x = normal()
		x[2] = NA
		series x_ismiss = missing(x)
		print x x_ismiss --byobs
	</code>
	<para>
	 sets a missing value at the second observation of <argname>x</argname>,
	 and creates a new boolean series <argname>x_ismiss</argname> which
	 identifies the missing observation
	</para>
	<code>
		             y     y_ismiss

		1    -1.551247            0
		2                         1
		3    -2.244616            0
	</code>
	<para>
	  <seelist>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	 Converts <lit>NA</lit>s to zeros. If <argname>x</argname> is
	 a series or matrix, the conversion is done element by
	 element. For example, the following code
	</para>
	<code>
		nulldata 3
		series x = normal()
		x[2] = NA
		y = misszero(x)
		print x y --byobs
	</code>
	<para>
	 sets a missing value at the second observation of <argname>x</argname>,
	 and creates a new series <argname>y</argname> for which the missing
	 observation is replaced by zero:
	</para>
	<code>
	             x            y

		1    0.7355250    0.7355250
		2                     0.000
		3   -0.2465936   -0.2465936
	</code>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Shifts up or down the rows of <argname>X</argname>.  If
	  <argname>p</argname> is a positive scalar, returns a matrix
	  in which the columns of <argname>X</argname> are shifted
	  down by <argname>p</argname> rows and the first
	  <argname>p</argname> rows are filled with the value
	  <argname>m</argname>. If <argname>p</argname> is a negative
	  number, <argname>X</argname> is shifted up and the last rows
	  are filled with the value <argname>m</argname>. If
	  <argname>m</argname> is omitted, it is understood to be
	  zero.
	</para>
	<para context="tex">
	  Shifts up or down the rows of <argname>X</argname>. If $p$
	  is a positive scalar, the returned matrix $Y$ has typical
	  element $Y_{i,j} = X_{i-p,j}$ for $i \ge p$ and zero
	  otherwise. In other words, the columns of
	  <argname>X</argname> are shifted down by
	  <argname>p</argname> rows and the first <argname>p</argname>
	  rows are filled with the value <argname>m</argname>. If
	  <argname>p</argname> is a negative number,
	  <argname>X</argname> is shifted up and the last rows are
	  filled with the value <argname>m</argname>. If
	  <argname>m</argname> is omitted, it is understood to be
	  zero.
	</para>
	<para>
	  If <argname>p</argname> is a vector the operation described
	  above is carried out for each element in
	  <argname>p</argname> and the resulting matrices are joined
	  horizontally. The following code illustrates this usage, for
	  input <argname>X</argname> with two columns and input
	  <argname>p</argname> calling for lags 1 and 2. Missing
	  values are set to NA as opposed to the default of 0.
	</para>
	<code>
	matrix X = mnormal(5, 2)
	print X
	eval mlag(X, {1, 2}, NA)
	</code>
	<code>
	m (5 x 2)

      1.5953    -0.070740
    -0.52713     -0.47669
     -2.2056     -0.28112
     0.97753       1.4280
     0.49654      0.18532

         nan          nan          nan          nan
      1.5953    -0.070740          nan          nan
    -0.52713     -0.47669       1.5953    -0.070740
     -2.2056     -0.28112     -0.52713     -0.47669
     0.97753       1.4280      -2.2056     -0.28112
	</code>
	<para>
	  See also <fncref targ="lags"/>.
	</para>
      </description>
    </function>

    <function name="mlincomb" section="midas" output="series">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">type</fnarg>
      </fnargs>
      <description>
	<para>
	  A convenience MIDAS function which combines <fncref
	  targ="lincomb"/> with <fncref targ="mweights"/>.  Given a
	  list <repl>hfvars</repl>, it constructs a series which is a
	  weighted sum of the elements of the list, the weights based
	  on the vector of hyper-parameters <repl>theta</repl> and the
	  type of parameterization: see <lit>mweights</lit> for
	  details. Note that <fncref targ="hflags"/> is generally
	  the best way to create a list suitable as the first argument
	  to this function.
	</para>
	<para>
	  To be explicit, the call
	</para>
	<code>
	  series s = mlincomb(hfvars, theta, 2)
	</code>
	<para>
	  is equivalent to
	</para>
	<code>
	  matrix w = mweights(nelem(hfvars), theta, 2)
	  series s = lincomb(hfvars, w)
	</code>
	<para>
	  but use of <lit>mlincomb</lit> saves on some typing and
	  also some CPU cycles.
	</para>
      </description>
    </function>

    <function name="mlog" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the matrix logarithm of <argname>A</argname>.
	  The algorithm employed relies on eigendecomposition,
	  which requires that <argname>A</argname> be
	  diagonalizable. See also <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix with <argname>r</argname> rows and
	  <argname>c</argname> columns, filled with standard normal
	  pseudo-random variates.  If omitted, the number of columns
	  defaults to 1 (column vector).
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a <by r="k" c="n"/> matrix of parameter estimates obtained
	  by OLS regression of the <by r="T" c="n"/> matrix
	  <argname>Y</argname> on the <by r="T" c="k"/> matrix
	  <argname>X</argname>.
	</para>
	<para>
	  If the third argument is not <lit>null</lit>, the <by r="T"
	  c="n"/> matrix <argname>U</argname> will contain the
	  residuals. If the final argument is given and is not
	  <lit>null</lit> then the <by r="k" c="k"/> matrix
	  <argname>V</argname> will contain (a) the covariance matrix
	  of the parameter estimates, if <argname>Y</argname> has just
	  one column, or (b) <math>X'X</math><sup>-1</sup> if
	  <argname>Y</argname> has multiple columns.
	</para>
	<para>
	  By default, estimates are obtained via Cholesky decomposition, with
	  a fallback to QR decomposition if the columns of
	  <argname>X</argname> are highly collinear.  The use of SVD
	  can be forced via the command <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mpols"/>
            <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">month</fnarg>
	<fnarg type="scalar-or-series">year</fnarg>
	<fnarg type="int">weeklen</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of (relevant) days in the specified month
	  in the specified year, on the proleptic Gregorian calendar.
	  The <argname>weeklen</argname> argument, which must equal 5,
	  6 or 7, gives the number of days in the week that should be
	  counted (a value of 6 omits Sundays, and a value of 5 omits
	  both Saturdays and Sundays).
	</para>
	<para>
	  The return value is a scalar if both
	  <argname>month</argname> and <argname>year</argname> are
	  scalars, otherwise a series.
	</para>
	<para>
	  For example, if you have a monthly dataset open, the call
	</para>
	<code>
	  series wd = monthlen($obsminor, $obsmajor, 5)
	</code>
	<para>
	  will return a series containing the number of working days
	  for each month in the sample.
	</para>
      </description>
    </function>

    <function name="movavg" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
	<fnarg type="scalar" optional="true">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Depending on the value of the parameter <argname>p</argname>,
	  returns either a simple or an exponentially weighted
	  moving average of the input series <argname>x</argname>.
	</para>
	<para context="notex">
	  If <argname>p</argname> &gt; 1, a simple
	  <argname>p</argname>-term moving average is computed, that
	  is, the arithmetic mean of <math>x</math> from period
	  <math>t</math> to <math>t-p+1</math>. If a non-zero value is
	  supplied for the optional <argname>control</argname>
	  parameter the MA is centered, otherwise it is
	  <quote>trailing</quote>. The optional <argname>y0</argname>
	  argument is ignored.
	</para>
	<para context="tex">
	  If $p&gt;1$, a simple <argname>p</argname>-term moving
	  average is computed, that is, $\frac{1}{p} \sum_{i=0}^{p-1}
	  x_{t-i}$. If a non-zero value is supplied for the optional
	  <argname>control</argname> parameter the MA is centered,
	  otherwise it is <quote>trailing</quote>. The optional
	  <argname>y0</argname> argument is ignored.
	</para>
	<para context="notex">
	  If <argname>p</argname> is a positive fraction, an
	  exponential moving average is computed:
	</para>
	<para context="notex">
	  <math>y(t) = p*x(t) + (1-p)*y(t-1)</math>
	</para>
	<para context="notex">
	  By default the output series, <math>y</math>, is initialized
	  using the first value of <argname>x</argname>, but the
	  <argname>control</argname> parameter may be used to specify
	  the number of initial observations that should be averaged
	  to produce <math>y(0)</math>. A zero value for
	  <argname>control</argname> indicates that all the
	  observations should be used. Alternatively, an initializer
	  may be specified using the optional <argname>y0</argname>
	  argument; in that case the <argname>control</argname>
	  argument is ignored.
	</para>
	<para context="tex">
	  If $0 &lt; p &lt; 1$, an exponential moving average is
	  computed: \[y_t = p x_t + (1-p)y_{t-1}\] This is the formula
	  of <cite key="roberts59">Roberts, 1959</cite>. By default
	  the output series $y$ is initialized using the first valid
	  value of $x$, but the <argname>control</argname> parameter
	  may be used to specify the number of initial observations
	  that should be averaged to produce $y_0$.  A zero value for
	  <argname>control</argname> indicates that all the
	  observations should be used. Alternatively, an initializer
	  may be specified using the optional <argname>y0</argname>
	  argument; in that case the <argname>control</argname>
	  argument is ignored.
	</para>
      </description>
    </function>

    <function name="mpiallred" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;object</fnarg>
	<fnarg type="string">op</fnarg>
      </fnargs>
      <description>
	<para>
	  Available only when gretl is in MPI mode (see <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Must be called by all
	  processes. This function works like <fncref
	  targ="mpireduce"/> except that all processes, not just the
	  root process, get a copy of the <quote>reduced</quote>
	  object in place of the original. It is therefore equivalent
	  to <lit>mpireduce</lit> followed by a call to <fncref
	  targ="mpibcast"/>, but more efficient.
	</para>
      </description>
    </function>

    <function name="mpibarrier" section="mpi" output="int">
      <description>
	<para>
	  Available only when gretl is in MPI mode (see <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Takes no
	  arguments. Enforces synchronization of MPI processes: no
	  process can continue beyond the barrier until it has been
	  reached by all.
	</para>
	<code>
	  # nobody gets past until everyone gets here
	  mpibarrier()
	</code>
      </description>
    </function>

    <function name="mpibcast" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;object</fnarg>
	<fnarg type="int" optional="true">root</fnarg>
      </fnargs>
      <description>
	<para>
	  Available only when gretl is in MPI mode (see <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Must be called by all
	  processes. Broadcasts the <argname>object</argname>
	  argument, which must be given in pointer form, to all
	  processes. The object in question (a matrix, bundle, scalar,
	  array, string or list) must be declared in all processes
	  prior to the broadcast. No process can continue beyond a
	  call to <lit>mpibcast</lit> until all processes have
	  successfully executed it.
	</para>
	<para>
	  By default <quote>root</quote>, the source of the broadcast,
	  is the MPI process with rank 0, but this can be adjusted
	  via the optional second argument, which must be an integer
	  from 0 to the number of MPI processes minus 1.
	</para>
	<para>
	  A simple example follows. On successful completion every
	  process will have a copy of the matrix <lit>X</lit> defined
	  at rank 0.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	      X = mnormal(T, k)
	  endif
	  mpibcast(&amp;X)
	</code>
      </description>
    </function>

    <function name="mpirecv" section="mpi" output="object">
      <fnargs>
	<fnarg type="int">src</fnarg>
      </fnargs>
      <description>
	<para>
	  Available only when gretl is in MPI mode (see <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). See <fncref
	  targ="mpisend"/>, with which <lit>mpirecv</lit> must always
	  be paired, for an explanation. The <argname>src</argname>
	  argument specifies the rank of the process from which the
	  object is to be received, in the range 0 to the number of
	  MPI processes minus 1.
	</para>
      </description>
    </function>

    <function name="mpireduce" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;object</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">root</fnarg>
      </fnargs>
      <description>
	<para>
	  Available only when gretl is in MPI mode (see <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Must be called by all
	  processes. This function gathers objects (scalars, matrices
	  or arrays) of a specified name, given in pointer form, from
	  all processes and <quote>reduces</quote> them to a single
	  object at the root node.
	</para>
	<para>
	  The <lit>op</lit> argument specifies the reduction operation
	  or method.  The methods supported for scalars are
	  <lit>sum</lit>, <lit>prod</lit> (product), <lit>max</lit>
	  and <lit>min</lit>. For matrices the methods are
	  <lit>sum</lit>, <lit>prod</lit> (Hadamard product),
	  <lit>hcat</lit> (horizontal concatenation) and
	  <lit>vcat</lit> (vertical concatenation). For arrays
	  only <lit>acat</lit> (concatenation) is supported.
	</para>
	<para>
	  By default <quote>root</quote>, the target of the reduction,
	  is the MPI process with rank 0, but this can be adjusted
	  via the optional third argument, which must be an integer
	  from 0 to the number of MPI processes minus 1.
	</para>
	<para>
	  An example follows. On successful completion of the above,
	  the root process will have a matrix <lit>X</lit> which is
	  the sum of the matrices <lit>X</lit> at all processes.
	</para>
	<code>
	  matrix X
	  X = mnormal(T, k)
	  mpireduce(&amp;X, sum)
	</code>
      </description>
    </function>

    <function name="mpiscatter" section="mpi" output="int">
      <fnargs>
	<fnarg type="matrixref">&amp;M</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">root</fnarg>
      </fnargs>
      <description>
	<para>
	  Available only when gretl is in MPI mode (see <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Must be called by all
	  processes. This function distributes chunks of a matrix in
	  the root process to all processes. The matrix must be
	  declared in all processes prior to the call to
	  <lit>mpiscatter</lit>, and must be given in pointer form.
	</para>
	<para>
	  The <lit>op</lit> argument must be either <lit>byrows</lit>
	  or <lit>bycols</lit>. Let <math>q</math> denote the quotient
	  of the number of rows in the matrix to be scattered and the
	  number of processes. In the <lit>byrows</lit> case root
	  sends the first <math>q</math> rows to process 0, the next
	  <math>q</math> to process 1, and so on. If there is a
	  remainder from the division of rows it is added to the last
	  allotment. The <lit>bycols</lit> case is exactly analogous
	  but splitting of the matrix is by columns.
	</para>
	<para>
	  An example follows. If there are 4 processes, each one
	  (including root) will each get a <by r="2500" c="10"/> share
	  of the original <lit>X</lit> as it existed in the root
	  process. If you want to preserve the full matrix in the root
	  process, it is necessary to make a copy of it before calling
	  <lit>mpiscatter</lit>.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	      X = mnormal(10000, 10)
	  endif
	  mpiscatter(&amp;X, byrows)
	</code>
      </description>
    </function>

    <function name="mpisend" section="mpi" output="int">
      <fnargs>
	<fnarg type="object">object</fnarg>
	<fnarg type="int">dest</fnarg>
      </fnargs>
      <description>
	<para>
	  Available only when gretl is in MPI mode (see <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Sends the named object
	  (a matrix, bundle, array, scalar, string or list) from the
	  current process to the one identified by the integer
	  <argname>dest</argname> (from 0 to the number of MPI
	  processes minus 1).
	</para>
	<para>
	  A call to this function must always be paired with a call to
	  <fncref targ="mpirecv"/> in the <argname>dest</argname>
	  process, as in the following example which sends a matrix
	  from rank 2 to rank 3.
	</para>
	<code>
	  if $mpirank == 2
	      matrix C = cholesky(A)
	      mpisend(C, 3)
	  elif $mpirank == 3
	      matrix C = mpirecv(2)
	  endif
	</code>
      </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Works exactly as <fncref targ="mols"/>, except that the calculations
	  are done in multiple precision using the GMP library.
	</para>
	<para>
	  By default GMP uses 256 bits for each floating point number, but
	  you can adjust this using the environment variable
	  <lit>GRETL_MP_BITS</lit>, &eg; <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-matrix">p1</fnarg>
	<fnarg type="scalar-or-matrix" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">rows</fnarg>
	<fnarg type="int">cols</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
        <example>matrix D = mrandgen(dir, {0.5,1,2,4}, 30)</example>
      </examples>
      <description>
	<para>
	  With one exception (see below), this function works like
	  <fncref targ="randgen"/> except that the return value is a
	  matrix rather than a series. The initial arguments to this
	  function (the number of which depends on the selected
	  distribution) are as described for <lit>randgen</lit>, but
	  they must be followed by two integers to specify the row and
	  column dimensions of the desired random matrix. If
	  <argname>p1</argname> or <argname>p2</argname> are given in
	  matrix form they must have a number of elements equal to the
	  product of <argname>rows</argname> and
	  <argname>cols</argname>.
	</para>
	<para>
	  The exceptional case is the Dirichlet distribution. This is
	  a multivariate distribution, and invoking
	  <lit>mrandgen</lit> with <quote>dir</quote> as first
	  parameter triggers special syntax: the second argument must
	  be a <math>k</math>-element positive vector <math>a</math>,
	  and the third a scalar <math>r</math>. The function will
	  return an <by r="r" c="k"/> matrix where each row is an
	  independent draw from a Dirichlet distribution with
	  parameter <math>a</math>.
	</para>
	<para>
	  The first example above calls for a column vector of length
	  50 holding draws from a continuous uniform distribution on
	  [0,100]. The second example specifies a <by r="20" c="20"/>
	  random matrix with draws from the <math>t</math>
	  distribution with 14 degrees of freedom; and the third
	  returns a <by r="30" c="4"/> matrix holding 30 draws from a
	  specified Dirichlet distribution.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Reads a matrix from a file named <argname>fname</argname>.
	  If the file name does not contain a full path specification,
	  it will be looked for in several <quote>likely</quote>
	  locations, beginning with the currently set <cmdref
	  targ="workdir"/>. However, if a non-zero value is given for
	  the optional <argname>import</argname> argument, the input
	  file is looked for in the user's <quote>dot</quote>
	  directory. This is intended for use with the
	  matrix-exporting functions offered in the context of the
	  <cmdref targ="foreign"/> command. In this case the
	  <argname>fname</argname> argument should be a plain
	  filename, without any path component.
	</para>

	<para>Currently, the function recognizes four file formats:
	</para>

	<subhead>Native text format</subhead>
	<para>
	  These files are identified by the extension
	  <quote><lit>.mat</lit></quote>, and are fully compatible
	  with the Ox matrix file format. If the filename has the
	  suffix <quote><lit>.gz</lit></quote> it is assumed that
	  gzip compression has been applied in writing the data.

	  The file is assumed to be plain text, conforming to the
	  following specification:
	</para>
	<ilist>
	  <li>
            <para>
	      It starts with zero or more comments, defined as lines
	      that start with the hash mark, <lit>#</lit>; such lines
	      are ignored.
            </para>
	  </li>
	  <li>
            <para>
              The first non-comment line contains two integers,
              separated by a tab character, indicating the number of
              rows and columns, respectively.
            </para>
	  </li>
	  <li>
            <para>
              The columns are separated by tabs.
            </para>
	  </li>
	  <li>
            <para>
              The decimal separator is the dot character,
              <quote><lit>.</lit></quote>.
            </para>
	  </li>
	</ilist>

	<subhead>Binary files</subhead>
	<para>
	  Files with the suffix <quote><lit>.bin</lit></quote> are
	  assumed to be in binary format. The
	  <quote><lit>.gz</lit></quote> suffix, for gzip compression,
	  is also recognized. The first 19 bytes contain the
	  characters <lit>gretl_binary_matrix</lit>, the next 8 bytes
	  contain two 32-bit integers giving the number of rows and
	  columns, and the remainder of the file contains the matrix
	  elements as little-endian <quote>doubles</quote>, in
	  column-major order. If gretl is run on a big-endian system,
	  the binary values are converted to little endian on writing,
	  and converted to big endian on reading.
	</para>

	<subhead>Delimited text files</subhead>
	<para>
	  If the name of the file to be read has extension
	  <quote><lit>.csv</lit></quote> the rules governing the
	  format of the file are different, and more relaxed. In this
	  case the actual data should <emphasis>not</emphasis> be
	  preceded by a line giving the number of rows and
	  columns. Gretl will try to figure out the delimiter (comma,
	  semicolon or space) and do its best to import the matrix,
	  allowing for use of comma as decimal separator if need be.
	  Note that the delimiter should not be the tab character, on
	  pain of confusing such files with those in gretl's
	  <quote>native</quote> matrix format.
	</para>

	<subhead>Gretl dataset files</subhead>
	<para>
	  Files with extension <quote><lit>.gdt</lit></quote> or
	  <quote><lit>.gdtb</lit></quote> are treated as gretl native
	  data files, as created by the <cmdref targ="store"/>
	  command. In this case, the matrix returned contains the
	  numerical values of the series of the dataset, arranged by
	  column.  Note that string-valued series are not read as
	  such; the matrix will just contain their numeric encodings.
	</para>

	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">bycol</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix containing the rows of <argname>X</argname>
	  in reverse order, or the columns in reverse order if the
	  optional second argument has a non-zero value.
	</para>
      </description>
    </function>

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Restricted least squares: returns a <by r="k" c="n"/> matrix
	  of parameter estimates obtained by least-squares regression
	  of the <by r="T" c="n"/> matrix <argname>Y</argname> on the
	  <by r="T" c="k"/> matrix <argname>X</argname> subject to the
	  linear restriction <math>RB</math> = <math>q</math>, where
	  <math>B</math> denotes the stacked coefficient vector.
	  <argname>R</argname> must have <math>kn</math> columns; each
	  row of this matrix represents a linear restriction. The
	  number of rows in <argname>q</argname> must match the number
	  of rows in <argname>R</argname>.
	</para>
	<para>
	  If the fifth argument is not <lit>null</lit>, the <by r="T"
	  c="n"/> matrix <argname>U</argname> will contain the
	  residuals. If the final argument is given and is not
	  <lit>null</lit> then the <by r="k" c="k"/> matrix
	  <argname>V</argname> will hold the restricted counterpart to
	  the matrix <math>X'X</math><sup>-1</sup>. The variance
	  matrix of the estimates for equation <math>i</math> can be
	  constructed by multiplying the appropriate sub-matrix of
	  <argname>V</argname> by an estimate of the error variance
	  for that equation.
	</para>
      </description>
    </function>

    <function name="mshape" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Rearranges the elements of <argname>X</argname> into a matrix
	  with <argname>r</argname> rows and <argname>c</argname> columns.
	  Elements are read from <argname>X</argname> and written to the
	  target in column-major order.  If <argname>X</argname> contains
	  fewer than <math>k</math> = <math>rc</math> elements, the
	  elements are repeated cyclically; otherwise, if
	  <argname>X</argname> has more elements, only the first
	  <math>k</math> are used.
	</para>
	<para>
	  If the third argument is omitted, <argname>c</argname>
	  defaults to 1 if <argname>X</argname> is <by r="1" c="1"/>
	  otherwise to <math>N</math>/<argname>r</argname> where
	  <math>N</math> is the total number of elements in
	  <argname>X</argname>. However, if <math>N</math> is not an
	  integer multiple of <argname>r</argname> an error is
	  flagged.
	</para>
	<para>
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix in which the rows of <argname>X</argname>
	  are reordered by increasing value of the elements in
	  column <argname>j</argname>. This is a stable sort:
	  rows that share the same value in column <argname>j</argname>
	  will not be interchanged.
	</para>
      </description>
    </function>

    <function name="msplitby" section="matrix" output="matrices">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-matrix">v</fnarg>
	<fnarg type="bool">bycol</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an array of matrices, the result of splitting
	  <argname>X</argname> horizontally or vertically under the
	  control of the arguments <argname>v</argname> and
	  <argname>bycol</argname>. If <argname>bycol</argname> is
	  nonzero, the matrix will be split by columns; otherwise, as
	  per default, by rows.
	</para>
	<para>
	  The argument <argname>v</argname> can be either a vector or
	  a scalar.
        </para>
        <ilist>
          <li>
            <para>
              vector: must be of length equal to the relevant (row or
              column) dimension of <argname>X</argname>, and must
              contain positive integers. The greatest integer sets the
              length of the array that is returned. Each element of
              <argname>v</argname> indicates the array index of the
              matrix to which the corresponding row of
              <argname>X</argname> should be assigned.
            </para>
          </li>
          <li>
            <para>
              scalar: the relevant dimension of
              <argname>X</argname> (row or column, as dictated by
              <argname>bycol</argname>) must be an exact multiple of
              the scalar value. <argname>X</argname> will be split in
              chunks with <argname>v</argname> rows or columns each.
            </para>
          </li>
        </ilist>
	<para>
	  In the following example we split a <by r="4" c="3"/> matrix
	  into three matrices: the first two rows are assigned to the
	  first matrix; the second matrix is left empty; the third and
	  fourth matrices gets row 3 and 4 of <argname>X</argname>,
	  respectively
	</para>
	<code>
	  matrix X = {1,2,3; 4,5,6; 7,8,9; 10,11,12}
	  matrices M = msplitby(X, {1,1,3,4})
	  print M
	</code>
	<para>
	  The print statement gives
	</para>
	<code>
	  Array of matrices, length 4
	  [1] 2 x 3
	  [2] null
	  [3] 1 x 3
	  [4] 1 x 3
	</code>
	<para>
	  The next example splits <argname>X</argname> evenly:
	</para>
	<code>
	  matrix X = {1,2,3; 4,5,6; 7,8,9; 10,11,12}
	  matrices MM = msplitby(X, 2)
	  print MM[1]
	  print MM[2]
	</code>
	<para>
	  which gives
	</para>
	<code>
	  ? print MM[1]
	  1   2   3
	  4   5   6

	  ? print MM[2]
	  7    8    9
	  10   11   12
	</code>
	<para>
	  See <fncref targ="flatten"/> for the inverse operation.
	</para>
      </description>
    </function>

    <function name="muniform" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix with <argname>r</argname> rows and
	  <argname>c</argname> columns, filled with uniform (0,1)
	  pseudo-random variates.  If omitted, the number of columns
	  defaults to 1 (column vector). Note: the preferred method
	  for generating a scalar uniform r.v. is to use the <fncref
	  targ="randgen1"/> function.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mweights" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">type</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a <math>p</math>-vector of MIDAS weights to be
	  applied to <math>p</math> lags of a high-frequency series,
	  based on the vector <repl>theta</repl> of hyper-parameters.
	</para>
	<para>
	  The <repl>type</repl> argument identifies the type of
	  parameterization, which governs the required number of
	  elements, <math>k</math>, in <repl>theta</repl>: 1 =
	  normalized exponential Almon (<math>k</math> at least 1,
	  typically 2); 2 = normalized beta with zero last
	  (<math>k</math> = 2); 3 = normalized beta with non-zero last
	  lag (<math>k</math> = 3); and 4 = Almon polynomial
	  (<math>k</math> at least 1). Note that in the normalized
	  beta case the first two elements of <repl>theta</repl>
	  must be positive.
	</para>
	<para>
	  The <repl>type</repl> may be given as an integer code, as
	  shown above, or by one of the following strings
	  (respectively): <lit>nealmon</lit>, <lit>beta0</lit>,
	  <lit>betan</lit>, <lit>almonp</lit>. If a string is used, it
	  should be placed in double quotes. For example, the
	  following two statements are equivalent:
	</para>
	<code>
	  W = mweights(8, theta, 2)
	  W = mweights(8, theta, "beta0")
	</code>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
	    <fncref targ="midasmult"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Writes the matrix <argname>X</argname> to a file named
	  <argname>fname</argname>. By default this file will be plain
	  text; the first line will hold two integers, separated by a
	  tab character, representing the number of rows and columns;
	  on the following lines the matrix elements appear, in
	  scientific notation, separated by tabs (one line per row).
	  To avoid confusion on reading, files to be written in this
	  format should be named with the suffix
	  <quote><lit>.mat</lit></quote>.  See below for alternative
	  formats.
	</para>
	<para>
	  If a file <argname>fname</argname> already exists, it will
	  be overwritten.  The nominal return value is 0 on successful
	  completion; if writing fails an error is flagged.
	</para>
	<para>
	  The output file will be written in the currently set <cmdref
	  targ="workdir"/>, unless the <repl>filename</repl> string
	  contains a full path specification. However, if a non-zero
	  value is given for the <argname>export</argname> argument,
	  the output file will be written into the user's
	  <quote>dot</quote> directory, where it is accessible by
	  default via the matrix-loading functions offered in the
	  context of the <cmdref targ="foreign"/> command. In this
	  case a plain filename, without any path component, should be
	  given for the second argument.
	</para>
	<para>
	  Matrices stored via the <lit>mwrite</lit> function in its
	  default form can be easily read by other programs; see
	  <guideref targ="chap:matrices"/> for details.
	</para>
	<para>
	  Three mutually exclusive inflections of this function are
	  available, as follows:
	</para>
	<ilist>
	  <li>
	    <para>
	      If <argname>fname</argname> has the suffix
	      <quote><lit>.gz</lit></quote> then the file is written
	      in the format described above but with gzip compression.
	    </para>
	  </li>
	  <li>
	    <para>
	      If <argname>fname</argname> has the suffix
	      <quote><lit>.bin</lit></quote> then the matrix is
	      written in binary format. In this case the first 19
	      bytes contain the characters
	      <lit>gretl_binary_matrix</lit>, the next 8 bytes contain
	      two 32-bit integers giving the number of rows and
	      columns, and the remainder of the file contains the
	      matrix elements as little-endian <quote>doubles</quote>,
	      in column-major order. If gretl is run on a big-endian
	      system, the binary values are converted to little endian
	      on writing, and converted to big endian on reading.
	    </para>
	  </li>
	  <li>
	    <para>
	      If <argname>fname</argname> has the suffix
	      <quote><lit>.csv</lit></quote> then the matrix is
	      written in comma-separated format, without a header
	      line indicating the number of rows and columns to
	      follow. This may be easier for third-party programs to
	      handle, but it is not recommended if the matrix file
	      is intended for reading by gretl.
	    </para>
	  </li>
	</ilist>
	<para>
	  Note that if the matrix file is to be read by a third-party
	  program it is not advisable to use the gzip or binary
	  options. But if the file is intended for reading by gretl
	  the alternative formats save space, and the binary format
	  allows for much faster reading of large matrices. The gzip
	  format is not recommended for very large matrices, since
	  decompression can be quite slow.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
	  </seelist>
	  And for writing a matrix to file as a dataset, see
	  <cmdref targ="store"/>.
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix holding the cross tabulation of the values
	  contained in <argname>x</argname> (by row) and
	  <argname>y</argname> (by column). The two arguments should
	  be of the same type (both series or both column vectors). It
	  is generally expected (though not required) that the
	  arguments will be discrete-valued, with fewer distinct
	  values than observations. Otherwise the cross-tabulation may
	  be very large and not very informative.
	</para>
	<para>
	  <seelist>
            <fncref targ="values"/>
	    <fncref targ="corresp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="naalen" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a sample of duration data, <argname>d</argname>,
	  possibly accompanied by a record of censoring status,
	  <argname>cens</argname>, computes the Nelson&ndash;Aalen
	  nonparametric estimator of the hazard function (<cite
	  key="nelson72">Nelson, 1972</cite>; <cite
	  key="aalen78">Aalen, 1978</cite>).  The returned matrix has
	  three columns holding, respectively, the sorted unique
	  values in <argname>d</argname>, the estimated cumulated
	  hazard function corresponding to the duration value in
	  column 1, and the standard error of the estimator.
	</para>
	<para>
	  If the <argname>cens</argname> series is given, the value 0
	  is taken to indicate an uncensored observation while a value
	  of 1 indicates a right-censored observation (that is, the
	  period of observation of the individual in question has
	  ended before the duration or spell has been recorded as
	  terminated). If <argname>cens</argname> is not given, it is
	  assumed that all observations are uncensored. (Note: the
	  semantics of <argname>cens</argname> may be extended at some
	  point to cover other types of censoring.)
	</para>
	<para>
	  <seelist>
            <fncref targ="kmeier"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="nonparam" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar" optional="true">h</fnarg>
	<fnarg type="bool" optional="true">LOO</fnarg>
	<fnarg type="scalar" optional="true">trim</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the Nadaraya&ndash;Watson nonparametric estimator
	  of the conditional mean of <argname>y</argname> given
	  <argname>x</argname>. The return value is a series holding
	  <math>m(x</math><sub>i</sub><math>)</math>, the estimate of
	  <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  for each non-missing element of the series
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i - x_j)}
	  {\sum_{j=1}^{n} K_h(x_i - x_j)} \] where the kernel function
	  <math>K_h(\cdot)</math> is given by
	  \[ K_h(x) = \exp\left(-\frac{x^2}{2h}\right)
	  \] for $|x| &lt; \tau$ and zero otherwise.
	  ($\tau$ = trimming parameter.)
	</para>
	<para context="notex">
	  The kernel function employed by this estimator is given by
	  <math>K = exp(-x</math><sup>2</sup><math> / 2h)</math> for
	  <math>|x| &lt; T</math>, and zero otherwise. (<math>T</math>
	  = trimming parameter.)
	</para>
	<para>
	  The three optional arguments inflect the behavior of the
	  estimator as described below.
	</para>
	<subhead>Bandwidth</subhead>
	<para>
	  The argument <argname>h</argname> can be used to control the
	  bandwidth, a positive real number. This is usually small;
	  larger values of <argname>h</argname> make <math>m(x)</math>
	  smoother. A popular choice is to make <argname>h</argname>
	  proportional to <math>n</math><sup>-0.2</sup>. If
	  <argname>h</argname> is omitted or set to zero, the
	  bandwidth defaults to a data-determined value using the
	  proportionality just mentioned but incorporating the
	  dispersion of the <argname>x</argname> data as measured by
	  the inter-quartile range or standard deviation; see
	  <guideref targ="chap:nonparam"/> for more details.
	</para>
	<subhead>Leave-one-out</subhead>
	<para>
	  <quote>Leave-one-out</quote> is a variant of the algorithm
	  which omits the <math>i</math>-th observation when
	  evaluating <math>m(x</math><sub>i</sub><math>)</math>. This
	  makes the Nadaraya&ndash;Watson estimator more robust
	  numerically and is generally advised when the estimator is
	  computed for inference purposes. This variant is not enabled
	  by default, but is activated if a non-zero value is given
	  for the <argname>LOO</argname> argument.
	</para>
	<para context="tex">
          In formulae, this estimator is
          \[
          m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i -
          x_j)} {\sum_{j \ne i} K_h(x_i - x_j)}
          \]
	</para>
	<subhead>Trimming</subhead>
	<para>
	  The <argname>trim</argname> argument can be used to control
	  the degree of <quote>trimming</quote>, which is imposed to
	  prevent numerical problems when the kernel function is
	  evaluated too far away from zero. This parameter is
	  expressed as a multiple of <argname>h</argname>, the default
	  value being 4. In some cases a value greater than 4 may be
	  preferable. Again see <guideref targ="chap:nonparam"/> for
	  details.
	</para>
	<para>
	  See also <fncref targ="loess"/>.
	</para>
      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="listetc">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of elements in the argument, which may be
	  a list, a matrix, a bundle, an array or a string, but not a
	  series. In the case of a string argument the number of
	  bytes (which may not be equal to the number of characters in
	  the string) is returned; see also <fncref targ="strlen"/>.
	</para>
      </description>
    </function>

    <function name="ngetenv" section="programming" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  If an environment variable by the name of
	  <argname>s</argname> is defined and has a numerical value,
	  returns that value; otherwise returns NA.  See also <fncref
	  targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a count of the complete lines (that is, lines that
	  end with the newline character) in <argname>buf</argname>.
	</para>
    <para>
        Example:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        scalar number = nlines(web_page)
        print number
    </code>
      </description>
    </function>

    <function name="NMmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="int">maxfeval</fnarg>
      </fnargs>
      <description>
	<para>
	  Numerical maximization via the Nelder&ndash;Mead
	  derivative-free simplex method.  On input the vector
	  <argname>b</argname> should hold the initial values of a set
	  of parameters, and the argument <argname>f</argname> should
	  specify a call to a function that calculates the (scalar)
	  criterion to be maximized, given the current parameter
	  values and any other relevant data. On successful
	  completion, <lit>NMmax</lit> returns the maximized value of
	  the criterion, and <argname>b</argname> holds the parameter
	  values which produce the maximum.
	</para>
	<para>
	  The optional third argument may be used to set the maximum
	  number of function evaluations; if it is omitted or set to
	  zero the maximum defaults to 2000. As a special signal to
	  this function the <argname>maxfeval</argname> value may be
	  set to a negative number. In this case the absolute value is
	  taken, and <lit>NMmax</lit> flags an error if the best value
	  found for the objective function at the maximum number of
	  function evaluations is not a local optimum. Otherwise
	  non-convergence in this sense is not treated as an error.
	</para>
	<para>
	  If the object is in fact minimization, either the function
	  call should return the negative of the criterion or
	  alternatively <lit>NMmax</lit> may be called under the
	  alias <lit>NMmin</lit>.
	</para>
	<para>
	  For more details and examples <guideref
	  targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NMmin" section="numerical" output="scalar">
      <description>
	<para>
	  An alias for <fncref targ="NMmax"/>; if called under this
	  name the function acts as a minimizer.
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the number of
	  non-missing observations for this series in the currently
	  selected sample.
	</para>
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  count of the series in the list that have a non-missing
	  value at observation <math>t</math>.
	</para>
	<para>
	  <seelist>
            <fncref targ="pnobs"/>
            <fncref targ="pxnobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Generates a series of Gaussian pseudo-random variates with
	  mean &mu; and standard deviation &sigma;. If no arguments
	  are supplied, standard normal variates <math>N</math>(0,1)
	  are produced.  The values are produced using the Ziggurat
	  method <cite key="marsaglia00" p="true">(Marsaglia and
	  Tsang, 2000)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normtest" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Carries out one or more tests for normality of
	  <argname>y</argname>. By default the Doornik&ndash;Hansen
	  test is performed but the optional <argname>method</argname>
	  argument can be used to select an alternative: use
	  <lit>swilk</lit> to get the Shapiro&ndash;Wilk test,
	  <lit>jbera</lit> for Jarque&ndash;Bera test, or
	  <lit>lillie</lit> for the Lilliefors test. Or give
	  <lit>all</lit> for the <argname>method</argname> argument to
	  carry out all four tests.
	</para>
	<para>
	  The second argument may be given in either quoted or
	  unquoted form. In the latter case, however, if the argument
	  is the name of a string variable the value of the variable
	  is substituted.
	</para>
	<para>
	  The returned matrix is <by r="1" c="2"/> for a single test,
	  or <by r="4" c="2"/> if all tests are performed. Test
	  statistics are found in the first column and p-values in the
	  second. The test statistic does not follow the same
	  distribution is all cases. For Doornik&ndash;Hansen and
	  Jarque&ndash;Bera it is chi-square(2); for the other methods
	  it is an idiosyncratic statistic whose p-value requires
	  special calculation.
	</para>
	<para>
	  See also the <cmdref targ="normtest"/> command.
	</para>
      </description>
    </function>

    <function name="npcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Calculates a measure of correlation between
	  <argname>x</argname> and <argname>y</argname> using a
	  nonparametric method. If given, the third argument should be
	  either <lit>kendall</lit> (for Kendall's tau, version b, the
	  default method) or <lit>spearman</lit> (for Spearman's rho).
	</para>
	<para>
	  The return value is a 3-vector holding the correlation
	  measure plus a test statistic and p-value for the null
	  hypothesis of no correlation. Note that if the sample size
	  is too small the test statistic and/or p-value may be
	  <lit>NaN</lit> (not a number, or missing).
	</para>
	<para>
	  See also <fncref targ="corr"/> for Pearson correlation.
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the Net Present Value of <argname>x</argname>,
	  considered as a sequence of payments (negative) and receipts
	  (positive), evaluated at annual discount rate
	  <argname>r</argname>, which must be expressed as a decimal
	  fraction, not a percentage (0.05 rather than 5<lit>%</lit>).
	  The first value is taken as dated <quote>now</quote> and is
	  not discounted.  To emulate an NPV function in which the
	  first value is discounted, prepend zero to the input
	  sequence.
	</para>
	<para>
	  Supported data frequencies are annual, quarterly, monthly, and
	  undated (undated data are treated as if annual).
	</para>
	<para>
	  <seelist>
            <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Numerical maximization via the Newton&ndash;Raphson method.
	  On input the vector <argname>b</argname> should hold the
	  initial values of a set of parameters, and the argument
	  <argname>f</argname> should specify a call to a function
	  that calculates the (scalar) criterion to be maximized,
	  given the current parameter values and any other relevant
	  data. If the object is in fact minimization, this function
	  should return the negative of the criterion.  On successful
	  completion, <lit>NRmax</lit> returns the maximized value of
	  the criterion, and <argname>b</argname> holds the parameter
	  values which produce the maximum.
	</para>
	<para>
	  The optional third and fourth arguments provide means of
	  supplying analytical derivatives and an analytical
	  (negative) Hessian, respectively. The functions referenced
	  by <argname>g</argname> and <argname>h</argname> must take
	  as their first argument a predefined matrix that is of the
	  correct size to contain the gradient or Hessian,
	  respectively, given in pointer form. They also must take the
	  parameter vector as an argument (in pointer form or
	  otherwise).  Other arguments are optional. If either or
	  both of the optional arguments are omitted, a numerical
	  approximation is used.
	</para>
	<para>
	  For more details and examples see <guideref
	  targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmin" section="numerical" output="scalar">
      <description>
	<para>
	  An alias for <fncref targ="NRmax"/>; if called under this
	  name the function acts as a minimizer.
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the right nullspace of <argname>A</argname>, via
	  the singular value decomposition: the result is a matrix
	  <math>B</math> such that the product <math>AB</math> is a
	  zero matrix, except when <argname>A</argname> has full
	  column rank, in which case an empty matrix is
	  returned. Otherwise, if <argname>A</argname> is <by r="m"
	  c="n"/>, <math>B</math> will be <math>n</math> by
	  (<math>n</math> &minus; <math>r</math>), where
	  <math>r</math> is the rank of <argname>A</argname>.
	</para>
	<para context="notex">
	  If <argname>A</argname> is not of full column rank, then
	  the vertical concatenation of <argname>A</argname> and
	  the transpose of <argname>B</argname> produces a full
	  rank matrix.
	</para>
	<para context="tex">
	  Computes the right nullspace of <argname>A</argname>, via the
	  singular value decomposition: the result is a matrix $B$ such
	  that
	  \begin{itemize}
	  \item $AB = [0]$, except when $A$ has full column rank, in which
	  case an empty matrix is returned. Otherwise, if $A$ is $m \times
	  n$, $B$ will be an $n \times (n-r)$ matrix, where $r$ is the
	  rank of $A$.
	  \item If $A$ is not of full column rank, then the vertical
	  concatenation of $A$ and $B'$ produces a full rank matrix.
	  \end{itemize}
	</para>
    <para>
        Example:
    </para>
    <code>
      A = mshape(seq(1,6),2,3)
      B = nullspace(A)
      C = A | B'

      print A B C

      eval A*B
      eval rank(C)
    </code>
    <para>
        Produces
    </para>
    <code>
      ? print A B C
      A (2 x 3)

      1   3   5
      2   4   6

      B (3 x 1)

      -0.5
         1
      -0.5

      C (3 x 3)

         1      3      5
         2      4      6
      -0.5      1   -0.5

      ? eval A*B
      -4.4409e-16
      -4.4409e-16

      ? eval rank(C)
      3
    </code>
    <para>
      <seelist>
        <fncref targ="rank"/>
        <fncref targ="svd"/>
      </seelist>
	</para>
      </description>
    </function>

    <function name="numhess" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Calculates a numerical approximation to the Hessian
	  associated with the <math>n</math>-vector
	  <argname>b</argname> and the objective function specified by
	  the argument <argname>fcall</argname>.  The function call
	  should take <argname>b</argname> as its first argument
	  (either straight or in pointer form), followed by any
	  additional arguments that may be needed, and it should
	  return a scalar result. On successful completion
	  <lit>numhess</lit> returns an <by r="n" c="n"/> matrix
	  holding the Hessian, which is exactly symmetric by construction.
	</para>
	<para>
	  The method used is Richardson extrapolation, with four
	  steps. The optional third argument can be used to set the
	  fraction <math>d</math> of the parameter value used in
	  setting the initial step size; if this argument is omitted
	  the default is <math>d</math> = 0.01.
	</para>
	<para>
	  Here is an example of usage:
	</para>
	<code>
	  matrix H = numhess(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	    <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Returns a series of consecutive integers, setting 1 at the
	  start of the dataset. Note that the result is invariant to
	  subsampling. This function is especially useful with
	  time-series datasets. Note: you can write <lit>t</lit>
	  instead of <lit>obs</lit> with the same effect.
	</para>
	<para>
	  <seelist>
            <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string-or-strings">
      <fnargs>
	<fnarg type="scalar-or-vec">t</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>t</argname> is a scalar, returns a single
	  string, the observation label for observation
	  <argname>t</argname>. The inverse function is provided by
	  <fncref targ="obsnum"/>.
	</para>
	<para>
	  If <argname>t</argname> is a vector, returns an array of
	  strings, the observation labels for the observations given
	  by the elements of <argname>t</argname>.
	</para>
	<para>
	  In either case the <argname>t</argname> values must be
	  integers, valid as 1-based indices of observations in the
	  current dataset, otherwise an error is flagged.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an integer corresponding to the observation specified by
	  the string <math>s</math>. Note that the result is invariant to
	  subsampling. This function is especially useful with time-series
	  datasets.  For example, the following code
	</para>
	<code>
	  open denmark
	  k = obsnum(1980:1)
	</code>
	<para>
	  yields <lit>k = 25</lit>, indicating that the first quarter of
	  1980 is the 25th observation in the <lit>denmark</lit> dataset.
	</para>
	<para>
	  <seelist>
            <fncref targ="obs"/>
            <fncref targ="obslabel"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a scalar, returns 1 if
	  <argname>x</argname> is not <lit>NA</lit>, otherwise 0.  If
	  <argname>x</argname> is a series, returns a series with
	  value 1 at observations with non-missing values and zeros
	  elsewhere. If <argname>x</argname> is a list, the output is
	  a series with 0 at observations for which at least one
	  series in the list has a missing value, and 1 otherwise.
	</para>
	<para>
	  If <argname>x</argname> is a matrix the function returns a
	  matrix of the same dimensions as <argname>x</argname>, with
	  1s in positions corresponding to finite elements of
	  <argname>x</argname> and 0s in positions where the elements
	  are non-finite (either infinities or not-a-number, as per
	  the IEEE 754 standard).
	</para>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	  But note that these functions are not applicable to matrices.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns the 1-norm of the matrix <argname>X</argname>, that is,
	  the maximum across the columns of <argname>X</argname> of the
	  sum of absolute values of the column elements.
	</para>
	<para context="tex">
	  Returns the 1-norm of the $r \times c$ matrix
	  <argname>X</argname>:
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
            <fncref targ="infnorm"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Outputs a matrix with <math>r</math> rows and <math>c</math>
	  columns, filled with ones. If omitted, the number of columns
	  defaults to 1 (column vector).
	</para>
	<para>
	  <seelist>
            <fncref targ="seq"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the forward orthogonal deviations for
	  variable <argname>y</argname>.
	</para>
	<para context="tex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the forward orthogonal deviations for
	  variable <argname>y</argname>, that is
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t}{T_i - t + 1}} \left( y_{i,t} -
	  \frac{1}{T_i - t} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  This transformation is sometimes used instead of
	  differencing to remove individual effects from panel data.
	  For compatibility with first differences, the deviations are
	  stored one step ahead of their true temporal location (that
	  is, the value at observation <math>t</math> is the deviation
	  that, strictly speaking, belongs at <math>t</math> &minus;
	  1).  That way one loses the first observation in each time
	  series, not the last.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, shape, scale, y)</example>
      </examples>
      <description>
	<para>
	  Probability density function calculator. Returns the density
	  at <argname>x</argname> of the distribution identified by
	  the code <argname>d</argname>.  See <fncref targ="cdf"/> for
	  details of the required (scalar) arguments.  The
	  distributions supported by the <lit>pdf</lit> function are
	  the normal, Student's <math>t</math>, chi-square,
	  <math>F</math>, Gamma, Beta, Exponential, Weibull, Laplace,
	  Generalized Error, Binomial and Poisson. Note that for the
	  Binomial and the Poisson what's calculated is in fact the
	  probability mass at the specified point. For Student's
	  <math>t</math>, chi-square, <math>F</math> the noncentral
	  variants are supported too.
	</para>
	<para>
	  For the normal distribution, see also <fncref targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">bandwidth</fnarg>
      </fnargs>
      <description>
	<para>
	  If only the first argument is given, computes the sample periodogram
	  for the given series or vector. If the second argument is given,
	  computes an estimate of the spectrum of <argname>x</argname> using a
	  Bartlett lag window of the given bandwidth, up to a maximum of half
	  the number of observations (<math>T</math>/2).
	</para>
	<para>
	  Returns a matrix with two columns and <math>T</math>/2 rows:
	  the first column holds the frequency, &omega;, from
	  2&pi;/<math>T</math> to &pi;, and the second the
	  corresponding spectral density.
	</para>
      </description>
    </function>

    <function name="pexpand" section="panel" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
        <fnarg type="bool" optional="true">by_individual</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the currently open dataset has a panel
	  structure. By default, performs the inverse operation of
	  <fncref targ="pshrink"/>. That is, given a vector of length
	  equal to the number of individuals in the current panel
	  sample, it returns a series in which each value is repeated
	  <math>T</math> times, for <math>T</math> the time-series
	  length of the panel. The resulting series is therefore
	  non-time varying.
	</para>
        <para>
          If a non-zero value is given for
          <argname>by_individual</argname>, the length of
          <argname>v</argname> should equal <math>T</math> and
          repetition is across the individuals in the panel.
        </para>
      </description>
    </function>

    <function name="pmax" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the maxima of variable
	  <argname>y</argname> for each cross-sectional unit (repeated
	  for each time period).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the time-mean of
	  variable <argname>y</argname> for each cross-sectional unit,
	  the values being repeated for each period. Missing
	  observations are skipped in calculating the means.
	</para>
	<para context="tex">
	  Only applicable if the current dataset has a panel
	  structure. Computes the time-mean of variable
	  <argname>y</argname> for each cross-sectional unit; that is,
	  \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\]
	  where $T_i$ is the number of valid observations for unit
	  $i$.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the minima of variable
	  <argname>y</argname> for each cross-sectional unit (repeated
	  for each time period).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the number of valid
	  observations of variable <argname>y</argname> for each
	  cross-sectional unit (repeated for each time period).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="math" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Finds the roots of a polynomial.  If the polynomial is of degree
	  <math>p</math>, the vector <argname>a</argname> should contain
	  <math>p</math> + 1 coefficients in ascending order, &ie; starting
	  with the constant and ending with the coefficient on
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  The return value is a complex column vector of length
	  <math>p</math>.
	</para>
      </description>
    </function>

    <function name="polyfit" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Fits a polynomial trend of order <argname>q</argname> to the
	  input series <argname>y</argname> using the method of
	  orthogonal polynomials. The series returned holds the
	  fitted values.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">covmat</fnarg>
      </fnargs>
      <description>
	<para>
	  Let the matrix <argname>X</argname> be <by r="T" c="k"/>,
	  containing <math>T</math> observations on <math>k</math>
	  variables.  The argument <argname>p</argname> must be a
	  positive integer less than or equal to <math>k</math>. This
	  function returns a <by r="T" c="p"/> matrix, <math>P</math>,
	  holding the first <math>p</math> principal components of
	  <argname>X</argname>.
	</para>
	<para>
	  The optional third argument acts as a boolean switch: if it is
	  non-zero the principal components are computed on the basis of
	  the covariance matrix of the columns of <argname>X</argname>
	  (the default is to use the correlation matrix).
	</para>
	<para context="notex">
	  The elements of <math>P</math> are computed as the sum from
	  <math>i</math> to <math>k</math> of
	  <math>Z</math><sub>ti</sub> times
	  <math>v</math><sub>ji</sub>, where
	  <math>Z</math><sub>ti</sub> is the standardized value (or
	  just the centered value, if the covariance matrix is used)
	  of variable <math>i</math> at observation <math>t</math> and
	  <math>v</math><sub>ji</sub> is the <math>j</math>th
	  eigenvector of the correlation (or covariance) matrix of the
	  <math>X</math><sub>i</sub>s, with the eigenvectors ordered
	  by decreasing value of the corresponding eigenvalues.
	</para>
	<para context="tex">
	  The elements of $P$ are computed as \[ P_{tj} =
	  \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \] where $Z_{ti}$ is the
	  standardized value (or just the centered value, if the
	  covariance matrix is used) of variable $i$ at observation
	  $t$, $Z_{ti} = (X_{ti} - \bar{X}_i) / \hat{\sigma}_i$, and
	  $v^{(j)}_i$ is the $j$th eigenvector of the correlation (or
	  covariance) matrix of the $X_i$s, with the eigenvectors
	  ordered by decreasing value of the corresponding
	  eigenvalues.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the product of the elements of <argname>X</argname>,
	  by column. If a non-zero value is given for the optional
	  second argument missing values are ignored, otherwise the
	  result is <lit>NA</lit> for any columns that contain missing
	  values. Note that specifying <argname>skip_na</argname> is
	  equivalent to treating missing values as if they were 1s.
	</para>
	<para>
	  <seelist>
            <fncref targ="prodr"/>
            <fncref targ="meanc"/>
            <fncref targ="sdc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the product of the elements of <argname>X</argname>,
	  by row. If a non-zero value is given for the optional second
	  argument missing values are ignored, otherwise the result is
	  <lit>NA</lit> for any rows that contain missing values.
	  Note that specifying <argname>skip_na</argname> is
	  equivalent to treating missing values as if they were 1s.
	</para>
	<para>
	  <seelist>
            <fncref targ="prodc"/>
            <fncref targ="meanr"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the sample standard
	  deviation of variable <math>y</math> for each
	  cross-sectional unit (with the values repeated for each time
	  period).  The denominator used is the sample size for each
	  unit minus 1, unless the number of valid observations for
	  the given unit is 1 (in which case 0 is returned) or 0 (in
	  which case <lit>NA</lit> is returned).
	</para>
	<para context="tex">
	  Only applicable if the current dataset has a panel
	  structure. Computes the per-unit sample standard deviation
	  for variable <math>y</math>, that is \[ \sigma_i =
	  \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} -
	  \bar{y}_i)^2 } \] The above formula holds for $T_i \ge 2$,
	  where $T_i$ is the number of valid observations for unit
	  $i$; if $T_i = 0$, <lit>NA</lit> is returned; if $T_i = 1$,
	  0 is returned.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  Note: this function makes it possible to check whether a given
	  variable (say, <lit>X</lit>) is time-invariant via the condition
	  <lit>max(psd(X)) == 0</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="bool" optional="true">psdcheck</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a generalized variant of the Cholesky decomposition
	  of the matrix <argname>A</argname>, which must be positive
	  semidefinite (but may be singular). If the input matrix is
	  not square an error is flagged, but symmetry is assumed and
	  not tested; only the lower triangle of <argname>A</argname>
	  is read.  The result is a lower-triangular matrix
	  <math>L</math> which satisfies <equation status="inline"
	  ascii="A = LL'" tex="$A = LL'$"/>.  Indeterminate elements
	  in the solution are set to zero.
	</para>
	<para>
	  To force a check on the positive semidefiniteness of
	  <argname>A</argname>, give a non-zero value for the optional
	  second argument. In that case an error is flagged if the
	  maximum absolute value of <equation status="inline" ascii="A
	  &minus; LL'" tex="$A - LL'$"/> exceeds 1.0e-8. Such a check
	  can also be performed manually:
	</para>
	<code>
	  L = psdroot(A)
	  chk = maxc(maxr(abs(A - L*L')))
	</code>
	<para>
	  For the case where <argname>A</argname> is positive definite,
	  see <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="panel" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a column vector holding the first valid
	  observation for the series <argname>y</argname> for each
	  cross-sectional unit in the panel, over the current sample
	  range. If a unit has no valid observations for the input
	  series it is skipped.
	</para>
	<para>
	  This function provides a means of compacting the series
	  returned by functions such as <fncref targ="pmax"/> and
	  <fncref targ="pmean"/>, in which a value pertaining to
	  each cross-sectional unit is repeated for each time
	  period.
	</para>
	<para>
	  See <fncref targ="pexpand"/> for the inverse operation.
	</para>
      </description>
    </function>

    <function name="psum" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  This function is applicable only if the current dataset has
	  a panel structure. It returns a series holding the sum over
	  time of variable <argname>y</argname> for each
	  cross-sectional unit, the values being repeated for each
	  period. Missing observations are skipped in calculating the
	  sums.
	</para>
	<para context="tex">
	  This function is applicable only if the current dataset has
	  a panel structure. It computes the sum over time of variable
	  <argname>y</argname> for each cross-sectional unit; that is,
	  \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\] where $T_i$ is the
	  number of valid observations for unit $i$.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  <math>P</math>-value calculator. Returns <equation
	  status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>, where
	  the distribution of <math>X</math> is determined by the
	  character <argname>c</argname>. Between the arguments
	  <argname>c</argname> and <argname>x</argname>, zero or more
	  additional arguments are required to specify the parameters
	  of the distribution; see <fncref targ="cdf"/> for details.
	  The distributions supported by the <lit>pvalue</lit>
	  function are the standard normal, <math>t</math>, Chi
	  square, <math>F</math>, gamma, binomial, Poisson,
	  Exponential, Weibull, Laplace and Generalized Error.
	</para>
	<para>
	  <seelist>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="urcpval"/>
            <fncref targ="imhof"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxnobs" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the number of valid
	  observations of <argname>y</argname> in each time period
	  (this count being repeated for each unit).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  Note that this function works in a different dimension from
	  the <fncref targ="pnobs"/> function.
	</para>
      </description>
    </function>

    <function name="pxsum" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the sum of the values of
	  <argname>y</argname> for each cross-sectional unit in each
	  period (the values being repeated for each unit).
	</para>
	<para context="tex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the cross-sectional sum for variable
	  <argname>y</argname> in each period; that is,
	  \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\]
	  where $N$ is the number of cross-sectional units.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  Note that this function works in a different dimension from
	  the <fncref targ="psum"/> function.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the quadratic form <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>.  Using this function
	  instead of ordinary matrix multiplication guarantees more
	  speed and better accuracy, when <argname>A</argname> is a
	  generic symmetric matrix. However, in the special case when
	  <argname>A</argname> is the identity matrix, the simple
	  expression <lit>x'x</lit> performs much better than
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Computes the quadratic form <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>.  Using this function
	  instead of ordinary matrix multiplication guarantees more
	  speed and better accuracy, when <argname>A</argname> is a
	  generic symmetric matrix.  However, in the special case <equation
	  status="inline" ascii="A = I" tex="$A = I$"/>, the simple
	  expression <lit>x'x</lit> performs much better than
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	  In the special case when <argname>A</argname> is a diagonal
	  matrix, the second argument can be given as a vector of the
	  appropriate size, which is understood to contain the main
	  diagonal of <argname>A</argname>. In this case, a more
	  efficient algorithm is used.
	</para>
	<para>
	  If <argname>x</argname> and <argname>A</argname> are not
	  conformable, or <argname>A</argname> is not symmetric, an error
	  is returned.
	</para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">df</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-values for the test statistic from the QLR
	  sup-Wald test for a structural break at an unknown point
	  (see <cmdref targ="qlrtest"/>), as per <cite
	  key="hansen97">Bruce Hansen (1997)</cite>.
	</para>
	<para>
	  The first argument, <argname>X2</argname>, denotes the
	  (chi-square form of) the maximum Wald test statistic and
	  <argname>df</argname> denotes its degrees of freedom.  The
	  third and fourth arguments represent, as decimal fractions
	  of the overall estimation range, the starting and ending
	  points of the central range of observations over which the
	  successive Wald tests are calculated. For example if the
	  standard approach of 15 percent trimming is adopted, you
	  would set <argname>p1</argname> to 0.15 and
	  <argname>p2</argname> to 0.85.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns quantiles for the standard normal distribution. If
	  <argname>x</argname> is not between 0 and 1, <lit>NA</lit> is
	  returned.
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
	<fnarg type="matrixref" optional="true">&amp;P</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the <quote>thin</quote> QR decomposition of an <by
	  r="m" c="n"/> matrix <argname>X</argname> with
	  <math>m</math> &ge; <math>n</math>, such that <math>X =
	  QR</math> where <math>Q</math> is an <by r="m" c="n"/>
	  orthogonal matrix and <math>R</math> is an <by r="n" c="n"/>
	  upper triangular matrix. The matrix <math>Q</math> is
	  returned directly, while <math>R</math> can be retrieved via
	  the optional second argument.
	</para>
	<para>
	  If the optional third argument is supplied the decomposition
	  employs column pivoting, and on successful completion
	  <argname>P</argname> holds the final ordering of the columns
	  in the form of a row vector. If the columns are not in fact
	  reordered <argname>P</argname> will compare equal to
	  <fncref targ="seq"/><lit>(1, n)</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">type</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="n" c="2"/> matrix for use with Gaussian
	  quadrature (numerical integration). The first column holds
	  the nodes or abscissae, the second the weights.
	</para>
	<para>
	  The first argument specifies the number of points (rows) to
	  compute. The second argument codes for the type of
	  quadrature: use 1 for Gauss&ndash;Hermite (the default);
	  2 for Gauss&ndash;Legendre; or 3 for Gauss&ndash;Laguerre.
	  The significance of the optional parameters
	  <argname>a</argname> and <argname>b</argname> depends on the
	  selected <argname>type</argname>, as explained below.
	</para>
	<para context="notex">
	  Gaussian quadrature is a method of approximating numerically
	  the definite integral of some function of interest. Let the
	  function be represented as the product
	  <math>f(x)W(x)</math>. The types of quadrature differ in the
	  specification of the component <math>W(x)</math>: in the
	  Hermite case this is exp(&minus;<math>x</math><sup>2</sup>);
	  in the Laguerre case, exp(&minus;<math>x</math>); and in the
	  Legendre case simply <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  Gaussian quadrature is a method of approximating numerically
	  the definite integral of some function of interest. Let the
	  function be represented as the product $f(x)W(x)$. The types
	  of quadrature differ in the specification of the component
	  $W(x)$: in the Hermite case we have $W(x) = \exp(-x^2)$; in
	  the Laguerre case, $W(x) = \exp(-x)$; and in the Legendre
	  case simply $W(x) = 1$.
	</para>
	<para context="notex">
	  For each specification of <math>W</math>, one can compute a
	  set of nodes, <math>x</math><sub>i</sub>, and weights,
	  <math>w</math><sub>i</sub>, such that the sum from
	  <math>i</math>=1 to <math>n</math> of
	  <math>w</math><sub>i</sub>
	  <math>f</math>(<math>x</math><sub>i</sub>) approximates the
	  desired integral. The method of <cite key="golub69">Golub
	  and Welsch (1969)</cite> is used.
	</para>
	<para context="tex">
	  For each specification of $W(x)$, one can compute a set of
	  nodes, $x_i$, and weights, $w_i$, such that $\sum_{i=1}^n
	  f(x_i) w_i$ approximates the desired integral. The method of
	  <cite key="golub69">Golub and Welsch (1969)</cite> is used.
	</para>
	<para context="notex">
	  When the Gauss&ndash;Legendre type is selected, the
	  optional arguments <argname>a</argname> and
	  <argname>b</argname> can be used to control the lower and
	  upper limits of integration, the default values being
	  &minus;1 and 1. (In Hermite quadrature the
	  limits are fixed at minus and plus infinity, while in
	  the Laguerre case they are fixed at 0 and infinity.)
	</para>
	<para context="tex">
	  When the Gauss&ndash;Legendre type is selected, the optional
	  arguments <argname>a</argname> and <argname>b</argname> can
	  be used to control the lower and upper limits of
	  integration, the default values being $-1$ and 1. (In Hermite
	  quadrature the limits are fixed at $-\infty$ and $+\infty$,
	  while in the Laguerre case they are fixed at 0 and $\infty$.)
	</para>
	<para context="notex">
	  In the Hermite case <argname>a</argname> and
	  <argname>b</argname> play a different role: they can be used
	  to replace the default form of
	  <math>W</math>(<math>x</math>) with the (closely related)
	  normal distribution with mean <argname>a</argname> and
	  standard deviation <argname>b</argname>. Supplying values of
	  0 and 1 for these parameters, for example, has the effect of
	  making <math>W</math>(<math>x</math>) into the standard
	  normal pdf, which is equivalent to multiplying the default
	  nodes by the square root of two and dividing the weights by
	  the square root of &pi;.
	</para>
	<para context="tex">
	  In the Hermite case <argname>a</argname> and
	  <argname>b</argname> play a different role: they can be used
	  to replace the default form of $W(x)$ with the
	  (closely related) normal distribution with mean
	  <argname>a</argname> and standard deviation
	  <argname>b</argname>. Supplying values of 0 and 1 for these
	  parameters, for example, has the effect of making
	  $W(x)$ into the standard normal pdf, which is equivalent
	  to multiplying the default $x_i$ values by $\sqrt{2}$
	  and dividing the default $w_i$ by $\sqrt{\pi}$.
	</para>
      </description>
    </function>

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>y</argname> is a series, returns the
	  <argname>p</argname>-quantile for the series. For example, when
	  <math>p</math> = 0.5, the median is returned.
	</para>
	<para>
	  If <argname>y</argname> is a matrix, returns a row vector
	  containing the <argname>p</argname>-quantiles for the columns of
	  <argname>y</argname>; that is, each column is treated as a
	  series.
	</para>
	<para>
	  In addition, for matrix <argname>y</argname> an alternate form
	  of the second argument is supported: <argname>p</argname> may be
	  given as a vector. In that case the return value is an <by r="m"
	  c="n"/> matrix, where <repl>m</repl> is the number of elements
	  in <argname>p</argname> and <repl>n</repl> is the number of
	  columns in <argname>y</argname>.
	</para>
	<para>
	  <cite key="hyndman96">Hyndman and Fan (1996)</cite> describe
	  nine variant methods for calculating sample quantiles. The
	  default method in gretl is the one they call
	  <math>Q</math><sub>6</sub> (which is also the default in
	  Python). Method <math>Q</math><sub>7</sub> (the default in
	  R) or <math>Q</math><sub>8</sub> (the one recommended by
	  Hyndman and Fan) can be selected instead via the <cmdref
	  targ="set"/> command, as in
	</para>
	<code>
	  set quantile_type Q7 # or Q8
	</code>
	<para context="tex">
	  The $p$-quantile, $Q_p$, for a series $y$ of length $n$ is
	  defined as:
	  \[Q_p = y_{[k]} + (h - k) (y_{[k+1]} - y_{[k]})\]
	  where $k$ is the integer part of $h$, a term that
	  differs by method---$h=(n+1)p$ for $Q_6$, $(n-1)p+1$
	  for $Q_7$ and $(n+1/3)p + 1/3$ for $Q_8$---and $y_{[i]}$ is the
	  $i$-th element of the series when sorted from smallest to
	  largest.
	</para>
	<para>
	For example, the code
	</para>
	<code>
	  set verbose off
	  matrix x = seq(1,7)'
	  set quantile_type Q6
	  printf "Q6: %g\n", quantile(x, 0.45)
	  set quantile_type Q7
	  printf "Q7: %g\n", quantile(x, 0.45)
	  set quantile_type Q8
	  printf "Q8: %g\n", quantile(x, 0.45)
	</code>
	<para>
	produces the following output:
	</para>
	<code>
	  Q6: 3.6
	  Q7: 3.7
	  Q8: 3.63333
	</code>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  All-purpose random number generator. The argument
	  <argname>d</argname> is a string (in most cases just a
	  single character) which specifies the distribution from
	  which the pseudo-random numbers should be drawn. The
	  arguments <argname>p1</argname> to <argname>p3</argname>
	  specify the parameters of the selected distribution; the
	  number of such parameters (and, in some cases, their nature)
	  depends on the distribution.
	</para>
	<para>
	  For distributions other than the beta-binomial and the
	  generic discrete, the parameters <argname>p1</argname> and
	  (if applicable) <argname>p2</argname> may be given as either
	  scalars or series: if they are given as scalars the output
	  series is identically distributed, while if a series is
	  given for <argname>p1</argname> or <argname>p2</argname> the
	  distribution is conditional on the parameter value at each
	  observation.
	</para>
	<para>
          The two special cases have the following requirements:
        </para>
        <ilist>
          <li>
            <para>
              beta-binomial: all three parameters must be scalar.
            </para>
          </li>
          <li>
            <para>
              generic discrete: a single parameter is wanted, namely a
              <math>k</math>-vector whose elements represent the
              probabilities for an integer-valued random variable with
              support from 1 to <math>k</math>.
            </para>
          </li>
        </ilist>
	<para>
	  Specifics are given below: the string code for each
	  distribution is shown in parentheses, followed by the
	  interpretation of the arguments <argname>p1</argname> and,
	  where applicable, <argname>p2</argname> and
	  <argname>p3</argname>.
	</para>

	<ilist context="notex">
	  <li>
            <para>
              Uniform (continuous) (u or U): minimum, maximum
            </para>
	  </li>
	  <li>
            <para>
              Uniform (discrete) (i): minimum, maximum
            </para>
	  </li>
	  <li>
            <para>
              Normal (z, n, or N): mean, standard deviation
            </para>
	  </li>
	  <li>
            <para>
              Student's t (t): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x, or X): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Snedecor's F (f or F): df (num.), df (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g or G): shape, scale
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b or B): probability, number of trials
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p or P): mean
            </para>
	  </li>
	  <li>
            <para>
              Exponential (exp): scale
            </para>
	  </li>
	  <li>
            <para>
              Logistic (lgt or s): location, scale
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w or W): shape, scale
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l or L): mean, scale
            </para>
	  </li>
	  <li>
            <para>
              Generalized Error (E): shape
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): shape1, shape2
            </para>
	  </li>
	  <li>
            <para>
              Beta-Binomial (bb): trials, shape1, shape2
            </para>
	  </li>
	  <li>
            <para>
              Generic discrete (disc): probabilities
            </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textbf{Distribution} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniform (continuous) &amp; \texttt{u} or \texttt{U} &amp; minimum &amp; maximum &amp; --\\
	  Uniform (discrete) &amp; \texttt{i} &amp; minimum &amp; maximum &amp; --\\
	  Normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp; mean &amp; standard deviation &amp; --\\
	  Student's $t$ &amp; \texttt{t} &amp; degrees of freedom &amp; -- &amp; --\\
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; degrees of freedom &amp; -- &amp; --\\
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp; df (num.) &amp; df (den.) &amp; --\\
	  Gamma &amp; \texttt{g} or \texttt{G} &amp; shape &amp; scale  &amp; --\\
	  Binomial &amp; \texttt{b} or \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} or \texttt{P} &amp; mean &amp; -- &amp; --\\
	  Exponential &amp; \texttt{exp} &amp; scale &amp; -- &amp; --\\
	  Logistic &amp; \texttt{s} &amp; location &amp; scale &amp; --\\
	  Weibull &amp; \texttt{w} or \texttt{W} &amp; shape &amp; scale &amp; --\\
	  Laplace &amp; \texttt{l} or \texttt{L} &amp; mean &amp; scale &amp; --\\
	  Generalized Error &amp; \texttt{e} or \texttt{E} &amp; shape &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; shape1 &amp; shape2 &amp; --\\
	  Beta-Binomial &amp; \texttt{bb} &amp; $n$ &amp; shape1 &amp; shape2 \\
	  Generic discrete &amp; \texttt{disc} &amp; $\mathbf{p}$ &amp; -- &amp; --
	</tabular>
	<para>
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="uniform"/>
            <fncref targ="mrandgen"/>
            <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Works like <fncref targ="randgen"/> except that the return
	  value is a scalar rather than a series.
	</para>
	<para>
	  The first example above calls for a value from the standard
	  normal distribution, while the second specifies a drawing
	  from the Gamma distribution with shape 3 and scale 2.5.
	</para>
	<para>
	  <seelist>
            <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a pseudo-random integer in the closed interval
	  [<argname>min</argname>, <argname>max</argname>].
	  <seelist>
	    <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randperm" section="probdist" output="vector">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  If only the first argument is given, returns a row vector
	  containing a random permutation of the integers from 1 to
	  <argname>n</argname>, without repetition of elements.  If the
	  second argument is given it must be a positive integer in
	  the range 1 to <argname>n</argname>; in this case the
	  function returns a row vector containing
	  <argname>k</argname> integers selected randomly from 1 to
	  <argname>n</argname> without replacement.
	</para>
	<para>
	  If you wish to sample <math>k</math> rows from a matrix
	  <lit>X</lit> with <math>n</math> rows (without replacement),
	  that can be accomplished as shown below:
	</para>
	<code>
	  matrix S = X[randperm(n, k),]
	</code>
	<para>
	  And if you wish to preserve the original order of the rows
	  in the sample:
	</para>
	<code>
	  matrix S = X[sort(randperm(n, k)),]
	</code>
	<para>
	  See also <fncref targ="resample"/> for resampling with
	  replacement.
	</para>
      </description>
    </function>

    <function name="randstr" section="strings" output="string">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a random string of length <argname>n</argname>
	  bytes. The string includes the numerals <lit>0</lit> to
	  <lit>9</lit> and the lower-case letters <lit>a</lit> to
	  <lit>f</lit> with equal probability, and is interpretable as
	  a hexadecimal integer. Intended usage is as a unique
	  identifier. For example, with <argname>n</argname> = 16 the
	  string will one of over 10<sup>19</sup> possibilities and so
	  unique with probability close to 1.
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">tol</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the rank of the <by r="r" c="c"/> matrix
	  <argname>X</argname>, numerically computed via the singular
	  value decomposition.
	</para>
	<para>
	  The result of this operation is the number of singular
	  values of <argname>X</argname> that are found to be
	  numerically greater than 0. The <argname>tol</argname>
	  optional parameter can be used for tweaking this
	  aspect. Singular values are considered to be non-zero if
	  they are greater than <math>m &times; tol &times; s</math>,
	  where <math>m</math> is the greater of <math>r</math> and
	  <math>c</math> and <math>s</math> is the largest singular
	  value. If the second argument is omitted
	  <argname>tol</argname> is set to machine epsilon (see
	  <fncref targ="$macheps"/>). In some cases, you may want to
	  set <argname>tol</argname> to a larger value (eg 1.0e-9) in
	  order to avoid overestimating the rank of
	  <argname>X</argname>, which may lead to numerically unstable
	  results.
	</para>
	<para>
	  <seelist>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a series or vector with the ranks of
	  <math>y</math>. The rank for observation <math>i</math> is
	  the number of elements that are less than
	  <math>y</math><sub>i</sub> plus one half the number of
	  elements that are equal to
	  <math>y</math><sub>i</sub>. (Intuitively, you may think of
	  chess points, where victory gives you one point and a draw
	  gives you half a point.) One is added so the lowest rank is
	  1 instead of 0.
	</para>
	<para context="tex">
	  Formally,
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \]
	  where $I$ denotes the indicator function.
	</para>
	<para>
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the reciprocal condition number for <argname>A</argname>
	  with respect to the 1-norm.  In many circumstances, this is a better
	  measure of the sensitivity of <argname>A</argname> to numerical
	  operations such as inversion than the determinant.
	</para>
	<para context="notex">
	  The value is computed as the reciprocal of the product, 1-norm
	  of <argname>A</argname> times 1-norm of
	  <argname>A</argname>-inverse.
	</para>
	<para context="tex">
	  Given that <math>A</math> is non-singular, we may define
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\]
	  This function returns $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="ldet"/>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="Re" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a real matrix of the same dimensions as
	  <argname>C</argname>, holding the real part of the
	  input matrix. See also <fncref targ="Im"/>.
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg type="string" optional="true">codeset</fnarg>
      </fnargs>
      <description>
	<para>
	  If a file by the name of <argname>fname</argname> exists and
	  is readable, returns a string containing the content of this
	  file, otherwise flags an error.  If <argname>fname</argname>
	  does not contain a full path specification, it will be
	  looked for in several <quote>likely</quote> locations,
	  beginning with the currently set <cmdref targ="workdir"/>.
	  If the file in question is gzip-compressed, this is handled
	  transparently.
	</para>
	<para>
	  If <argname>fname</argname> starts with the identifier of a
	  supported internet protocol (<lit>http://</lit>,
	  <lit>ftp://</lit> or <lit>https://</lit>), libcurl is invoked to
	  download the resource. See also <fncref targ="curl"/> for
	  more elaborate downloading operations.
	</para>
	<para>
	  If the text to be read is not encoded in UTF-8, gretl will
	  try recoding it from the current locale codeset if that is
	  not UTF-8, or from ISO-8859-15 otherwise. If this simple
	  default does not meet your needs you can use the optional
	  second argument to specify a codeset. For example, if you
	  want to read text in Microsoft codepage 1251 and that is not
	  your locale codeset, you should give a second argument of
	  <lit>"cp1251"</lit>.
	</para>
    <para>
        Examples:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        print web_page

        string current_settings = readfile("@dotdir/.gretl2rc")
        print current_settings
    </code>
	<para>
	  Also see the <fncref targ="sscanf"/> and <fncref
	  targ="getline"/> functions.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string">match</fnarg>
	<fnarg type="string">repl</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>s</argname> is a single string, returns a copy
	  of <argname>s</argname> in which all occurrences of the
	  pattern <argname>match</argname> are replaced using
	  <argname>repl</argname>. The arguments
	  <argname>match</argname> and <argname>repl</argname> are
	  interpreted as Perl-style regular expressions. If
	  <argname>s</argname> is an array of strings or string-valued
	  series this operation is performed on each string in the
	  array or series.
	</para>
	<para>
	  See also <fncref targ="strsub"/> for simple substitution of
	  literal strings.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>
      <description>
	<para>
	  If a file by the name of <argname>fname</argname> exists and
	  is writable by the user, this function removes (deletes) the
	  file and returns 0. If there is no such file or for some
	  reason the file cannot be deleted, a non-zero error code is
	  returned.
	</para>
	<para>
	  If <argname>fname</argname> does not specify a full path, it
	  is taken to be relative to the current <cmdref
	  targ="workdir"/>.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">find</fnarg>
	<fnarg type="scalar-or-vec">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  Replaces each element of <argname>x</argname> equal to
	  the <math>i</math>-th element of <argname>find</argname>
	  with the corresponding element of <argname>subst</argname>.
	</para>
	<para>
	  If <argname>find</argname> is a scalar, <argname>subst</argname>
	  must also be a scalar.  If <argname>find</argname> and
	  <argname>subst</argname> are both vectors, they must have the same
	  number of elements.  But if <argname>find</argname> is a vector and
	  <argname>subst</argname> a scalar, then all matches will be replaced
	  by <argname>subst</argname>.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  find = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, find, subst)
	  print a b
	</code>
	<para>
	  produces
	</para>
	<code>
          a (2 x 3)

          1   2   3
          3   4   5

          b (2 x 3)

          -1    2   -8
          -8    0    5
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">blocksize</fnarg>
	<fnarg optional="true" type="int">draws</fnarg>
      </fnargs>
      <description>
	<para>
	  The initial description of this function pertains to
	  cross-sectional or time-series data; see below for
	  the case of panel data.
	</para>
	<para>
	  Resamples from <argname>x</argname> with replacement.  In
	  the case of a series argument, each value of the returned
	  series, <math>y</math><sub>t</sub>, is drawn from among all
	  the values of <math>x</math><sub>t</sub> with equal
	  probability.  When a matrix argument is given, each row of
	  the returned matrix is drawn from the rows of
	  <argname>x</argname> with equal probability. See also
	  <fncref targ="randperm"/> for sampling rows from a matrix
	  without replacement.
	</para>
	<para>
	  The optional argument <argname>blocksize</argname>
	  represents the block size for resampling by moving blocks.
	  If this argument is given it should be a positive integer
	  greater than or equal to 2. The effect is that the output is
	  composed by random selection with replacement from among all
	  the possible contiguous sequences of length
	  <argname>blocksize</argname> in the input.  (In the case of
	  matrix input, this means contiguous rows.) If the length of
	  the data is not an integer multiple of the block size, the
	  last selected block is truncated to fit.
	</para>
	<subhead>Number of draws</subhead>
	<para>
	  By default the number of resampled observations in the
	  output is equal to that in the input&mdash;if
	  <argname>x</argname> is a series, the length of the current
	  sample range; if <argname>x</argname> is a matrix, its
	  number of rows.  In the matrix case
	  <emphasis>only</emphasis> this can be adjusted via the
	  optional third argument, which must be a positive integer.
	  Note that if <argname>blocksize</argname> is greater than
	  1, <argname>draws</argname> refers to the number of
	  individual observations, not the number of blocks.
	</para>
	<subhead>Panel data</subhead>
	<para>
	  If the argument <argname>x</argname> is a series and the
	  dataset takes the form of a panel, resampling by moving
	  blocks is not supported. The basic form of resampling is
	  supported, but has this specific interpretation: the data
	  are resampled <quote>by individual</quote>. Suppose you have
	  a panel in which 100 individuals are observed over 5
	  periods. Then the returned series will again be composed of
	  100 blocks of 5 observations: each block will be drawn with
	  equal probability from the 100 individual time series, with
	  the time-series order preserved.
	</para>
      </description>
    </function>

    <function name="rgbmix" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="string">color1</fnarg>
	<fnarg type="string">color2</fnarg>
	<fnarg type="matrix">f</fnarg>
	<fnarg type="bool" optional="true">plot</fnarg>
      </fnargs>
      <description>
	<para>
	  Given two colors and a vector <argname>f</argname> of
	  length <math>n</math> containing values in [0,1], this
	  function returns an array of <math>n</math> strings, element
	  <math>i</math> of which holds the hexadecimal RGB code for a
	  mixture of the form (1-<math>f</math><sub>i</sub>) &times;
	  <lit>color1</lit> + <math>f</math><sub>i</sub> &times;
	  <lit>color2</lit>. The weighted average is taken over
	  the Red, Green and Blue channels of the input colors.
	</para>
	<para>
	  The color arguments can be specified by names known to
	  <cmdref targ="gnuplot"/>, or as hexadecimal values in the form
	  <lit>0xrrggbb</lit> or <lit>#rrggbb</lit>. Hex values in the
	  first of these forms may be given numerically, otherwise
	  strings are needed. If a non-zero value is given for the
	  <argname>plot</argname> argument, a plot that shows the
	  color mixtures is produced.
	</para>
	<para>
	  This function offers a means of generating a set of related
	  colors for plotting purposes, the primary use case being
	  specification of multiple bands in a plot (for example, to
	  indicate confidence intervals at more than one level). Three
	  examples follow: the first produces successive lightenings of
	  an initial blue; the second progressive darkenings of a
	  pink shade; and the third a transition from red to yellow.
	</para>
	<code>
	  f = {0, 0.5, 0.75, 0.875, 0.9375}
	  mixes = rgbmix(0x1b43dc, "white", f, 1)
	  print mixes
	  f = {0, 0.1, 0.2, 0.3, 0.4}
	  rgbmix(0xefd0d3, "black", f, 1)
	  f = {0, 0.2, 0.4, 0.6, 0.8, 1}
	  rgbmix("red", "yellow", f, 1)
	</code>
	<para>
	  The output from the <lit>print</lit> command in the first example
	  is
	</para>
	<code>
	  [1] "0x1b43dc"
	  [2] "0x8da1ee"
	  [3] "0xc6d0f6"
	  [4] "0xe2e8fb"
	  [5] "0xf1f3fd"
	</code>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Rounds to the nearest integer. Note that when <math>x</math>
	  lies halfway between two integers, rounding is done "away
	  from zero", so for example 2.5 rounds to 3, but
	  <lit>round(-3.5)</lit> gives &minus;4. This is a common
	  convention in spreadsheet programs, but other software may
	  yield different results.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">r</fnarg>
      </fnargs>
      <description>
	<para>
	  If the <argname>r</argname> argument is given, retrieves
	  the name for row <argname>r</argname> of matrix
	  <argname>M</argname>. If <argname>M</argname> has no row
	  names attached the value returned is an empty string; if
	  <argname>r</argname> is out of bounds for the given matrix
	  an error is flagged.
	</para>
	<para>
	  If no second argument is given, retrieves an array of
	  strings holding the row names from <argname>M</argname>, or
	  an empty array if the matrix does not have row names
	  attached.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  rnameset(A, "First Second")
	  string name = rnameget(A, 2)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="rnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameset" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Attaches names to the rows of the <by r="m" c="n"/> matrix
	  <argname>M</argname>. If <argname>S</argname> is a named
	  list, the names are taken from the names of the listed
	  series; the list must have <math>m</math> members. If
	  <argname>S</argname> is an array of strings, it should
	  contain <math>m</math> elements. A single string is also
	  acceptable as the second argument; in that case it should
	  contain <math>m</math> space-separated substrings.
	</para>
	<para>
	  The nominal return value is 0 on successful completion; in
	  case of failure an error is flagged.  See also <fncref
	  targ="cnameset"/>.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(3)
	  S[1] = "Row1"
	  S[2] = "Row2"
	  S[3] = "Row3"
	  rnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="rows" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of rows of the matrix <argname>X</argname>.
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="schur" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;Z</fnarg>
	<fnarg type="matrixref" optional="true">&amp;w</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs the Schur decomposition of the complex matrix
	  <argname>A</argname>, returning a complex upper triangular
	  matrix <math>T</math>. If the second argument is given and
	  is not <lit>null</lit> it retrieves a complex matrix
	  <math>Z</math> holding the Schur vectors associated with
	  <math>A</math> and <math>T</math>, such that <math>A</math>
	  = <math>ZTZ</math><sup>H</sup>. If the third argument is
	  given it retrieves the eigenvalues of <math>A</math> in a
	  complex column vector.
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar) sample
	  standard deviation, skipping any missing observations.
	</para>
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  sample standard deviation of the values of the series in
	  the list at observation <math>t</math>.  By default the
	  standard deviation is recorded as <lit>NA</lit> if there are
	  any missing values at <math>t</math>, but if you pass a
	  non-zero value for <argname>partial</argname> any
	  non-missing values will be used to form the statistic.
	</para>
	<para>
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the standard deviations of the columns of
	  <argname>X</argname>. If <argname>df</argname> is positive
	  it is used as the divisor for the column variances,
	  otherwise the divisor is the number of rows in
	  <argname>X</argname> (that is, no degrees of freedom
	  correction is applied). If a non-zero value is given for the
	  optional third argument missing values are ignored,
	  otherwise the result is <lit>NA</lit> for any columns that
	  contain missing values.
	</para>
	<para>
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes seasonal differences: <equation status="inline"
	  ascii="y(t) - y(t-k)"  tex="$y_t - y_{t-k}$"/>, where
	  <math>k</math> is the periodicity of the current dataset (see
	  <fncref targ="$pd"/> or <fncref targ="$panelpd"/>). Starting
	  values are set to <lit>NA</lit>.
	</para>
	<para>
	  When a list is returned, the individual variables are
	  automatically named according to the template
	  <lit>sd_</lit><repl>varname</repl> where
	  <repl>varname</repl> is the name of the original series.
	  The name is truncated if necessary, and may be adjusted in
	  case of non-uniqueness in the set of names thus constructed.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="ldiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">baseline</fnarg>
	<fnarg optional="true" type="bool">center</fnarg>
      </fnargs>
      <description>
	<para>
	  Applicable only if the dataset has a time-series structure
	  with periodicity greater than 1. Returns a list of dummy
	  variables coding for the period or season, named
	  <lit>S1</lit>, <lit>S2</lit> and so on.
	</para>
	<para>
	  The optional <argname>baseline</argname> argument can be
	  used to exclude one period from the set of dummies. For
	  example, if you give a baseline value of 1 with quarterly
	  data the returned list will hold dummies for quarters 2, 3
	  and 4 only.  If this argument is omitted or set to zero a
	  full set of dummies is generated; if non-zero, it must be an
	  integer from 1 to the periodicity of the data.
	</para>
	<para>
	  The <argname>center</argname> argument, if non-zero, calls
	  for the dummies to be centered; that is, to have their
	  population mean subtracted. For example, with quarterly data
	  centered seasonals will have values &minus;0.25 and 0.75
	  rather than 0 and 1.
	</para>
	<para>
	  With weekly data the precise effect depends on whether the
	  data are dated or not. If they are dated, up to 53 seasonals
	  are created, based on the ISO 8601 week number (see <fncref
	  targ="isoweek"/>); if not, the maximum number of series is
	  52 (and over a long time span the <quote>seasonals</quote>
	  will drift out of phase with the calendar year). In the
	  dated weekly case, if you wish to create monthly seasonals
	  this can be done as follows:
	</para>
	<code>
	  series month = $obsminor
	  list months = dummify(month)
	</code>
	<para>
	  See <fncref targ="dummify"/> for details.
	</para>
      </description>
    </function>

    <function name="selifc" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Selects from <argname>A</argname> only the columns for which
	  the corresponding element of <argname>b</argname> is
	  non-zero. <argname>b</argname> must be a row vector with
	  the same number of columns as <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Selects from <argname>A</argname> only the rows for which
	  the corresponding element of <argname>b</argname> is
	  non-zero. <argname>b</argname> must be a column vector with
	  the same number of rows as <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifc"/>
            <fncref targ="trimr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matrix" output="rvec">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg optional="true" type="scalar">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Given only two arguments, returns a row vector filled with
	  values from <argname>a</argname> to <argname>b</argname>
	  with an increment of 1, or a decrement of 1 if
	  <argname>a</argname> is greater than <argname>b</argname>.
	</para>
	<para>
	  If the third argument is given, returns a row vector
	  containing a sequence of values starting with
	  <argname>a</argname> and incremented (or decremented, if
	  <argname>a</argname> is greater than <argname>b</argname>)
	  by <argname>k</argname> at each step.  The final value is
	  the largest member of the sequence that is less than or
	  equal to <argname>b</argname> (or mutatis mutandis for
	  <argname>a</argname> greater than <argname>b</argname>).
	  The argument <argname>k</argname> must be positive.
	</para>
	<para>
	  <seelist>
            <fncref targ="ones"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
	<fnarg type="string">note</fnarg>
      </fnargs>
      <description>
	<para>
	  Sets a descriptive note for the object identified by
	  <argname>key</argname> in the bundle <argname>b</argname>.
	  This note will be shown when the <lit>print</lit> command is
	  used on the bundle. This function returns 0 on success or
	  non-zero on failure (for example, if there is no object in
	  <argname>b</argname> under the given
	  <argname>key</argname>).
	</para>
      </description>
    </function>

    <function name="sgn" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the sign function of <argname>x</argname>; that is,
	  0 if <argname>x</argname> is zero, 1 if <argname>x</argname> is
	  positive, &minus;1 if <argname>x</argname> is negative, or
	  <lit>NA</lit> if <argname>x</argname> is Not a Number.
	</para>
      </description>
    </function>

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Implements simulated annealing, which may be helpful in
	  improving the initialization for a numerical optimization
	  problem.
	</para>
	<para>
	  On input the first argument holds the initial value of a
	  parameter vector and the second argument specifies a
	  function call which returns the (scalar) value of the
	  maximand. The optional third argument specifies the maximum
	  number of iterations (which defaults to 1024). On successful
	  completion, <lit>simann</lit> returns the final value of the
	  maximand and <argname>b</argname> holds the associated
	  parameter vector.
	</para>
	<para>
	  For more details and an example see <guideref
	  targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the sine of <argname>x</argname>.
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the hyperbolic sine of <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="asinh"/>
            <fncref targ="cosh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the skewness value for the series <argname>x</argname>,
	  skipping any missing observations.
	</para>
      </description>
    </function>

    <function name="sleep" section="programming" output="scalar">
      <fnargs>
	<fnarg type="scalar">ns</fnarg>
      </fnargs>
      <description>
	<para>
	  Not of any direct use for econometrics, but can be useful
	  for testing parallelization methods. This function simply
	  causes the current thread to <quote>sleep</quote>&mdash;that
	  is, do nothing&mdash;for <argname>ns</argname> seconds. The
	  argument must be non-negative. On wake-up, the function
	  returns 0.
	</para>
      </description>
    </function>

    <function name="smplspan" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">startobs</fnarg>
	<fnarg type="string">endobs</fnarg>
	<fnarg type="int">pd</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of observations from
	  <argname>startobs</argname> to <argname>endobs</argname>
	  (inclusive) for time-series data with frequency
	  <argname>pd</argname>.
	</para>
	<para>
	  The first two arguments should be given in the form
	  preferred by gretl for annual, quarterly or monthly
	  data&mdash;for example, <lit>1970</lit>, <lit>1970:1</lit>
	  or <lit>1970:01</lit> for each of these frequencies,
	  respectively&mdash;or as ISO 8601 dates,
	  <lit>YYYY-MM-DD</lit>.
	</para>
	<para>
	  The <argname>pd</argname> argument must be 1, 4 or 12
	  (annual, quarterly, monthly); one of the daily frequencies
	  (5, 6, 7); or 52 (weekly). If <argname>pd</argname> equals
	  1, 4 or 12, then ISO 8601 dates are acceptable for the first
	  two arguments if they indicate the start of the period in
	  question. For example, <lit>2015-04-01</lit> is acceptable
	  in place of <lit>2015:2</lit> to represent the second
	  quarter of 2015.
	</para>
	<para>
	  If you already have a dataset of frequency
	  <argname>pd</argname> in place, with a sufficient range of
	  observations, then the result of this function could easily
	  be emulated using <fncref targ="obsnum"/>. The advantange of
	  <lit>smplspan</lit> is that you can calculate the number of
	  observations without having a suitable dataset (or any
	  dataset) in place. An example follows:
	</para>
	<code>
	  scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  nulldata T
	  setobs 5 2010-01-01
	</code>
	<para>
	  This produces:
	</para>
	<code>
	  ? scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  Generated scalar T = 1565
	  ? nulldata T
	  periodicity: 1, maxobs: 1565
	  observations range: 1 to 1565
	  ? setobs 5 2010-01-01
	  Full data range: 2010-01-01 - 2015-12-31 (n = 1565)
	</code>
	<para>
	  After the above, you can be confident that the last
	  observation in the dataset created via <cmdref
	  targ="nulldata"/> will be <lit>2015-12-31</lit>. Note that
	  the number 1565 would have been rather tricky to compute
	  otherwise.
	</para>
      </description>
    </function>

    <function name="sort" section="matrix" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Sorts <argname>x</argname> in ascending order. Observations
	  with missing values are skipped if <math>x</math> is a
	  series, but sorted to the end if <math>x</math> is a vector.
	  <seelist>
            <fncref targ="dsort"/>
            <fncref targ="values"/>
	  </seelist>
	  For matrices specifically, see <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a series containing the elements of
	  <argname>y2</argname> sorted by increasing value of the first
	  argument, <argname>y1</argname>.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sphericorr" section="stats" output="matrix">
      <fnargs>
       <fnarg type="matrix">X</fnarg>
       <fnarg type="int">mode</fnarg>
       <fnarg type="matrixref" optional="true">&amp;J</fnarg>
      </fnargs>
      <description>
       <para>
	 Calculates the spherical coordinates representation of a
	 correlation matrix, or its inverse, depending on the value
	 of the <argname>mode</argname> parameter.
       </para>
       <para>
	 When <argname>mode</argname> is 0 or omitted,
	 <argname>X</argname> is assumed to be an <by r="n" c="n"/>
	 correlation matrix. The returned value will be a vector with
	 <math>n(n-1)/2</math> elements between 0 and &pi;. In this
	 mode the reference to <argname>J</argname> is ignored.
       </para>
       <para>
	 When <argname>mode</argname> is 1 or 2 the inverse
	 transformation is performed, so <argname>X</argname> must be
	 a vector with <math>n(n-1)/2</math> elements between 0 and
	 &pi;. The return value is the correlation matrix
	 <math>R</math> if <argname>mode</argname> equals 1, or its
	 Cholesky factor <math>K</math> if <argname>mode</argname>
	 equals 2.  The optional pointer to matrix
	 <argname>J</argname>, if present, retrieves the Jacobian of
	 vech(<math>R</math>) or vech(<math>K</math>) with respect to
	 <math>X</math>.
       </para>
       <para>
	 Note that the spherical coordinates representation makes it
	 very easy to compute the log-determinant of the correlation
	 matrix <math>R</math>:
	</para>
       <code>
	 omega = sphericorr(X)
	 log_det = 2 * sum(log(sin(omega)))
	</code>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  The returned string is constructed by printing the values of
	  the trailing arguments, indicated by the dots above, under
	  the control of <argname>format</argname>. It is meant to
	  give you great flexibility in creating strings. The
	  <argname>format</argname> is used to specify the precise way
	  in which you want the arguments to be printed.
	</para>
	<para>
	  In general, <argname>format</argname> must be an expression
	  that evaluates to a string, but in most cases will just be a
	  string literal (an alphanumeric sequence surrounded by
	  double quotes). Some character sequences in the format have
	  a special meaning: those beginning with the percent
	  character (%) are interpreted as <quote>placeholders</quote>
	  for the items contained in the argument list; moreover,
	  special characters such as the newline character are
	  represented via a combination beginning with a backslash.
	</para>
	<para>
	  For example, the code below
	</para>
	<code>
	  scalar x = sqrt(5)
	  string claim = sprintf("sqrt(%d) is (roughly) %6.4f.\n", 5, x)
	  print claim
	</code>
	<para>
	  will output
	</para>
	<code>
	  sqrt(5) is (roughly) 2.2361.
	</code>
	<para>
	  The expression <lit>%d</lit> in the format string indicates
	  that we want an integer at that place in the output; since
	  it is the leftmost <quote>percent</quote> expression, it is
	  matched to the first argument, that is 5. The second special
	  sequence is <lit>%6.4f</lit>, which stands for a decimal
	  value at least 6 digits wide with 4 digits after the decimal
	  separator.  The number of such sequences must match the
	  number of arguments following the format string.
	</para>
	<para>
	  See the help page for the <cmdref targ="printf"/> command
	  for more details about the syntax you can use in format
	  strings.
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the positive square root of <argname>x</argname>; produces
	  <lit>NA</lit> for negative values.
	</para>
	<para>
	  Note that if the argument is a matrix the operation is
	  performed element by element. For the <quote>matrix square
	  root</quote> see <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">cross-products</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a list that references the squares of the variables
	  in the list <argname>L</argname>, named on the pattern
	  <lit>sq_</lit><repl>varname</repl>.  If the optional second
	  argument is present and has a non-zero value, the returned
	  list also includes the cross-products of the elements of
	  <argname>L</argname>; these are named on the pattern
	  <repl>var1</repl><lit>_</lit><repl>var2</repl>.  In these
	  patterns the input variable names are truncated if need be,
	  and the output names may be adjusted in case of duplication
	  of names in the returned list.
	</para>
	<para>
	  Note that dummy variables will be skipped when computing
	  squares to avoid producing an identical series, but their
	  product (aka <quote>interaction</quote>) with other series
	  in the input list <argname>L</argname> will be computed.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string-or-strings">src</fnarg>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Reads values from <argname>src</argname> under the control
	  of <argname>format</argname> and assigns these values to one
	  or more trailing arguments, indicated by the dots above.
	  Returns the number of values assigned. This is a simplified
	  version of the <lit>sscanf</lit> function in the C
	  programming language, with an extension to the scanning of
	  an entire matrix; this extension is described under the
	  leading <quote>Scanning a matrix</quote> below. Note that
	  giving an array of strings as <argname>src</argname> is
	  acceptable only in the case of matrix scanning.
	</para>
	<para>
	  <repl>src</repl> may be either a literal string, enclosed
	  in double quotes, or the name of a predefined string
	  variable.  <repl>format</repl> is defined similarly to the
	  format string in <cmdref targ="printf"/> (more on this
	  below). <repl>args</repl> should be a comma-separated list
	  containing the names of predefined variables: these are the
	  targets of conversion from <repl>src</repl>.  (For those
	  used to C: one can prefix the names of numerical variables
	  with <lit>&amp;</lit> but this is not required.)
	</para>
	<para>
	  Literal text in <repl>format</repl> is matched against
	  <repl>src</repl>.  Conversion specifiers start with
	  <lit>%</lit>, and recognized conversions include
	  <lit>%f</lit>, <lit>%g</lit> or <lit>%lf</lit> for
	  floating-point numbers; <lit>%d</lit> for integers;
	  <lit>%s</lit> for strings.  You may insert a positive
	  integer after the percent sign: this sets the maximum number
	  of characters to read for the given
	  conversion. Alternatively, you can insert a literal
	  <lit>*</lit> after the percent to suppress the conversion
	  (thereby skipping any characters that would otherwise have
	  been converted for the given type).  For example,
	  <lit>%3d</lit> converts the next 3 characters in
	  <repl>src</repl> to an integer, if possible; <lit>%*g</lit>
	  skips as many characters in <repl>src</repl> as could be
	  converted to a single floating-point number.
	</para>
	<para>
	  In addition to <lit>%s</lit> conversion for strings, a
	  simplified version of the C format
	  <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit>
	  is available.  In this format <repl>N</repl> is the maximum
	  number of characters to read and <repl>chars</repl> is a set
	  of acceptable characters, enclosed in square brackets:
	  reading stops if <repl>N</repl> is reached or if a character
	  not in <repl>chars</repl> is encountered. The function of
	  <repl>chars</repl> can be reversed by giving a circumflex,
	  <lit>^</lit>, as the first character; in that case reading
	  stops if a character in the given set is found.  (Unlike C,
	  the hyphen does not play a special role in the
	  <repl>chars</repl> set.)
	</para>
	<para>
	  If the source string does not (fully) match the format, the
	  number of conversions may fall short of the number of
	  arguments given.  This is not in itself an error so far as
	  gretl is concerned.  However, you may wish to check the
	  number of conversions performed; this is given by the return
	  value.  Some simple examples follow:
	</para>
	<code>
	  # scanning scalar values
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)
	  # scanning string values
	  string s = "one two"
	  string s1
	  string s2
	  sscanf(s, "%s %s", s1, s2)
	  print s1 s2
	</code>
	<subhead>Scanning a matrix</subhead>
	<para>
	  Matrix scanning must be signaled by the special conversion
	  specification <quote><lit>%m</lit></quote>. The maximum
	  number of rows to be read can be specified by inserting an
	  integer between the <quote><lit>%</lit></quote> sign and the
	  <quote><lit>m</lit></quote> for matrix.  Two variants are
	  supported: <argname>src</argname> a single string
	  representing a matrix, and <argname>src</argname> an array
	  of strings. We describe these options in turn.
	</para>
	<para>
	  If <argname>src</argname> is a single string argument the
	  scanner reads a line of input and counts the (space- or
	  tab-separated) number of numeric fields.  This defines the
	  number of columns in the matrix.  By default, reading then
	  proceeds for as many lines (rows) as contain the same number
	  of numeric columns, but the maximum number of rows can be
	  limited via the optional integer value mentioned above.
	</para>
	<para>
	  If <argname>src</argname> is an array of strings the output
	  is necessarily a column vector, each element of which is the
	  numerical conversion of the corresponding string, or
	  <lit>NA</lit> if the string is not numeric. Here are some
	  simple examples.
	</para>
	<code>
	  # scanning a single string
	  string s = sprintf("1 2 3 4\n5 6 7 8")
	  print s
	  matrix m
	  sscanf(s, "%m", m)
	  print m
	  # scanning an array of strings
	  strings S = defarray("1.1", "2.2", "3.3", "4.4", "5.5")
	  sscanf(S, "%4m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the sum of squared deviations from the mean for the
	  non-missing observations in the series or vector
	  <argname>y</argname>.
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="stack" section="panel" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Designed for manipulation of data into the stacked time
	  series format required by gretl for panel data. The return
	  value is a series obtained by stacking
	  <quote>vertically</quote> <argname>n</argname> observations
	  from each series in the list <argname>L</argname>. By
	  default the first <argname>n</argname> observations are used
	  (corresponding to <argname>offset</argname> = 0) but the
	  starting point can be shifted by supplying a positive value
	  for <argname>offset</argname>. If the resulting series is
	  longer than the existing dataset, observations are added as
	  needed.
	</para>
	<para>
	  This function can handle the case where a data file holds
	  side-by-side time series for a number of cross-sectional
	  units, as well as the case where time runs horizontally
	  and each row represents a cross-sectional unit.
	</para>
	<para>
	  See the section titled <quote>Panel data specifics</quote>
	  in <guideref targ="chap:datafiles"/> for details and
	  examples of usage.
	</para>
      </description>
    </function>

    <function name="stdize" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-list-or-mat">X</fnarg>
	<fnarg type="int" optional="true">v</fnarg>
	<fnarg type="bool" optional="true">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  By default, returns a standardized version of the series,
	  list or matrix: the input is centered and divided by its
	  sample standard deviation (with a degrees of freedom
	  correction of 1). Results are computed by column in the case
	  of matrix input.
	</para>
	<para>
	  The optional second argument can be used to inflect the
	  result. A non-negative value of <argname>v</argname> sets
	  the degrees of freedom correction used in the standard
	  deviation, so <argname>v</argname> = 0 gives the maximum
	  likelihood estimator. As a special case, if
	  <argname>v</argname> equals &minus;1 only centering
	  is performed.
	</para>
	<para>
	  By default missing values are automatically skipped in the
	  case of series or list input but not for matrix input. To
	  have missing values ignored in the matrix case, supply
	  a non-zero value for <argname>skip_na</argname>.
	</para>
      </description>
    </function>

    <function name="strfday" section="calendar" output="depends">
      <fnargs>
	<fnarg type="anyfloat">epoch_day</fnarg>
	<fnarg type="string" optional="true">format</fnarg>
      </fnargs>
      <description>
	<para>
	 This function works like <fncref targ="strftime"/>,
	 converting from a numeric value to a string governed by
	 <argname>format</argname>, except that the input is an
	 <quote>epoch day</quote>, for the definition of which see
	 <fncref targ="epochday"/>.  Since the resolution is daily,
	 only date-related formats are handled; time-related formats
	 give undefined results.
	</para>
        <para>
          If the second argument is omitted the format defaults to
          ISO 8601 extended, <lit>YYYY-MM-DD</lit>.
        </para>
      </description>
    </function>

    <function name="strftime" section="calendar" output="depends">
      <fnargs>
	<fnarg type="anyfloat">tm</fnarg>
	<fnarg optional="true" type="string">format</fnarg>
	<fnarg optional="true" type="scalar">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>tm</argname> is taken to give
	  <quote>Unix time</quote>, the number of seconds since the
	  start of the year 1970 according to UTC, and the return
	  value is a string giving the corresponding date and/or
	  time&mdash;either in a format specified via the optional
	  second argument or, by default, the <quote>preferred date
	  and time representation for the current locale</quote> as
	  determined by the system C library. See below for more on
	  the format specification.
	</para>
	<para>
	  The optional <argname>offset</argname> argument can be used
	  to specify an offset in seconds relative to UTC, thus
	  selecting a time zone other than the default, which is
	  always local time. For example an offset of 3600 selects
	  Central European Time, while 0 selects GMT. The absolute
	  value of <argname>offset</argname> should not exceed 86400
	  (24 hours).
	</para>
	<para>
	  The specific type returned depends on that of
	  <argname>tm</argname>: if <argname>tm</argname> is a scalar,
	  vector, or series the output is, respectively, a single
	  string, an array of strings, or a string-valued series.
	</para>
	<para>
	  Values of <argname>tm</argname> suitable for use with this
	  function may be obtained via the <fncref targ="$now"/>
	  accessor or the <fncref targ="strptime"/> function.
	</para>
	<para>
	  Note that while <argname>tm</argname> is taken as relative
	  to UTC the output of this function is by default
	  <quote>local</quote>, relative to the time-zone setting on
	  the host computer. A given <argname>tm</argname> will
	  therefore show a different time, and perhaps a different
	  date, in different time zones. But if you want a string
	  representing UTC rather than local time, gretl can do that;
	  see below.
	</para>
	<subhead>Format options</subhead>
	<para>
	  The standard formatting options may be found by consulting
	  the <lit>strftime</lit> manual page, on systems which have
	  such pages, or via one of the many websites which present
	  relevant information, such as
	  <url>https://devhints.io/strftime</url>. In addition to the
	  standard formats gretl recognizes a special option: if
	  <argname>format</argname> is just
	  <quote><lit>8601</lit></quote>, date and time are shown in
	  ISO 8601 format.
	</para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Provides a means of defining string values for the series
	  <argname>y</argname>. Two conditions must be satisfied for
	  this to work: the target series must have nothing but
	  integer values, none of them less than 1, and the array
	  <argname>S</argname> must have at least <math>n</math>
	  elements where <math>n</math> is the largest value in
	  <argname>y</argname>.  In addition each element of
	  <argname>S</argname> must be valid UTF-8. If any of these
	  conditions is not met, an error is flagged.  The nominal
	  return value is 0 on successful completion.
	</para>
	<para>
	  An alternative to <lit>stringify</lit> that may be useful in
	  some contexts is direct assignment from an array of strings
	  to a series: this creates a series whose values are taken
	  from the array in sequence; the number of elements in the
	  array must equal either the full length of the dataset or
	  the length of the current sample range, and values may be
	  repeated as required.
	</para>
	<para>
	  <seelist>
            <fncref targ="strvals"/>
	    <fncref targ="strvsort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string-or-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>s</argname> is a single string, returns the
	  number of UTF-8 characters it contains.  Note that this will
	  be less than the number of bytes if the string contains any
	  multi-byte (non-ASCII) characters. If you want the number of
	  bytes you can use the <fncref targ="nelem"/> function. For
	  example:
	</para>
	<code>
	  string s = "Ol!"
	  printf "strlen(s) = %d, nelem(s) = %d\n", strlen(s), nelem(s)
	</code>
	<para>
	  should return
	</para>
	<code>
	  strlen(s) = 5, nelem(s) = 7
	</code>
	<para>
	  If the argument is an array of strings the return value is a
	  column vector holding the number of characters in each string.
	  A string-valued series is also an acceptable argument: in
	  this case the return value is a series holding the length of
	  the string values over the current sample range.
	</para>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Compares the two string arguments and returns an integer less
	  than, equal to, or greater than zero if <argname>s1</argname> is
	  found, respectively, to be less than, to match, or be greater
	  than <argname>s2</argname>, up to the first <argname>n</argname>
	  characters.  If <argname>n</argname> is omitted the comparison
	  proceeds as far as possible.
	</para>
	<para>
	  Note that if you just want to compare two strings for
	  equality, that can be done without using a function, as in
	  <lit>if (s1 == s2) ...</lit>
	</para>
      </description>
    </function>

    <function name="strpday" section="calendar" output="depends">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string" optional="true">format</fnarg>
      </fnargs>
      <description>
	<para>
	 This function works just like <fncref targ="strptime"/>,
	 except that the return value is an <quote>epoch day</quote>
	 value, for the definition of which see <fncref
	 targ="epochday"/>.  Since the resolution is daily, any
	 time-of-day information in <argname>s</argname> is ignored.
	</para>
      </description>
    </function>

    <function name="strptime" section="calendar" output="depends">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string" optional="true">format</fnarg>
      </fnargs>
      <description>
	<para>
	 This function is the converse of <fncref targ="strftime"/>;
	 it parses one or more date/time strings using the specified
	 <argname>format</argname> and returns the number of seconds
	 since the start of 1970 according to Coordinated Universal
	 Time (UTC).  The specific type of the return value depends on
	 that of <argname>s</argname>: if <argname>s</argname> is a
	 string, strings array, or string-valued series the output is,
	 respectively, a scalar, a column vector, or a numeric series.
	</para>
	<para>
	  If <argname>format</argname> is omitted, it defaults to ISO
	  8601 <quote>extended</quote>, <lit>YYYY-MM-DD</lit> (which
	  translates to <quote><lit>%Y-%m-%d</lit></quote> as a
	  strptime format).
	</para>
	<para>
	  As a special case, the first argument may be given as an
	  8-digit integer conforming to the ISO 8601
	  <quote>basic</quote> date format, <lit>YYYYMMDD</lit> (or a
	  vector or series containing such values).  In that case
	  <argname>format</argname> should be omitted.
	</para>
	<para>
	  Note that the first argument to this function is taken as
	  relative to the time-zone setting on the host computer. So
	  for example, the call
	</para>
	<code>
	  strptime("13/02/2009 23:31.30", "%d/%m/%Y %H:%M.%S")
	</code>
	<para>
	  will produce 1234567890 on output if your system time is set
	  to UTC but if you're in the Central European time zone
	  (UTC+01:00) the output will be 1234564290.
	</para>
	<para>
	  The <argname>format</argname> options may be found by
	  consulting the <lit>strptime</lit> manual page, on systems
	  which have such pages, or via one of the many websites which
	  present relevant information, such as
	  <url>http://man7.org/linux/man-pages/man3/strptime.3.html</url>.
	</para>
	<para>
	  The example below shows how one can convert date information
	  from one format to another.
	</para>
	<code>
	  scalar tm = strptime("Thursday 02/07/19", "%A %m/%d/%y")
	  eval strftime(tm) # default output
	  eval strftime(tm, "%B %d, %Y")
	</code>
	<para>
	  On the East Coast of the USA the result is
	</para>
	<code>
	  Thu 07 Feb 2019 12:00:00 AM EST
	  February 07, 2019
	</code>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg optional="true" type="string">sep</fnarg>
	<fnarg optional="true" type="int">i</fnarg>
      </fnargs>
      <description>
	<para>
	  In basic usage, with a single argument, returns the array of
	  strings that results from the splitting of
	  <argname>s</argname> on white space (that is on any
	  combination of the space, tab and/or newline characters).
	</para>
	<para>
	  The optional second argument can be used to specify the
	  separator used for splitting <argname>s</argname>. For
	  example
	</para>
	<code>
	  string basket = "banana,apple,jackfruit,orange"
	  strings S = strsplit(basket, ",")
	</code>
	<para>
	  will split the input into an array of four strings using
	  comma as separator.
	</para>
	<para>
	  The backslash-escape sequences <quote><lit>\n</lit></quote>,
	  <quote><lit>\r</lit></quote> and
	  <quote><lit>\t</lit></quote> are taken to represent newline,
	  carriage return and tab, respectively, in the optional
	  <argname>sep</argname> argument. If you wish to include a
	  literal backslash as a separator character you should double
	  it, as in <quote><lit>\\</lit></quote>. Example:
	</para>
	<code>
	  string s = "c:\fiddle\sticks"
	  strings S = strsplit(s, "\\")
	</code>
	<para>
	  Regardless of the separator, the members of the returned
	  array are trimmed of any leading or trailing white space.
	  Correspondingly, if <argname>sep</argname> contains
	  non-whitespace characters then it is stripped of any leading
	  or trailing space.
	</para>
	<para>
	  If an integer value greater than zero is given as the third
	  argument the return value is a single string, namely the
	  (1-based) element <argname>i</argname> of the array that
	  would otherwise be produced. If <argname>i</argname> is less
	  than 1 that provokes an error, but if <argname>i</argname>
	  is greater than the implied number of elements an empty
	  string is returned.
	</para>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="bool">ign_case</fnarg>
      </fnargs>
      <description>
	<para>
	  Searches <argname>s1</argname> for an occurrence of the string
	  <argname>s2</argname>.  If a match is found, returns a copy of the
	  portion of <argname>s1</argname> that starts with
	  <argname>s2</argname>, otherwise returns an empty string.
	</para>
	<para>
          Example:
	</para>
	<code>
          string s1 = "Gretl is an econometrics package"
          string s2 = strstr(s1, "an")
          print s2
	</code>
	<para>
	  If the optional argument <argname>ign_case</argname> is nonzero, the
	  search is case-insensitive. For example,
	</para>
	<code>
	  strstr("Chicago", "c")
	</code>
	<para>
	  returns <quote>cago</quote>, but
	</para>
	<code>
	  strstr("Chicago", "c", 1)
	</code>
	<para>
	  returns <quote>Chicago</quote>.
	</para>
	<para>
	  If you just wish to find out if <argname>s1</argname>
	  contains <argname>s2</argname> (boolean test), see
	  <fncref targ="instring"/>.
	</para>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a copy of the argument <argname>s</argname> from
	  which leading and trailing white space have been removed.
	</para>
	<para>
          Example:
	</para>
	<code>
          string s1 = "    A lot of white space.  "
          string s2 = strstrip(s1)
          print s1 s2
	</code>
      </description>
    </function>

    <function name="strsub" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string">find</fnarg>
	<fnarg type="string">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>s</argname> is a single string, returns a copy
	  of <argname>s</argname> in which all occurrences of
	  <argname>find</argname> are replaced by
	  <argname>subst</argname>. If <argname>s</argname> is an
	  array of strings or string-valued series this operation is
	  performed on each string in the array or series.  See also
	  <fncref targ="regsub"/> for more complex string replacement
	  via regular expressions.
	</para>
	<para>
          Example:
	</para>
	<code>
          string s1 = "Hello, Gretl!"
          string s2 = strsub(s1, "Gretl", "Hansl")
          print s2
	</code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg optional="true" type="bool">subsample</fnarg>
      </fnargs>
      <description>
	<para>
	  If the series <argname>y</argname> is string-valued, returns
	  by default an array containing all its distinct values
	  (irrespective of the current setting of the sample range),
	  ordered by the associated numerical values starting at 1.
	  If the dataset is currently subsampled you can give a
	  non-zero value for the optional second argument to obtain an
	  array holding just the string values present in the
	  subsample.
	</para>
	<para>
	  If <argname>y</argname> is not string-valued an empty
	  strings array is returned.
	  <seelist>
            <fncref targ="stringify"/>
	  </seelist>
	</para>
	<para>
	  An alternative to <lit>strvals</lit> that may be useful in
	  some contexts is direct assignment of a string-valued series
	  to an array of strings: this provides not just the distinct
	  values, but all values of the series in the current sample
	  range.
	</para>
      </description>
    </function>

    <function name="strvsort" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg optional="true" type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Carries out one or other of two sorts of rearrangment of the
	  series <argname>y</argname>, which must be
	  string-valued. The nominal return value is 0 on successful
	  completion.
	</para>
	<para>
	  Method 1: If the second argument is not given, the effect is
	  to sort <argname>y</argname> in this sense: the distinct
	  string values are alphabetized and then the series is
	  recoded such that 1 is assigned for the first of the ordered
	  strings, 2 for the second, and so on. This can be useful,
	  among other reasons, for ensuring a uniform encoding for
	  multiple series that share the same set of string values.
	</para>
	<para>
	  Method 2: If the second argument is given, it must be an
	  array which contains exactly the distinct string values of
	  <argname>y</argname> (which can be found via <fncref
	  targ="strvals"/>), but put into a preferred order. Then the
	  effect is to recode the series such that value 1 is assigned
	  for the first string in <argname>S</argname>, value 2 for
	  the second, and so on.  This can be useful for ensuring that
	  the numeric codes <quote>make sense</quote> when string
	  values can be thought of as naturally ordered.
	</para>
	<para>
	  The primary use case for these methods is the handling of
	  string-valued series imported from third-party sources such
	  as comma-separated files. For such data, gretl assigns
	  numeric codes based simply on the order of occurrence of the
	  strings across the rows of the file. So in a series with
	  values <lit>low</lit>, <lit>middle</lit> and
	  <lit>high</lit>, <lit>high</lit> will be assigned code 1 if
	  it happens to occur first, rather than 3, which would
	  clearly be more <quote>natural</quote>. This can be fixed
	  using Method 2. Moreover, if two or more series share the
	  same string values, they will be encoded differently unless
	  their distinct values happen to appear in the same order in
	  the data file. This could be fixed by either method.
	</para>
	<para>
	  <seelist>
	    <fncref targ="stringify"/>
	    <fncref targ="strvals"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="int">start</fnarg>
	<fnarg type="int">end</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>s</argname> is a single string, returns the
	  substring of <argname>s</argname> from the character with
	  (1-based) index <argname>start</argname> to that with index
	  <argname>end</argname>, inclusive, or from
	  <argname>start</argname> to the end of <argname>s</argname>
	  if <argname>end</argname> is &minus;1. If the argument is an
	  array of strings or string-valued series, this operation
	  is performed on each string in the array or series.
	</para>
	<para>
          For example, the code below
	</para>
	<code>
          string s1 = "Hello, Gretl!"
          string s2 = substr(s1, 8, 12)
          print s2
	</code>
	<para>
          gives:
	</para>
	<code>
	  ? print s2
	  Gretl
	</code>
	<para>
          It should be noted that in some cases you may be willing to
          trade clarity for conciseness, and use slicing and increment
          operators, as in
	</para>
	<code>
          string s1 = "Hello, Gretl!"
          string s2 = s1[8:12]
          string s3 = s1 + 7
          print s2
          print s3
	</code>
	<para>
	  which would give you
	</para>
	<code>
	  ? print s2
	  Gretl
	  ? print s3
	  Gretl!
	</code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar)
	  sum of the non-missing observations in
	  <argname>x</argname>. See also <fncref targ="sumall"/>.
	</para>
	<para>
	  If <argname>x</argname> is a matrix, returns the sum of the
	  elements of the matrix.
	</para>
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  sum of the values of the variables in the list at
	  observation <math>t</math>. By default the sum is recorded
	  as <lit>NA</lit> if there are any missing values at
	  <math>t</math>, but if you pass a non-zero value for
	  <argname>partial</argname> any non-missing values will be
	  used to form the sum.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the sum of the observations of <argname>x</argname>
	  over the current sample range, or <lit>NA</lit> if there are
	  any missing values. Use <fncref targ="sum"/> if you want
	  missing values to be skipped.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the sums of the columns of <argname>X</argname>. If
	  a non-zero value is given for the optional second argument
	  missing values are ignored, otherwise the result is
	  <lit>NA</lit> for any columns that contain missing values.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the sums of the rows of <argname>X</argname>.  If a
	  non-zero value is given for the optional second argument
	  missing values are ignored, otherwise the result is
	  <lit>NA</lit> for any rows that contain missing values.
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Performs the singular values decomposition of the matrix
	  <argname>X</argname>.
	</para>
	<para context="tex">
	  Performs the singular values decomposition of the $r \times c$
	  matrix $X$:
	  \[ X = U \left[
	  \begin{array}{cccc}
	  \sigma_1 \\
	  &amp; \sigma_2 \\
	  &amp; &amp; \ddots \\
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \]
	  where $n = \min(r,c)$. $U$ is $r \times
	  n$ and $V$ is $n \times c$, with $U'U = I$ and $VV' = I$.
	</para>
	<para>
	  The singular values are returned in a row vector.  The left
	  and/or right singular vectors <math>U</math> and <math>V</math>
	  may be obtained by supplying non-null values for arguments 2 and
	  3, respectively.  For any matrix <lit>A</lit>, the code
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V)
	  B = (U .* s) * V
	</code>
	<para>
	  should yield <lit>B</lit> identical to <lit>A</lit> (apart from
	  machine precision).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svm" section="nonparam" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="bundle">bparms</fnarg>
	<fnarg type="bundleref" optional="true">bmod</fnarg>
	<fnarg type="bundleref" optional="true">bprob</fnarg>
      </fnargs>
      <description>
	<para>
	  This function enables the training of, and prediction based
	  on, an SVM (a Support Vector Machine), using LIBSVM as
	  back-end. The list argument <argname>L</argname> should
	  include the dependent variable followed by the independent
	  variables and the <argname>bparms</argname> bundle is used
	  to pass options to the SVM mechanism. The return value is a
	  series holding the SVM's predictions.  The two optional
	  bundle-pointer argument can be used to retrieve additional
	  information after training and/or prediction.
	</para>
	<para>
	  For details, please see the PDF documentation for
	  <mnu targ="gretlSVM">gretl + SVM</mnu>.
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the tangent of <argname>x</argname>.
	  <seelist>
            <fncref targ="atan"/>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the hyperbolic tangent of <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="atanh"/>
            <fncref targ="cosh"/>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tdisagg" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="series-or-mat">Y</fnarg>
	<fnarg optional="true" type="series-list-or-mat">X</fnarg>
	<fnarg type="scalar">s</fnarg>
	<fnarg optional="true" type="bundle">opts</fnarg>
	<fnarg optional="true" type="bundle">results</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs temporal disaggregation (conversion to higher
	  frequency) of the time-series data in
	  <argname>Y</argname>. The argument <argname>s</argname>
	  gives the expansion factor (for example, 3 for quarterly
	  to monthly). The argument <argname>X</argname> may contain
	  one or more covariates at the higher frequency to aid in
	  the disaggregation. Several options may be passed in
	  <argname>opts</argname>, and details of the disaggregation
	  may be retrieved via <argname> results</argname>.
	</para>
	<para>
	  See <guideref targ="chap:tdisagg"/> for details.
	</para>
      </description>
    </function>

    <function name="thresh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
	<fnarg type="anyfloat">a</fnarg>
	<fnarg optional="true" type="scalar">hard</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs soft or hard thresholding on <argname>x</argname>,
	  depending on the value of the optional Boolean parameter
	  <argname>hard</argname>, whose default value is 0.
	</para>
	<para>
	  In both cases, entries in <argname>x</argname> whose
	  absolute value is less than <argname>a</argname> are set to
	  0. With soft thresholding, the other ones are shrunk towards
	  0. For example, the code below
	</para>
	<code>
	  s = seq(-2,2,0.5)'
	  eval s ~ thresh(s, 0.5) ~ thresh(s, 0.5, 1)
	</code>
	<para>
	  produces
	</para>
	<code>
             -2      -1.5       -2
           -1.5        -1     -1.5
             -1      -0.5       -1
           -0.5         0        0
              0         0        0
            0.5         0        0
              1       0.5        1
            1.5         1      1.5
              2       1.5        2
	</code>
	<para>
	  If the two arguments differ in type, the type of the result
	  is the <quote>higher</quote> of the two, where the ordering
	  is matrix &gt; series &gt; scalar. For example, if
	  <argname>y</argname> is a scalar and <argname>x</argname> an
	  <math>n</math>-vector (or vice versa) the result is an
	  <math>n</math>-vector. Note that matrix arguments must be
	  vectors, and if neither argument is a scalar the two
	  arguments must be of the same length.
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
	<fnarg optional="true" type="scalarref">&amp;det</fnarg>
      </fnargs>
      <description>
	<para>
	  Solves a Toeplitz system of linear equations, that is
	  <math>Tx = b</math> where <math>T</math> is a square matrix
	  whose element <math>T</math><sub>i,j</sub> equals
	  <math>c</math><sub>i-j</sub> for
	  <equation status="inline"
	  ascii="i&gt;=j" tex="$i\ge j$"/>
	  and <math>r</math><sub>j-i</sub> for
	  <equation status="inline" ascii="i&lt;=j"
	  tex="$i\le j$"/>.
	  Note that the first elements of <math>c</math> and
	  <math>r</math> must be equal, otherwise an error is
	  returned. Upon successful completion, the function returns
	  the vector <math>x</math>.
	</para>
	<para>
	  The algorithm used here takes advantage of the special
	  structure of the matrix <math>T</math>, which makes it much
	  more efficient than other unspecialized algorithms,
	  especially for large problems. Warning: in certain cases,
	  the function may spuriously issue a singularity error when
	  in fact the matrix <math>T</math> is nonsingular; this
	  problem, however, cannot arise when <math>T</math> is
	  positive definite.
	</para>
	<para>
	  If the optional argument <argname>det</argname> is supplied
	  (in pointer form), it will contain on exit the determinant
	  of <math>T</math>. For example, the code:
	</para>
	<code>
	  A = unvech({3;2;1;3;2;3})    # Build a 3x3 Toeplitz matrix
	  x = ones(3,1)                # and a 3x1 vector
	  print A x
	  eval A\x                     # solution via generic inversion
	  eval det(A)                  # print the determinant
	  a = A[1,]
	  d = 0
	  eval toepsolv(a, a, x, &amp;d)   # use the dedicated function
	  print d
	</code>
	<para>
	  produces
	</para>
	<code>
A (3 x 3)

  3   2   1
  2   3   2
  1   2   3

x (3 x 1)

  1
  1
  1

     0.25000
 -3.3307e-17
     0.25000

8
     0.25000
  2.7756e-17
     0.25000


d =  8.0000000
	</code>
      </description>
    </function>

    <function name="tolower" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>s</argname> is a single string, returns a copy
	  of <argname>s</argname> in which any upper-case characters
	  are converted to lower case. If <argname>s</argname> is an
	  array of strings or string-valued series this operation is
	  performed on each string in the array or series.
	</para>
	<para>
          Example:
	</para>
	<code>
          string s1 = "Hello, Gretl!"
          string s2 = tolower(s1)
          print s2
	</code>
      </description>
    </function>

    <function name="toupper" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>s</argname> is a single string, returns a copy
	  of <argname>s</argname> in which any lower-case characters
	  are converted to upper case. If <argname>s</argname> is an
	  array of strings or string-valued series this operation is
	  performed on each string in the array or series.
	</para>
	<para>
          Examples:
	</para>
	<code>
          string s1 = "Hello, Gretl!"
          string s2 = toupper(s1)
          print s2
	</code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the trace of the square matrix <argname>A</argname>, that
	  is, the sum of its diagonal elements.
	  <seelist>
            <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the transpose of <argname>X</argname>. Note: this is rarely
	  used; in order to get the transpose of a matrix, in most cases you
	  can just use the prime operator: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trigamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns the trigamma function of <argname>x</argname>, that
	  is the second derivative of the log of the Gamma function.
	</para>
	<para context="tex">
	  Returns the trigamma function of $x$, that is
	  $\frac {\mathrm{d}^2} {\mathrm{d} x^2}\, \log \Gamma(x)$.
	</para>
	<para>
	  <seelist>
            <fncref targ="lngamma"/>
            <fncref targ="digamma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="trimr" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">ttop</fnarg>
	<fnarg type="int">tbot</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix that is a copy of <argname>X</argname> with
	  <argname>ttop</argname> rows trimmed at the top and
	  <argname>tbot</argname> rows trimmed at the bottom.  The
	  latter two arguments must be non-negative, and must sum to
	  less than the total rows of <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typename" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  A convenience function which combines <fncref
	  targ="typeof"/> and <fncref targ="typestr"/>, with a little
	  value added. Basically, the following two statements are
	  equivalent
        </para>
	<code>
	  eval typestr(typeof(x))
	  eval typename(x)
	</code>
	<para>
	  except that if <argname>expr</argname> names an array,
	  <lit>typename</lit> returns the specific type of the
	  array, as in
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  eval typestr(typeof(S))  # gives "array"
	  eval typename(S)         # gives "strings"
	</code>
      </description>
    </function>

    <function name="typeof" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">expr</fnarg>
      </fnargs>
      <description>
	<para>
          Returns a numeric code indicating the type of
          <argname>expr</argname>, if it names a currently defined
          variable, specifies a sub-object such as a bundle member or
          array element, or is a valid expression that could stand as
          the right-hand side of an assignment statement.  The codes
          are 1 for scalar, 2 for series, 3 for matrix, 4 for string,
          5 for bundle, 6 for array and 7 for list. A return value of
          0 indicates that <argname>expr</argname> names no existing
          object, or more generally that an assignment with
          <argname>expr</argname> on the right-hand side would fail.
	</para>
	<para>
	  A few examples follow:
	</para>
	<code>
	  strings S = defarray("foo", "bar")
	  eval typeof(S)            # gives 6 (array)
	  eval typeof(S[1])         # gives 4 (string)
	  eval typeof(S[7])         # gives 0 (out of bounds)
	  eval typeof(S[x])         # gives 0 (invalid index)
	  eval typeof(1+1)          # gives 1 (scalar)
	  eval typeof(sqrt("foo"))  # gives 0 (invalid)
	</code>
	<para>
	  The function <fncref targ="typestr"/> may be used to get the
	  string corresponding to the return value from
	  <lit>typeof</lit>, though if you just want the string result
	  <fncref targ="typename"/> may be a more convenient
	  alternative.
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">typecode</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a gretl type code (for example, obtained via <fncref
	  targ="typeof"/> or <fncref targ="inbundle"/>), returns a
	  string giving the name of the type. The mapping from codes
	  to strings is: 1 = <quote>scalar</quote>, 2 =
	  <quote>series</quote>, 3 = <quote>matrix</quote>, 4 =
	  <quote>string</quote>, 5 = <quote>bundle</quote>, 6 =
	  <quote>array</quote>, 7 = <quote>list</quote>, and 0 =
	  <quote>null</quote>.
	</para>
	<para>
	  See also <fncref targ="typename"/> for an alternative.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Generates a series of uniform pseudo-random variates in the
	  interval (<argname>a</argname>, <argname>b</argname>), or,
	  if no arguments are supplied, in the interval (0,1). The
	  algorithm used by default is the SIMD-oriented Fast Mersenne
	  Twister developed by <cite key="saito_matsumoto08">Saito and
	  Matsumoto (2008)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="normal"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a vector containing the distinct non-missing
	  elements of <argname>x</argname>, not sorted but in their
	  order of appearance. See <fncref targ="values"/> for a
	  variant that sorts the elements.
	</para>
      </description>
    </function>

    <function name="unvech" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  If the second argument is omitted, returns an <by r="n"
	  c="n"/> symmetric matrix obtained by rearranging the
	  elements of <math>v</math>. The number of elements in
	  <math>v</math> must be a triangular integer&mdash;&ie;, a
	  number <math>k</math> such that an integer <math>n</math>
	  exists with the property <equation status="inline" ascii="k
	  = n(n+1)/2" tex="$k = n(n+1)/2$"/>. This is the inverse of
	  the function <fncref targ="vech"/>.
	</para>
	<para>
	  If the argument <argname>d</argname> is given, the function
	  returns an <by r="(n+1)" c="(n+1)"/> matrix with the
	  extra-diagonal entries filled with the elements of
	  <math>v</math> as above. All the elements of the diagonal
	  are set to <argname>d</argname> instead.
       </para>
    <para>
        Example:
    </para>
    <code>
        v = {1;2;3}
        matrix one = unvech(v)
        matrix two = unvech(v, 99)
        print one two
    </code>
    <para>
      returns
    </para>
    <code>
      one (2 x 2)

      1   2
      2   3

      two (3 x 3)

      99     1     2
       1    99     3
       2     3    99
    </code>
    <para>
      <seelist>
        <fncref targ="mshape"/>
        <fncref targ="vech"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="upper" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns an <by r="n" c="n"/> upper triangular matrix: the elements
	  on and above the diagonal are equal to the corresponding elements of
	  <argname>A</argname>; the remaining elements are zero.
	</para>
	<para context="tex">
	  Returns an $n\times n$ upper triangular matrix <math>B</math>
	  for which $B_{ij} = A_{ij}$ if $i \le j$ and 0 otherwise.
	</para>
	<para>
	  <seelist>
            <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-values for the test statistic from the
	  Dickey&ndash;Fuller unit-root test and the
	  Engle&ndash;Granger cointegration test, as per <cite
	  key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  The arguments are as follows: <argname>tau</argname> denotes
	  the test statistic; <argname>n</argname> is the number of
	  observations (or 0 for an asymptotic result);
	  <argname>niv</argname> is the number of potentially
	  cointegrated variables when testing for cointegration (or 1
	  for a univariate unit-root test); and <argname>itv</argname>
	  is a code for the model specification: 1 for no constant, 2
	  for constant included, 3 for constant and linear trend, 4
	  for constant and quadratic trend.
	</para>
	<para>
	  Note that if the test regression is <quote>augmented</quote>
	  with lags of the dependent variable, then you should give an
	  <argname>n</argname> value of 0 to get an asymptotic result.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="qlrpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a vector containing the distinct elements of
	  <argname>x</argname> sorted in ascending order, ignoring any
	  missing values.  If you wish to truncate the values to
	  integers before applying this function, use the expression
	  <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="uniq"/>
            <fncref targ="dsort"/>
            <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar)
	  sample variance, skipping any missing observations.
	</para>
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  sample variance of the values of the variables in the list
	  at observation <math>t</math>. By default the variance is
	  recorded as <lit>NA</lit> if there are any missing values at
	  <math>t</math>, but if you pass a non-zero value for
	  <argname>partial</argname> any non-missing values will be
	  used to form the statistic.
	</para>
	<para>
	  In each case the sum of squared deviations from the mean is
	  divided by (<math>n</math> &minus; 1) for <math>n</math>
	  &gt; 1. Otherwise the variance is given as zero if
	  <math>n</math> = 1, or as <lit>NA</lit> if <math>n</math> =
	  0.
	</para>
	<para>
	  <seelist>
            <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>
      <description>
	<para>
	  If given an integer argument, returns the name of the
	  variable with ID number <argname>v</argname>, or generates
	  an error if there is no such variable.
	</para>
	<para>
	  If given a list argument, returns a string containing the
	  names of the variables in the list, separated by commas.  If
	  the supplied list is empty, so is the returned string. To
	  get an array of strings as return value, use <fncref
	  targ="varnames"/> instead.
	</para>
    <para>
        Example:
    </para>
    <code>
        open broiler.gdt
        string s = varname(7)
        print s
    </code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an array of strings containing the names of the
	  variables in the list <argname>L</argname>. If the supplied
	  list is empty, so is the returned array.
	</para>
    <para>
        Example:
    </para>
    <code>
        open keane.gdt
        list L = year wage status
        strings S = varnames(L)
        eval S[1]
        eval S[2]
        eval S[3]
    </code>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">varname</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the ID number of the variable called
	  <argname>varname</argname>, or NA is there is no such
	  variable.
	</para>
      </description>
    </function>

    <function name="varsimul" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Simulates a <math>p</math>-order <math>n</math>-variable
	  VAR, that is
	  <equation status="inline"
		    ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)."
		    tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
	  The coefficient matrix <argname>A</argname> is composed by
	  stacking the <math>A</math><sub>i</sub> matrices
	  horizontally; it is <by r="n" c="np"/>, with one row per
	  equation. This corresponds to the first <math>n</math> rows
	  of the matrix <lit>$compan</lit> provided by the
	  <lit>var</lit> and <lit>vecm</lit> commands.
	</para>
	<para>
	  The <math>u_t</math> vectors are contained (as rows) in
	  <argname>U</argname> (<by r="T" c="n"/>). Initial values are in
	  <argname>y0</argname> (<by r="p" c="n"/>).
	</para>
	<para>
	  If the VAR contains deterministic terms and/or exogenous
	  regressors, these can be handled by folding them into the
	  <argname>U</argname> matrix: each row of <argname>U</argname>
	  then becomes
	  <equation status="inline"
		    ascii="u(t) = B'x(t) + e(t)."
		    tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  The output matrix has <math>T</math> + <math>p</math> rows
	  and <math>n</math> columns; it holds the initial
	  <math>p</math> values of the endogenous variables plus
	  <math>T</math> simulated values.
	</para>
	<para>
	  <seelist>
            <fncref targ="$compan"/>
            <cmdref targ="var"/>
            <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matrix" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Stacks the columns of <argname>X</argname> as a column vector.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matrix" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg optional="true" type="bool">omit-diag</fnarg>
      </fnargs>
      <description>
	<para>
	  This function rearranges the the elements of
	  <argname>A</argname> on and above the diagonal into a column
	  vector, unless the <argname>omit-diag</argname> is given a
	  non-zero value, in which case only the entries above the
	  diagonal are considered.
        </para>
        <para>
	  Typically, this function is used on symmetric matrices, in
	  which case it can be undone by the function <fncref
	  targ="unvech"/>. If the input matrix is not symmetric and
	  it's the lower triangle that contains the
	  <quote>right</quote> values, <lit>vech(A')</lit> will give
	  the desired answer (its elements may have to be re-ordered,
	  however).
	  <seelist>
            <fncref targ="vec"/>
          </seelist>
        </para>
      </description>
    </function>

    <function name="vma" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix" optional="true">K</fnarg>
	<fnarg type="int" optional="true">horizon</fnarg>
      </fnargs>
      <description>
	<para>
	  This function yields the VMA representation for a VAR
	  system. If <equation status="inline" ascii="y(t) = A1 y(t-1)
	  + ... + Ap y(t-p) + u(t)" tex="$y_t = \sum_{i=1}^p A_i
	  y_{t-i} + u_t$"/>, where <math>u</math><sub>t</sub> are the
	  one-step-ahead prediction errors, the corresponding VMA
	  representation is <equation status="inline" ascii="y(t) = C0
	  e(t) + C1 e(t-1) + ..."  tex="$y_t = C_0 e_t + C_1 e_{t-1} +
	  \ldots$."/>. The relationship between the forecast errors
	  <math>u</math><sub>t</sub> and the structural shocks
	  <math>e</math><sub>t</sub> is given by <equation
	  status="inline" ascii="u(t) = K e(t)" tex="$u_t = K
	  e_t$"/>. (Note that <math>C</math><sub>0</sub> =
	  <math>K</math>.)
        </para>
        <para>
          The coefficient matrix <argname>A</argname> is composed by
	  stacking the <math>A</math><sub>i</sub> matrices horizontally;
	  it is <by r="n" c="np"/>, with one row per equation. This
	  corresponds to the first <math>n</math> rows of the matrix
	  <lit>$compan</lit> provided by gretl's <lit>var</lit> and
	  <lit>vecm</lit> commands. The <argname>K</argname> matrix is
	  optional, and defaults to the identity matrix if omitted.
	</para>
        <para>
          The returned matrix will have <argname>horizon</argname>
	  rows and <math>n</math><sup>2</sup> columns: its
	  <math>i</math>-th row contains <math>C</math><sub>i-1</sub>
	  in vectorized form. The <argname>horizon</argname> value
	  defaults to 24 if omitted.
	</para>
	<para>
	  <seelist>
            <fncref targ="irf"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">year</fnarg>
	<fnarg type="scalar-or-series">month</fnarg>
	<fnarg type="scalar-or-series">day</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the day of the week (from Sunday = 0 to Saturday =
	  6) for the date(s) specified by the three arguments, or
	  <lit>NA</lit> if the date is invalid. Note that all three
	  arguments must be of the same type, either scalars
	  (integers) or series.
	</para>
	<para>
	  An alternative call is also supported: if a single argument
	  is given, it is taken to be a date (or series of dates) in
	  ISO 8601 <quote>basic</quote> numeric format,
	  <lit>YYYYMMDD</lit>. So the following two calls produce the
	  same result, namely 2 (Tuesday).
	</para>
	<code>
	  eval weekday(1990, 5, 1)
	  eval weekday(19900501)
	</code>
	<para>
	  A common alternative numbering for days of the week runs
	  from Monday = 1 to Sunday = 7. If you have a series named
	  <lit>wd</lit> obtained via <lit>weekday</lit> and you want
	  to convert to the alternative you can do
	</para>
	<code>
	  altwd = wd == 0 ? 7 : wd
	</code>
	<para>
	  Note that if you simply add 1 to <lit>wd</lit> you get a
	  numbering that's valid but non-standard, namely Sunday = 1
	  to Saturday = 7.
	</para>
      </description>
    </function>

    <function name="wmean" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a series <math>y</math> such that
	  <math>y</math><sub>t</sub> is the weighted mean of the
	  values of the variables in list <argname>Y</argname> at
	  observation <math>t</math>, the respective weights given by
	  the values of the variables in list <argname>W</argname> at
	  <math>t</math>.  The weights can therefore be
	  time-varying. The lists <argname>Y</argname> and
	  <argname>W</argname> must be of the same length and the
	  weights must be non-negative.
	</para>
	<para>
	  By default the result is NA if any values are missing at
	  observation <math>t</math>, but if you pass a non-zero value
	  for <argname>partial</argname> any non-missing values will
	  be used.
	</para>
	<para>
	  <seelist>
            <fncref targ="wsd"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wsd" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a series <math>y</math> such that
	  <math>y</math><sub>t</sub> is the weighted sample standard
	  deviation of the values of the variables in list
	  <argname>Y</argname> at observation <math>t</math>, the
	  respective weights given by the values of the variables in
	  list <argname>W</argname> at <math>t</math>.  The weights
	  can therefore be time-varying. The lists
	  <argname>Y</argname> and <argname>W</argname> must be of the
	  same length and the weights must be non-negative.
	</para>
	<para>
	  By default the result is NA if any values are missing at
	  observation <math>t</math>, but if you pass a non-zero value
	  for <argname>partial</argname> any non-missing values will
	  be used.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wvar" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a series <math>y</math> such that
	  <math>y</math><sub>t</sub> is the weighted sample variance
	  of the values of the variables in list <argname>X</argname>
	  at observation <math>t</math>, the respective weights given
	  by the values of the variables in list <argname>W</argname>
	  at <math>t</math>.  The weights can therefore be
	  time-varying. The lists <argname>Y</argname> and
	  <argname>W</argname> must be of the same length and the
	  weights must be non-negative.
	</para>
	<para>
	  By default the result is NA if any values are missing at
	  observation <math>t</math>, but if you pass a non-zero value
	  for <argname>partial</argname> any non-missing values will
	  be used.
	</para>
	<para context="tex">
	  The weighted sample variance is computed as
	  \[ s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} \]
	  where $n'$ is the number of non-zero weights and $\bar{x}_w$ is
	  the weighted mean.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wsd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmlget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string-or-strings">path</fnarg>
	<fnarg optional="true" type="scalarref">&amp;matches</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>buf</argname> should be an XML buffer,
	  as may be retrieved from a suitable website via the <fncref
	  targ="curl"/> function (or read from file via <fncref
	  targ="readfile"/>), and the <argname>path</argname> argument
	  should be either a single XPath specification or an array
	  of such.
	</para>
	<para>
	  This function returns a string representing the data found
	  in the XML buffer at the specified path. If multiple nodes
	  match the path expression the items of data are printed one
	  per line in the returned string. If an array of paths is
	  given as the second argument the returned string takes the
	  form of a comma-separated buffer, with column <math>i</math>
	  holding the matches from path <math>i</math>. In this case
	  if a string obtained from the XML buffer contains any spaces
	  or commas it is wrapped in double quotes.
	</para>
	<para>
	  By default an error is flagged if <argname>path</argname> is
	  not matched in the XML buffer, but this behavior is
	  modified if you pass the third, optional argument: in that
	  case the argument retrieves a count of the matches and an
	  empty string is returned if there are none. Example call:
	</para>
	<code>
	  ngot = 0
	  ret = xmlget(xbuf, "//some/thing", &amp;ngot)
	</code>
	<para>
	  However, an error is still flagged in case of a malformed
	  query.
	</para>
	<para>
	  A good introduction to XPath usage and syntax can be found
	  at
	  <url>https://www.w3schools.com/xml/xml_xpath.asp</url>. The
	  back-end for <lit>xmlget</lit> is provided by the xpath
	  module of libxml2, which supports XPath 1.0 but not XPath
	  2.0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="jsonget"/>
	    <fncref targ="readfile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeromiss" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converts zeros to <lit>NA</lit>s. If <argname>x</argname> is
	  a series or matrix, the conversion is done element by
	  element.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Outputs a zero matrix with <math>r</math> rows and
	  <math>c</math> columns.  If omitted, the number of columns
	  defaults to 1 (column vector).
      <seelist>
        <fncref targ="ones"/>
        <fncref targ="seq"/>
      </seelist>
    </para>
      </description>
    </function>

  </funclist>
</funcref>
