<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE funcref SYSTEM "gretl_functions.dtd">

<funcref language="italian">

  <funclist name="Accessors" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
        <para>
          Deve seguire la stima di un modello panel a effetti fissi. Produce le
          stime degli effetti fissi individuali (intercette delle singole
          unità).
        </para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
        <para>
          Produce il criterio di informazione di Akaike per l'ultimo
          modello stimato, se disponibile. Si veda <guideref
          targ="chap:criteria"/> per dettagli.
        </para>
      </description>
    </function>

    <function name="$allprobs" section="access" output="matrix">
      <description>
        <para>
          Deve seguire la stima di un modello ordinale (logit o
          probit) o di un logit multinomiale. Produce una matrice <by
          r="n" c="j"/>, dove <math>n</math> è il numero di
          osservazioni usate e <math>j</math> è il numero di valori
          possibili della variabile dipendente. La matrice conterrà la
          probabilità stimata per ogni valore e per ogni osservazione.
       </para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Produce il criterio di informazione bayesiano di Schwarz per
	  l'ultimo modello stimato, se disponibile. Si veda <guideref
	  targ="chap:criteria"/> per dettagli.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Produce la statistica chi-quadro complessiva per l'ultimo
	  modello stimato, se disponibile.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  L'accessore <lit>$coeff</lit> può essere usato in due modi:
	  senza argomenti produce un vettore colonna che contiene i
	  coefficienti dell'ultimo modello stimato. Con l'argomento
	  opzionale, produce uno scalare che corrisponde alla stima
	  del coefficiente chiamato <argname>s</argname>.
	  <seelist>
            <fncref targ="$stderr"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg
	  b = $coeff
	  macoef = $coeff(theta_1)
	</code>
	<para>
	  Se il <quote>modello</quote> in questione è effettivamente
	  un sistema (un VAR o un VECM, o un sistema di equazioni
	  simultanee), <lit>$coeff</lit> senza parametri produce la
	  matrice dei coefficienti, una colonna per equazione.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Deve seguire la stima di un modello; restituisce la stringa
	  del comando relativo, come ad esempio <lit>ols</lit> oppure
	  <lit>probit</lit>.
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VAR o un VECM; produce la matrice
	  compagna.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Restituisce un intero corrispondente al tipo di dataset
	  attualmente in memoria: 0 = nessun dato; 1 = dati
	  cross-sezionali (non datati); 2 = serie storiche; 3 = panel.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Deve seguire la stima di un modello ad equazione singola e
	  restituisce il nome della variabile dipendente.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Produce i gradi di libertà dell'ultimo modello stimato. Se
	  questo consiste di un sistema di equazioni, viene restituito
	  il numero dei gradi di libertà per equazione; se questo
	  differisce da un'equazione all'altra, allora il valore
	  restituito è pari al numero di osservazioni meno la media del
	  numero di coefficienti per equazione (arrotondato all'intero
	  più vicino).
	</para>
      </description>
    </function>

    <function name="$diagpval" section="access" output="scalar">
      <description>
	<para>
	  Deve seguire la stima di un sistema di
	  equazioni. Restituisce il <math>P</math>-value associato
	  alla statistica <fncref targ="$diagtest"/>.
	</para>
      </description>
    </function>

    <function name="$diagtest" section="access" output="scalar">
      <description>
	<para>
	  Deve seguire la stima di un sistema di
	  equazioni. Restituisce il test per l'ipotesi che la matrice
	  di covarianza dei disturbi sia diagonale. La statistica
	  utilizzata è quella di Breusch&ndash;Pagan tranne nel caso
	  del SUR iterato, nel qual caso è un test LR. si veda la
	  <guideref targ="chap:system"/> per dettagli; vedi anche
	  <fncref targ="$diagpval"/>.
	</para>
      </description>
    </function>

    <function name="$dotdir" section="access" output="string">
      <description>
	<para>
	  Questo accessore restituisce la directory usata da gretl per
	  salvare file temporanei, come ad esempio quelli creati da
	  <fncref targ="mwrite"/> quando il terzo argomento non è
	  zero.
	</para>
      </description>
    </function>

    <function name="$dw" section="access" output="scalar">
      <description>
	<para>
	  Restituisce la statistica di Durbin&ndash;Watson per
	  l'autocorrelazione di primo ordine dall'ultimo modello
	  stimato, se disponibile.
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Fornisce il p-value per la statistica Durbin&ndash;Watson
	  relativa all'ultimo modello stimato, se disponibile. Tale
	  valore è calcolato tramite la procedura di <cite
	  key="imhof61">Imhof</cite>. Essa ritorna il p-value per un
	  test a una coda con l'alternativa dei autocorrelazione di
	  primo ordine positiva. Per il p-value del test a due code,
	  si usi 2<math>P</math> se DW &lt; 2 oppure 2(1 &minus;
	  <math>P</math>) se DW &gt; 2, dove <math>P</math> è il
	  valore fornito dall'accessore.
	</para>
	<para>
	  A causa della limitata precisione dell'aritmetica digitale,
	  l'integrale di Imhof può diventare negativo quando la
	  statistica di Durbin&ndash;Watson è vicina a 0. Se questo
	  accade, l'accessore restituisce <lit>NA</lit>. Poiché
	  qualsiasi altro malfunzionamento porta a un codice di
	  errore, si può ritenere con una certa sicurezza che un
	  valore NA indica che il p-value è
	  <quote>piccolissimo</quote>, benché gretl non sia in grado
	  di quantificarlo esattamente.
	</para>

      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM e restituisce una matrice
	  contenente i termini di correzione d'errore.  La matrice
	  restituita ha tante righe quante sono le osservazioni usate
	  nella stima e un numero di colonne pari al rango di
	  cointegrazione del sistema.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Restituisce il codice interno di errore, che avrà un valore
	  diverso da 0 se si è verificato un errore in presenza del
	  modificatore <cmdref targ="catch"/>. Si noti che l'uso di
	  questo accessore resetta il codice di errore interno a 0. Si
	  veda anche <fncref targ="errmsg"/>. Per il messaggio
	  d'errore associato a un dato codice, bisogna salvare il
	  valore in una variabile temporanea; ad esempio:
	</para>
	<code>
	  err = $error
	  if (err)
          printf "Errore %d (%s)\n", err, errmsg(err);
	  endif
	</code>
	<para>
	  <seelist>
            <cmdref targ="catch"/>
            <fncref targ="errmsg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Produce la somma dei quadrati degli errori dell'ultimo modello
          stimato.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM; restituisce un vettore
	  contenente gli autovalori usati nel calcolo del test traccia
	  per la cointegrazione.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire il comando <cmdref targ="fcast"/>; restituisce le
	  previsioni sotto forma di matrice. Se il modello usato per
	  le previsioni è un modello a più equazioni, ogni colonna
	  corrisponde ad un'equazione; altrimenti, restituisce un vettore
	  colonna.
	</para>
      </description>
    </function>

    <function name="$fcse" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire il comando <cmdref targ="fcast"/>; restituisce gli
	  errori standard per le previsioni sotto forma di matrice. Se
	  il modello usato per le previsioni è un modello a più
	  equazioni, ogni colonna corrisponde ad un'equazione;
	  altrimenti, restituisce un vettore colonna.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VAR. Restituisce una matrice
	  contenete la scomposizione della varianza dell'errore di
	  previsione (FEVD). Questa avrà <math>h</math> righe, dove
	  <math>h</math> è l'orizzonte di previsione, che può essere
	  modificato tramite il comando <lit>set horizon</lit> o,
	  altrimenti, viene fissato automaticamente sulla base della
	  frequenza dei dati.
	</para>
	<para>
	  Per un VAR con <math>p</math>
	  variabili, la matrice ha <math>p</math><sup>2</sup>
	  colonne: il primo blocco di <math>p</math> colonne contiene le FEVD
	  per la prima variabile, il secondo blocco la FEVD per la
	  seconda, e così via. La parte dell'errore di previsione sulla variabile
	  <math>i</math> attribuibile allo shock alla variabile
	  <math>j</math> si troverà nella colonna (<math>i</math> &minus;
	  1)<math>p</math> + <math>j</math>.
	</para>
 	<para>
	  Per una variante più flessibile di questa funzionalità, si
	  veda la funzione <fncref targ="fevd"/>.
	</para>
     </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Restituisce la statistica F complessiva per l'ultimo modello
	  stimato, se disponibile.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Deve seguire un blocco <lit>gmm</lit>. Produce il valore della
          funzione obiettivo al suo minimo.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Deve seguire un comando <lit>garch</lit>. Produce la
	  varianza condizionale stimata.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Deve seguire un comando <lit>tsls</lit> o <lit>panel</lit> con
	  l'opzione effetti casuali. Produce un vettore <by r="1"
	  c="3"/> contenente nell'ordine: il valore della statistica del
	  test di Hausman, i corrispondenti gradi di libertà e p-value.
	</para>
      </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Produce il criterio di informazione di Hannan-Quinn per l'ultimo
          modello stimato, se disponibile. Per maggiori dettagli sulla
          metodologia di calcolo, v. <guideref
          targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Restituisce un numero positivo molto grande. Per impostazione
	  predefinita è pari a 1.0E100, ma tale valore si può cambiare
	  usando il comando <cmdref targ="set"/>.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM, e produce la matrice dei pesi, che
          contiene tante righe quante sono le variabili del VECM e tante colonne
          quanto è il rango di cointegrazione.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM, e produce la matrice di
          cointegrazione, che contiene tante righe quante sono le
          variabili del VECM (più il numero di eventuali variabili esogene
          vincolate allo spazio di cointegrazione) e un numero di colonne
          pari al rango di cointegrazione.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM, e produce la matrice di covarianza
          stimata per gli elementi dei vettori di cointegrazione.
	</para>
	<para>
	  Nel caso di stima non vincolata, ha un numero di righe pari al numero
          di elementi non vincolati nello spazio di cointegrazione dopo la
          normalizzazione di Phillips. Se però si stima un sistema vincolato
          con il comando <lit>restrict</lit> e l'opzione <lit>--full</lit>,
          verrà prodotta una matrice singolare con <math>(n+m)r</math> righe
          (<math>n</math> è il numero delle variabili endogene,
          <math>m</math> quello delle variabili esogene vincolate allo
          spazio di cointegrazione e <math>r</math> è il
          rango di cointegrazione).
	</para>
	<para>
	  Esempio: il codice
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	  b[1,1] = 1
	  b[1,2] = -1
	  b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  produce il risultato seguente.
	</para>
	<code>
	  s0 (4 x 4)

          0.019751     0.029816  -0.00044837     -0.12227
          0.029816      0.31005     -0.45823     -0.18526
	  -0.00044837     -0.45823       1.2169    -0.035437
          -0.12227     -0.18526    -0.035437      0.76062

	  s1 (5 x 5)

	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000      0.27398     -0.27398    -0.019059
	  0.0000       0.0000     -0.27398      0.27398     0.019059
	  0.0000       0.0000    -0.019059     0.019059    0.0014180
	</code>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  Per alcuni modelli stimati con massima verosimiglianza,
	  produce la serie dei contributi alla log-verosimiglianza di tutte le
	  osservazioni. Al momento, questo accessore funziona solo per
	  logit e probit binari, tobit e heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Produce la log-verosimiglianza dell'ultimo modello stimato (dove
          possibile).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Restituisce il valore dell'<quote>epsilon macchina</quote>,
	  ossia un limite superiore all'errore relativo dovuto
	  all'aritmetica a virgola mobile in doppia precisione.
	</para>
      </description>
    </function>

    <function name="$mapfile" section="access" output="string">
      <description>
	<para>
	  Se il dataset in uso è stato caricato da un file GeoJSON o
	  ESRI (shapefile), restituisce il nome del file da aprire per
	  ottenere il poligoni della mappa, o una stringa vuota
	  altrimenti. Questo accessore è usato con la funzione <fncref
	  targ="geoplot"/>.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Dopo la stima di un modello logit multinomiale, crea una
	  matrice con le probabilità stimate di tutti i possibili
	  esiti per tutte le osservazioni usate nella stima. Le
	  osservazioni sono per riga e gli esiti per colonna. Dalla
	  versione 2023a l'uso di quest'accessore è deprecato: si
	  raccomanda di usare <fncref targ="$allprobs"/> al suo posto.
	</para>
      </description>
    </function>

    <function name="$model" section="access" output="bundle">
      <description>
	<para>
	  Deve seguire la stima di un modello ad equazione singole, e
	  restituisce un bundle contenente svariati elementi relativi
	  al modello. I consueti accessori sono tutti inclusi, e sono
	  referenziati da chiavi identiche al nome dell'accessore,
	  meno il segno del dollaro. Ad esempio, i residui appaiono
	  sotto la chiave <lit>uhat</lit> e la somma dei quadrati dei
	  residui sotto <lit>ess</lit>.
	</para>
	<para>
	  A seconda dello stimatore, potrebbero essere disponibili
	  informazioni aggiuntive; le chiavi relative dovrebbero
	  essere (si spera) relativamente auto-esplicative. Il modo
	  più semplice per verificare il contenuto del bundle è
	  stamparlo, come in questo esempio:
	</para>
	<code>
	  ols y 0 x
	  bundle b = $model
	  print b
	</code>
      </description>
    </function>

    <function name="$mpirank" section="access" output="int">
      <description>
	<para>
	  Se gretl è compilato con supporto MPI, e il programma è
	  stato lanciato in modalità MPI, ritorna il
	  <quote>rango</quote> a base 0 o l'ID del processo
	  attuale. Altrimenti ritorna &minus;1.
	</para>
      </description>
    </function>

    <function name="$mpisize" section="access" output="int">
      <description>
	<para>
	  Se gretl è compilato con supporto MPI, e il programma è
	  stato lanciato in modalità MPI, ritorna il numero di
	  processi MPI attualmente in svolgimento. Altrimenti ritorna
	  0.
	</para>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Produce il numero totale dei coefficienti stimati nell'ultimo modello.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" output="int">
      <description>
	<para>
	  Produce il numero delle osservazioni nel campione
	  selezionato. Si veda anche <fncref targ="$tmax"/>.
	</para>
	<para>
	  Nel caso di dati panel il valore restituito è il numero di
	  osservazioni "pooled" (numero di unità per numero di
	  osservazioni per unità). Per ottenere la dimensione
	  temporale del panel va usato l'accessore <fncref
	  targ="$pd"/>; il numero di unità longitudinali si può
	  ottenere come <lit>$nobs</lit> diviso per <lit>$pd</lit>.
	</para>
      </description>
    </function>

    <function name="$now" section="access" output="vector">
      <description>
	<para>
	  Produce un vettore a 2 elementi: il primo elemento è il
	  numero di secondi trascorsi dal 1970-01-01 00:00:00 +0000
	  (UTC), che una misura molto comune nel mondo
	  dell'informatica per rappresentare l'ora. Il secondo è la
	  data attuale nel formato ISO 8601 <quote>di base</quote>, e
	  cioè <lit>YYYYMMDD</lit>; per processare il secondo elemento
	  si può usare la funzione <fncref targ="epochday"/>.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Produce il numero delle variabili nel dataset (inclusa la
	  costante). Poiché <lit>const</lit> è sempre presente in
	  qualunque dataset, un valore ritornato di 0 indica che
	  nessun dataset è aperto. Si noti che se questo accessore
	  viene usato in una funzione, il numero di serie
	  effettivamente accessibili potrebbe benissimo essere minore
	  di <lit>$nvars</lit>.
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Applicabile quando il dataset corrente è una serie storica
	  con frequenza decennale, annuale, trimestrale, mensile,
	  settimanale o giornaliera, oppure è un panel in cui la
	  variabile che indicizza i periodi ha la frequenza
	  appropriata (si veda il comando <cmdref targ="setobs"/>).
	  La variabile risultante ha 8 cifre con la struttura
	  <lit>YYYYMMDD</lit> (formato <quote>base</quote> delle date
	  secondo l'ISO 8601), che corrisponde al giorno
	  di osservazione o al primo giorno del periodo di
	  osservazione nel caso di serie storiche con frequenza minore
	  di quella giornaliera.
	</para>
	<para>
	  Questa variabile può essere utile quando si usa il comando
	  <cmdref targ="join"/>.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  Applicabile quando le osservazioni nel dataset aperto hanno
	  una struttura maggiore:minore, come in serie storiche
	  trimestrali (anno:trimestre), mensili (anno:mese), orarie
	  (giorno:ora) e dati panel (individuo:periodo). Restituisce una
	  variabile contenente la componente maggiore (a frequenza più
	  bassa, come l'anno).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsminor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  Applicabile quando le osservazioni nel dataset aperto hanno
	  una struttura maggiore:minore:micro, come in serie storiche
	  giornaliere (anno:mese:giorno). Restituisce una
	  variabile contenente la componente micro (a frequenza più
	  alta, come il giorno).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  Applicabile quando le osservazioni nel dataset aperto hanno
	  una struttura maggiore:minore, come in serie storiche
	  trimestrali (anno:trimestre), mensili (anno:mese), orarie
	  (giorno:ora) e dati panel (individuo:periodo). Restituisce una
	  variabile contenente la componente minore (a frequenza più
	  alta, come il mese).
	</para>
	<para>
	  Per dati giornalieri, <lit>$obsminor</lit> ritorna il mese
	  dell'osservazione corrispondente.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$panelpd" section="access" output="int">
      <description>
	<para>
	  Restituisce la periodicità di un dataset panel lungo l'asse
	  temporale (p. es. 4 per dati trimestrali). Se tale
	  periodicità non è impostata, il risultato è 1 in analogia
	  con <fncref targ="$pd"/> per dati cross-sezionali o senza
	  data; per altri tipi di dataset, la funzione restituisce NA.
	</para>
	<para>
	  <seelist>
	    <fncref targ="$pd"/>
	    <fncref targ="$datatype"/>
	    <cmdref targ="setobs"/>
	  </seelist>
	</para>
     </description>
    </function>

    <function name="$parnames" section="access" output="strings">
      <description>
	<para>
	  Dopo la stima di un modello ad equazione singola, produce un
	  vettore di stringhe contenente i nomi dei parametri del
	  modello. il numero dei nomi è pari al numero di elementi
	  nel vettore <fncref targ="$coeff"/> .
	</para>
	<para>
	  Per modelli specificati con una lista di regressori il risultato
	  sarà lo stesso di
	</para>
	<code>
	  varnames($xlist)
	</code>
	<para>
	  (vedi <fncref targ="varnames"/>), ma <lit>$parnames</lit> è
	  è più generale, poiché funziona anche con modelli senza lista di
	  regressori (<cmdref targ="nls"/>, <cmdref targ="mle"/>, <cmdref
	  targ="gmm"/>).
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Produce la frequenza o la periodicità dei dati (es. 4 per dati
          trimestrali). Nel caso di dati panel il valore prodotto rappresenta
          la lunghezza della serie storica.
	</para>
	<para>
	  <seelist>
            <fncref targ="$panelpd"/>
	  </seelist>
	  </para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Restituisce il valore di &pi; in doppia precisione.
	</para>
      </description>
    </function>

    <function name="$pkgdir" section="access" output="string">
      <description>
	<para>
	  Pensato per gli autori di pacchetti di funzioni. Ritorna una
	  stringa vuota, a meno che non sia in esecuzione una funzione
	  appartenente ad un pacchetto, nel qual caso ritorna il path
	  completo (dipendente dal sistema operativo) in cui il
	  pacchetto è installato. Ad esempio, il valore ritornato
	  potrebbe essere
	</para>
	<code>
	  /usr/share/gretl/functions/foo
	</code>
	<para>
	  se questa è la directory in cui si trova
	  <lit>foo.gfn</lit>. Questo accessore dà modo di accedere a
	  risorse come ad esempio file contenti matrici speciali,
	  inclusi nel pacchetto.
	</para>
      </description>
    </function>

    <function name="$pmanteau" section="access" output="matrix">
      <description>
	<para>
	Disponibile dopo la stima di un VAR. Restituisce un vettore
	riga contenente i risultati del test portmanteau multivariato
	per l'autocorrelazione dei residui, come discusso alle pagine
	21&ndash;22 in <cite key="johansen95">Johansen
	(1995)</cite>. Gli elementi sono, in ordine, la statistica
	Ljung&ndash;Box, il ritardo massimo considerato, i gradi di
	libertà per il test chi-quadro e il p-value del test.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Produce il p-value della statistica test generata
	  dall'ultimo comando esplicito di test di ipotesi (es.
	  <lit>chow</lit>).  Si veda <guideref
	  targ="chap:genr"/> per ulteriori dettagli.
	</para>
	<para>
	  Nella maggior parte dei casi il valore prodotto è scalare ma talvolta
	  può essere costituito da una matrice (per esempio i p-value
	  delle statistiche della traccia e lambda-max del test di
	  cointegrazione di Johansen); in questo caso i valore contenuti
	  nella matrice sono organizzati seguendo la stessa struttura con la
	  quale vengono riportati i risultati.
	</para>
	<para>
	  <seelist>
            <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$qlrbreak" section="access" output="scalar">
      <description>
	<para>
	  Deve seguire il comando <cmdref targ="qlrtest"/> (test QLR
	  per un break strutturale). Ritorna il numero ordinale (a
	  base 1) dell'osservazione che massimizza la statistica test.
	</para>
      </description>
    </function>

    <function name="$result" section="access" output="matrix-or-bundle">
      <description>
	<para>
	  Fornisce le informazioni immagazzinate da alcuni comandi che non hanno
	  specifici accessori. Tali comandi includono <cmdref targ="bds"/>,
	  <cmdref targ="bkw"/>, <cmdref targ="corr"/>, <cmdref
	  targ="fractint"/>, <cmdref targ="freq"/>, <cmdref targ="hurst"/>,
	  <cmdref targ="leverage"/>, <cmdref targ="summary"/>, <cmdref
	  targ="vif"/> e <cmdref targ="xtab"/> ; in questi casi il risultato è
	  una matrice. In più <cmdref targ="pkg"/>, che opzionalmente registra
	  come risultato un bundle.
	</para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Senza argomenti, produce il coefficiente autoregressivo del
	  prim'ordine per i residui dell'ultimo modello. Dopo aver stimato
	  un modello con il comando <lit>ar</lit>, la sintassi
	  <lit>$rho(n)</lit> produce la corrispondente stima di
	  &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rlnl" section="access" output="scalar">
      <description>
	<para>
          Dopo la stima di un VECM vincolato, restituisce la
          log-verosimiglianza del modello vncolato. Si vedano anche
          <fncref targ="$lnl"/>, e <guideref targ="chap:vecm"/> per
          esempi d'uso.
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Produce l'<math>R</math><sup>2</sup> non aggiustato
	  dell'ultimo modello stimato, se disponibile. Normalmente
	  questo sarà l'indice <math>R</math><sup>2</sup> centrato ma
	  se la specifica non contiene una costante (e nessun insieme
	  di regressori che <quote>si sommano</quote> a una costante),
	  allora sarà la versione non centrata. In tal caso è
	  possibile accedere alla versione centrata come
	  <lit>$model.centered_R2</lit>.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Deve seguire la stima di un modello ad equazione
	  singola. Restituisce una variabile binaria con 1 per le
	  osservazioni usate nella stima, 0 per osservazioni incluse
	  nel campione corrente ma non usate nella stima (ad esempio,
	  per via di valori mancanti nella variabile dipendente) e NA
	  per osservazioni al di fuori del campione corrente.
	</para>
	<para>
	  Se fosse necessario calcolare statistiche basate sul
	  campione usato per un certo modello, ad esempio, si potrebbe
	  usare la seguente sintassi:
	</para>
	<code>
	  ols y 0 xlist
	  genr sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Deve seguire un comando <lit>tsls</lit>. Produce un vettore <by
	  r="1" c="3"/> che contiene nell'ordine: il valore della
	  statistica del test di Sargan di sovraidentificazione, i
	  corrispondenti gradi di libertà e il p-value. Se il modello è
	  esattamente identificato, la statistica non è disponibile, e
	  tentare di ottenerla provoca un errore.
	</para>
      </description>
    </function>

    <function name="$seed" section="access" output="scalar">
      <description>
	<para>
	  Ritorna il seme usato dal generatore di numeri casuali di
	  gretl. Ovviamente questo accessore è inutile se il seme è
	  stato fissato in precedenza, ma può essere di interesse se
	  il seme è stato generato automaticamente (in base al momento
	  in cui il programma è stato lanciato).
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Richiede che sia stato stimato un modello. Se quest'ultimo consiste
	  di un'unica equazione, restituisce uno scalare, lo Standard Error
	  della Regressione (in altre parole, lo scarto quadratico medio dei
	  residui, con l'opportuna correzione per i gradi di libertà). Se il
	  modello contiene un sistema di equazioni, la funzione restituisce
	  la matrice di covarianza dei residui delle diverse equazioni.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  L'accessore <lit>$stderr</lit> restituisce un vettore colonna
	  contenente lo standard error dei coefficienti dell'ultimo modello.
	  Con il parametro opzionale, restituisce uno scalare contenente lo
	  standard error del parametro <argname>s</argname>.
	</para>
	<para>
	  Se il <quote>modello</quote> in questione è un sistema, il
	  risultato dipende dalle sue caratteristiche: per sistemi VAR
	  e VECM il valore restituito è una matrice con una colonna per
	  equazione; altrimenti, è un vettore colonna contenente i
	  coefficienti della prima equazione, seguiti da quelli della
	  seconda, e così via.
	</para>
	<para>
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Deve essere preceduto dal comando <lit>set stopwatch</lit>,
	  che attiva la misurazione del tempo di CPU.  Il primo uso di
	  questo accessore restituisce i secondi di CPU time trascorsi dal
	  comando <lit>set stopwatch</lit>. Ad ogni accesso il
	  cronometro viene riazzerato, cosicché l'uso successivo
	  dell'accessore restituisce i secondi di CPU intercorsi dalla
	  chiamata precedente.
	</para>
	<para>
	  Durante l'esecuzione di una funzione definita dall'utente,
	  il comando <lit>set stopwatch</lit> e l'accessore
	  <lit>$stopwatch</lit> sono locali alla funzione&mdash;vale a
	  dire che i tempi presi nella funzione non hanno effetto sui
	  tempi <quote>globali</quote> che potrebbero essere presi
	  esternamente.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un sistema simultaneo.  Restituisce
	  la matrice dei coefficienti delle endogene ritardate, se
	  presenti nella forma strutturale. Si veda il comando <cmdref
	  targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un sistema simultaneo.  Restituisce
	  la matrice dei coefficienti delle esogene nella forma
	  strutturale. Si veda il comando <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un sistema simultaneo.  Restituisce
	  la matrice dei coefficienti delle endogene contemporanee
	  nella forma strutturale. Si veda il comando <cmdref
	  targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
	<para>
	  Restituisce un bundle contenente informazioni sulle caratteristiche
	  della versione di gretl e del sistema sul quale quest'ultimo viene
	  eseguito. I membri del bundle sono i seguenti:
	</para>
	<ilist>
	  <li>
	    <para>
	      <lit>gui_mode</lit>: intero, pari a 1 se gretl è
	      eseguito in modalità GUI, altrimenti è pari a 0.
	    </para>
	  </li>
	  <li>
            <para>
              <lit>mpi</lit>: intero, pari a 1 se il sistema è compatibile con
              MPI (Message Passing Interface), altrimenti è pari a 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>omp</lit>: intero, pari a 1 se la versione di gretl è
              compatibile con Open MP, altrimenti è pari a 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>ncores</lit>: integer, il numero di processori
	      fisici disponibili.
            </para>
	  </li>
	  <li>
            <para>
              <lit>nproc</lit>: intero, il numero di processori
	      disponibili, che può essere più grande di
	      <lit>ncores</lit> se lo hyperthreading è abilitato nel sistema.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mpimax</lit>: intero, il numero massimo di processi MPI che
              possono essere eseguiti in parallelo. Questo valore è nullo se
              il sistema non è compatibile con MPI, altrimenti è pari al valore
              locale <lit>nproc</lit> a meno che non sia stato specificato un
              file di MPI hosts; in questo caso esso è pari alla somma del
              numero dei processori o degli <quote>slots</quote> presenti
              su tutte le macchine elencate in quel file.
            </para>
	  </li>
	  <li>
            <para>
              <lit>wordlen</lit>: intero, pari a 32 o 64 rispettivamente
              per sistemi a 32- o 64-bit.
            </para>
	  </li>
	  <li>
            <para>
              <lit>os</lit>: stringa contenente il sistema operativo:
              può essere pari a <lit>linux</lit>, <lit>macos</lit>,
              <lit>windows</lit> o <lit>other</lit>. Nota bene:
              versioni di gretl precedenti alla 2021e restituivano la
              stringa <lit>osx</lit> per i Mac; un test se si è su un
              Mac che funziona per tutte le versioni di gretl è
              <lit>instring($sysinfo.os, "os")</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>hostname</lit>: il nome della macchina host sulla quale
              viene eseguito il processo corrente di gretl (con il valore di
              ripiego <lit>localhost</lit> nel caso in cui il nome non potesse
              essere individuato).
            </para>
	  </li>
	  <li>
            <para>
              <lit>mem</lit>: un vettore di due elementi indicante la
	      memoria totale fisica e quella disponibile (in
	      MB). Questa informazione potrebbe non essere disponibile
	      su tutti i sistemi operativi ma dovrebbe funzionare
	      correttamente in Windows, macOS e Linux.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>blas</lit>: stringa identificativa della Libreria
              BLAS (Basic Linear Algebra Subprograms) in uso di gretl.
             </para>
	  </li>
	  <li>
	    <para>
              <lit>blas_version</lit>: stringa che identifica la versione
	      della libreria blas in uso.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>blascore</lit>: (se applicabile) una stringa che
              identifica il tipo di CPU per cui l'attuale libreria
              blas è ottimizzata.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>compilatore</lit>: una stringa che identifica il compilatore
              utilizzato durante la creazione di libgretl.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>cpuid</lit>: una stringa che identifica marca e
              modello della CPU su cui è in esecuzione libgretl.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>gnuplot</lit>: una stringa che identifica la versione di
              gnuplot disponibile per gretl, sotto forma di
              tre numeri separati da punti che danno la versione maggiore, minore
              e livello di patch.
            </para>
	  </li>
	  <li>
            <para>
	      <lit>foreign</lit>:  un bundle contenente
	      indicatori binari per la presenza nel sistema di vari
	      programmi utilizzabili col comando <cmdref targ
	      ="foreign">foreign</cmdref>, ossia <lit>julia</lit>,
	      <lit>octave</lit>, <lit>ox</lit>, <lit>python</lit>,
	      <lit>Rbin</lit>, <lit>Rlib</lit> e <lit>stata</lit>.
	      Le due chiavi relative a R fanno riferimento
	      rispettivamente all'eseguibile R e alla libreria.
            </para>
	  </li>
	</ilist>
	<para>
	  Si noti che i singoli elementi del bundle possono essere recuperati
	  usando la notazione <quote>dot</quote> senza bisogno di copiare
	  l'intero bundle con un nuovo nome specificato dall'utente.
	  Per esempio,
	</para>
	<code>
	  if $sysinfo.os == "linux"
          # effettua un'operazione specifica a linux
	  endif
	</code>
      </description>
    </function>

    <function name="$system" section="access" output="bundle">
      <description>
	<para>
	  Deve seguire la stima di un sistema di equazioni, eseguita
	  con uno dei comandi <cmdref targ="system"/>, <cmdref targ="var"/>
	  o <cmdref targ="vecm"/>; restituisce un bundle contenente
	  svariati elementi relativi al sistema. Sono inclusi tutti
	  gli accessori di sistema rilevanti, sotto chiavi che hanno
	  lo stesso nome dei normali accessori, a parte il dollaro
	  iniziale. Ad esempio, i residui compaiono sotto la chiave
	  <lit>uhat</lit> e i coefficienti sotto <lit>coeff</lit>. Le
	  altre chiavi dovrebbero essere (si spera)
	  auto-esplicative. Per vedere il contenuto del bundle, basta
	  prenderne una copia e stamparne il contenuto, come mostrato
	  qui di seguito:
	</para>
	<code>
	  var 4 y1 y2 y2
	  bundle b = $system
	  print b
	</code>
	<para>
	  Un bundle ottenuto a questo modo può essere passato come
	  ultimo argomento alle funzioni <fncref targ="fevd"/>
	  e <fncref targ="irf"/>.
	</para>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Ritorna il numero di osservazioni usato nella stima dell'ultimo
	  modello.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Indice (a base 1) della prima osservazione nel campione
	  attualmente selezionato.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Indice (a base 1) dell'ultima osservazione nel campione
	  attualmente selezionato.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Restituisce il valore della statistica test generata
	  dall'ultimo comando esplicitamente volto al test di ipotesi
	  (p. es: <lit>chow</lit>), se presente. Si veda <guideref
	  targ="chap:genr"/> per maggiori dettagli.
	</para>
	<para>
	  Nella maggior parte dei casi il valore restituito è uno scalare
	  ma talvolta può trattarsi di una matrice (per esempio nel caso delle
	  statistiche della traccia e lambda-max del test di cointegrazione
	  di Johansen); in questo caso gli elementi della matrice sono
	  organizzati seguendo la stessa struttura utilizzata nella stampa
	  dei risultati.
	</para>
	<para>
	  <seelist>
            <fncref targ="$pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$time" section="access" output="series">
      <description>
	<para>
	  Per dataset panel o di serie storiche, crea un indice a base
	  1 del tempo. Nel caso panel la sequenza si ripete per ogni unità.
	</para>
	<para>
	  Il comando <quote><lit>genr time</lit></quote> è una
	  alternativa, con la differenza che la variante
	  <lit>genr</lit> crea automaticamente una serie di nome
	  <lit>time</lit> mentre quando si usa <lit>$time</lit> il
	  nome della serie è deciso dal chiamante, come ad esempio in
	</para>
	<code>
	  series trend = $time
	</code>
	<para>
	  Questo accessore non è disponibile per dati cross-section.
	</para>
      </description>
    </function>

    <function name="$tmax" section="access" output="int">
      <description>
	<para>
	  Ritorna il massimo ammissibile come fine del campione nel
	  comando <cmdref targ="smpl"/>. Nella maggioranza dei casi,
	  questo sarà il numero di osservazioni nel dataset, ma in una
	  funzione hansl <lit>$tmax</lit> potrebbe essere inferiore,
	  poiché in generale l'accesso ai dati dentro una funzione è
	  limitato al sottocampione effettivo al momento della chiamata.
	</para>
	<para>
	  Si noti che, in generale, <lit>$tmax</lit> non è uguale a
	  <fncref targ="$nobs"/>, che restituisce il numero di
	  osservazioni nel sottocampione attualmente in vigore.
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Restituisce <math>TR</math><sup>2</sup> (numerosità campionaria
	  per R quadro) dall'ultimo modello.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Restituisce i residui dall'ultimo modello stimato. Cosa si
	  intenda per 'residui' dipende dal modello che è stato
	  stimato. Ad esempio, dopo una stima ARMA <lit>$uhat</lit>
	  contiene gli errori di previsione a un passo; dopo un
	  probit, i residui generalizzati.
	</para>
	<para>
	  Se il modello in questione è multi-equazionale (un VAR o un
	  VECM, o un sistema di equazioni simultanee), <lit>$uhat</lit> senza
	  parametri restituisce una matrice contenente i residui nelle
	  colonne.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Valido solo per dataset di tipo panel.  Restituisce una variabile
	  con 1 per tutte le osservazioni della prima unità cross-sezionale,
	  2 per le osservazioni della seconda e così via.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s1</fnarg>
	<fnarg optional="true" type="coeffname">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Senza argomenti, <lit>$vcv</lit> restituisce una matrice quadrata
	  contenente le covarianze stimate dei coefficienti dell'ultimo modello.
	  Nel caso quest'ultimo contenesse una sola equazione è possibile
	  indicare i nomi di due parametri fra parentesi per recuperare
	  la covarianza stimata fra i parametri di nome
	  <argname>s1</argname> e <argname>s2</argname>.
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  Questo accessore non è disponibile per modelli di tipo VAR o
	  VECM; in tal caso, si veda piuttosto <fncref targ="$sigma"/> e
	  <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM; restituisce una matrice in cui
	  le matrici Gamma (cioè i coefficienti delle differenze
	  ritardate) sono messe una fianco all'altra.  Ogni riga
	  rappresenta un'equazione; per un VECM di ordine
	  <math>p</math> ci sono <math>p</math> &minus; 1
	  sottomatrici.
	</para>
      </description>
    </function>

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Restituisce un valore intero che codifica la versione del
	  programma, La versione attuale di gretl è data da un numero a 4
	  cifre, per l'anno, seguito da una lettera da a a j, che indica
	  la sequenza di rilasci all'interno dell'anno (ad esempio,
	  2015d). Il valore di ritorno è dato dall'anno moltiplicato per
	  10 più l'ordinale della lettera (a base a=0), cosicché 2015d
	  diventa 20153.
	</para>
	<para>
	  In precedenza (prima della versione 2015d) la versione era in
	  forma <lit>x.y.z</lit> (ad esempio, 1.7.6).  Il valore prodotto
	  da questo accessore è pari a <lit>10000*x + 100*y + z</lit>,
	  cosicché 1.7.6 diventa 10706. Come si vede, l'ordinamento
	  risulta preservato dal vecchio al nuovo sistema.
	</para>
      </description>
    </function>


    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VAR o di un VECM; restituisce
	  una matrice contenente la rappresentazione VMA fino
	  all'ordine specificato tramite il comando <lit>set
	  horizon</lit>. Per maggiori dettagli, si veda <guideref
	  targ="chap:var"/>.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Restituisce 1 se gretl sta girando sotto Windows e 0
	  altrimenti. Questo accessore viene tipicamente usato per
	  scrivere script portabili da un sistema operativo ad un
	  altro.
	</para>
	<para>
	  Si veda anche il comando <cmdref targ="shell"/>.
	</para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  Se l'ultimo modello stimato è un'equazione singola,
	  restituisce la lista dei regressori. Se l'ultimo modello
	  stimato è un sistema di equazioni, restituisce la lista
	  <quote>globale</quote> delle variabili esogene e
	  predeterminate (nello stesso ordine con cui compaiono in
	  <fncref targ="$sysB"/>). Se l'ultimo modello è un VAR,
	  restituisce la lista dei regressori esogeni, laddove
	  presenti.
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Quando segue la stima di un VAR o di un VECM, restituisce
	  <math>X'X</math><sup>-1</sup>, dove <math>X</math> è la
	  matrice comune dei regressori usati in ciascuna delle
	  equazioni. Questo accessore non è disponibile per un VECM
	  stimato con una restrizione imposta su &agr;, la matrice dei
	  <quote>loading</quote>.
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Restituisce i valori stimati dall'ultima regressione.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  Se l'ultimo modello stimato è un VAR, un VECM o un sistema
	  di equazioni simultanee, restituisce la lista delle
	  variabili endogene nel modello. Se l'ultimo modello stimato
	  è un'equazione singola, questo accessore fornisce una lista
	  di un solo elemento: la variabile dipendente. Nel caso
	  particolare di un modello biprobit la lista contiene due
	  elementi.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Stringhe predefinite" ref="string_constants">

    <function name="$dotdir" section="access" output="string">
      <description>
	<para>
	  Questo accessore restituisce il percorso dove gretl salva i
	  file temporanei. Per usare questa stringa in modalità
	  sostituzione, si usi la chiocciola (<lit>@dotdir</lit>).
	</para>
      </description>
    </function>

    <function name="$gnuplot" section="straccess" output="string">
      <description>
        <para>
	  Restituisce il percorso completo all'eseguibile di
	  <lit>gnuplot</lit>. Per usare questa stringa in modalità sostituzione,
	  si usi la chiocciola (<lit>@gnuplot</lit>).
        </para>
      </description>
    </function>

    <function name="$gretldir" section="straccess" output="string">
        <description>
        <para>
	  Restituisce il percorso completo dell'installazione di
	  gretl. Per usare questa stringa in modalità sostituzione, si
	  usi la chiocciola (<lit>@gretldir</lit>).
        </para>
        </description>
    </function>

    <function name="$lang" section="access" output="string">
      <description>
	<para>
	  Restituisce una stringa indicante la lingua attualmente
	  usata da gretl, se può essere determinata. La stringa è data
	  da un codice a due lettere ISO 639-1 (per esempio,
	  <lit>en</lit> per l'inglese, <lit>jp</lit> per il
	  giapponese, <lit>el</lit> per il greco) seguito da un
	  trattino basso e un codice a due lettere ISO 3166-1 per il
	  paese.  Quindi, ad esempio, il portoghese europeo è
	  <lit>pt_PT</lit>, mentre quello brasiliano è
	  <lit>pt_BR</lit>.
	</para>
	<para>
	  Se la lingua di sistema non si può determinare, il risultato
	  è la stringa <quote><lit>unknown</lit></quote>.
	</para>
      </description>
    </function>

    <function name="$seats" section="straccess" output="string">
        <description>
        <para>
	  Restituisce il percorso completo all'eseguibile di
	  <lit>seats</lit>. Per usare questa stringa in modalità
	  sostituzione, si usi la chiocciola (<lit>@seats</lit>).
        </para>
        </description>
    </function>

    <function name="$tramo" section="straccess" output="string">
        <description>
        <para>
	  Restituisce il percorso completo all'eseguibile di
	  <lit>tramo</lit>. Per usare questa stringa in modalità
	  sostituzione, si usi la chiocciola (<lit>@tramo</lit>).
        </para>
        </description>
    </function>

    <function name="$tramodir" section="straccess" output="string">
        <description>
        <para>
	  Restituisce il percorso completo dell'installazione di
	  <lit>tramo</lit>. Per usare questa stringa in modalità
	  sostituzione, si usi la chiocciola (<lit>@tramodir</lit>).
        </para>
        </description>
    </function>

    <function name="$workdir" section="access" output="string">
      <description>
	<para>
	  Questo accessore restituisce il percorso di default dove
	  gretl legge e scrive file. Una descrizione più ampia si
	  trova nella Command Reference sotto <cmdref
	  targ="workdir"/>. Si noti che questa stringa può essere
	  impostata tramite il comando <cmdref targ="set"/>. Per usare
	  questa stringa in modalità sostituzione, si usi la
	  chiocciola (<lit>@tramodir</lit>).
        </para>
      </description>
    </function>

    <function name="$x12a" section="straccess" output="string">
        <description>
        <para>
	  Restituisce il percorso completo all'eseguibile di
	  <lit>x-12-arima</lit> (o <lit>x-13-arima</lit>). Per usare
	  questa stringa in modalità sostituzione, si usi la
	  chiocciola (<lit>@x12a</lit>).
        </para>
        </description>
    </function>

    <function name="$x12adir" section="straccess" output="string">
        <description>
        <para>
	  Restituisce il percorso completo dell'installazione di
	  <lit>x-12-arima</lit> (o <lit>x-13-arima</lit>). Per usare
	  questa stringa in modalità sostituzione, si usi la
	  chiocciola (<lit>@x12adir</lit>).
        </para>
        </description>
    </function>

  </funclist>

  <funclist name="Funzioni vere e proprie" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Valore assoluto di <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Arcocoseno di <argname>x</argname>, ossia il numero il cui
	  coseno è <argname>x</argname>.  Il risultato è in radianti;
	  l'argomento deve essere compreso fra &minus;1 e 1.
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcoseno iperbolico di <argname>x</argname>
	  (soluzione positiva). <argname>x</argname> deve essere maggiore di 1;
	  in caso contrario, viene restituito NA.
	  <seelist>
            <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="series-or-list">byvar</fnarg>
	<fnarg type="string" optional="true">funcname</fnarg>
      </fnargs>
      <description>
	<para>
	  La maggior parte di quel che segue assume che i primi due
	  argomenti siano serie o liste, ma si veda sotto 
	  <quote>Input matriciale</quote> per un uso alternativo.
	</para>
	<para>
	  Nella versione più minimale, <argname>x</argname> è la
	  parola chiave <lit>null</lit>, <argname>byvar</argname> è
	  una serie e il terzo argomento è omesso oppure
	  <lit>null</lit>. La funzione produce una matrice con due
	  colonne contenenti rispettivamente i valori distinti di
	  <argname>byvar</argname>, ordinati in senso ascendente e le
	  corrispondenti frequenze assolute di
	  <argname>byvar</argname>. Ad esempio,
	</para>
	<code>
	  open data4-1
	  eval aggregate(null, bedrms)
	</code>
	<para>
	  mostrerà che la serie <lit>bedrms</lit> ha come valori
	  3 (in 5 casi) e 4 (in 9 casi).
	</para>
	<para>
	  Più in generale, se <argname>byvar</argname> è una lista di
	  <math>n</math> elementi, allora le prime <math>n</math>
	  colonne da sinistra contengono le combinazioni dei valori
	  distinti di ciascuna delle <math>n</math> variabili, mentre la
	  colonna immediatamente successiva contiene il numero delle
	  osservazioni in cui ciascuna combinazione
	  ricorre. Quest'ultima, quindi, starà alla posizione
	  <lit>nelem(byvar) + 1</lit>.
	</para>
	<subhead>Uso con un operatore funzionale</subhead>
	<para>
	  Se viene usato il terzo argomento, <argname>x</argname> non
	  può essere <lit>null</lit>, e le <math>m</math> colonne più
	  a destra contengono i valori della statistica specificate da
	  <argname>funcname</argname> per ciascuna delle variabili in
	  <argname>x</argname>. (Pertanto, <math>m</math> è 1 se
	  <argname>x</argname> <argname>x</argname> è una serie e
	  <lit>nelem(x)</lit> se <argname>x</argname> è una lista.)
	  La statistica è calcolata per righe sulla base dei
	  sottocampioni definiti dalle combinazioni dei valori di
	  <argname>byvar</argname>, in senso ascendente; tali
	  combinazioni sono mostrate nelle prime <math>n</math>
	  colonne della matrice risultato.
	</para>
	<para>
	  Quindi, quando <argname>x</argname> che
	  <argname>byvar</argname> siano ambedue delle serie, la
	  matrice risultato avrà tre colonne, contenenti
	  rispettivamente i valori di <argname>byvar</argname>, in
	  senso ascendente, il numero di osservazioni di
	  <argname>byvar</argname> per ognuno di essi e i valori della
	  statistica specificata da <argname>funcname</argname>,
	  calcolati su <argname>x</argname> sul sottocampione dato
	  dalle osservazioni in cui <argname>byvar</argname> prende il
	  valore in colonna 1.
	</para>
	<para>
	  I seguenti valori di <argname>funcname</argname> sono
	  supportati <quote>in modo nativo</quote>: <fncref
	  targ="sum"/>, <fncref targ="sumall"/>, <fncref
	  targ="mean"/>, <fncref targ="sd"/>, <fncref targ="var"/>,
	  <fncref targ="sst"/>, <fncref targ="skewness"/>, <fncref
	  targ="kurtosis"/>, <fncref targ="min"/>, <fncref
	  targ="max"/>, <fncref targ="median"/>, <fncref
	  targ="nobs"/>, <fncref targ="gini"/>, <fncref
	  targ="isconst"/> e <fncref targ="isdummy"/>. Ciascuna di
	  queste funzioni accetta come argomento una variabile e
	  restituisce uno scalare, e in tal senso può dirsi che
	  <quote>aggrega</quote> la variabile in un qualche modo. È
	  anche possibile inserire il nome di una funzione definita
	  dall'utente come aggregatore. Come le funzioni supportate in
	  modo nativo, tale funzione deve accettare come argomento una
	  singola variabile e ritornare uno scalare.
	</para>
	<para>
	  Si noti che, benché il conteggio dei casi sia fornito
	  automaticamente, la funzione <lit>nobs</lit> non è
	  ridondante come aggregatore, poiché fornisce il numero di
	  osservazioni valide (non-missing) in <argname>x</argname>
	  per ciascuna combinazione <argname>byvar</argname>.
	</para>
	<para>
	  Ad esempio, mettiamo che <lit>region</lit> sia la codifica
	  di regioni geografiche con valori interi da 1 ad
	  <math>n</math> e <lit>income</lit> il reddito
	  familiare. Allora quanto segue produrrà una matrice <by
	  r="n" c="3"/> contenente: nella prima colonna, i codici
	  delle regioni; nella seconda, il numero delle osservazioni
	  in ciascuna regione; nella terza, il reddito familiare medio
	  per regione:
	</para>
	<code>
	  matrix m = aggregate(income, region, mean)
	</code>
	<para>
	  Per un esempio che utilizza liste, si ipotizzi che
	  <lit>gender</lit> sia una variabile dummy maschio/femmina e
	  <lit>race</lit> una variabile categoriale con tre possibili
	  valori.
	</para>
	<code>
	  list BY = gender race
	  list X = income age
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  Il codice qui sopra genererà una matrice con <by r="6"
	  c="5"/>: le prime due colonne conterranno le combinazioni
	  possibili gender/race; quella centrale il numero di
	  osservazioni di ciascuna di queste combinazioni; e le ultime
	  due la deviazione standard campionaria di <lit>income</lit>
	  e <lit>age</lit>:
	</para>
	<para>
	  Si noti che, nel caso in cui <argname>byvar</argname> sia
	  una lista, alcune combinazioni dei valori di
	  <argname>byvar</argname> potrebbero non essere presenti nei
	  dati (il numero di osservazioni sarà zero). In tal caso, il
	  valore delle statistiche per <argname>x</argname> viene
	  registrato come <lit>NaN</lit> (Not a Number). Nel caso si
	  voglia non considerare tali casi, si può utilizzare la
	  funzione <fncref targ="selifr"/> per selezionare solo le
	  righe associate ad un numero di osservazioni diverso da
	  zero. La colonna da testare sarà quella immediatamente a
	  destra delle prime <math>n</math> colonne partendo da
	  sinistra, dove <math>n</math> è il numero di variabili
	  <argname>byvar</argname>. Possiamo quindi eseguire il
	  seguente codice:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
	<subhead>Input matriciale</subhead>
	<para>
	  Anziché serie o liste, <argname>x</argname> e
	  <argname>byvar</argname> possono essere matrici. Tuttavia,
	  se vengono forniti entrambi gli argomenti, devono
	  corrispondere nel tipo (non è possibile fornire una serie o
	  un elenco per un argomento e una matrice per l'altro) e le
	  due matrici devono avere lo stesso numero di righe. Si noti
	  inoltre che in questo contesto le colonne della matrice
	  vengono trattate come se fossero serie, quindi la funzione
	  di aggregazione deve seguire lo schema descritto sopra,
	  prendendo un argomento di serie e restituendo uno scalare.
	</para>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string" optional="true">default</fnarg>
      </fnargs>
      <description>
	<para>
	  Per <argname>s</argname>, il nome di un parametro in una
	  funzione definita dall'utente, restituisce il nome del
	  corrispondente argomento, o una stringa vuota se l'argomento
	  era anonimo. Se l'argomento non ha nome, viene prodotta una
	  stringa vuota, a meno che non venga usato l'argomento
	  <argname>default</argname>, che viene usato in tal caso.
	</para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione <quote>costruttrice</quote> di base per una nuova
	  variabile di tipo array. Nell'uso di questa funzione, si
	  deve specificare un tipo (in forma plurale) per l'array:
	  <lit>strings</lit>, <lit>matrices</lit>, <lit>bundles</lit>
	  oppure <lit>lists</lit>.  Il valore prodotto è un array del
	  tipo specificato con <argname>n</argname> elementi, ognuno
	  dei quali è inizializzato come <quote>vuoto</quote> (ad
	  esempio, stringhe nulle, matrici 0x0). Esempi d'uso:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  Vedi anche <fncref targ="defarray"/>.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcoseno di <argname>x</argname>, cioè, il
	  valore il cui seno è <argname>x</argname>.  Il risultato è
	  in radianti; l'input deve essere tra &minus;1 e 1, estremi
	  compresi.
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcoseno iperbolico di <argname>x</argname>.
	  <seelist>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="asort" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="array">a</fnarg>
	<fnarg type="string">fname</fnarg>
      </fnargs>
      <description>
	<para>
	  Esegue un ordinamento sul posto degli elementi di
	  <argname>a</argname>, utilizzando una funzione comparatrice
	  specificata dal chiamante sotto il controllo della routine
	  quicksort.
	</para>
	<para>
	  L'argomento <argname>a</argname> può essere di qualsiasi
	  tipo supportato per un array gretl, vale a dire
	  <lit>strings</lit>, <lit>matrices</lit>, <lit>bundles</lit>,
	  <lit>lists</lit> o <lit>arrays</lit>. L'argomento
	  <argname>fname</argname> deve essere il nome di una funzione
	  a due argomenti <lit>const</lit>, il cui tipo corrisponde a
	  quello degli elementi di <argname>a</argname>. Tale funzione
	  deve tornare un valore intero secondo il seguente schema: 0
	  se due gli argomenti hanno lo stesso ordinamento, negativo
	  se il primo l'argomento viene ordinato prima del secondo, o
	  positivo se è il secondo ordina prima del primo. (I valori
	  esatti non contano.)
	</para>
	<para>
	  Ad esempio, supponiamo di voler ordinare un array di bundle,
	  ognuno dei quali contiene uno scalare chiamato
	  <lit>crit</lit>, per valori crescenti di <lit>crit</lit>. La
	  funzione seguente sarebbe adatta come argomento di
	  <lit>asort</lit>:
	</para>
	<code>
	  function scalar my_bsort (const bundle b1, const bundle b2)
	    return sgn(b1.crit - b2.crit)
	  end function
	</code>
	<para>
	  Se si desidera preservare l'array non ordinato, bisogna
	  crearne una copia prima di passarlo a <lit>asort</lit>. Il
	  valore restituito dalla funzione è 0 in caso di successo.
	</para>
	<para>
	  Vedi anche <fncref targ="sort"/> per l'ordinamento semplice di un
	  array di stringhe.
	</para>
      </description>
    </function>

    <function name="assert" section="programming" output="scalar">
      <fnargs>
	<fnarg type="scalar">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione serve per testare o fare il debug di codice
	  hansl. L'argomento deve essere un'espressione scalare. Il
	  valore ritornato è 1 se <argname>expr</argname> ritorna un
	  valore non-zero (il valore booleano <quote>vero</quote>, o
	  <quote>successo</quote>) o 0 se l'espressione uguaglia zero
	  (il valore booleano <quote>falso</quote>, o
	  <quote>insuccesso</quote>).
	</para>
	<para>
	  Di default, non ci sono conseguenze se <lit>assert</lit>
	  fallisce, a parte il fatto che il valore restituito è
	  zero. Tuttavia, si può usare il comando <cmdref targ="set"/>
	  per far sì che succeda qualcosa in caso di insuccesso. Ci
	  sono tre livelli:
	</para>
	<code>
	  # stampa un messaggio di avvertimento ma l'esecuzione continua
	  set assert warn
	  # stampa un messaggio e interrompe l'esecuzione dello script
	  set assert stop
	  # stampa un messaggio su stderr e chiude il programma
	  set assert fatal
	</code>
	<para>
	  Nella maggior parte dei casi, <lit>stop</lit> è sufficiente
	  per fermare lo script, ma in alcuni casi particolari (come la
	  chiamata in una funzione contenuta in un blocco tipo <cmdref
	  targ="mle"/>) potrebbe essere necessario usare
	  <lit>fatal</lit> per avere una chiara indicazione
	  dell'asserzione fallita. Si noti che in questo caso il
	  messaggio sarà scritto sul device "standard error".
       </para>
	<para>
	  Il comportamento standard viene ripristinato col comando
	</para>
	<code>
	  set assert off
	</code>
	<para>
	  Un esempio semplice: se a un certo punto di uno script lo
	  scalare <lit>x</lit> dev'essere non-negativo, questo codice
	  controllerà questa condizione e fermerà l'esecuzione se essa
	  non è soddisfatta:
	</para>
	<code>
	  set assert stop
	  assert(x >= 0)
	</code>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione arcotangente di <argname>x</argname>, ossia il valore
	  la cui tangente è <argname>x</argname>.  Il risultato è in
	  radianti.
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
            <fncref targ="tan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il valore principale dell'arcotangente di
	  <argname>y</argname>/<argname>x</argname>, usando i segni
	  dei due argomenti per determinare il quadrante del
	  risultato, che è espresso in radianti, nell'intervallo
	  [&minus;&pi;, &pi;].
	</para>
	<para>
	  Se i due argomenti sono di tipo diverso, il risultato è del
	  tipo <quote>più alto</quote>dei due, dove l'ordinamento è
	  matrice &gt; serie &gt; scalare. Ad esempio, se
	  <argname>y</argname> è uno scalare e <argname>x</argname> un
	  vettore di <math>n</math> elementi (o viceversa), il
	  risultato è anch'esso un vettore. Si noti che gli argomenti
	  matriciali debbono essere vettori, e che se nessuno dei due
	  è uno scalare devono avere la stessa dimensione.
	</para>
	<para>
	  <seelist>
            <fncref targ="tan"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcotangente iperbolica di <argname>x</argname>.
	  <seelist>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Analoga alla funzione della libreria C con lo stesso
	  nome. Restituisce il risultato della conversione della stringa
	  <argname>s</argname> (o della porzione di essa che segue
	  qualsiasi spazio iniziale) in un numero a virgola mobile. In
	  modo diverso dalla funzione <lit>atof</lit> in C, comunque, per
	  questioni di portabilità, si assume sempre che il carattere
	  decimale sia <quote><lit>.</lit></quote>. Qualsiasi carattere
	  che segue la porzione di <argname>s</argname> convertita in
	  numero decimale a virgola mobile sotto questa assunzione è
	  ignorata.
	</para>
	<para>
	  Se nessuna porzione di <argname>s</argname> (che segue
	  qualsiasi spazio iniziale) risulta convertibile sotto le
	  suddette assunzioni, la funzione restituisce <lit>NA</lit>.
	</para>
	<code>
	  # examples
	  x = atof("1.234") # gives x = 1.234
	  x = atof("1,234") # gives x = 1
	  x = atof("1.2y")  # gives x = 1.2
	  x = atof("y")     # gives x = NA
	  x = atof(",234")  # gives x = NA
	</code>
	<para>
	  Si veda anche <fncref targ="sscanf"/> per modalità più flessibili di
	  conversione da stringa a numero.
	</para>
      </description>
    </function>

    <function name="bcheck" section="programming" output="scalar">
      <fnargs>
	<fnarg type="bundleref">target</fnarg>
	<fnarg type="bundle">input</fnarg>
	<fnarg type="strings" optional="true">chiaviric</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è tipicamente usata per la scrittura di
	  pacchetti di funzioni quando, data una funzione che prende
	  un bundle come argomento, diverse scelte sono
	  possibili: alcuni elementi del bundle possono avere dei
	  default, cosicché una scelta esplicita non è indispensabile,
	  mentre altri elementi potrebbero essere obbligatori. Bisogna
	  determinare se il bundle passato come argomento è valido. Il
	  testo che segue assume che venga fornito un bundle
	  <argname>input</argname> dal chiamante, ma si veda la
	  sezione <quote>Nessun bundle in input</quote>per il caso opposto.

	</para>
	<para>
	  A tal fine, si costruisce un bundle di riferimento che
	  contiene tutte le chiavi supportate, con valori che
	  esemplificano il tipo associato ad ognuna; questo bundle di
	  riferimento viene passato, in forma di puntatore, come
	  <argname>target</argname>. Il secondo argomento,
	  <argname>input</argname>, è il bundle passato alla funzione
	  originaria. la funzione <lit>bcheck</lit> effettua i
	  seguenti controlli:
	</para>
	<ilist>
	  <li>
	    <para>
	      Ci sono delle chiavi in <argname>input</argname> ma non
	      in <argname>target</argname>? In tal caso,
	      <lit>bcheck</lit> ritorna un valore non-zero, indicante
	      che <argname>input</argname> è erroneo. (In molti casi,
	      è semplicemente un errore di battitura.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Ci sono delle chiavi in <argname>input</argname> di tipo
	      diverso da quello della chiave corrispondente in
	      <argname>target</argname>? Anche in questo caso, il
	      valore restituito dalla funzione è non-zero.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se uno o più argomenti in <argname>target</argname> non
	      hanno un valore di default (e quindi il valore assegnato
	      è semplicemente un esempio del tipo di dato atteso),
	      bisogna passare alla funzione <lit>bcheck</lit> un terzo
	      argomento: un array di stringhe con le chiavi per cui
	      l'input non è opzionale. Questo farà sì che il valore
	      restituito dalla funzione sia non-zero se il bundle
	      <argname>input</argname> è privo di una o più di queste
	      chiavi.
	    </para>
	  </li>
	</ilist>
	<para>
	  In aggiunta a questi controlli, uno potrebbe voler imporre
	  dei limiti (inferiore o superiore) ad alcuni dei membri
	  scalari del bundle. In tal caso, va aggiunto un bundle di
	  nome <lit>bounds</lit> a quello di riferimento. Ogni membro
	  di questo bundle secondario deve vere una <i>chiave</i> che
	  identifica un membro del nbundle di riferimento; il suo
	  <i>valore</i> deve essere un vettore a due elementi col
	  minimo e il massimo, usando <lit>NA</lit> al posto di uno
	  dei due limiti se necessario. Quindi, ad esempio, il codice
	  seguente controllerà che <lit>x1</lit> is sia fra 1 e 5, e
	  che <lit>x2</lit> sia non negativo:
	</para>
	<code>
	  template.bounds = _(x1={1,5}, x2={0,NA})
	</code>
	<para>
	  Se i controlli precedenti sono andati a buon fine, i valori
	  contenuti in <argname>input</argname> vengono copiati in
	  <argname>target</argname> (e quindi i valori di default sono
	  rimpiazzati da quelli scelti dall'utente). Se si verificano
	  errori a questo punto, verrà stampato un messaggio
	  esplicativo dei problemi riscontrati in
	  <argname>input</argname>.
	</para>
	<para>
	  Facciamo un semplice esempio: prendiamo una funzione che ha
	  come argomento un bundle contenente (obbligatoriamente) una
	  matrice <lit>X</lit>, uno scalare <lit>z</lit> non negativo
	  con default pari a 0, e una stringa <lit>s</lit> con default
	  pari a <quote><lit>display</lit></quote>. Il frammento
	  seguente controllerà la correttezza del bundle
	  <lit>uservals</lit>, che si immagina fornito dalla funzione
	  chiamante:
	</para>
	<code>
	  bundle target = _(X={}, z=0, s="display")
	  target.bounds = _(z={0,NA})
	  strings req = defarray("X")
	  err = bcheck(&amp;target, uservals, req)
	  if err
	     # fa' qualcosa
	  else
	     # vai avanti
	  endif
	</code>
        <subhead>Nessun bundle in input</subhead>
        <para>
	  Se il bundle <argname>input</argname> non viene fornito a
	  <lit>bcheck</lit>, questa si comporta come segue. Se
	  l'argomento <argname>chiaviric</argname> non viene fornito,
	  restituisce zero (poiché nessuna delle condizioni di errore
	  menzionate sopra può verificarsi) e
	  <argname>target</argname> non viene modificato. Altrimenti
	  restituisce un valore diverso da zero poiché è chiaro che
	  una o più specifiche mancano. Questo comportamento fa sì che
	  passare un <argname>input</argname> nullo a
	  <lit>bcheck</lit> non provoca errori.
        </para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">type</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola una delle varianti della funzione di Bessel di
	  ordine <argname>v</argname> con argomento
	  <argname>x</argname>. Il valore restituito è dello stesso
	  tipo dell'argomento <argname>x</argname>. La variante
	  specifica della funzione è selezionata sulla base del primo
	  argomento, che deve essere <lit>J</lit>, <lit>Y</lit>,
	  <lit>I</lit>, o <lit>K</lit>.  Una buona discussione delle
	  funzioni di Bessel si trova su Wikipedia; qui forniamo una
	  breve sintesi.
	</para>
	<para>
	  caso <lit>J</lit>: Funzione di Bessel del primo
	  tipo. Ricorda un'onda sinusoidale smorzata. Definita per
	  reali. Tuttavia, se <argname>x</argname> è negativo,
	  <argname>v</argname> deve essere un numero intero.
	</para>
	<para>
	  caso <lit>Y</lit>: Funzione di Bessel del secondo
	  tipo. Definita per <argname>v</argname> e
	  <argname>x</argname> reali, ma ha una singolarità a
	  <argname>x</argname> = 0.
	</para>
	<para>
	  caso <lit>I</lit>: Funzione di Bessel modificata del primo
	  tipo. Una funzione con crescita esponenziale. Gli argomenti
	  accettati sono gli stessi del caso <lit>J</lit>.
	</para>
	<para>
	  caso <lit>K</lit>: Funzione di Bessel modificata del secondo
	  tipo. Una funzione con decadimento esponenziale. Diverge a
	  <argname>x</argname> = 0 e non è definita per valori
	  negativi di <argname>x</argname>. È simmetrica
	  attorno a <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Massimizzazione numerica con il metodo di Broyden, Fletcher,
	  Goldfarb e Shanno. Il vettore <argname>b</argname> deve
	  contenere i valori iniziali di un insieme di parametri,
	  mentre la stringa <argname>s</argname> deve specificare la
	  chiamata a una funzione che calcola il criterio (scalare) da
	  massimizzare, dati i valori correnti dai parametri e
	  qualsiasi altro dato rilevante. Se l'oggetto è di fatto una
	  minimizzazione, è sufficiente ridefinire la funzione
	  chiamata in modo che restituisca il criterio cambiato di
	  segno. In caso di successo, <lit>BFGSmax</lit> restituisce
	  il valore massimizzato del criterio, e <argname>b</argname>
	  contiene i valori dei parametri associati al valore del
	  criterio restituito.
	</para>
	<para>
	  Il terzo argomento opzionale permette di fornire le derivate
	  analitiche (in caso contrario il gradiente è calcolato
	  numericamente). La chiamata della funzione del gradiente
	  <argname>g</argname> deve avere come primo argomento una matrice
	  predefinita con dimensioni identiche a quelle del gradiente,
	  indicata con un puntatore. Inoltre deve accettare il vettore dei
	  parametri fra gli argomenti (come puntatore o altro). Gli altri
	  argomenti sono opzionali.
	</para>
	<para>
	  Per maggiori dettagli ed esempi, si veda il capitolo sui metodi
	  numerici in <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Come <fncref targ="BFGSmax"/>, ma risolve un problema di
	  minimo anziché di massimo.
	</para>
      </description>
    </function>

    <function name="BFGScmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="matrix">bounds</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Massimizzazione numerica vincolata via L-BFGS-B (limited
	  memory BFGS, vedi <cite key="byrd-etal95">Byrd, Lu, Nocedal
	  e Zhu, 1995</cite>).  In ingresso, il vettore
	  <argname>b</argname> contiene i valori iniziali di un
	  insieme di parametri, <argname>bounds</argname> contiene i
	  vincoli a tali parametri (vedi sotto), e
	  <argname>f</argname> specifica la chiamata ad una funzione
	  che ritorna il criterio (scalare) da massimizzare, dati i
	  valori dei parametri ed altri dati rilevanti. Per un
	  problema di minimo, basterà definire la funzione col segno
	  cambiato.  Se la funzione va a buon fine,
	  <lit>BFGScmax</lit> ritorna il massimo della funzione
	  obiettivo, sotto i vincoli contenuti in
	  <argname>bounds</argname>, mentre <argname>b</argname>
	  conterrà i parametri che producono tale valore.
	</para>
        <subhead>Vincoli sui parametri</subhead>
	<para>
	  La matrice <argname>bounds</argname> dovrà avere 3 colonne e
	  tante righe quanti sono gli elementi vincolati del vettore
	  di parametri <argname>b</argname>. Per ogni riga, il primo
	  elemento è l'indice (a base 1) del parametro da vincolare;
	  il secondo ed il terzo sono rispettivamente i limiti
	  inferiore e superiore. Per indicare l'assenza di vincolo in
	  una direzione, si usano i valori <lit>-$huge</lit> e
	  <lit>$huge</lit>. Ad esempio, il vincolo secondo cui il
	  secondo elemento del vettore dev'essere non-negativo si
	  esprime come:
	</para>
	<code>
	  matrix bounds = {2, 0, $huge}
	</code>
        <subhead>Derivate analitiche</subhead>
	<para>
	  Il terzo argomento (opzionale) permette di fornire il
	  gradiente analitico (se assente, il gradiente sarà calcolato
	  numericamente).  La chiamata alla funzione gradiente
	  <argname>g</argname> deve avere come primo argomento una
	  puntatore ad una matrice
	  pre-definita delle dimensioni corrette per contenere il gradiente.
	  Inoltre, deve prendere come argomento il vettore dei
	  parametri (come puntatore o meno). Altri argomenti sono opzionali.
	</para>
	<para>
	  Per maggiori dettagli ed esempi si veda <guideref
	  targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGScmin" section="numerical" output="scalar">
      <description>
	<para>
	  Come <fncref targ="BFGScmax"/>, ma risolve un problema di
	  minimo anziché di massimo.
	</para>
      </description>
    </function>

    <function name="bin2dec" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Data una matrice binaria <argname>B</argname>, questa funzione
	  interpreta ogni riga come la rappresentazione binaria di un
	  intero, e restituisce un vettore colonna con la
	  rappresentazione decimale di tali interi. La matrice non può
	  avere più di 32 colonne, altrimenti viene generato un errore.
	</para>
	<para>
	  Si noti che il bit meno significativo è nella prima colonna:
	  di conseguenza, la colonna 1 corrisponde a 
	  <math>2</math><sup>0</sup>, la colonna 2 a
	  <math>2</math><sup>1</sup> e così via. Ad esempio, l'espressione
	</para>
	<code>
	  scalar x = bin2dec({1,0,1})
	</code>
	<para>
	  rende <math>x</math> uguale a 5.
	</para>
	<para>
	  La funzione <fncref targ="dec2bin"/> produce la
	  trasformazione inversa.
	</para>
      </description>
    </function>
    
    <function name="bincoeff" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">n</fnarg>
	<fnarg type="anyfloat">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola il coefficiente binomiale, ossia il numero di modi
	  in cui <argname>k</argname> elementi possono essere presi
	  senza ripetizione da <argname>n</argname> scelte possibili,
	  indipendentemente dal loro ordinamento. Questo numero è
	  anche uguale al <argname>(k+1)</argname>-esimo coefficiente
	  nella espansione polinomiale di <equation status="inline"
	  ascii="(1+x)^n" tex="$(1+x)^n$"/>.
	</para>
	<para context="tex">
	  Per argomenti interi, il risultato è $n!/k!(n-k)!$, ma la
	  funzione accetta anche argomenti reali, e la formula si
	  generalizza a $\frac{\Gamma(n+1)}{\Gamma(k+1)
	  \Gamma(n-k+1)}$.
	</para>
	<para context="notex">
	  Per argomenti interi, il risultato è
	  <math>n!/k!(n-k)!</math>, ma la funzione accetta anche
	  argomenti reali, e la formula si generalizza a <math>
	  Γ(n+1)/( Γ(k+1) &times; Γ(n-k+1) )</math>
	</para>
	<para>
	  Quando <argname>k</argname> &gt; <argname>n</argname> oppure
	  <argname>k</argname> &lt; 0, la funzione produce un errore.
	</para>
	<para>
	  Se i due argomenti sono di tipo diverso, il risultato è del
	  tipo <quote>più alto</quote>dei due, dove l'ordinamento è
	  matrice &gt; serie &gt; scalare. Ad esempio, se
	  <argname>n</argname> è uno scalare e <argname>k</argname> un
	  vettore di <math>r</math> elementi (o viceversa), il
	  risultato è anch'esso un vettore. Si noti che gli argomenti
	  matriciali debbono essere vettori, e che se nessuno dei due
	  è uno scalare devono avere la stessa dimensione.
	</para>
	<para>
	  Vedi anche <fncref targ="gammafun"/> e <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="binperms" section="math" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Permutazioni binarie: restituisce una matrice <by r="p"
	  c="n"/>, in cui ognuna delle righe contiene un diverso modo
	  di disporre <math>k</math> uni e <math>n</math> &minus;
	  <math>k</math> zeri (lo so che "uni" non si dice, ma oh). Il
	  valore massimo di <math>n</math> è 64, <math>n</math> e
	  <math>k</math> devono essere non-negativi, e <math>k</math>
	  deve essere minore o uguale a <math>n</math>; altrimenti, ci
	  sarà un errore. Se <math>n</math> = <math>k</math> = 0 il
	  risultato è una matrice vuota.
	</para>
	<para>
	  Per esempio, con <math>n</math> = 4 e <math>k</math> = 2, il
	  risultato è
	</para>
	<code>
	  0   0   1   1 
	  0   1   0   1 
	  0   1   1   0 
	  1   0   0   1 
	  1   0   1   0 
	  1   1   0   0
	</code>
	<para>
	  <emphasis>Attenzione:</emphasis> il numero di permutazioni
	  <math>p</math> cresce molto rapidamente al variare di
	  <math>n</math> e raggiunge il massimo quando <math>k</math>
	  è la metà di <math>n</math>. Può essere consigliabile
	  controllare in anticipo la dimensione della matrice
	  risultato, cosa che si può fare facilmente con <fncref
	  targ="bincoeff"/>, che ritorna <math>p</math>, e lo spazio
	  occupato in memoria dalla matrice risultato (espresso in Mb)
	  si può calcolare con
	</para>
	<code>
	  MB = 8 * n * bincoeff(n, k) / 10^6
	</code>
	<para>
	  Ad esempio, se <math>n</math> = 30 e <math>k</math> = 25, il
	  risultato è di circa 34Mb, ma sale a 7211 MB nel caso
	  <math>k</math> = 20, e a 20758 MB se <math>k</math> = 18.
	</para>
      </description>
    </function>

    <function name="bkfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il risultato dell'applicazione del filtro passa banda di
	  Baxter&ndash;King alla variabile <argname>y</argname>. I parametri
	  opzionali <argname>f1</argname> e <argname>f2</argname>
	  rappresentano, rispettivamente, i limiti inferiore e
	  superiore delle frequenze da estrarre, mentre
	  <argname>k</argname> è l'ordine dell'approssimazione da
	  usare.
	</para>
	<para>
	  Se questi argomenti non sono forniti dall'utente, i valori di
	  default dipendono dalla periodicità del dataset. Per dati
	  annuali, i valori di default per <argname>f1</argname>,
	  <argname>f2</argname> e <argname>k</argname> sono
	  rispettivamente 2, 8 e 3; per dati trimestrali, 6, 32 e 12; per
	  dati mensili, 18, 96 e 36. Questi valori sono scelti in modo da
	  rispettare la scelta più comune fra gli economisti applicati, e
	  cioè di usare questo filtro per estrarre la componente alla
	  frequenza di <quote>business cycle</quote>; questa, a sua volta,
	  è di solito definita come compresa fra 18 mesi e 8 anni. Il
	  filtro, come impostazione predefinita, usa 3 anni di dati.
	</para>
	<para>
	  Se <argname>f2</argname> è maggiore o uguale del numero di
	  osservazioni disponibili, verrà usata la versione "passa-basso"
	  del filtro e il risultato deve essere interpretato come una
	  stima del trend, anziché del ciclo.
	  <seelist>
            <fncref targ="bwfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bkw" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">V</fnarg>
	<fnarg optional="true" type="strings">parnames</fnarg>
	<fnarg optional="true" type="bool">verbose</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola il test diagnostico BKW per la collinearità (vedi
	  <cite key="belsley-etal80">Belsley, Kuh and Welsch
	  (1980)</cite>) data la matrice covarianza delle stime dei
	  parametri <argname>V</argname>. Il secondo argomento
	  opzionale, che che può essere un vettore di stringhe o una
	  stringa contenente nomi separati da virgole, è usato per
	  etichettare le colonne che mostrano le proporzioni della
	  varianza; il numero di nomi deve eguagliare la dimensione di
	  <argname>V</argname>.  Dopo aver stimato un modello in
	  gretl, gli accessori <fncref targ="$vcv"/> e <fncref
	  targ="$parnames"/>. possono essere usati per generare
	  oggetti appropriati per esseri usate come argomenti.
	</para>
	<para>
	  Di default questa funzione producendo solamente la tabella
	  BKW come matrice, ma se si inserisce un valore differente da
	  0 come terzo argomento, insieme alla tabella vengono
	  stampate a video alcune analisi.
	</para>
	<para>
	  Esiste anche un comando che svolge gli stessi calcoli,
	  <cmdref targ="bkw"/>, che automaticamente usa l'ultimo
	  modello stimato e non richiede alcun argomento.
	</para>
      </description>
    </function>

    <function name="boxcox" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la trasformazione Box&ndash;Cox con parametro
	  <argname>d</argname> della variabile positiva
	  <argname>y</argname> (o le colonne della matrice
	  <argname>y</argname>).
	</para>
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  Il risultato è (<math>y</math><sup>d</sup> - 1)/<math>d</math>
	  per <math>d</math> diverso da zero, o log(<math>y</math>) per
	  <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">nomefile</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Legge un bundle dal file <argname>nomefile</argname>. Per
	  default, il bundle deve essere un file XML (opzionalmente
	  compresso se ha estensione<lit>.gz</lit>). Se però
	  l'estensione è <lit>.json</lit> oppure <lit>.geojson</lit>
	  allora si intende che il file è di tipo JSON.
	</para>
	<para>
	  Se il file è XML, esso deve contenere un elemento
	  <lit>gretl-bundle</lit>, usato a sua volta per contenere zero o
	  più elementi <lit>bundled-item</lit>. Ad esempio:
	</para>
	<code>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;gretl-bundle name="temp"&gt;
          &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
          &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
	  &lt;/gretl-bundle&gt;
	</code>
	<para>
	  Come ci si può aspettare, file di questo tipo vengono generati
	  automaticamente dalla funzione complementare <fncref targ="bwrite"/>.
	</para>
	<para>
	  Se il nome di file non contiene un percorso, il file sarà
	  cercato in una o più directory <quote>papabili</quote>,
	  cominciando con la directory settata come <cmdref
	  targ="workdir"/>.  Se viene però indicato un valore non nullo per
	  l'argomento opzionale <argname>import</argname>, la ricerca
	  del file di input avviene all'interno della directory
	  <quote>dot</quote> dell'utente. In questo caso l'argomento
	  <argname>fname</argname> dovrebbe essere semplicemente un
	  nome di file, senza indicazione del percorso.
	</para>
	<para>
	  Se dovesse verificarsi un errore (per esempio dovuto al fatto
	  che il file è inaccessibile o mal formattato) l'accessore
	  <fncref targ="$error"/> risulterà non-zero.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
            <fncref targ="bwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="brename" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">vecchia</fnarg>
	<fnarg type="string">nuova</fnarg>
      </fnargs>
      <description>
	<para>
	  Se il bundle <argname>B</argname> contiene un elemento con
	  l'etichetta <argname>vecchia</argname>, questa viene
	  cambiata in <argname>nuova</argname>; in caso contrario, si
	  produce un errore. Se l'operazione va a buon fine, ritorna
	  0.
	</para>
	<para>
	  Questa non è un'operazione molto comune, ma può essere
	  necessaria in funzioni che lavorano coi bundle, e
	  <lit>brename</lit> permette di svolgere questa operazione in
	  modo efficiente. Esempio:
	</para>
	<code>
	  # costruisci un bundle contenente una grossa matrice
	  bundle b
	  b.X = mnormal(1000, 1000)
	  if 0
	      # cambia la chiave a mano
	      Xcopy = b.X
	      delete b.X
	      b.Y = Xcopy
	      delete Xcopy
	  else
	      # meglio: più efficiente
	      brename(b, "X", "Y")
	  endif
	</code>
	<para>
	  Il primo metodo richiede che la matrice sia copiata due
	  volte, mentre il metodo efficiente cambia direttamente la chiave.
	</para>
      </description>
    </function>

    <function name="bwfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il risultato dell'applicazione di un filtro
	  passa-basso Butterworth di ordine <argname>n</argname> e
	  frequenza di taglio <argname>omega</argname> alla variabile
	  <argname>y</argname>. La frequenza di taglio è espressa in
	  gradi e deve essere maggiore di 0 e minore di 180. Frequenze
	  di taglio minori restringono il passa banda alle frequenze
	  minori e quindi producono trend più smussati. Valori
	  maggiori di <argname>n</argname> producono un taglio più
	  netto, al costo di una possibile instabilità numerica.
	</para>
	<para>
	  L'esame del periodogramma della variabile target è un passo
	  preliminare utile quando si vuole applicare questa
	  funzione. Si veda <guideref targ="chap:tsfilter"/> per i
	  dettagli.
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Salva il bundle <argname>B</argname> in un file di nome
	  <argname>fname</argname> in formato XML oppure, se
	  l'estensione è <lit>.json</lit> o <lit>.geojson</lit>, in
	  formato JSON. Per una sommaria descrizione del formato XML,
	  si veda la funzione <fncref targ="bread"/>.  Se il file
	  <argname>fname</argname> esiste già verrà sovrascritto.  Il
	  valore restituito è 0 in caso l'esecuzione venga portata a
	  termine correttamente; se la scrittura fallisce, sarà
	  generato un errore.
	</para>
	<para>
	  Se il nome di file non contiene un percorso, il file sarà
	  scritto nella directory settata come <cmdref
	  targ="workdir"/>.  Se viene però indicato un valore non
	  nullo per l'argomento opzionale <argname>export</argname>,
	  il file di output sarà salvato nella directory
	  <quote>dot</quote> dell'utente. In questo caso è necessario
	  indicare come secondo argomento il nome del file privo del
	  percorso.
	</para>
	<para>
	  Quando il formato di output è XML il file viene scritto, di
	  default, senza compressione; se però
	  <argname>fname</argname> ha l'estensione <lit>.gz</lit>,
	  allora verrà applicata la compressione gzip.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="carg" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna una matrice reale <by r="m" c="n"/> contenente gli
	  <quote>argomenti</quote> complessi di ogni elemento della
	  matrice complessa <by r="m" c="n"/>
	  <argname>C</argname>. L'argomento del numero complesso
	  <math>z</math> = <math>x</math> + <math>yi</math> può essere
	  calcolato anche come <lit>atan2(y, x)</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="abs"/>
	    <fncref targ="cmod"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">standardize</fnarg>
      </fnargs>
      <description>
	<para>
	  Centra le colonne della matrice <argname>X</argname> attorno
	  alla loro media. Se il secondo argomento (opzionale) è non-zero,
	  allora le colonne vengono standardizzate, usando la deviazione
	  standard aggiustata per gradi di libertà (ossia <math>n</math>
	  &minus; 1, dove <math>n</math> è il numero di righe di
	  <argname>X</argname>).
	</para>
	<para>
	  Se viene fornito un valore nonzero per
	  <argname>skip_na</argname>, i valori mancanti vengono
	  ignorati; altrimenti, se una colonna di <argname>X</argname>
	  contiene valori mancanti, la colonna corrispondente
	  nell'output conterrà solo valori mancanti.
	</para>
	<para>
	  Si noti che la funzione <fncref targ="stdize"/> è più
	  flessibile.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Calcola funzioni di ripartizione. Restituisce <equation
	  status="inline" ascii="P(X &lt; x)" tex="$P(X \le x)$"/>,
	  dove la distribuzione di <math>X</math> è determinata dal
	  carattere <argname>c</argname>. Tra gli argomenti
	  <argname>c</argname> e <argname>x</argname>, possono essere
	  richiesti parametri aggiuntivi a seconda della
	  distribuzione, come specificato qui di seguito.
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normale standard (c = z, n, o N): nessun argomento supplementare
            </para>
	  </li>
	  <li>
            <para>
              Normale bivariata (D): coefficiente di correlazione
            </para>
	  </li>
	  <li>
            <para>
              Logistica (lgt): nessun argomento supplementare
            </para>
	  </li>
	  <li>
            <para>
              t di Student (t): gradi di libertà
            </para>
	  </li>
	  <li>
            <para>
              Chi quadro (c, x, o X): gradi di libertà
            </para>
	  </li>
	  <li>
            <para>
              F di Snedecor (f o F): gradi di libertà (num.); gradi
              di libertà (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g o G): forma; scala
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): 2 parametri di forma
            </para>
	  </li>
	  <li>
            <para>
              Binomiale (b o B): probabilità; numero di prove
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p o P): Media
            </para>
	  </li>
	  <li>
            <para>
              Esponenziale negativa (exp): scala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w o W): forma; scala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l o L): media; scala
            </para>
	  </li>
	  <li>
            <para>
              Generalized Error (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Chi-quadro non centrale (ncX): gdl, parametro di non
	      centralità
	    </para>
	  </li>
	  <li>
	    <para>
	      F non centrale (ncF): gdl (num.), gdl (den.), parametro di
	      non centralità
	    </para>
	  </li>
	  <li>
	    <para>
	      t non centrale (nct): gdl, parametro di non centralità
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribuzione} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Normale standardizzata &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp;
	  -- &amp; -- \\
	  Normale bivariata &amp; \texttt{D} &amp;
	  $\rho$ &amp; -- \\
	  Logistica &amp; \texttt{lgt} &amp;
	  -- &amp; -- &amp; --\\
	  $t$ di Student (centrale) &amp; \texttt{t} &amp;
	  gradi di libertà &amp; -- \\
	  Chi quadro &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp;
	  gradi di libertà &amp; -- \\
	  $F$ di Snedecor &amp; \texttt{f} o \texttt{F} &amp;
	  gdl (num.) &amp; gdl (den.) \\
	  Gamma &amp; \texttt{g} o \texttt{G} &amp;
	  forma &amp; scala \\
	  Binomiale &amp; \texttt{b} o \texttt{B} &amp;
	  probabilit\`a &amp; prove \\
	  Poisson &amp; \texttt{p} o \texttt{P} &amp;
	  media &amp; -- \\
	  Esponenziale &amp; \texttt{exp} &amp;
	  scala &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} o \texttt{W} &amp;
	  forma &amp; scala &amp; --\\
	  Laplace &amp; \texttt{l} or \texttt{L} &amp;
	  media &amp; scala &amp; --\\
	  Generalized Error &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ non centrale &amp; \texttt{ncX} &amp;
	  gdl &amp; non centralit{\`a} &amp; -- \\
	  $F$  non centrale &amp; \texttt{ncF} &amp;
	  gdl (num.) &amp; gdl (den.) &amp; non centralit{\`a}  \\
	  $t$  non centrale &amp; \texttt{nct} &amp;
	  gdl &amp; non centralit{\`a} &amp; -- \\
	</tabular>
	<para>
	  La maggior parte delle distribuzioni usano degli alias per
	  rendere più agevole la memorizzazione dei codici.  Il caso
	  della normale bivariata è particolare: la sintassi è <lit>x
	  = cdf(D, rho, z1, z2)</lit> dove <lit>rho</lit> è la
	  correlazione fra <lit>z1</lit> e <lit>z2</lit>.
	</para>
	<para context="tex">
	  La parametrizzazione che \app{gretl} adotta per la
	  v.c. Gamma implica che la funzione di densità possa essere
	  scritta come
	  \[
	  f(x; k, \theta) = \frac{x^{k-1}}{\theta^k}
	  \frac{e^{-x/\theta}}{\Gamma(k)}
	  \]
	  dove $k>0$ è il parametro
	  di forma e $\theta>0$ il parametro di scala.
	</para>
	<para>
	  <seelist>
            <fncref targ="pdf"/>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è obsoleta: risale a prima che gretl
	  supportasse i numeri complessi e viene mantenuta solo per
	  motivi di compatibilità.
	</para>
	<para>
	  Divisione complessa. I due argomenti devono avere lo stesso
	  numero di righe, <math>n</math>, e una o due colonne.  La
	  prima colonna contiene la parte reale e l'eventuale seconda
	  quella immaginaria.  Restituisce una matrice <by r="n" c="2"/>
	  oppure, se la parte immaginaria del risultato è nulla, un
	  vettore a <math>n</math> elementi.
	  <seelist>
            <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione ritorna una lista in cui ogni serie in
	  <argname>L</argname> che possiede l'attributo
	  <quote>codificata</quote> è sostituita da un insieme di
	  dummy ognuna delle quali rappresenta uno dei valori
	  codificati, omettendo quello più piccolo. Se
	  <argname>L</argname> non contiene serie codificate, la lista
	  risultato sarà identica a <argname>L</argname>.
	</para>
	<para>
	  Le dummy eventualmente generate avranno un nome dato da
	  <lit>D</lit><repl>nomevar</repl><lit>_</lit><repl>vi</repl>
	  dove <repl>vi</repl> è l'<repl>i</repl>-esimo valore
	  rappresentato dalla variabile codificata. Se ve ne fossero
	  di negativi, verrà inserita una <quote>m</quote> prima del
	  valore assoluto di <repl>vi</repl>.
	</para>
	<para>
	  Ad esempio, facciamo che <argname>L</argname> contenga una
	  serie codificata di nome <lit>C1</lit> con valori &minus;9,
	  &minus;7, 0, 1 e 2.  Le dummy generate saranno
	  <lit>DC1_m7</lit> (codifica per C1 = &minus;7),
	  <lit>DC1_0</lit> (codifica per C1 = 0), e così via.
	</para>
	<para>
	  <seelist>
            <fncref targ="dummify"/>
	    <fncref targ="getinfo"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Parte intera superiore: restituisce il più piccolo numero
	  intero maggiore o uguale a <argname>x</argname>.
	  <seelist>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Esegue la decomposizione di Cholesky della matrice
	  <argname>A</argname>. Se <argname>A</argname> è reale, deve
	  essere simmetrica e definita positiva. In tal caso, il
	  risultato è una matrice triangolare inferiore <math>L</math>
	  che soddisfa <equation status="inline" ascii="A = LL'"
	  tex="$A = LL'$"/>. Nel caso complesso, <argname>A</argname> deve
	  essere hermitiana e definita positiva, e il
	  risultato è una matrice triangolare inferiore <math>L</math>
	  tale per cui <equation status="inline" ascii="A = LL^H"
	  tex="$A = LL^{\mathrm H}$"/>.  La funzione restituisce un errore se
	  <argname>A</argname> non è simmetrica o definita positiva.
	</para>
	<para>
	  Per il caso reale, si veda anche <fncref targ="psdroot"/> e
	  <fncref targ="Lsolve"/>.
	</para>
      </description>
    </function>

    <function name="chowlin" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">xfac</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è da ritenersi obsoleta, e il suo uso è
	  sconsigliato: è preferibile usare la funzione <fncref
	  targ="tdisagg"/>.
	</para>
	<para>
	  Espande i dati in ingresso, <argname>Y</argname>, a una
	  frequenza maggiore, usando il metodo di <cite
	  key="chowlin71">Chow e Lin (1971)</cite>. Si assume che le
	  colonne di <argname>Y</argname> rappresentino serie di dati;
	  la matrice restituita ha tante colonne quante sono le
	  colonne di <argname>Y</argname> e tante righe quante sono
	  quelle di <argname>Y</argname> moltiplicate per
	  <argname>xfac</argname>. Si assume anche che ogni valore a
	  bassa frequenza sia trattato come la media di
	  <argname>xfac</argname> valori ad alta frequenza.
	</para>
	<para>
	  Il secondo argomento rappresenta il fattore di espansione:
	  deve essere 3 per espandere la frequenza della serie da
	  trimestrale a mensile, o 4 per espansioni da annuale a
	  trimestrale. Il terzo argomento opzionale può essere
	  utilizzato per generare una matrice di regressori con una
	  frequenza (obiettivo) maggiore.
	</para>
	<para>
	  I regressori utilizzati di default sono una costante e un
	  trend. Se viene fornita <argname>X</argname>, le sue colonne
	  sono utilizzate come regressori addizionali; è un errore se
	  il numero di righe in <argname>X</argname> non è uguale a
	  <argname>xfac</argname> per il numero di righe in
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmod" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna una matrice reale <by r="m" c="n"/> contenente i
	  valori assoluti (o <quote>moduli</quote>) di ogni elemento
	  della matrice complessa <by r="m" c="n"/>
	  <argname>C</argname>. Il modulo del numero complesso
	  <math>z</math> = <math>x</math> + <math>yi</math> è uguale
	  alla radice quadrata di <math>x</math><sup>2</sup> +
	  <math>y</math><sup>2</sup>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="carg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cmult" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è obsoleta: risale a prima che gretl
	  supportasse i numeri complessi e viene mantenuta solo per
	  motivi di compatibilità.
	</para>
	<para>
	  Moltiplicazione complessa. I due argomenti devono avere lo
	  stesso numero di righe, <math>n</math>, e una o due colonne.
	  La prima colonna contiene la parte reale e l'eventuale
	  seconda quella immaginaria.  Restituisce una matrice <by r="n"
	  c="2"/> oppure, se la parte immaginaria del risultato è
	  nulla, un vettore a <math>n</math> elementi.
	  <seelist>
            <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la funzione di distribuzione cumulativa di una normale
	  standard.
	  <seelist>
            <fncref targ="dnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnumber" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna il numero di condizionamento della matrice
	  <argname>X</argname>, di dimensioni <by r="n" c="k"/>, come
	  definito in <cite key="belsley-etal80">Belsley, Kuh e
	  Welsch (1980)</cite>. Se le colonne di <argname>X</argname>
	  sono ortogonali fra loro, il risultato è 1. All'opposto, un
	  valore molto grande del numero di condizionamento è un
	  indicatore di collinearità; per
	  <quote>grande</quote> si intende di solito 50 o più (a
	  volte, 30 o più).
	</para>
	<para>
	  I passi del calcolo sono: (1) formare una matrice
	  <math>Z</math> le cui colonne sono quelle di
	  <argname>X</argname> divise per le rispettive norme
	  euclidee; (2) calcolare gli autovalori di <math>Z'Z</math>;
	  (3) calcolare la radice quadrata del rapporto fra
	  l'autovalore massimo e quello minimo.
	</para>
	<para>
	  <seelist>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Se viene dato l'argomento <argname>col</argname>, ritorna il
	  nome per quella colonna della matrice
	  <argname>M</argname>. Se <argname>M</argname> non ha nomi di
	  colonna viene restituita una stringa vuota; si ha errore se
	  <argname>col</argname> non è un numero di colonna.
	</para>
	<para>
	  Se il secondo argomento non viene fornito, il risultato è un
	  array di stringhe coi nomi di colonna di
	  <argname>M</argname> se ne ha, altrimenti un array vuoto.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  cnameset(A, "Col_A Col_B Col_C")
	  string name = cnameget(A, 3)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="cnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameset" section="matrix" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Attribuisce dei nomi alle colonne della matrice
	  <argname>M</argname> di dimensioni <by r="m" c="n"/>.  Se
	  <argname>s</argname> è una lista, i nomi sono copiati da quelli
	  delle variabili; la lista deve avere tanti elementi quante sono
	  le colonne di <argname>M</argname>. Se <argname>S</argname> è un
	  array di stringhe, deve contenere <math>n</math> elementi; se
	  invece è una sola stringa, deve contenere <math>n</math>
	  sub-stringhe separate da spazi. Come caso particolare,
	  se il secondo argomento è una stringa vuota, i nomi di
	  colonna esistenti saranno rimossi.
	</para>
	<para>
	  Restituisce 0 se la funzione è andata a buon fine; in caso
	  contrario, viene generato un errore. Si veda anche <fncref
	  targ="rnameset"/>.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(2)
	  S[1] = "Col1"
	  S[2] = "Col2"
	  cnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Il numero di colonne di <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="commute" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
	<fnarg optional="true" type="int">post</fnarg>
	<fnarg optional="true" type="int">add_id</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la matrice <argname>A</argname> premoltiplicata
	  per la matrice di commutazione <math>K</math><sub>m,n</sub>
	  (più efficiente che la moltiplicazione esplicita). Ogni
	  colonna di <argname>A</argname> è pensata come la
	  vettorizzazione di una matrice <math>m x n</math>. In
	  particolare,
	</para>
	<code>
	  commute(vec(B), rows(B), cols(B))
	</code>
	<para>
	  produce vec(<math>B'</math>). Per ottenere la matrice di
	  commutazione vera e propria,basta applicare la funzione ad
	  una matrice identità di dimensione appropriata. Ad esempio:
	</para>
	<code>
	  K_32 = commute(I(6), 3, 2)
	</code>
	<para>
	  L'argomento opzionale <argname>n</argname> ha
	  <argname>m</argname> come default.  Se l'argomento opzionale
	  <argname>post</argname> è non-zero, allora viene eseguita la
	  postmoltiplicazione anziché la premoltiplicazione; se
	  l'argomento <argname>add_id</argname> è non-zero, la
	  moltiplicazione sarà eseguita usando <math>I +
	  K</math><sub>m,n</sub> invece di
	  <math>K</math><sub>m,n</sub>.
	</para>
      </description>
    </function>

    <function name="complex" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="scalar-or-matrix">A</fnarg>
	<fnarg optional="true" type="scalar-or-matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna una matrice complessa, dove <argname>A</argname> è
	  utilizzata per fornire la parte reale e <argname>B</argname>
	  quella immaginaria. Se <argname>A</argname> è <by r="m"
	  c="n"/> e <argname>B</argname> è uno scalare, il risultato è
	  <by r="m" c="n"/> con parte immaginaria costante&mdash;e
	  similmente nel caso opposto, ma con parte reale costante. Se
	  entrambi gli argomenti sono matrici, esse devono essere
	  della stessa dimensione.  Se il secondo argomento è omesso,
	  la parte immaginaria è di default uguale a 0.
	  <seelist><fncref targ="cswitch"/></seelist>
	</para>
      </description>
    </function>

    <function name="conj" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna una matrice complessa <by r="m" c="n"/> contenente i
	  complessi coniugati di ogni elemento della matrice complessa
	  <by r="m" c="n"/> <argname>C</argname>. Il coniugato di un
	  numero complesso<math>z</math> = <math>x</math> +
	  <math>yi</math> è uguale a <math>x</math> &minus;
	  <math>yi</math>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="carg"/>
	    <fncref targ="cmod"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="contains" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
	<fnarg type="matrix">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione permette di determinare se l'oggetto
	  <argname>x</argname> contiene uno degli elementi della matrice
	  <argname>S</argname> usate per indicare un insieme.
	</para>
	<para>
	  Il valore restituito è un oggetto della stessa dimensione di
	  <argname>x</argname> contenente elementi zero o uno, a
	  seconda che l'elemento corrispondente di
	  <argname>x</argname> sia uguale ad uno degli elementi di <argname>S</argname>.
	  Ad esempio, il codice
	</para>
	<code>
	  matrix A = mshape(seq(1,9), 3, 3)
	  matrix C = contains(A, {1, 5, 9})
	</code>
	<para>
	  produce il seguente output
	</para>
	<code>
	  A (3 x 3)

	  1   4   7
	  2   5   8
	  3   6   9

	  C (3 x 3)

	  1   0   0
	  0   1   0
	  0   0   1
	</code>
	<para>
	  Questa funzione è particolarmente utile nei casi in cui
	  <argname>x</argname> sia una serie contenente una codifica
	  di una variabile qualitativa, e si desideri estrarre un
	  sottoinsieme delle categorie. Includendo in
	  <argname>S</argname> i valori da estrarre si può ottenere
	  facilmente una dummy con valore 1 per le osservazioni volute
	  e 0 altrimenti.
	</para>
	<para>
	  Poiché <argname>S</argname> è inteso come insieme, è
	  consigliabile per ragioni di efficienza di evitare che
	  contenga valori ripetuti, anche se in realtà la funzione
	  accetta matrici arbitarie.
	</para>
      </description>
    </function>

    <function name="conv2d" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la convoluzione bidimensionale delle matrici
	  <argname>A</argname> and <argname>B</argname>. Se
	  <argname>A</argname> è <by r="r" c="c"/> e
	  <argname>B</argname> è <by r="m" c="n"/> la matrice prodotta
	  avrà <math>r+m-1</math> righe e <math>c+n-1</math> colonne.
	</para>
	<para context="tex">
	  La convoluzione bidimensionale delle matrici
	  <argname>A</argname> e <argname>B</argname> è definita
	  come: \[ C_{i,j} = \sum_{k=1}^r\sum_{l=1}^c A_{k,l}
	  B_{i-k+1,j-l+1}, \] dove le somme includono solo quei
	  valori di $k$ e $l$ per i quali i pedici di $B$ rientrano
	  nei limiti.
	</para>
	<para>
	  <seelist>
            <fncref targ="fft"/>
            <fncref targ="filter"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cquad" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">Z</fnarg>
      </fnargs>
      <description>
	<para>
	  Data una matrice complessa <by r="m" c="n"/>
	  <argname>Z</argname>, restituisce una matrice reale <by
	  r="m" c="n"/> contenente le quadranze degli elementi di
	  <argname>Z</argname>. La quadranza del numero complesso
	  <math>z</math> = <math>a</math> + <math>bi</math> è definita
	  come <math>a</math><sup>2</sup> +
	  <math>b</math><sup>2</sup>, ed è quindi pari al modulo di
	  <math>z</math> al quadrato. È anche uguale al prodotto di
	  <math>z</math> per il suo coniugato, ma l'algoritmo
	  impiegato in <lit>cquad</lit> è considerevolmente più
	  efficiente degli altri due approcci.
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola il coefficiente di correlazione fra
	  <argname>y1</argname> e <argname>y2</argname>. Gli argomenti dovrebbero
	  essere due variabili o due vettori con la stessa lunghezza.
	  <seelist>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	    <fncref targ="npcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corresp" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">a</fnarg>
	<fnarg type="series-or-vec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Sulla base di una tabulazione incrociata di <argname>a</argname>
	  e <argname>b</argname>, restituisce un codice intero
	  indicando il tipo di corrispondenza tra i due
	  variabili, come segue.
	</para>
	<ilist>
	  <li>
	    <para>
	      Codice = 2: esiste una relazione 1 a 1.
	    </para>
	  </li>
	  <li>
	    <para>
	      Codice = 1: esiste una relazione 1 a n
	      (<argname>a</argname> può essere interpretato come una
	      funzione di <argname>b</argname> in senso matematico).
	    </para>
	  </li>
	  <li>
	    <para>
	      Codice = &minus;1: esiste una relazione n a 1
	      (<argname>b</argname> può essere interpretato come una
	      funzione di <argname>a</argname>).
	    </para>
	  </li>
	  <li>
	    <para>
	      Codice = 0: non c'è relazione.
	    </para>
	  </li>
	</ilist>
	<para>
	  Si noti che questi codici si basano esclusivamente sui
	  valori campionari dei due argomenti. Nel caso in cui
	  <argname>b</argname> sia il quadrato di
	  <argname>a</argname>, ad esempio, il risultato sarà diverso
	  a seconda che <argname>a</argname> contenga o meno alcune
	  coppie di valori che differiscono solo per il segno (codice
	  = &minus;1), oppure no (codice = 2).
	</para>
	<para>
	  Un possibile caso d'uso è verificare se due serie discrete
	  codificano le stesse informazioni. Ad esempio, il
	  codice:
	</para>
	<code>
	  open grunfeld.gdt
	  c = corresp($unit, firm)
	</code>
	<para>
	  ritorna <lit>c</lit> = 2, indicando che la serie
	  <lit>firm</lit> è in effetti un identificatore univoco per
	  le unità in questo dataset panel.
	</para>
	<para>
	  Vedi anche <fncref targ="mxtab"/>.
	</para>
      </description>
    </function>
    
    <function name="corrgm" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se sono forniti solo i primi due argomenti, calcola il
	  correlogramma di <argname>x</argname> con ritardi da 1 a
	  <argname>p</argname>. Il valore restituito è una matrice con
	  <argname>p</argname> righe e 2<math>k</math> colonne, dove
	  <math>k</math> è il numero di elementi di
	  <argname>x</argname>, ovvero: 1 se <argname>x</argname> è
	  una variabile; il numero di colonne di <argname>x</argname> se
	  <argname>x</argname> è una matrice; il numero degli elementi
	  di <argname>x</argname> se <argname>x</argname> è una
	  lista. Le prime <math>k</math> colonne della matrice
	  restituita contengono le autocorrelazioni, mentre le
	  restanti colonne le rispettive autocorrelazioni parziali.
	</para>
	<para>
	  Se è fornito un terzo argomento, questa funzione calcola il
	  correlogramma incrociato per ciascuno dei <math>k</math>
	  elementi di <argname>x</argname> e <argname>y</argname>,
	  dagli anticipi (<quote>lead</quote>) di ordine
	  <argname>p</argname> fino ai ritardi (<quote>lag</quote>) di
	  ordine <argname>p</argname>. La matrice restituita ha
	  2<math>p</math> + 1 righe e <math>k</math> colonne. Se
	  <argname>x</argname> è una variabile o una lista e
	  <argname>y</argname> un vettore, il vettore deve avere tante
	  righe quante sono le osservazioni nell'intervallo del
	  campione corrente.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il coseno di <argname>x</argname>.
	  <seelist>
            <fncref targ="sin"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il coseno iperbolico di <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="acosh"/>
            <fncref targ="sinh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la covarianza fra <argname>y1</argname> e
	  <argname>y2</argname>. Gli argomenti dovrebbero essere due variabili o due
	  vettori con lo stesso numero di elementi.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Calcola i valori critici, ossia <math>x</math> tale che
	  <equation status="inline" ascii="P(X &gt; x) = p" tex="$P(X
	  &gt; x) = p$"/>, dove la distribuzione di <math>X</math> è
	  determinata dal carattere <argname>c</argname>. Tra gli
	  argomenti <argname>c</argname> e <argname>x</argname>,
	  possono essere richiesti parametri aggiuntivi a seconda
	  della distribuzione, come specificato qui di seguito.
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normale standard (c = z, n, o N): nessun argomento addizionale
            </para>
	  </li>
	  <li>
            <para>
              t di Student (t): gradi di libertà
            </para>
	  </li>
	  <li>
            <para>
              Chi quadro (c, x, o X): gradi di libertà
            </para>
	  </li>
	  <li>
            <para>
              F di Snedecor (f o F): gradi di libertà (num.); gradi
              di libertà (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomiale (b o B): probabilità; numero di prove
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p o P): Media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l o L): media; scala
            </para>
	  </li>
	  <li>
            <para>
              GED Standardizzata (E): forma
            </para>
	  </li>
	</ilist>
	<tabular colspec="llll">
	  \textit{Distribuzione} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Normale standard &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp;
	  -- &amp; -- \\
	  $t$ di Student (centrale) &amp; \texttt{t} &amp;
	  gradi di libert\`a &amp; -- \\
	  Chi quadro &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp;
	  gradi di libert\`a &amp; -- \\
	  $F$ di Snedecor &amp; \texttt{f} o \texttt{F} &amp;
	  gdl (num.) &amp; gdl (den.) \\
	  Binomiale &amp; \texttt{b} o \texttt{B} &amp;
	  $p$ &amp; $n$ \\
	  Poisson &amp; \texttt{p} o \texttt{P} &amp;
	  $\lambda$ &amp; -- \\
	  Laplace &amp; \texttt{l} o \texttt{L} &amp;
	  media &amp; scala \\
	  GED Standardizzata &amp; \texttt{E} &amp;
	  forma &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cswitch" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="scalar">mode</fnarg>
      </fnargs>
      <description>
	<para>
	  Reinterpreta una matrice reale come contenente valori
	  complessi o viceversa.  L'azione precisa dipende dalla
	  <argname>modalità</argname> (che può avere valore 1,2,3 o 4)
	  come di seguito illustrato:
	</para>
	<para>
	  modalità 1: <argname>A</argname> deve essere una matrice reale
	  con un numero pari di colonne. Produce una matrice complessa con
	  la metà delle colonne; le colonne dispari di
	  <argname>A</argname> forniscono la parte reale e le colonne pari
	  forniscono le parti immaginarie.
	</para>
	<para>
	  modalità 2: Svolge l'operazione inversa rispetto alla
	  modalità 1. <argname>A</argname> deve essere una matrice complessa
	  e il risultato è una matrice reale con il doppio delle colonne di <argname>A</argname>.
	</para>
	<para>
	  modalità 3: <argname>A</argname> deve essere una matrice
	  reale con un numero pari di right. Produce una matrice
	  complessa con la metà delle righe; le righe dispari di
	  <argname>A</argname> forniscono la parte reale e le righe
	  pari forniscono le parti immaginarie.
	</para>
	<para>
	  modalità 4: Svolge l'operazione inversa rispetto alla
	  modalità 3. <argname>A</argname> deve essere una matrice
	  complessa e il risultato è una matrice reale con il doppio
	  delle righe di <argname>A</argname>.
	</para>
	<para>
	  <seelist><fncref targ="complex"/></seelist>
	</para>
      </description>
    </function>

    <function name="ctrans" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce la matrice complessa <by r="n" c="m"/> contenente i
	  coniugati trasposti della matrice complessa <by r="m"
	  c="n"/> <argname>C</argname>. Anche l'operatore <lit>'</lit>
	  (primo) svolge la trasposizione coniugata per le matrici
	  complesse. La funzione <fncref targ="transp"/> può essere
	  usata sulle matrici complesse ma opera una trasposizione
	  <quote>diretta</quote> (non coniugata).
	</para>
      </description>
    </function>

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola la somma cumulata di <argname>x</argname>. Se
	  <argname>x</argname> è una serie, restituisce una serie
	  <math>y</math> in cui ciascuno degli elementi è la somma dei
	  valori di <argname>x</argname> fino a quel punto; il primo
	  termine della somma è la prima osservazione non mancante
	  (non-missing) nel campione corrente. Se ci sono valori
	  mancanti successivi in <math>x</math>, anche i valori di
	  <math>y</math> corrispondenti saranno mancanti. Se
	  <argname>x</argname> è una matrice, la somma cumulata viene
	  calcolata per ciascuna delle colonne.
	</para>
	<para context="tex">
	  Calcola la somma cumulata di <argname>x</argname>. Se
	  <math>x</math> è una variabile, produce una variabile $y_t =
	  \sum_{s=m}^t x_s$. Il punto iniziale della sommatoria,
	  <math>m</math>, è la prima osservazione non mancante
	  nel campione corrente. Se la funzione incontra
	  valori mancanti in <math>x</math>, i valori
	  successivi in <math>y</math> saranno mancanti. Quando
	  <argname>x</argname> è una matrice, gli elementi vengono
	  sommati per colonna.
	</para>
	<para>
	  Nel caso di dati panel la cumulazione avviene lungo la
	  dimensione temporale, separatamente per ogni unità.
	</para>
	<para>
	  Per far sì che i valori mancanti vengano ignorati nella
	  cumulazione, basta trattarli come zeri e applicare la
	  funzione <fncref targ="misszero"/>. Per esempio:
	</para>
	<code>
	  series cx = cum(misszero(x))
	</code>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione dà modo all'utente di riempire un buffer di
	  testo con dati provenienti da un server di rete usando
	  libcurl. Il bundle di input <argname>b</argname> deve
	  contenere una stringa di nome <lit>URL</lit> con l'indirizzo
	  completo dell'host da cui scaricare i dati. Seguono altri
	  elementi, tutti opzionali.
	</para>
	<ilist>
	  <li>
	    <para>
	      <quote><lit>header</lit></quote>: una stringa contenente
	      un header HTTP da mandare al server.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>postdata</lit></quote>: una stringa
	      contenente dati da mandare al server.
	    </para>
	  </li>
	</ilist>
	<para>
	  I campi <lit>header</lit> e <lit>postdata</lit> vengono
	  usati in congiunzione con una richiesta HTTP
	  <lit>POST</lit>; se <lit>postdata</lit> è presente, allora
	  il metodo <lit>POST</lit>è implicito, altrimenti lo è il
	  metodo <lit>GET</lit>. (Si noti però che per semplici
	  richieste di tipo <lit>GET</lit>, la funzione <fncref
	  targ="readfile"/> fornisce un'interfaccia più snella.)
	</para>
	<para>
	  In più, è possibile includere nel bundle un altro elemento
	  opzionale: uno scalare di nome <lit>include</lit>, che è
	  interpretato, se non-zero, come una richiesta di includere
	  lo header dal server insieme al corpo del messaggio.
	</para>
	<para>
	  Se la richiesta va a buon fine, il testo ricevuto dal server
	  è aggiunto al bundle sotto il nome
	  <quote><lit>output</lit></quote>.
	</para>
	<para>
	  Se si verifica un qualche errore (ad esempio la
	  <lit>URL</lit> è irraggiungibile) la funzione ritorna un
	  valore non-zero, nel qual caso il messaggio di errore di
	  curl viene aggiunto al bundle sotto la chiave
	  <quote><lit>errmsg</lit></quote>.  Si noti, tuttavia, che
	  <quote>a buon fine</quote> in questo senso non implica che
	  tutti i dati desiderati siano stati scaricati, ma solo che
	  il server ha dato una qualche risposta. È responsabilità
	  dell'utente controllare il contenuto del buffer di output
	  (che per esempio potrebbe contenere semplicemente il testo
	  <quote>Page not found</quote>).
	</para>
	<para>
	  A seguire, un esempio, in cui scaricheremo dei dati dal
	  sito dell'US Bureau of Labor Statistics; a tal fine, bisogna
	  formulare una query JSON. Si noti l'uso di <cmdref
	  targ="sprintf"/> per inserire il carattere nei
	  dati <lit>POST</lit> il carattere <quote>virgoletta doppia</quote>.
	</para>
	<code>
	  bundle req
	  req.URL = "http://api.bls.gov/publicAPI/v1/timeseries/data/"
	  req.include = 1
	  req.header = "Content-Type: application/json"
	  string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	  req.postdata = s
	  err = curl(&amp;req)
	  if err == 0
	  s = req.output
	  string line
	  loop while getline(s, line)
	      printf "%s\n", line
	  endloop
	  endif
	</code>
	<para>
	  Vedi anche le funzione <fncref targ="jsonget"/> e <fncref
	  targ="xmlget"/> per elaborare i dati JSON o XML
	  rispettivamente.
	</para>
      </description>
    </function>

    <function name="dayspan" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">ed1</fnarg>
	<fnarg type="int">ed2</fnarg>
	<fnarg type="int">weeklen</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di giorni rilevanti tra le date
	  epocali <argname>ed1</argname> e <argname>ed2</argname>,
	  estremi inclusi. L'argomento <argname>weeklen</argname> deve
	  essere 5, 6 o 7, e si riferisce al numero di giorni della
	  settimana da contare (il valore 6 omette le domeniche; il
	  valore 5 omette sabati e domeniche).
	</para>
	<para>
	  Per convertire date formato epocale, vedi <fncref
	  targ="epochday"/>.
	</para>
      </description>
    </function>


    <function name="dec2bin" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la rappresentazione binaria dei numeri contenuti
	  nel vettore colonna <argname>x</argname>, sotto forma di una
	  matrice di 32 colonne contenente cifre binarie. Gli elementi
	  di <argname>x</argname> devono essere tutti interi fra 0 e
	  <math>2</math><sup>32</sup><math>-1</math>, o si verificherà
	  un errore.
	</para>
	<para>
	  Si noti che il bit meno significativo è nella colonna 1: di
	  conseguenza, la colonna 1 corrisponde a 
	  <math>2</math><sup>0</sup>, la colonna 2 a
	  <math>2</math><sup>1</sup> e così via. Ad esempio, l'espressione
	</para>
	<code>
	  matrix B = dec2bin(5)
	</code>
	<para>
	  produce un vettore riga con tutti elementi pari a 0, eccetto
	  per gli elementi 1 e 3.
	</para>
	<para>
	  La funzione <fncref targ="bin2dec"/> effettua la
	  trasformazione inversa.
	</para>
      </description>
    </function>

<function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permette la definizione di una variabile array per
	  esteso. Per usare questa funzione bisogna specificare un
	  tipo (in forma plurale) per l'array: <lit>strings</lit>,
	  <lit>matrices</lit>, <lit>bundles</lit> oppure
	  <lit>lists</lit>. Ognuno degli argomenti deve risultare un
	  oggetto del tipo specificato. Se la funzione va a buon fine,
	  il valore restituito sarà un array di <math>n</math>
	  elementi, dove <math>n</math> è il numero di argomenti.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  Vedi anche <fncref targ="array"/>.
	</para>
      </description>
    </function>

    <function name="defbundle" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permette la definizione di una variabile bundle per
	  esteso; questo avviene specificando zero o più coppie di
	  argomenti nella forma <repl>chiave</repl>,
	  <repl>valore</repl>. Contando gli argomenti da 1, gli
	  argomenti di posto dispari (le chiavi) devono essere
	  espressioni che restituiscono una stringa, mentre quelli di
	  posto pari devono contenere un'espressione che possa essere
	  inclusa in un bundle.
	</para>
	<para>
	  Due semplici esempi:
	</para>
	<code>
	  bundle b1 = defbundle("s", "Una stringa", "m", I(3))
	  bundle b2 = defbundle("yn", normal(), "x", 5)
	</code>
	<para>
	  Il primo esempio crea un bundle contenente una stringa e
	  una matrice; il secondo, un bundle con una serie e uno
	  scalare. Si noti che, con questa funzione, non è possibile
	  specificare un tipo per gli argomenti, ma bisogna accettare
	  il tipo <quote>naturale</quote> per l'argomento in
	  questione.  Se, ad esempio, si volesse includere in un
	  bundle <lit>b1</lit> una serie costante in cui tutti gli
	  elementi sono uguali a 5 bisognerebbe fare qualcosa del
	  genere (dopo aver dichiarato <lit>b1</lit>):
	</para>
	<code>
	  series b1.s5 = 5
	</code>
	<para>
	  Se alla funzione non vengono dati argomenti, verrà creato un
	  bundle vuoto, allo stesso modo di
	</para>
	<code>
	  bundle b = null
	</code>
	<subhead>Sintassi alternativa</subhead>
	<para>
	  Questa funzione può anche essere invocata con una sintassi
	  alternativa, a sua volta articolata in due varianti. In ambo
	  i casi, la stringa <lit>defbundle</lit> è rimpiazzata da un
	  trattino basso. Nel primo caso, gli argomenti prendono la
	  forma  <lit>chiave=valore</lit>, dove la chiave è
	  interpretata come una stringa e non richiede le
	  virgolette. Ad esempio:
	</para>
	<code>
	  bundle b = _(x=5, strval="buongiorno!", m=I(3))
	</code>
	<para>
	  Questa variante è particolarmente comoda quando si deve
	  costruire un bundle anonimo <quote>al volo</quote> come
	  argomento di una funzione, come ad esempio in
	</para>
	<code>
	  b = regls(ys, LX, _(lfrac=0.35, stdize=0))
	</code>
	<para>
	  dove la funzione <lit>regls</lit> prende come argomento un
	  bundle opzionale contenete vari parametri.
	</para>
	<para>
	  La seconda variante è pensata per il caso in cui si vogliano
	  includere nel bundle più oggetti preesistenti: tutto quel
	  che basta fare è elencarli:
	</para>
	<code>
	  bundle b = _(x, y, z)
	</code>
	<para>
	  Qui l'oggetto <lit>x</lit> è copiato nel bundle sotto la
	  chiave <quote><lit>x</lit></quote>, e lo stesso succede per
	  <lit>y</lit> e <lit>z</lit>.
	</para>
	<para>
	  Queste forme alternative sono più compatte della chiamata
	  standard a <lit>defbundle()</lit> e probabilmente sono più
	  comode in varia circostanze, ma si noti che sono meno
	  flessibili. Solo la versione standard gestisce il caso in
	  cui le chiavi siano passate come variabili stringa anziché
	  come costanti.
	</para>
      </description>
    </function>

    <function name="deflist" section="data-utils" output="list">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Definisce una lista (di serie), dati uno o più argomenti
	  appropriati. Ogni argomento deve essere una serie
	  (identificata dal nome o dal suo numero ID) o una lista
	  (data dal nome di una lista preesistente o da un'espressione
	  che restituisce una lista).
	</para>
	<para>
	  Si noti: questa funzione non fa altro che concatenare la
	  serie e/o liste fornite come argomenti. È responsabilità
	  dell'utente assicurarsi che non ci siano duplicazioni.
	</para>
      </description>
    </function>

    <function name="deseas" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="bundle">opts</fnarg>
      </fnargs>
      <description>
	<para>
	  Lo scopo principale di questo comando è di produrre una
	  versione destagionalizzata della serie in ingresso
	  <argname>x</argname> (che deve essere trimestrale o mensile)
	  usando X-13-ARIMA-SEATS; quest'ultimo dev'essere installato
	  separatamente. Se il secondo argomento viene omesso,
	  l'aggiustamento stagionale viene effettuato usando tutti i
	  default di X13-ARIMA, cioè usando la cosiddetta procedura
	  automatica. Quando il bundle <argname>opts</argname> viene
	  specificato, esso può contenere una o più delle seguenti
	  chiavi:
	</para>
	<ilist>
	  <li>
	    <para>
	      <lit>seats</lit>: 1 per usare l'algoritmo SEATS anziché
	      il default (X11), oppure 0.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>airline</lit>: 1 per forzare la specificazione
	      ARIMA al modello <quote>airline</quote>, ossia
	      (0,1,1)(0,1,1) anziché usare un modello ARIMA
	      selezionato automaticamente; 0 (default) per la
	      selezione automatica.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>arima</lit>: usato per imporre una specificazione
	      ARIMA data, sotto forma di un vettore a 6 elementi
	      contentente piccoli interi non negativi. Questi sono
	      interpretati come (p,d,q,P,D,Q) nella notazione
	      standard: i primi tre termini rappresentano gli ordini
	      AR, di integrazione e MA non stagionali. Gli ultimi tre,
	      le loro controparti stagionali. Se sono presenti ambedue
	      le chiavi <lit>airline</lit> e <lit>arima</lit>, la
	      precedenza viene data alla seconda.
	    </para>
	  </li>
	  <li>
	    <para>
	    <lit>outliers</lit>: usato per abilitare la correzione
	    automatica degli outlier. Le scelte vanno da 0 a 7. Il
	    valore 0 disattiva questa operazione. Per quanto riguarda
	    gli altri valori, ci sono tre tipi possibiili di
	    correzione, i cui codici numerici sono: 1 = outlier
	    additivo (ao), 2 = salto di livello (level shift, ls), 4 =
	    cambiamento temporaneo (temporary change, tc). Questi
	    codici funzionano a livello di bit, talché i vari tipi
	    possono essere combinati addizionando i codici; per
	    esempio, usare 1 + 2 + 4 = 7 per attivarli tutti e tre. Si
	    noti che la scelta 3 = 1 + 2 (ao e ls) corrisponde al
	    default di X-13ARIMA-SEATS, per cui il significato della
	    casella acceso/spento per gli outlier nella finestra di
	    dialogo della GUI per la destagionalizzazione via X13
	    riguarda l'opzione 3.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>critical</lit>: uno scalare positivo,
	      corrispondente al valore critico per definire gli
	      outlier. Il default è automatico, e dipende dalla
	      numerosità dei dati. Si applica solo quando
	      <lit>outliers</lit> è diverso da 0.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>logtrans</lit>: trasformazione logaritimica della
	      serie in ingresso. 0 = no, 1 = sì, 2 = selezione
	      automatica (il default). Si noti che è sconsigliato
	      passare la serie già trasformata in logaritmo; se si
	      vuole usare il logaritmo, meglio usare la serie in
	      livelli e specificare <lit>logtrans=1</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>trading_days</lit>: Includere l'effetto "giorni
	      lavorativi"?  0 = no, 1 = sì, 2 = scelta automatica (il
	      default).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>working_days</lit>: una versione più semplice di
	      <lit>trading_days</lit> in cui l'unica distinzione che
	      viene fatta è fra giorni feriali e fine settimana. 0 =
	      no (il default), 1 = sì, 2 = automatico.  Nota:
	      <lit>trading_days</lit> e <lit>working_days</lit> non
	      possono essere usati insieme.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>easter</lit>: 1 per incorporare l'effetto Pasqua,
	      in supplemento a <lit>trading_days</lit> o
	      <lit>working_days</lit>, oppure 0 (il default).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>output</lit>: una stringa per selezionare il tipo
	      di output desiderato: <lit>"sa"</lit> per la serie
	      aggiustata (il default), <lit>"trend"</lit> per il trend
	      stimato, o <lit>"irreg"</lit> per la componente
	      irregolare.'
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>save_spc</lit>: flag vero/falso, default 0; vedi sotto.
	     </para>
	   </li>
	 </ilist>
	<subhead>Risultati "completi"</subhead>
	<para>
	  In certi casi, potrebbe essere necessario ottenere tutti e
	  tre i risultati di cui sopra usando una sola invocazione
	  della funzione <lit>deseas</lit>. Se così fosse, si può
	  passare l'argomento <argname>opts</argname> come puntatore,
	  e nella chiave the <lit>output</lit> inserire la stringa
	  <lit>"all"</lit>.  Il risultato della funzione sarà la serie
	  destagionalizzata, ma se la funzione è andata a buon fine
	  <argname>opts</argname> conterrà una matrice a tre colonne
	  di nome <lit>results</lit>, contenente le tre
	  componenti. Per esempio,
	</para>
	<code>
	  bundle b = _(output="all")
	  deseas(y, &amp;b)
	  series y_dseas = b.results[,1]
	  series y_trend = b.results[,2]
	  series y_irreg = b.results[,3]
	</code>
	<para>
	  si noti che il risultato della funzione non viene salvato.
        </para>
       <subhead>Salvare la specificazione X-13ARIMA</subhead>
       <para>
	 L'opzione <lit>save_spc</lit> serve a salvare il contenuto
	 del file passato da gretl in input a X-13ARIMA. Il bundle
	 delle opzioni dev'essere passato come puntatore: la
	 specificazione sarà contenuta nella chiave
	 <lit>x13a_spc</lit> sotto forma di stringa. Il codice
	 seguente illustra come salvare questa in un file di nome
	 <lit>myspec.spc</lit> nella directory di lavoro. (Si noti che
	 l'estensione <lit>.spc</lit> è richiesta da X-13ARIMA.)
       </para>
       <code>
	 bundle b = _(save_spc=1)
	 deseas(y, &amp;b)
	 outfile myspec.spc
	    print b.x13a_spc
	 end outfile
       </code>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il determinante di <argname>A</argname>,
	  calcolato tramite la scomposizione LU. Si noti che, se ciò
	  che serve è il suo logaritmo, la funzione <fncref
	  targ="ldet"/> è preferibile.
	  <seelist>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diag" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la diagonale principale di <argname>X</argname> in
	  un vettore colonna. Nota: se <argname>X</argname> è una
	  matrice <by r="m" c="n"/>, il numero di elementi del vettore
	  risultato è min(<math>m</math>, <math>n</math>).
	  <seelist>
            <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la somma diretta di <argname>A</argname> e
	  <argname>B</argname>, ossia una matrice che ha
	  <argname>A</argname> nell'angolo nord-ovest e
	  <argname>B</argname> in quello sud-est. Se
	  <argname>A</argname> e <argname>B</argname> sono entrambe
	  quadrate, la matrice risultato è diagonale a blocchi.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le differenze prime. Se <argname>y</argname> è una
	  variabile, o una lista di variabili, i valori iniziali restituiti
	  sono <lit>NA</lit>. Se <argname>y</argname> è una matrice,
	  le differenze prime sono calcolate per colonna e i valori
	  iniziali restituiti sono 0.
	</para>
	<para>
	  Quando il risultato è una lista, le variabili che ne fanno parte
	  prendono automaticamente un nome dato da <lit>d_</lit>
	  <repl>nomevar</repl> dove <repl>nomevar</repl> è il nome della
	  serie originale.  Quest'ultimo viene troncato se necessario, e
	  potrebbe subire altri aggiustamenti in caso di non-unicità dei
	  nomi così costruiti.
	</para>
	<para>
	  <seelist>
            <fncref targ="cum"/>
            <fncref targ="ldiff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce la funzione digamma (o Psi) di
	  <argname>x</argname>, cioè la derivata del logaritmo della
	  funzione Gamma.
	</para>
	<para context="tex">
	  Restituisce la funzione digamma (o Psi) di $x$, cioè
	  $\frac {\mathrm{d}} {\mathrm{d} x}\, \log \Gamma(x)$.
	</para>
	<para>
	  <seelist>
            <fncref targ="lngamma"/>
            <fncref targ="trigamma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="distance" section="math" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="string">metrica</fnarg>
	<fnarg optional="true" type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola distanze fra punti, secondo una matrica che può
	  essere <lit>euclidean</lit> (il default),
	  <lit>manhattan</lit>, <lit>hamming</lit>,
	  <lit>chebyshev</lit>, <lit>cosine</lit> oppute
	  <lit>mahalanobis</lit>. La stringa per la metrica può essere
	  abbreviata, purché non risulti ambigua. Altre metriche, come
	  quella di correlazione, Euclidea standardizzata e di
	  Mahalanobis possono essere ottenute con semplici
	  trasformazioni dell'argomento <argname>X</argname>; vedi più
	  avanti.
	</para>
	<para>
	  Ogni riga della matrice <by r="m" c="n"/>
	  <argname>X</argname> è considerata un punto a <math>n</math>
	  dimensioni; in un contesto econometrico l'uso tipico è di
	  rappresentare un'osservazione su <math>n</math> variabili.
	</para>
	<subhead>Casi standard</subhead>
	<para>
	  Questa sezione descrive il comportamento della funzione per
	  tutte le metriche a parte quella di Mahalanobis, per la
	  quale la sintassi è lievemente diversa (vedi sotto).
	</para>
	<para>
	  Se <argname>Y</argname> non è specificato, il risultato è un
	  vettore colonna con <math>m</math>(<math>m</math> &minus;
	  1)/2 elementi, con tutte le distanze fra le <math>m</math>
	  righe di <argname>X</argname>. Dato tale vettore
	  <lit>d</lit>, la matrice completa delle distanze fra i punti
	  con zero sulla diagonale) può essere ottenuta col comando
	</para>
	<code>
	  D = unvech(d, 0)
	</code>
	<para>
	  poiché <lit>d</lit> è il vech di <lit>D</lit>, una volta che
	  la diagonale sia omessa. Il secondo argomento di <fncref
	  targ="unvech"/> indica che la diagonale va popolata con
	  zeri.
	</para>
	<para>
	  Se l'argomento <argname>Y</argname> è specificato, esso
	  dev'essere una matrice <by r="p" c="n"/>, le cui righe sono
	  a loro volta prese come punti a <math>n</math>
	  dimensioni. In questo caso il risultato è una matrice <by
	  r="m" c="p"/>, il cui elemento <math>i,j</math> contiene la
	  distanza fra la <math>i</math>-esima riga di
	  <argname>X</argname> e la <math>i</math>-esima di
	  <argname>Y</argname>.
	</para>
	<para>
	  Per ottenere le distanze da un punto di riferimento dato (ad
	  esempio il centroide) a ognuno di <math>k</math> punti, si
	  può specificare <argname>X</argname> come matrice di una
	  riga e <argname>Y</argname> con <math>k</math> righe, o
	  viceversa.
	</para>
	<subhead>Definizione delle metriche</subhead>
	<ilist>
	  <li>
	    <para>
	      <lit>euclidean</lit>: la radice quadrata della somma
	      delle differenze al quadrato fra le coordinate.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>manhattan</lit>: la somma delle differenze fra le
	      coordinate in modulo.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>hamming</lit>: la proporzione di coordinate per cui
	      la differenza è zero (quindi, compresa fra 0 e 1).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>chebyshev</lit>: l'elemento più grande tra le
	      differenze fra le coordinate in modulo.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>cosine</lit>: 1 meno il coseno dell'angolo fra i
	      <quote>punti</quote> dati dai vettori.
	    </para>
	  </li>
	</ilist>
	<subhead>Distanza di Mahalanobis</subhead>
	<para>
	  Le distanze di Mahalanobis sono definite come le distanze
	  euclidee fra i punti dati dalle righe di
	  <argname>X</argname> e un centroide dato, ove le coordinate
	  siano scalate dall'inversa di una matrice di covarianze. Nel
	  caso più semplice il centroide è il vettore delle medie
	  aritmetiche e la matrice di covarianze è quella campionaria.
        </para>
        <para>
	  Queste distanze possono essere prodotte indicando come
	  secondo argomento la stringa <quote>mahalanobis</quote> o
	  una sua abbreviazione non ambigua, come ad esempio
	</para>
	<code>
	  dmahal = distance(X, "mahal")
	</code>
	<para>
          In questo caso il terzo argomento <argname>Y</argname> non è
          consentito, e il vettore ritornato avrà <math>m</math>
          elementi, dati dalle distanze di Mahalanobis di ogni riga
          <argname>X</argname> dal centroide (la media
          campionaria). In pratica, la matrice risultato che si
          ottiene in questo caso è la stessa che si ha eseguando il
          comando <cmdref targ="mahal"/> su una lista di serie
          corrispondenti alle colonne di <argname>X</argname>.
	</para>
	<para>
	  Per calcolare le distanze di Mahalanobis rispetto a un altro
	  centroide
	  <lit>mu</lit> e/o diversa matrice di covarianze inversa
	  <lit>ICV</lit> si può usare la seguente sintassi:
	</para>
	<code>
	  dmahal = distance(X*cholesky(ICV), "euc", mu)
	</code>
	<subhead>Altre metriche</subhead>
	<para>
	  La distanza euclidea standardizzata e la distanza di
	  correlazione possono essere ottenute come segue:
	</para>
	<code>
	  # euclidea standardizzata
	  dseu = distance(stdize(X), "eu")
	  # correlazione (basata sul coseno)
	  dcor = distance(stdize(X')', "cos")
	</code>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la funzione di densità di una normale standard in
	  <argname>x</argname>. Per calcolare la densità di una
	  distribuzione normale non standardizzata in <math>x</math>,
	  applicate la funzione <lit>dnorm</lit> allo <math>z</math>-score
	  di <math>x</math> e moltiplicate il risultato così ottenuto per
	  lo Jacobiano della trasformazione <math>z</math>, 1/&sigma;,
	  come illustrato nell'esempio seguente:
	</para>
	<code>
	  mu = 100
	  sigma = 5
	  x = 109
	  fx = (1/sigma) * dnorm((x-mu)/sigma)
	</code>
	<para>
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una lista con gli stessi elementi di
	  <argname>X</argname>, fuorché le serie collineari. Quindi,
	  se tutte le serie in <argname>X</argname>
	  sono linearmente indipendenti, la lista risultato è
	  semplicemente una copia di <argname>X</argname>.
	</para>
	<para>
	  L'algoritmo adopera la scomposizione QR (trasformazione di
	  Householder), per cui è soggetto ad un errore derivante
	  dalla precisione macchina. Per aggiustare la sensibilità
	  dell'algoritmo, si può usare un secondo parametro opzionale
	  <argname>epsilon</argname> per rendere il test di
	  collinearità più o meno stringente. Il valore di default per
	  <argname>epsilon</argname> è 1.0e-8. Incrementando tale
	  valore, la probabilità che una serie venga omessa aumenta.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # imposta epsilon ad un valore assurdamente piccolo
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produce
	</para>
	<code>
	  ? list print X
	  foo bar foobar
	  ? list print Y
	  foo bar
	  ? list Y = dropcoll(X, 1.0e-30)
	  Replaced list Y
	  ? list print Y
	  foo bar foobar
	</code>
      </description>
    </function>

    <function name="dsort" section="matrix" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordina <argname>x</argname> in ordine discendente, saltando
	  le osservazioni con valori mancanti se <argname>x</argname> è
	  una variabile.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  L'argomento <argname>x</argname> deve essere una variabile
	  discreta. Questa funzione crea un insieme di variabili dummy
	  (o binarie) che codificano i valori distinti della
	  variabile. Per impostazione predefinita, il valore più piccolo
	  della variabile originale è preso come categoria di riferimento
	  e per tale valore non viene restituita alcuna dummy.
	</para>
	<para>
	  Il secondo argomento, opzionale, rappresenta il valore di
	  <argname>x</argname> che deve essere assunto come categoria
	  di riferimento, e quindi da omettere. L'effetto che si
	  ottiene inserendo un solo argomento e tralasciando quello
	  opzionale è equivalente a <lit>dummify(x, min(x))</lit>. Al
	  fine di generare l'insieme completo delle dummy, non
	  omettendo alcuna categoria, è possibile utilizzare il
	  comando <lit>dummify(x, NA)</lit>.
	</para>
	<para>
	  Le variabili generate sono nominate in modo automatico
	  secondo lo schema
	  <lit>D</lit><repl>varname</repl><lit>_</lit><repl>i</repl>,
	  dove <repl>varname</repl> è il nome della variabile originale e
	  <repl>i</repl> un indice in cui il valore iniziale è 1
	  (<quote>1-based index</quote>). Il nome originale della
	  variabile è troncato se necessario e può essere modificato in
	  caso di non unicità nell'insieme dei nomi così generato.
	</para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Dato l'anno in <argname>x</argname>, ritorna la data di
	  Pasqua nel calendario gregoriano sotto forma dello scalare
	  <math>mese + giorno/100</math>. Si noti che, per questa
	  convenzione, il 10 aprile è 4.1; quindi, 4.2 sarà il 20
	  aprile, non il 2 (che sarebbe 4.02).
	</para>
	<code>
	  scalar e = easterday(2014)
	  scalar m = floor(e)
	  scalar d = 100*(e-m)
	</code>
      </description>
    </function>

    <function name="ecdf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola la funzione di ripartizione empirica di
	  <argname>y</argname>. Il risultato occupa una matrice di due
	  colonne: nella prima ci sono i valori distinti di
	  <argname>y</argname>, ordinati in senso crescente;
	  nell'altra, la frequenza relativa cumulata, ossia il numero
	  di osservazioni minore o uguale al numero nella prima
	  colonna, diviso per il numero di osservazioni.
	</para>
	<para context="tex">
	  Calcola la funzione di ripartizione empirica di
	  <argname>y</argname>. Il risultato occupa una matrice di due
	  colonne: nella prima ci sono i valori distinti di
	  <argname>y</argname>, ordinati in senso crescente;
	  nell'altra, la frequenza relativa cumulata, \[ F(y) =
	  \frac{1}{n} \sum_{i=1}^n I(y_i \leq y) \] dove $n$ è il
	  numero di osservazioni e $I()$ la funzione indicatrice.
	</para>
      </description>
    </function>

    <function name="eigen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
	<fnarg type="matrixref" optional="true">&amp;W</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola gli autovalori e, opzionalmente, gli autovettori destri
	  e/o sinistri, della matrice <by r="n" c="n"/>
	  <argname>A</argname>, che può essere reale o complessa. Gli
	  autovalori sono ritornati come vettore colonna
	  complesso. Per ottenere la loro norma, si può usare la
	  funzione <fncref targ="abs"/>, che accetta argomenti complessi.
	</para>
	<para>
	  Se si desidera ottenere gli autovettori destri (nella forma di una
	  matrice complessa <by r="n" c="n"/>), fornire il nome di
	  una matrice esistente, preceduta da <lit>&amp;</lit> per indicare
	  l'<quote>indirizzo</quote> della matrice in questione, come secondo
	  argomento. Altrimenti questo argomento può essere omesso.
	</para>
	<para>
	  Per ottenere gli autovettori sinistri (di nuovo, nella forma di una
	  matrice complessa), fornire l'indirizzo di una matrice come terzo argomento.
	  Notare che se si desiderano gli autovettori sinistri e non quelli destri,
	  occorre inserire la parola chiave <lit>null</lit>
	  al posto del secondo argomento.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola gli autovalori, e, se richiesto, gli autovettori
	  destri della matrice <by r="n" c="n"/>
	  <argname>A</argname>. Se tutti gli autovalori sono reali, la
	  funzione restituisce una matrice <by r="n" c="1"/>; in caso
	  contrario, il risultato è una matrice <by r="n" c="2"/>,
	  dove la prima colonna contiene le parti reali degli
	  autovalori, mentre la seconda le corrispondenti parti
	  immaginarie. Non c'è alcuna garanzia sul fatto che gli
	  autovalori siano ordinati in alcun modo particolare.
	</para>
	<para>
	  Il secondo argomento può essere il nome di una matrice
	  esistente preceduto da <lit>&amp;</lit> (per indicare
	  l'<quote>indirizzo</quote> della matrice in questione), e in tal caso gli
	  autovettori destri vengono scritti in questa matrice, oppure
	  la parola chiave <lit>null</lit>, e in tal caso gli
	  autovettori non vengono riportati.
	</para>
	<para>
	  Quando il secondo argomento è diverso da <lit>null</lit>, la
	  matrice stessa è sovrascritta (non è necessario abbia la
	  dimensione giusta per ricevere il risultato). La matrice
	  risultante è organizzata come segue:
	</para>
	<ilist>
	  <li>
            <para>
              Se l'<math>i</math>-esimo autovalore è reale,
              l'<math>i</math>-esima colonna di <math>U</math>
              conterrà l'autovettore corrispondente;
            </para>
	  </li>
	  <li>
            <para>
              Se l'<math>i</math>-esimo autovalore è complesso,
              l'<math>i</math>-esima colonna di <argname>U</argname>
              conterrà la parte reale dell'autovettore corrispondente
              e la colonna successiva la parte
              immaginaria. L'autovettore associato all'autovalore
              coniugato è il coniugato dell'autovettore.
            </para>
	  </li>
	</ilist>
	<para>
	  In altre parole, gli autovettori compaiono nello stesso
	  ordine degli autovalori, ma gli autovettori reali occupano
	  una colonna, mentre quelli complessi ne occupano due (la
	  parte reale è la prima); il numero totale di colonne è
	  comunque <math>n</math>, perché l'autovettore coniugato è
	  tralasciato.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="qrdecomp"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funziona esattamente come <fncref targ="eigengen"/>, ma
	  l'argomento <argname>A</argname> deve essere una matrice
	  simmetrica (in questo caso i calcoli possono essere
	  semplificati). A differenza di <fncref targ="eigengen"/>, gli
	  autovalori sono ordinati in senso crescente. Per avere
	  l'ordinamento opposto, si può fare così:
	</para>
	<code>
	  matrix U
	  e = eigensym(A, &amp;U)
	  Tmp = msortby((-e' | U)',1)'
	  e = -Tmp[1,]'
	  U = Tmp[2:,]
	  # now largest to smallest eigenvalues
	  print e U
	</code>
	<para>
	  Notare che nel calcolo degli autovalori ed autovettori di una
	  matrice del tipo <math>X'X</math>, ove <math>X</math> sia di
	  dimensioni elevate, è preferibile utilizzare la forma
	  <lit>X'X</lit> invece della più generale sintassi
	  <lit>X'*X</lit>. La prima espressione utilizza infatti un
	  algoritmo specifico che presenta il duplice vantaggio di essere
	  più efficiente dal punto di vista computazionale e di assicurare
	  come risultato una matrice priva per costruzione di
	  approssimazioni indotte dalla precisione macchina, che possono
	  renderlo numericamente non simmetrico.
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Risolve il problema degli autovalori generalizzati
	  |<math>A</math> &minus; &lgr;<math>B</math>| = 0, dove sia
	  <math>A</math> sia <math>B</math> sono matrici simmetriche e
	  <math>B</math> è definita positiva. Gli autovalori vengono
	  restituiti direttamente, ordinati in senso crescente. Il
	  terzo argomento opzionale deve essere il nome di una matrice
	  esistente preceduto da <lit>&amp;</lit>. In tal caso, la
	  funzione calcola anche gli autovettori generalizzati, che
	  vengono salvati nella suddetta matrice.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">anno</fnarg>
	<fnarg type="scalar-or-series">mese</fnarg>
	<fnarg type="scalar-or-series">giorno</fnarg>
      </fnargs>
      <description>
	<para>
	  Ha come argomenti l'anno, il mese e il giorno e restituisce il
	  numero di giorni nell'epoca corrente (che è uguale ad 1 per il 1
	  gennaio dell'anno 1 d.C.), ed è pari a 733786 al 01-01-2010. Se
	  qualcuno degli argomenti è fornito sotto forma di variabile il
	  valore restituito è una variabile, in caso contrario uno
	  scalare.
	</para>
	<para>
	  Gli argomenti <argname>anno</argname>, <argname>mese</argname> e
	  <argname>giorno</argname> sono riferiti al calendario
	  gregoriano, a meno che l'anno sia negativo, nel qual caso si fa
	  riferimento al calendario giuliano.
	</para>
	<para>
	  È possibile invocare la funzione con una sintassi
	  alternativa: se viene passato un solo argomento, esso viene
	  inteso come una data (o una serie di date) in formato ISO
	  8601 <quote>di base</quote>, e cioè
	  <lit>AAAAMMGG</lit>. Quindi, le due righe seguenti producono
	  lo stesso risultato, e cioè 700115:
	</para>
	<code>
	  eval epochday(1917, 11, 7)
	  eval epochday(19171107)
	</code>
	<para>
	  Per la funzione inversa, vedi <fncref targ="isodate"/> e anche
	  (per il calendario giuliano) <fncref targ="juldate"/>.
	</para>
      </description>
    </function>

    <function name="errmsg" section="programming" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Recupera il messaggio di errore di gretl associato a
	  <argname>errno</argname>. Si veda anche <fncref
	  targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="errorif" section="programming" output="scalar">
      <fnargs>
	<fnarg type="bool">condizione</fnarg>
	<fnarg type="string">msg</fnarg>
      </fnargs>
      <description>
	<para>
	  Applicabile solo nel contesto di una funzione creata dall'utente.
	  Se la <argname>condizione</argname> è diversa da 0,
	  termina l'esecuzione della funzione attuale, evidenziando la condizione
	  di errore; l'argomento <argname>msg</argname>
	  è poi stampato a video come parte del messaggio mostrato
	  a chi utilizza la funzione in questione.
	</para>
	<para>
	  Il valore (1) ritornato da questa funzione è puramente nominale.
	</para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna non-zero se <argname>name</argname> è l'identificativo di
	  un oggetto definito, che sia uno scalare, una serie, una
	  matrice, lista, stringa, bundle o array; altrimenti, ritorna
	  0.  Vedi anche <fncref targ="typeof"/>.
	</para>
	<para>
	  L'uso tipico riguarda il caso in cui una funzione definita
	  dall'utente ha un parametro facoltativo con un valore
	  predefinito <lit>null</lit>. In questo caso si può usare
	  <lit>exists()</lit>, passando il nome del parametro, per
	  verificare se il chiamante ha fornito o meno un
	  argomento. Si tenga presente che a questo riguardo gli
	  argomenti di tipo lista sono un'eccezione: se un parametro
	  lista ha un valore predefinito <lit>null</lit> e il
	  chiamante non fornisce un argomento, la funzione ottiene una
	  lista vuota anziché nessuna lista; quindi <lit>exists</lit>
	  restituirà sempre un valore diverso da zero. Per verificare
	  se un argomento lista è vuoto, si usi <fncref
	  targ="nelem"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce <math>e</math><sup>x</sup>.
	  Si noti che nel caso di una matrice la funzione è
	  calcolata elemento per elemento. Per il calcolo
	  dell'esponenziale di una matrice, si veda <fncref
	  targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-or-mat">f</fnarg>
	<fnarg optional="true" type="bool">U2</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice contenente diverse statistiche utili
	  per valutare <argname>f</argname> come previsione della
	  variabile <argname>y</argname>.
	</para>
	<para>
	  Se <argname>f</argname> è una serie o un vettore, l'output
	  sarà un vettore colonna; se <argname>f</argname> è una lista
	  con <math>k</math> elementi o una matrice <by r="T" c="k"/>,
	  l'output avrà <math>k</math> colonne, ognuna delle quali
	  conterrà le statistiche relative alla colonna corrispondente
	  di <argname>f</argname> come previsore di
	  <argname>y</argname>.
	</para>
	<para>
	  In ogni caso, la dimensione verticale dell'input (per una
	  serie o una lista l'ampiezza campionaria corrente, per una
	  matrice il numero di righe) deve essere uguale per i due
	  argomenti.
	</para>
	<para>
	  La struttura dell'output è la seguente:
	</para>
	<code>
	  1  Errore Medio (Mean Error, ME)
	  2  Errore Quadratico Medio (Mean Squared Error, MSE)
	  3  Errore Medio Assoluto (Mean Absolute Error, MAE)
	  4  Errore Medio Percentuale (Mean Percentage Error, MPE)
	  5  Errore Medio Assoluto Percentuale (Mean Absolute Percentage Error, MAPE)
	  6  Coefficiente U di Theil (U1 o U2)
	  7  Proporzione della distorsione (Bias proportion, UM)
	  8  Proporzione della regressione (Regression proportion, UR)
	  9  Proporzione del disturbo (Disturbance proportion, UD)
	</code>
	<para>
	  La variante della U di Theil mostrata di default dipende
	  dalla natura dei dati: se essi sono di tipo serie storiche,
	  viene usata U2, altrimenti U1. Questa scelta può però essere
	  forzata usanto il terzo argomento (opzionale): con un valore
	  non-zero si forza la scelta a U2, con zero si forza U1.
	</para>
	<para>
	  Per maggiori dettagli sul calcolo di queste statistiche e
	  l'interpretazione dei valori del coefficiente
	  <math>U</math>, si veda <guideref targ="chap:forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
          Calcola un'approssimazione numerica allo Jacobiano associato
          al vettore <argname>b</argname> (con <math>n</math>elementi)
          e la trasformazione definita dall'argomento
          <argname>fcall</argname>. Questa funzione deve avere
          <argname>b</argname> come suo primo argomento (in forma di
          puntatore o no), seguito da eventuali altri parametri, se
          necessario; deve restituire una matrice <by r="m"
          c="1"/>. Se il comando va a buon fine, verrà restituita una
          matrice <by r="m" c="n"/> contenente lo Jacobiano. Ad
          esempio:
	</para>
	<para>
	  Il terzo argomento (opzionale) consente di aggiustare la
	  lunghezza di passo <math>h</math> usata nel meccanismo di
	  approssimazione (vedi sotto); se omesso, <math>h</math> viene
	  determinata automaticamente.
	</para>
	<para>
	  Per esempio:
	</para>
	<code>
	  matrix J = fdjac(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  La funzione può usare tre metodi diversi: differenza in
	  avanti, differenza bilaterale o un'estrapolazione di
	  Richardson a 4 nodi. Rispettivamente:
	</para>
	<para context="tex">
	  \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
	</para>
	<para context="tex">
	  \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
	</para>
	<para context="tex">
	  \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
	</para>
	<para context="notex">
	  <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>2</sub>  = <math>[8 (f(x+h) -  f(x-h)) -
	  (f(x+2h) - f(x-2h))] /12h</math>
	</para>
	<para>
	  Queste tre alternative, in generale, rappresentano un
	  compromesso diverso fra velocità e accuratezza. Per
	  scegliere quale metodo usare, il comando <cmdref
	  targ="set"/> consente di impostare a 0, 1 o 2 la variabile
	  <lit>fdjac_quality</lit>.
	</para>
	<para>
	  Per maggiori dettagli ed esempi si veda il capitolo sulle
	  funzioni speciali in <lit>genr</lit> in <guideref
	  targ="chap:genr"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="numhess"/>
            <cmdref targ="set"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="feval" section="programming" output="seebelow">
      <fnargs>
	<fnarg type="string">funcname</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Utile soprattutto per gli autori di funzioni. Il primo
	  argomento è il nome di una funzione, e quelli restanti
	  sono gli argomenti passati alla funzione in questione. In pratica,
	  la funzione identificata da <argname>funcname</argname> viene trattata come essa stessa
	  una variabile. Il valore ritornato è quello che la funzione <argname>funcname</argname>
	  ritorna dati gli argomenti specificati.
	</para>
	<para>
	  L'esempio seguente illustra alcuni possibili usi.
	</para>
	<code>
	  function scalar utility (scalar c, scalar sigma)
	  return (c^(1-sigma)-1)/(1-sigma)
	  end function

	  strings S = defarray("log", "utility")

	  # chiama una funzione con un argomento
	  x = feval(S[1], 2.5)
	  # chiama una funzione definita dall'utente
	  x = feval(S[2], 5, 0.5)
	  # una funzione con due argomenti
	  func = "zeros"
	  m = feval(func, 5-2, sqrt(4))
	  print m
	  # una integrata a 3 argomenti
	  x = feval("monthlen", 12, 1980, 5)
	</code>
	<para>
	  C'è una lieve analogia tra <lit>feval</lit> e <fncref
	  targ="genseries"/>: entrambe le funzioni rendono variabile un
	  elemento sintattico che di solito è fisso, nel momento in cui
	  lo script è compilato.
	</para>
	<para>
	  <seelist>
            <fncref targ="fevalb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fevalb" section="programming" output="seebelow">
      <fnargs>
	<fnarg type="string">funcname</fnarg>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è una variante di <fncref targ="feval"/>,
	  utile a gestire casi in cui il numero e il tipo di argomenti
	  da passare alla funzione non sono noti in anticipo. Gli
	  argomenti non vengono passati individualmente, ma come
	  membri del bundle argomento <argname>b</argname>.
	</para>
	<para>
	  Poiché l'ordine dei membri in un bundle è indeterminato, è
	  necessario un meccanismo per garantire che il gli argomenti
	  vengono passati alla funzione in questione nel file ordine
	  corretto. Ciò è automaticamente garantito se le chiavi nel
	  bundle sono in ordine lessicografico. Ad esempio, le chiavi
	  potrebbero essere <lit>arg1</lit>, <lit>arg2</lit> e così
	  via (o <lit>arg01</lit>, <lit>arg02</lit> e così via
	  nell'improbabile caso in cui la funzione abbia più di nove
	  argomenti).  In alternativa il bundle può contenere un array
	  di stringhe dal nome speciale
	  <lit>arglist</lit>. L'array deve contenere esattamente le
	  chiavi del bundle <argname>b</argname>, tranne che 
	  <lit>arglist</lit> stesso, nell'ordine desiderato.
	</para>
	<para>
	  L'esempio seguente illustra i due approcci applicati alla
	  funzione <fncref targ="monthlen"/>.
	</para>
	<code>
	  # usando l'ordine lessicografico
	  bundle b = _(arg1=12, arg2=1980, arg3=5)
	  n = feval("monthlen", b)

	  # usando arglist
	  bundle b = _(month=12, year=1980, wkdays=5)
	  b.arglist = defarray("month", "year", "wkdays")
	  n = feval("monthlen", b)
	</code>
	<para>
	  <seelist>
            <fncref targ="feval"/>
	  </seelist>
	</para>
      </description>
    </function>
    
    <function name="fevd" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione fornisce un'alternativa più flessibile
	  all'accessore <fncref targ="$fevd"/> per ottenere la matrice
	  di scomposizione della varianza dell'errore di previsione
	  (FEVD)dopo la stima di un VAR o di un VECM. Senza
	  l'argomento finale (opzionale), è disponibile soltanto
	  quando l'ultimo modello stimato è un VAR o un VECM. In
	  alternativa, le informazioni sul modello possono essere
	  contenute in un bundle via l'accessore <fncref targ="$system"/>
	  e poi passate alla funzione <lit>fevd</lit>.
	</para>
	<para>
	  Gli argomenti <argname>target</argname> e
	  <argname>shock</argname> hanno la forma di indici (a base 1)
	  per le variabili endogene del sistema, con 0 che significa
	  <quote>tutte</quote>. L'uso è esemplificato nel frammento di
	  codice seguente. Nel primo esempio, la matrice
	  <lit>fe1</lit> contiene le quote di FEVD per <lit>y1</lit>
	  attribuibili a <lit>y1</lit>, <lit>y2</lit> e <lit>y3</lit>
	  (con le righe che sommano a 1). Nel secondo, <lit>fe2</lit>
	  contiene il contributo di <lit>y2</lit> alla varianza di
	  tutte e tre le variabili (e quindi le righe non sommano a
	  1). Nel terzo caso, il valore ritornato è un vettore colonna
	  contenente la <quote>propria quota</quote> di FEVD per
	  <lit>y1</lit>.
	</para>
	<code>
	  var 4 y1 y2 y3
	  bundle vb = $system
	  matrix fe1 = fevd(1, 0, vb)
	  matrix fe2 = fevd(0, 2, vb)
	  matrix fe3 = fevd(1, 1, vb)
	</code>
	<para>
	  Il numero di periodi (righe) per cui la scomposizione è
	  calcolata è determinato in automatico dalla periodicità dei
	  dati, ma può essere modificato attraverso l'argomento
	  <lit>horizon</lit> al comando <cmdref targ="set"/>, come ad
	  esempio in <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="irf"/></seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Trasformata discreta di Fourier. La matrice di input
	  <argname>X</argname> può essere reale o complessa. L'output è
	  una matrice complessa della stessa dimensione di <argname>X</argname>.
	</para>
	<para>
	  Qualora dovesse essere necessario calcolare la trasformata
	  di Fourier di diversi vettori con lo stesso numero di
	  elementi, risulta numericamente più efficiente raggruppare i
	  vettori in una matrice invece di utilizzare <lit>fft</lit>
	  per ogni vettore separatamente.
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Trasformata discreta reale di Fourier inversa. Si assume che
	  <argname>X</argname> contenga <math>n</math> vettori colonna
	  complessi. Il risultato è una matrice con <math>n</math>
	  colonne.
	</para>
	<para>
	  Se si desidera calcolare la trasformata di Fourier inversa
	  su diversi vettori con lo stesso numero di elementi, è
	  numericamente più efficiente raggrupparli in una matrice
	  piuttosto che invocare <lit>ffti</lit> separatamente per
	  ciascuno di essi.
	  <seelist>
            <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="timeseries" output="seebelow">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Applica un filtro di tipo ARMA all'argomento
	  <argname>x</argname>. In formule, la trasformazione è
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> =
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub> <math>y</math><sub>t-p</sub>
	</para>
	<para>
	  Se l'argomento <argname>x</argname> è una variabile, il
	  risultato sarà esso stesso una variabile. Se invece
	  <argname>x</argname> è una matrice con <math>T</math> righe
	  e <math>k</math> colonne, il risultato sarà una matrice
	  delle stesse dimensioni, in cui il filtraggio vien fatto
	  colonna per colonna.
	</para>
	<para>
	  I due argomenti <argname>a</argname> e <argname>b</argname>
	  sono opzionali. Possono essere scalari, vettori o la parola chiave
	  <lit>null</lit>.
	</para>
	<para>
	  Se <argname>a</argname> è uno scalare, viene usato come
	  <math>a</math><sub>0</sub> e implica <math>q=0</math>; se è
	  un vettore di <math>q+1</math> elementi, contiene i
	  coefficienti da <math>a</math><sub>0</sub> ad
	  <math>a</math><sub>q</sub>. Se <argname>a</argname> è
	  <lit>null</lit> oppure omesso, è equivalente ad
	  <math>a</math><sub>0</sub><math>=1</math> e
	  <math>q=0</math>.
	</para>
	<para>
	  Se <argname>b</argname> è uno scalare, viene usato come
	  <math>b</math><sub>1</sub> ed implica <math>p=1</math>; se è
	  un vettore di <math>p</math> elementi, essi sono
	  interpretati come i coefficienti da
	  <math>b</math><sub>1</sub> a <math>b</math><sub>p</sub>. Se
	  <argname>b</argname> è <lit>null</lit> oppure omesso, è
	  equivalente a <math>B(L)=1</math>.
	</para>
	<para>
	  L'argomento scalare opzionale <argname>y0</argname>
	  rappresenta i valori di <math>y</math> antecedenti
	  all'inizio del campione (usato solo se <math>p>0</math>). Se
	  omesso, si intende 0.  Valori di <argname>x</argname>
	  antecedenti all'inizio del campione sono sempre considerati
	  0.
	</para>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
            <fncref targ="fracdiff"/>
            <fncref targ="hpfilt"/>
            <fncref targ="movavg"/>
            <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produce
	</para>
	<code>
          index            y

          1            1     -0.40000
          2            2      1.36000
          3            3      0.27600
          4            4      1.75160
          5            5      0.92356

          x (5 x 2)

          1   1
          2   0
          3   0
          4   0
          5   0

          w (5 x 2)

          -0.40000     -0.40000
          1.3600      0.36000
          0.27600     -0.32400
          1.7516      0.29160
          0.92356     -0.26244
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">insample</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il primo valore non-mancante della variabile
	  <argname>y</argname>. Si noti che se si sta operando su un
	  sottocampione ristretto, il valore ottenuto può essere più
	  piccolo della variabile dollaro <fncref targ="$t1"/>. Se però
	  l'argomento <argname>insample</argname> è nonzero, viene
	  considerato solo il sottocampione attualmente in vigore.
	  <seelist>
            <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">rawname</fnarg>
      </fnargs>
      <description>
	<para>
	  Destinato principalmente all'uso col comando <cmdref
	  targ="join"/>.  Restituisce il risultato della conversione
	  di <argname>rawname</argname> in un identificatore gretl
	  valido, che deve iniziare con un carattere alfabetico,
	  contenere esclusivamente caratteri (ASCII), numeri e
	  trattino basso, e non deve eccedere i 31 caratteri. Le
	  regole utilizzate per la conversione sono:
	</para>
	<para>
	  1. Eliminare qualsiasi carattere iniziale che non sia un
	  carattere alfabetico.
	</para>
	<para>
	  2. Fino al limite dei 31 caratteri o al completamento
	  dell'input: trascrivere i caratteri <quote>legali</quote>;
	  saltare i caratteri <quote>illegali</quote> esclusi gli
	  spazi; e sostituire uno o più spazi consecutivi con un
	  trattino basso, a meno che il precedente carattere
	  trascritto sia un trattino, nel qual caso lo spazio è
	  saltato.
	</para>
	<para>
	  Se si è sicuri che la stringa in input non è troppo lunga (e
	  quindi potenzialmente troncata), è possibile far sì che
	  sequenze di caratteri illegali vengano sostituite con un
	  trattino basso anziché cancellate, così da produrre un
	  risultato più leggibile. Per fare ciò, bisogna passare un
	  argomento non-zero come secondo argomento. Tuttavia questo
	  non è consigliabile nel contesto del comando <cmdref
	  targ="join"/> visto che il nome <quote>aggiustato</quote>
	  non userà i trattini bassi in questo modo.
	</para>
      </description>
    </function>

    <function name="flatten" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="matrices-or-strings">A</fnarg>
	<fnarg optional="true" type="int-or-string">alt</fnarg>
      </fnargs>
      <description>
	<para>
	  Compatta un array di matrici in una singola matrice oppure
	  un array di stringhe in una singola stringa.
	</para>
	<para>
	  Nel caso matriciale, il modo in cui le matrici in
	  <argname>A</argname> sono accostate dipende dal valore
	  dell'argomento <argname>alt</argname>, che deve essere
	  compreso 0 per l'accortamento orizzontale, 1 per quello
	  verticale o 2 per quello <quote>vettorizzato</quote>. Il
	  modo migliore di spiegare la differenza tra le tre
	  alternative è un esempio: il codice
	</para>
	<code>
	  X = {1,3,5; 2,4,6}
	  A = defarray(X, X+6)
	  U = flatten(A,0) # = A[1] ~ A[2]
	  V = flatten(A,1) # = A[1] | A[2]
	  W = flatten(A,2) # = vec(A[1]) ~ vec(A[2])
	</code>
	<para>
	  produce le tre matrici seguenti:
	</para>
	<code>
	  U (2 x 6)

	  1    3    5    7    9   11 
	  2    4    6    8   10   12 

	  V (4 x 3)

	  1    3    5 
	  2    4    6 
	  7    9   11 
	  8   10   12 

	  W (6 x 2)

	  1    7 
	  2    8 
	  3    9 
	  4   10 
	  5   11 
	  6   12 
	</code>
	<para>
	  Qualora le matrici nell'array non siano conformabili per
	  l'operazione, viene prodotto un errore.  Si veda <fncref
	  targ="msplitby"/> per l'operazione inversa.
	</para>
	<para>
	  Nel caso in cui <argname>A</argname> sia un array di
	  stringhe l'output le conterrà una per riga di default. Se un
	  valore diverso da 0 è inserito in <argname>alt</argname> le
	  stringhe verranno separate da spazi anziché da interruzioni
	  di riga, ma è anche supportata una sintassi alternativa, in
	  cui <argname>alt</argname> è una specifica stringa da usare
	  come separatore. La funzione inversa è, in questo caso,
	  <fncref targ="strsplit"/>.
	</para> 
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il più grande intero minore o uguale di
	  <argname>x</argname>. Nota: <fncref targ="int"/> e
	  <lit>floor</lit> differiscono nel loro effetto su argomenti
	  negativi: <lit>int(-3.5)</lit> restituisce &minus;3, mentre
	  <lit>floor(-3.5)</lit> produce &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce la differenza frazionale di ordine
	  <argname>d</argname> per la variabile <argname>y</argname>.
	</para>
	<para context="tex">
          \[
          \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
          \]
	  dove
          \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Si noti che in teoria la differenziazione frazionale
	  corrisponde ad un filtro infinitamente lungo. In pratica, i
	  valori di <math>y</math><sub>t</sub> precedenti al campione
	  estratto sono posti pari a zero.
	</para>
	<para>
	  L'argomento <argname>d</argname> può essere negativo, nel qual
	  caso si può parlare di integrazione frazionale anziché
	  differenziazione.
	</para>
      </description>
    </function>

    <function name="fzero" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar-or-vec">init</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Tenta di trovare la radice di una funzione di una variabile
	  (tipicamente non lineare) <math>f</math>, cioè un valore dello
	  scalare <math>x</math> tale che
	  <math>f</math>(<math>x</math>) = 0. L'argomento
	  <argname>fcall</argname> dovrebbe chiamare
	  la funzione in questione; <argname>fcall</argname> può includere
	  un numero arbitrario di argomenti ma il primo
	  deve essere uno scalare che svolga la funzione di<math>x</math>.
	  Qualora la funziona svolga il suo compito con successo, essa
	  restituisce il valore della radice.
	</para>
	<para>
	  Il metodo utilizzato è quello di <cite key="ridders79">Ridders
	  (1979)</cite>. Esso necessita di un supporto iniziale
	  &lbr;<math>x</math><sub>0</sub>,
	  <math>x</math><sub>1</sub>&rbr; tale che entrambi i valori di
	  <math>x</math> giacciano nel dominio della funzione e
	  i corrispondenti valori della funzione siano di segno opposto.
	  Sarà più probabile ottenere migliori risultati qualora l'utente
	  inserisca, come secondo argomento, un vettore di cui componenti
	  contenente gli estremi del supporto. Altrimenti, è possibile fornire un solo
	  valore scalare e <lit>fzero</lit> tenterà di trovare un intervallo adeguato.
	  Se il secondo argomento è omesso, <math>x</math><sub>0</sub>
	  è inizializzato ad un piccolo valore positivo.
	</para>
	<para>
	  L'argomento opzionale <argname>toler</argname> può essere utilizzato
	  per definire la massima differenza assoluta accettabile di
	  <math>f</math>(<math>x</math>) da 0; il valore di default è
	  1.0e&minus;14.
	</para>
	<para>
	  Di default questa funzione opera silenziosamente, ma è possibile visualizzare
	  le iterazioni attraverso il comando <quote><lit>set max_verbose on</lit></quote> prima
	  di chiamare <lit>fzero</lit>.
	</para>
	<para>
	  Di seguito alcuni semplici esempi.
	</para>
	<code>
	  #Si approssima pi trovando uno zero della
	  #funzione sin() nel supporto 2.8-3.2
	  x = fzero(sin(x), {2.8, 3.2})
	  printf "\nx = %.12f vs pi = %.12f\n\n", x, $pi

	  # Si approssima la costante Omega partendo da x=0.5
	  function scalar f(scalar x)
	  return log(x) + x
	  end function
	  x = fzero(f(x), 0.5)
	  printf "x = %.12f f(x) = %.15f\n", x, f(x)
	</code>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la funzione gamma di <argname>x</argname>.
	</para>
	<para>
	  Vedi anche <fncref targ="bincoeff"/> e <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="genseries" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">varname</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è pensata principalmente per gli autori di
	  script: fornisce un metodo per generare serie i cui nomi
	  non siano noti a priori, e/o creare una serie ed aggiungerla
	  ad una lista con un solo comando.
	</para>
	<para>
	  Il primo argomento specifica l'identificativo della serie da
	  creare (o modificare); questo può essere una stringa fissa,
	  una variabile di tipo stringa, o un'espressione che risulta
	  in una stringa.  Il secondo argomento,
	  <argname>rhs</argname> (<quote>right-hand side</quote>),
	  definisce la serie origine: l'identificativo di una serie
	  pre-esistente o un'espressione che risulta in una serie,
	  così come apparirebbe alla destra del segno di uguale quando
	  si assegnano valori alle serie nel solito modo.
	</para>
	<para>
	  Il valore ritornato da questa funzione è il numero ID della
	  serie nel dataset, che può essere incluso in una lista (o
	  &minus;1 in caso di errore).
	</para>
	<para>
	  Per esempio, immaginiamo di voler aggiungere <math>n</math>
	  serie casuali normali al dataset e raccoglierle tutte in una
	  lista:
	</para>
	<code>
	  nulldata 10
	  list Normals = null
	  scalar n = 3
	  loop i = 1 .. n
	      Normals += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  Alla fine del ciclo, <lit>Normals</lit> conterrà le serie
	  <lit>norm1</lit>, <lit>norm2</lit> e <lit>norm3</lit>.
	</para>
	<para>
	  Una funzione affine, che svolge un compito simile, è <fncref
	  targ="feval"/>.
	</para>
      </description>
    </function>

    <function name="geoplot" section="data-utils" output="none">
      <fnargs>
	<fnarg type="string">mapfile</fnarg>
	<fnarg optional="true" type="series">payload</fnarg>
	<fnarg optional="true" type="bundle">options</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce una mappa tematica se sono presenti adeguati dati
	  geografici. Il più delle volte, l'argomento
	  <argname>mapfile</argname> sarà uguale a <fncref
	  targ="$mapfile"/>, un accessore che ritorna il nome del file
	  GeoJSON o dello shapefile rilevante. L'argomento opzionale
	  <argname>payload</argname> è invece usato per indicare il
	  nome della serie usata per colorare la mappa. Opzioni
	  aggiuntive possono essere indicate nell'argomento opzionale
	  <argname>options</argname>.
	</para>
	<para>
	  Per tutti i dettagli svariati esempi, rinviamo alla
	  documentazione specifica <doc>geoplot.pdf</doc>. Il
	  documento contiene anche una lista completa delle opzioni
	  configurabili tramite il bundle <argname>options</argname>.
	</para>
      </description>
    </function>

    <function name="getenv" section="programming" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se è definita una variabile di ambiente di nome
	  <argname>s</argname>, questa funzione restituisce una stringa
	  contenente il valore di quella variabile,
	  altrimenti restituisce una stringa vuota.
	  Si veda anche <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getinfo" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce varie informazioni sulla serie in argomento, che
	  può essere specificate per nome o col suo numero ID. Il
	  bundle risultato contiene tutti gli attributi controllabili
	  per mezzo del comando <cmdref targ="setinfo"/>, nonché altre
	  informazioni su serie create come trasformate di altre
	  (ritardi, logaritmi, ecc.): queste ultime includono il
	  comando usato allo scopo sotto la chiave
	  <quote>transform</quote> e il nome della serie primaria ad
	  esso associata sotto <quote>parent</quote>. Per serie
	  ritardate, la chiave <quote>lag</quote> contiene il ritardo
	  specifico.
	</para>
	<para>
	  Segue un esempio d'uso:
	</para>
	<code>
	  open data9-7
	  lags QNC
	  bundle b = getinfo(QNC_2)
	  print b
	</code>
	<para>
	  In esecuzione si ha:
	</para>
	<code>
	  has_string_table = 0
	  lag = 2
	  parent = QNC
	  name = QNC_2
	  graph_name =
	  coded = 0
	  discrete = 0
	  transform = lags
	  description = = QNC(t - 2)
	</code>
	<para>
	  Per verificate se la serie 5 in un dataset è una ritardata,
	  si può usare un meccanismo tipo il seguente:
	</para>
	<code>
	  if getinfo(5).lag != 0
	  printf "la serie 5 è un ritardo di %s\n", getinfo(5).parent
	  endif
	</code>
	<para>
	  Si noti che la notazione col punto funziona anche quando il
	  bundle è <quote>anonimo</quote> (non è salvato sotto un
	  qualche nome).
	</para>
      </description>
    </function>

    <function name="getkeys" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un array di stringhe con le chiavi
	  identificative degli elementi del bundle
	  <argname>b</argname>. Se il bundle è vuoto il risultato sarà
	  a sua volta vuoto.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">source</fnarg>
	<fnarg type="string">target</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è usata per leggere righe successiva da
	  <argname>source</argname>, che dovrebbe essere una variabile
	  stringa. Ad ogni chiamata una linea della fonte è scritta in
	  <argname>target</argname> (anch'essa una variabile
	  stringa), privata del carattere che produce una nuova
	  linea. Il risultato è 1 se non c'è ancora qualcosa da
	  leggere (incluse linee vuote), 0 se la lettura dalla fonte è
	  stata completata.
	</para>
	<para>
	  Questo è un esempio in cui il contenuto di un file di testo è riportato
	  su più righe:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, line)
              printf "line %d = '%s'\n", i++, line
          endloop
	</code>
	<para>
	  In questo esempio possiamo essere sicuri che la fonte è
	  stata esaurita quando termina il ciclo. Se la fonte non può
	  essere completata le chiamate di <lit>getline</lit>
	  dovrebbero essere seguite da una chiamata di <quote>clean
	  up</quote>, in cui <argname>target</argname> è sostituito da
	  <lit>null</lit> (o omesso) come segue
	</para>
	<code>
	  getline(s, line)
	  getline(s, null)
	</code>
	<para>
	  Si noti che, anche se la posizione di lettura avanza ad ogni chiamata di
	  <lit>getline</lit>, questa funzione non modifica <argname>source</argname>
	  ma solo <argname>target</argname>.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola l'approssimazione basata sull'algoritmo GHK (Geweke,
	  Hajivassiliou, Keane) della funzione di ripartizione della
	  normale multivariata; si veda <cite key="geweke91">Geweke
	  (1991)</cite>. Il valore prodotto è un vettore <by r="n"
	  c="1"/> di probabilità.
	</para>
	<para>
	  L'argomento <argname>C</argname> (<by r="m" c="m"/>) deve
	  contenere la scomposizione di Cholesky (triangolare inferiore)
	  della matrice di covarianza delle <math>m</math>
	  variabili normali.  Gli argomenti <argname>A</argname> e
	  <argname>B</argname> dovrebbero essere entrambi <by r="n"
	  c="m"/>, fornendo rispettivamente il limite inferiore e
	  superiore da applicare alle variabili per ciascuna delle
	  <math>n</math> osservazioni. Nel caso in cui le variabili
	  siano illimitate, è necessario indicarlo
	  utilizzando la costante <fncref targ="$huge"/> o il suo
	  opposto.
	</para>
	<para>
	  La matrice <argname>U</argname> deve essere di dimensione
	  <by r="m" c="r"/>, dove <math>r</math> è il numero di
	  estrazioni pseudo-casuali dalla distribuzione uniforme;
	  funzioni idonee alla creazione di <argname>U</argname> sono
	  <fncref targ="muniform"/> e <fncref targ="halton"/>.
	</para>
	<para>
	  Nel seguente esempio, le variabili <argname>P</argname> e
	  <argname>Q</argname> dovrebbero essere numericamente molto
	  simili l'una all'altra, essendo <argname>P</argname> la
	  "vera" probabilità e <argname>Q</argname> la sua
	  approssimazione basata sull'algoritmo GHK:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = muniform(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
    	<para>
	  L'argomento opzionale <argname>dP</argname> contiene, se
	  usato, la matrice <by r="n" c="k"/> di derivate delle
	  probabilità, dove <math>k</math> è pari a 2<math>m</math> +
	  <math>m</math>(<math>m</math> + 1)/2. Le prime
	  <math>m</math> colonne contengono le derivate rispetto ai
	  limiti inferiori e le seguenti <math>m</math> quelle rispetto
	  ai limiti superiori; quelle restanti sono le derivate
	  rispetto agli elementi unici della matrice <math>C</math>
	  (in ordine <quote>vech</quote>).
	</para>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce l'indice di Gini per la serie od il vettore
	  <argname>y</argname>, che devono contenere valori
	  non-negativi. Un risultato pari a 0 indica uguaglianza
	  perfetta. Il valore massimo per l'indice, con una serie
	  contenente <math>n</math> membri è (<math>n</math> &minus;
	  1)/<math>n</math>, che si ha quando un solo elemento ha valore
	  positivo; il valore 1.0 è, pertanto, il limite a cui tende una
	  serie molto grande con massima disuguaglianza.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="scalar" optional="true">tol</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce <math>A</math><sup>+</sup>, l'inversa di
	  Moore&ndash;Penrose o inversa generalizzata di una matrice
	  <argname>A</argname>, con dimensione <by r="r" c="c"/>,
	  calcolata attraverso la scomposizione per valori singolari.
	</para>
	<para>
	  Il risultato dell'operazione dipende dal numero di valori
	  singolari di <argname>A</argname> numericamente diversi da
	  0. Il parametro opzionale <argname>tol</argname> regola
	  precisamente questo aspetto, in quanto un valore singolare è
	  definito nullo ogniqualvolta minore di <math>m &times; tol
	  &times; s</math>, dove <math>m</math> è il massimo tra
	  <math>r</math> e <math>c</math>, mentre <math>s</math> il
	  valore singolare più grande. Se omesso,
	  <argname>tol</argname> sarà pari a <fncref
	  targ="$macheps"/>. In certi casi, può essere necessario
	  impostare <argname>tol</argname> a un valore più grande
	  (p. es. 1.0e-9) per evitare di sovrastimare il rango di
	  <argname>A</argname>, ciò che può portare a risultati
	  numericamente instabili.
	</para>
	<para context="notex">
	  Questa matrice gode delle proprietà seguenti:
	  <math>A</math> <math>A</math><sup>+</sup> <math>A</math>
	  = <math>A</math> e <math>A</math><sup>+</sup>
	  <math>A</math>  <math>A</math><sup>+</sup>
	  = <math>A</math><sup>+</sup> .
	  I prodotti <math>A</math>
	  <math>A</math><sup>+</sup> e <math>A</math><sup>+</sup>
	  <math>A</math>, inoltre, sono simmetrici per costruzione.
	</para>
	<para context="tex">
	  Questa matrice gode delle seguenti proprietà
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+
	  \end{eqnarray*}
	  I prodotti $A^+ A$ e $A A^+$, inoltre, sono simmetrici per costruzione.
	</para>
	<para>
	  <seelist>
            <fncref targ="inv"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="GSSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Massimizzazione unidimensionale col metodo della sezione
	  aurea. La matrice <argname>b</argname> deve essere un
	  vettore a tre elementi. In input, il primo viene ignorato,
	  mentre gli altri due identificano l'intervallo in cui
	  effettuare la ricerca.. L'argomento
	  <argname>fncall</argname> deve essere il nome di una
	  funzione che ritorna il valore da massimizzare; l'elemento 1
	  di <argname>b</argname> conterrà il valore corrente del
	  parametro da calibrare e deve essere dato come primo
	  argomento; altri eventuali parametri possono essere presenti
	  come secondo, terzo argomento eccetera. Affinché il metodo
	  trovi l'effettivo massimo con sicurezza, è necessario che la
	  funzione da massimizzare sia unimodale all'interno
	  dell'intervallo indicato.
	</para>
	<para>
	  Se la funzione va a buon fine, essa ritornerà il valore
	  della funzione nel punto di massimo, mentre
	  <argname>b</argname> conterrà il massimo trovato
	  numericamente, e un intervallo che lo contiene.
	</para>
	<para>
	  Il terzo parametro (opzionale) può essere utilizzato per
	  indicare la tolleranza dell'algoritmo, ossia l'ampiezza
	  massima dell'intervallo finale. Per default, è pari a
	  0.0001.
	</para>
	<para>
	  Se la funzione obiettivo va minimizzata, su può usare una
	  funzione che ritorna il negativo dell'obiettivo, o
	  alternativamente usare l'alias <lit>GSSmin</lit> anziché
	  <lit>GSSmax</lit>.
	</para>
	<para>
	  Un semplice esempio di uso:
	</para>
	<code>
	  function scalar trigfunc (scalar theta)
	  return 4 * sin(theta) * (1 + cos(theta))
	  end function

	  matrix m = {0, 0, $pi/2}
	  eval GSSmax(&amp;m, trigfunc(m[1]))
	  printf "\n%10.7f", m
	</code>
      </description>
    </function>

    <function name="GSSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Come <fncref targ="GSSmax"/>, ma risolve un problema di
	  minimo anziché di massimo.
	</para>
      </description>
    </function>

    <function name="halton" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce una matrice <by r="m" c="r"/> contenente
	  <math>m</math> sequenze di Halton di lunghezza
	  <math>r</math>; <math>m</math> è limitata ad un massimo di
	  40. Le sequenze sono costruite utilizzando i primi
	  <math>m</math> numeri primi. Se non diversamente
	  specificato, i primi 10 elementi di ogni sequenza sono
	  scartati: questo valore può essere modificato specificando
	  l'argomento opzionale <argname>offset</argname> (che deve
	  essere un numero intero non-negativo). Si veda
	  <cite key="halton64">Halton e Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Prodotto diretto orizzontale. I due argomenti devo avere lo
	  stesso numero di righe, <math>r</math>. Il risultato è una
	  matrice con <math>r</math> righe, in cui la riga
	  <math>i</math>-esima è il prodotto di Kronecker delle
	  corrispondenti righe di <argname>X</argname> e
	  <argname>Y</argname>. L'omissione di <argname>Y</argname> fa
	  sì che venga usata la sintassi abbreviata (vedi sotto).
	</para>
	<para context="tex">
	  In altri termini, se $X$ è una matrice $r \times k$, $Y$ è una matrice
	  $r \times m$ e $Z$ è il risultato del
	  prodotto diretto orizzontale di $X$ per $Y$, allora $Z$ avrà
	  $r$ righe e $k\cdot m$ colonne. Inoltre,
	  \[
	  Z_{in} = X_{ij} Y_{il}
	  \]
	  dove $n = (j-1) m + l$.
	</para>
	<para context="notex">
	  Se <argname>X</argname> è una matrice <math>r x k</math> e
	  <argname>Y</argname> è una matrice <math>r x m</math>, il
	  risultato sarà una matrice con <math>r</math> righe e
	  <math>km</math> colonne.
	</para>
	<para>
	  <quote>Prodotto diretto orizzontale</quote>
	  (<quote>Horizontal direct product</quote>) è il modo con cui
	  questa operazione viene chiamata nel linguaggio di
	  programmazione GAUSS. Il suo equivalente in algebra
	  matriciale standard si chiama <quote>prodotto di Khatri-Rao
	  per riga</quote>, o prodotto <quote>face-splitting</quote>
	  in teoria dei segnali.
	</para>
	<para>
	  Esempio: il codice
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produce la matrice seguente:
	</para>
	<code>
           0    1    0    2    0    3
          -4    4   -5    5   -6    6
	</code>
	<subhead>Sintassi abbreviata</subhead>
	<para>
	  Se <argname>X</argname> e <argname>Y</argname> sono uguali,
	  ogni riga della matrice risultato sarà la vettorizzazione di
	  una matrice simmetrica. In questi casi, il secondo argomento
	  può essere omesso; tuttavia, la matrice risultato conterrà
	  solo le colonne non ridondanti, e avrà quindi
	  <math>k(k+1)/2</math> colonne.  Per esempio,
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  C = hdprod(A)
	</code>
	<para>
	  produce
	</para>
	<code>
	  1    2    3    4    6    9
	  16   20   24   25   30   36
	</code>
	<para context="tex">
	  Si noti che la $i$-esima riga di $C$ è $\mathrm{vech}(a_i
	  a_i')$, dove $a_i$ è la $i$-esima riga di $A$.
	</para>
	<para context="notex">
	  Si noti che la <math>i</math>-esima riga di <math>C</math> è
	  <math>vech(a</math><sub>i</sub>
	  <math>a</math><sub>i</sub><math>')</math>, dove
	  <math>a</math><sub>i</sub> è la <math>i</math>-esima riga
	  di <math>A</math>.
	</para>
	<para>
	  Quando si usa la sintassi abbreviata con matrici complesse,
	  il secondo argomento implicito è la <i>coniugata</i> del
	  primo, per far sì che ogni riga del risultato sia la
	  vettorizzazione simmetrica di una matrice hermitiana.
	</para>
      </description>
    </function>

    <function name="hfdiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">mlist</fnarg>
	<fnarg type="scalar">moltiplicatore</fnarg>
      </fnargs>
      <description>
	<para>
	  Data una <cmdref targ="MIDAS_list"/>, produce una lista
	  della stessa lunghezza con differenze prime ad alta
	  frequenza. Il secondo argomento, che è opzionale e 1 se
	  omesso, si usa per moltiplicare il risultato per una
	  costante.
	</para>
      </description>
    </function>

    <function name="hfldiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">mlist</fnarg>
	<fnarg type="scalar">moltiplicatore</fnarg>
      </fnargs>
      <description>
	<para>
	  Data una <cmdref targ="MIDAS_list"/>, produce una lista
	  della stessa lunghezza con differenze logaritmiche ad alta
	  frequenza. Il secondo argomento, che è opzionale e 1 se
	  omesso, si usa per moltiplicare il risultato per una
	  costante, ad esempio 100 per variazioni percentuali
	  approssimate.
	</para>
      </description>
    </function>

    <function name="hflags" section="midas" output="list">
      <fnargs>
	<fnarg type="int">minlag</fnarg>
	<fnarg type="int">maxlag</fnarg>
	<fnarg type="list">mlist</fnarg>
      </fnargs>
      <description>
	<para>
	  Data una <cmdref targ="MIDAS_list"/>, <repl>mlist</repl>,
	  produce una lista contenente i ritardi ad alta frequenza da
	  <repl>minlag</repl> fino a <repl>maxlag</repl>. Valori
	  positivi indicano ritardi, valori negativi anticipi. Ad esempio, se
	  <repl>minlag</repl> è pari a &minus;3 e <repl>maxlag</repl> è 5
	  la lista risultato conterrà 9 serie: 3 anticipi, il valore
	  contemporaneo e 5 ritardi.
	</para>
	<para>
	  Nota bene: il ritardo 0 ad alta frequenza corrisponde al
	  primo sottoperiodo del periodo a bassa frequenza, ossia (ad
	  esempio) il primo mese del trimestre o il primo giorno del
	  mese.
	</para>
      </description>
    </function>

    <function name="hflist" section="midas" output="list">
      <fnargs>
	<fnarg type="vector">x</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg type="string">prefisso</fnarg>
      </fnargs>
      <description>
	<para>
	  Dato il vettore <repl>x</repl>, la funzione produce una <cmdref
	  targ="MIDAS_list"/> di <repl>m</repl> serie, dove
	  <repl>m</repl> è il rapporto fra la frequenza dei dati nel
	  vettore <repl>x</repl> e la frequenza del dataset
	  attuale. il valore di <repl>m</repl> dev'essere almeno 3 e
	  la lunghezza di <repl>x</repl> dev'essere uguale a
	  <repl>m</repl> per il numero di osservazioni nel
	  sottocampione corrente.
	</para>
	<para>
	  I nomi delle serie così create verranno costruiti dal
	  <repl>prefisso</repl> (che dev'essere una stringa ASCII
	  di 24 caratteri al massimo, obbediente ai requisiti di un
	  identificativo valido), più una o più cifre per il
	  sottoperiodo. Se uno o più dei nomi così risultanti fosse
	  già esistente, verrà segnalato un errore.
	</para>
      </description>
    </function>

    <function name="hpfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la componente ciclica ottenuta dall'applicazione
	  del filtro di Hodrick&ndash;Prescott alla variabile
	  <argname>y</argname>. Se il parametro di lisciaggio
	  <argname>lambda</argname> non viene fornito questo viene
	  automaticamente calcolato sulla base dei dati a
	  disposizione: viene posto uguale 100 volte il quadrato della
	  periodicità dei dati (100 per dati annuali, 1600 per dati
	  trimestrali, e così via).
	</para>
	<para>
	  Per default il filtro è ella sua versione solita a due lati, ma
	  se il terzo argomento (opzionale) è non-zero allora viene
	  calcolata la variante ad un lato (senza valori futuri) nel modo
	  illustrato in <cite key="stock-watson1999">Stock e Watson
	  (1999)</cite>.
	</para>
	<para>
	  Il filtro HP viene di soluto usato per detrendizzare una serie,
	  ma se invece quel che interessa è il trend, basta sottrarre il
	  risultato dalla serie originale, come di seguito:
	</para>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="hyp2f1" section="math" output="scalar-or-matrix">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg type="scalar">c</fnarg>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce la funzione ipergeometrica di Gauss per
	  l'argomento reale <argname>x</argname>. I valori validi per
	  <argname>x</argname> sono compresi tra &minus;1 e 1
	  (inclusi). Questa funzione è molto generale e si riduce a
	  una funzione più semplice in alcuni casi particolari, come
	  ad esempio
	  <math>-</math>log(<math>1-x</math>)/<math>x</math> per
	  <math>a=b=1</math> e <math>c=2</math>. Si veda
	  <url>https://en.wikipedia.org/wiki/Hypergeometric_function</url>
	  per maggiori dettagli. </para>
	  <para context="tex">
	  Restituisce la funzione ipergeometrica di Gauss
	  <math>{}_2F_1(a,b;c;z) = \sum_{n=0}^\infty \frac{(a)_n
	  (b)_n}{(c)_n} \frac{z^n}{n!}.</math> per l'argomento reale
	  <argname>x</argname>. I valori validi per
	  <argname>x</argname> sono compresi tra <math>-1</math> e 1
	  (inclusi). Questa funzione è molto generale e si riduce a
	  una funzione più semplice in alcuni casi speciali, come ad
	  esempio <math>-\frac{\log(1-x)}{x}</math> per <math>a=b=1</math> e
	  <math>c=2</math>. Si veda
	  <url>https://en.wikipedia.org/wiki/Hypergeometric_function</url>
	  per maggiori dettagli. </para>
	  <para>
	    Se <argname>x</argname> è uno scalare, il valore
	    restituito sarà scalare; in caso contrario, sarà una
	    matrice delle stesse dimensioni di
	    <argname>x</argname>. Ad esempio,
	  </para>
	  <code>
	    a = hyp2f1(1, 1, 2, {-1, 0, 0.5})
	    print a
	  </code>
	  <para>
	    produce l'output seguente:
	  </para>
	  <code>
	  a (1 x 3)
	  
	  0.69315       1.0000       1.3863 
	  </code>
      </description>
    </function>

    <function name="I" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg optional="true" type="int">m</fnarg>
      </fnargs>
      <description>
	<para>
	  Se l'argomento <argname>m</argname> è omesso, produce la
	  matrice identità con <argname>n</argname> righe e
	  colonne. Altrimenti, ritorna una matrice <by r="n" c="m"/>
	  con uno sulla diagonale e zero altrove.
	</para>
      </description>
    </function>


    <function name="Im" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna una matrice reale delle stesse dimensioni di
	  <argname>C</argname>, contenente le parti immaginarie
	  della matrice in input. Si veda anche <fncref targ="Re"/>.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="scalar">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore contenente gli indici riga dei
	  massimi delle colonne di <argname>X</argname>. Per colonne
	  contenenti <lit>NA</lit> il risultato è <lit>NA</lit> a meno
	  che il parametro opzionale <argname>skip_na</argname> sia
	  diverso da zero, nel qual caso il risultato è l'indice del
	  massimo fra i valori validi.
	</para>
	<seelist>
          <fncref targ="imaxr"/>
          <fncref targ="iminc"/>
          <fncref targ="maxc"/>
	</seelist>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="scalar">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore contenente gli indici colonna dei
	  massimi delle righe di <argname>X</argname>. Per righe
	  contenenti <lit>NA</lit> il risultato è <lit>NA</lit> a meno
	  che il parametro opzionale <argname>skip_na</argname> sia
	  diverso da zero, nel qual caso il risultato è l'indice del
	  massimo fra i valori validi.
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola Prob(<math>u'Au</math> &lt; <math>x</math>) per una
	  forma quadratica di variabili normali standard,
	  <math>u</math>, utilizzando la procedura sviluppata da <cite
	  key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Calcola ${\rm Prob}(u'Au &lt; x)$ per una forma
	  quadratica di variabili normali standard, $u$, utilizzando la procedura
	  sviluppata da <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  Il primo argomento, <argname>M</argname>, può essere una
	  matrice quadrata o un vettore colonna, altrimenti viene
	  visualizzato un messaggio di errore.  Nel primo caso
	  <argname>M</argname> è utilizzato per specificare
	  <math>A</math>, nel secondo caso <argname>M</argname> viene
	  considerato il vettore contenente gli autovalori di
	  <math>A</math>.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="scalar">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore contenente gli indici riga dei minimi
	  delle colonne di <argname>X</argname>. Per colonne
	  contenenti <lit>NA</lit> il risultato è <lit>NA</lit> a meno
	  che il parametro opzionale <argname>skip_na</argname> sia
	  diverso da zero, nel qual caso il risultato è l'indice del
	  minimo fra i valori validi.
	</para>
	<seelist>
          <fncref targ="imaxc"/>
          <fncref targ="iminr"/>
          <fncref targ="minc"/>
	</seelist>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="scalar">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore contenente gli indici colonna dei
	  minimi delle righe di <argname>X</argname>. Per righe
	  contenenti <lit>NA</lit> il risultato è <lit>NA</lit> a meno
	  che il parametro opzionale <argname>skip_na</argname> sia
	  diverso da zero, nel qual caso il risultato è l'indice del
	  minimo fra i valori validi.
	</para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="iminc"/>
            <fncref targ="minr"/>
	  </seelist>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">chiave</fnarg>
      </fnargs>
      <description>
	<para>
	  Controlla se il bundle  <argname>b</argname> contiene un elemento di nome
	  <argname>key</argname>. Il valore restituito è un intero diverso a seconda del
	  tipo di elemento: 0 indica nessun elemento, 1 scalare, 2 variabile,
	  3 matrice, 4 stringa e 5 bundle. Per recuperare la stringa associata
	  al codice può essere utilizzata la funzione <fncref
	  targ="typestr"/>.
	</para>
      </description>
    </function>

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce la norma infinito di <argname>X</argname>, ovvero
	  il massimo valore, lungo le righe di <argname>X</argname>,
	  della somma dei valori assoluti degli elementi nelle righe.
	</para>
	<para context="tex">
	  Restituisce la norma-$\infty$ di una matrice $r\times c$
	  <argname>X</argname>:
          \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la posizione di <argname>y</argname> (a partire
	  dalla prima posizione) nella lista <argname>L</argname>, o 0
	  se <argname>y</argname> non è presente in
	  <argname>L</argname>.
	</para>
	<para>
	  Il secondo argomento può essere il nome di una variabile o il
	  suo identificativo numerico (intero). Se si sa già per certo che
	  una certa serie (diciamo, <lit>pippo</lit>) esiste, allora la
	  funzione può essere chiamata così:
	</para>
	<code>
	  pos = inlist(L, pippo)
	</code>
	<para>
	  In questo caso, sarebbe come chiedere <quote>Dimmi la posizione
	  della serie <lit>pippo</lit> nella lista <lit>L</lit> (o 0 se non
	  c'è).</quote> Se però non si è certi dell'effettiva esistenza
	  della serie, il nome va fra virgolette, come in
	</para>
	<code>
	  pos = inlist(L, "pippo")
	</code>
	<para>
	  In questo caso, invece, sarebbe come chiedere <quote>Se c'è una
	  serie <lit>pippo</lit> nella lista <lit>L</lit>, dimmi a che
	  posto sta, e 0 se non c'è.</quote>
	</para>
      </description>
    </function>

    <function name="instring" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="bool">ign_case</fnarg>
      </fnargs>
      <description>
	<para>
	  Analogo booleano di <fncref targ="strstr"/>: ritorna 1 se
	  <argname>s1</argname> contiene <argname>s2</argname> e 0
	  altrimenti. L'espressione condizionale
	</para>
	<code>
	  if instring("cattle", "cat")
	</code>
	<para>
	  è logicamente equivalente a
	</para>
	<code>
	  if strlen(strstr("cattle", "cat")) > 0
	</code>
	<para>
	  ma più efficiente.
	</para>
	<para>
	  Se l'argomento opzionale <argname>ign_case</argname> è
	  nonzero, la ricerca è insensibile a maiuscole/minuscole. Ad esempio,
	</para>
	<code>
	  instring("Cattle", "cat")
	</code>
	<para>
	  ritorna 0, ma
	</para>
	<code>
	  instring("Cattle", "cat", 1)
	</code>
	<para>
	  ritorna 1.
	</para>
      </description>
    </function>

    <function name="instrings" section="strings" output="matrix">
      <fnargs>
	<fnarg type="strings">S</fnarg>
	<fnarg type="string">test</fnarg>
	<fnarg type="bool" optional="true">simple</fnarg>
      </fnargs>
      <description>
	<para>
	  Controlla quali tra gli elementi dell'array di stringhe
	  <argname>S</argname> siano uguali a
	  <argname>test</argname>. Ritorna un vettore colonna di lunghezza
	  pari al numero di corrispondenze, contenente le posizioni
	  delle corrispondenze all'interno dell'array, o una matrice vuota in caso
	  di assenza di corrispondenze.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  strings S = defarray("A", "B", "C", "B")
	  eval instrings(S, "B")
	  2
	  4
	</code>
	<para>
	  Se viene fornito un valore nonzero per l'argomento opzionale
	  <argname>simple</argname>, il valore restituito è uno
	  scalare: 1 se <argname>test</argname> si trova in
	  <argname>S</argname>, 0 altrimenti. In questo caso la
	  funzione usa un algoritmo semplificato e quindi è più
	  efficiente se si desidera solo una risposta vero/falso.
	</para>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritornaa la parte intera di <argname>x</argname>,
	  troncandone la parte frazionaria. Se il risultato non può
	  essere rappresentato come intero a 32 bit (cioè non è
	  compreso fra &minus;2147483648 e 2147483647), allora il
	  risultato è NA.
	</para>
	<para>
	  Si noti che <lit>int</lit> e <fncref targ="floor"/>
	  differiscono in termini di risultato sui numeri negativi:
	  <lit>int(-3.5)</lit> restituisce &minus;3, mentre
	  <lit>floor(-3.5)</lit> produce &minus;4.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="round"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="interpol" section="data-utils" output="series">
      <fnargs>
       <fnarg type="series">x</fnarg>
      </fnargs>
      <description>
       <para>
	 Ritorna una serie in cui i valori mancanti in
	 <argname>x</argname> vengono imputati tramite interpolazione
	 lineare per dati in serie storica oppure, nel caso di un
	 dataset panel, lungo la dimensione temporale. La funzione non
	 effettua estrapolazione: i valori mancanti sono interpolati
	 solo se preceduti e succeduti da almeno un'osservazione valida.
       </para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'inversa di <argname>A</argname>. Se
	  <argname>A</argname> è singolare o non quadrata viene
	  visualizzato un messaggio di errore e non viene prodotto
	  alcun risultato. Si noti che gretl controlla automaticamente
	  la struttura di <argname>A</argname> e utilizza la procedura
	  numerica più efficiente per il calcolo dell'inversa.
	</para>
	<para>
	  I tipi di matrice che sono controllati da gretl sono: identità;
	  diagonale; simmetrica e positiva definita; simmetrica ma non
	  positiva definita; triangolare.
	</para>
	<para>
	  Notare che ha senso utilizzare questa funzione solamente se si
	  intende usare l'inversa di <argname>A</argname> più di una
	  volta. Se serve semplicemente calcolare un'espressione del tipo
	  <math>A</math><sup>-1</sup><math>B</math> conviene decisamente
	  utilizzare gli operatori di <quote>divisione matriciale</quote>,
	  <lit>\</lit> e <lit>/</lit>. Per ulteriori dettagli vedere
	  <guideref targ="chap:matrices"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ginv"/>
            <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">u</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione di distribuzione inversa. Restituisce il valore
	  <math>x</math> tale che <equation status="inline" ascii="P(X
	  &lt; x) = u" tex="$P(X \le x) = u$"/>, dove la distribuzione
	  di <math>X</math> è determinata dal carattere
	  <argname>c</argname> e <argname>u</argname> sta fra 0 e
	  1. For Per distribuzioni discrete (Binomiale o Poisson),
	  la funzione produce la <math>x</math> più piccola tale che <equation
	  status="inline" ascii="P(X &le; x) &ge; u" tex="$P(X \le x)
	  \ge u$"/>.
	</para>
	<para>
	  The distribution of <math>X</math> is determined by the
	  string <argname>d</argname>.  Between the arguments
	  <argname>d</argname> and <argname>u</argname>, zero or more
	  additional scalar arguments are required to specify the
	  parameters of the distribution, as follows.
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normale standardizzata (c = z, n, o N): nessun argomento addizionale
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g o G): forma; scala
            </para>
	  </li>
	  <li>
            <para>
              T di Student (t): numero di gradi di libertà
            </para>
	  </li>
	  <li>
            <para>
              Chi-quadrato (c, x, o X): numero di gradi di libertà
            </para>
	  </li>
	  <li>
            <para>
              F di Snedecor (f o F): gradi di libertà (num.); gradi di libertà (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomiale (b o B): probabilità; numero di prove
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p o P): media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l o L): media; scala
            </para>
	  </li>
	  <li>
            <para>
              GED standardizzata (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Chi-quadro non centrale (ncX): gdl, parametro di non
	      centralità
	    </para>
	  </li>
	  <li>
	    <para>
	      F non centrale (ncF): gdl (num.), gdl (den.), parametro di
	      non centralità
	    </para>
	  </li>
	  <li>
	    <para>
	      t non centrale (nct): gdl, parametro di non centralità
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribuzione} &amp; codice, $c$ &amp;
	  \textit{Arg.} 2 &amp; \textit{Arg.} 3 &amp; \textit{Arg.} 4 \\[4pt]
	  Normale Standard &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp;
	  -- &amp; -- &amp; -- \\
	  Gamma &amp; \texttt{g} o \texttt{G} &amp;
	  forma &amp; scala &amp; -- \\
	  $t$ di Student (centrata) &amp; \texttt{t} &amp;
	  gradi di libertà &amp; -- &amp; -- \\
	  Chi-quadrato &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp;
	  gradi di libertà &amp; -- &amp; -- \\
	  $F$ di Snedecor &amp; \texttt{f} o \texttt{F} &amp;
	  gradi di libertà (num.) &amp; gradi di libertà (den.) \\
	  Binomiale &amp; \texttt{b} o \texttt{B} &amp;
	  $p$ &amp; $n$ &amp; -- \\
	  Poisson &amp; \texttt{p} o \texttt{P} &amp;
          $\lambda$ &amp; -- &amp; -- \\
	  Laplace &amp; \texttt{l} or \texttt{L} &amp;
          media &amp; scala  &amp; -- \\
	  GED standardizzata &amp; \texttt{E} &amp; forma &amp; -- &amp; -- \\
	  $\chi^2$ non centrale &amp; \texttt{ncX} &amp;
	  gdl &amp; non centralit{\`a} &amp; -- \\
	  $F$  non centrale &amp; \texttt{ncF} &amp;
	  gdl (num.) &amp; gdl (den.) &amp; non centralit{\`a}  \\
	  $t$  non centrale &amp; \texttt{nct} &amp;
	  gdl &amp; non centralit{\`a} &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="critical"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce il reciproco del rapporto di Mills calcolato in
	  <argname>x</argname>, ossia il rapporto tra la densità della
	  normale standard e il complemento della funzione di
	  distribuzione della normale standard, entrambe valutate in
	  <argname>x</argname>.
	</para>
	<para>
	  Questa funzione utilizza un algoritmo dedicato che produce
	  maggiore accuratezza rispetto al calcolo utilizzando <fncref
	  targ="dnorm"/> e <fncref targ="cnorm"/>, ma la differenza
	  tra i due metodi è apprezzabile solo per valori di
	  <argname>x</argname> negativi e molto grandi.
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
	<fnarg optional="true" type="scalarref">&amp;logdet</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'inversa di una matrice simmetrica, definita
	  positiva <argname>A</argname>.  Questa funzione è leggermente più veloce
	  di <fncref targ="inv"/> per grandi matrici poiché non viene
	  effettuato nessun controllo per la simmetria; per questa
	  ragione deve essere utilizzata con attenzione.
	</para>
	<para>
	  Se l'argomento opzionale <argname>&amp;logdet</argname> è
	  presente e la funzione termina senza errori, lo scalare
	  corrispondente conterrà il log determininante di
	  <argname>A</argname>. In certi casi (come ad esempio il
	  calcolo di una log-verosimiglianza gaussiana) questo numero
	  è utile perché viene calcolato come sottoprodotto
	  dell'algoritmo di inversione e il ricorso a
	  <argname>&amp;logdet</argname> evita calcoli non necessari.
	</para>
	<para>
	  Si noti che nel calcolo dell'inversa di una matrice del tipo
	  <math>X'X</math>, ove <math>X</math> sia di dimensioni
	  elevate, è preferibile utilizzare la forma <lit>X'X</lit>
	  invece della più generale sintassi <lit>X'*X</lit>. La prima
	  espressione utilizza infatti un algoritmo specifico che
	  presenta il duplice vantaggio di essere più efficiente dal
	  punto di vista computazionale e di assicurare come risultato
	  una matrice priva per costruzione di approssimazioni indotte
	  dalla precisione macchina, che possono renderlo
	  numericamente non simmetrico.
	</para>
      </description>
    </function>

    <function name="irf" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="pscalar" optional="true">alpha</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione produce le risposte di impulso (IRF) stimate
	  relative ad un VAR o ad un VECM, fino a un certo
	  orizzonte. Se l'ultimo argomento (opzionale) è omesso, la
	  funzione produce risultati solo se l'ultimo modello stimato
	  è un VAR o un VECM. In caso contrario, si assume che le
	  informazioni necessarie siano contenute nel bundle
	  <argname>sys</argname>, che deve avere la stessa struttura
	  di quello prodotto dell'accessore <fncref targ="$system"/>
	  per tali modelli.
	</para>
	<para>
	  Gli argomenti <argname>target</argname> e
	  <argname>shock</argname> sono gli indici (partendo da 1)
	  delle variabili endogene del sistema, mentre 0 è un codice
	  convenzionale per <quote>tutte</quote>. Le IRF sono espresse
	  nell'unità di misura della variabile
	  <argname>target</argname> e sono relative ad uno shock di
	  una deviazione standard nella variabile
	  <argname>shock</argname>.  Se si specifica l'argomento
	  opzionale <argname>alpha</argname>, la matrice dei risultati
	  comprenderà anche un intervallo di confidenza al livello 1
	  &minus; &agr;, per cui da esempio il valore 0.1 fornisce un
	  intervallo al 90 per cento.
	</para>
	<para>
	  Il frammento di codice che segue illustra l'uso della
	  funzione. Nel primo esempio, la matrice <lit>ir1</lit>
	  contiene le IRF di <lit>y1</lit> alle innovazioni di
	  ciascuna fra <lit>y1</lit>, <lit>y2</lit> e <lit>y3</lit>
	  (visto che <argname>alpha</argname> è omesso, si tratta di
	  stime puntuali). Nel secondo, <lit>ir2</lit> contiene tutte
	  le IRF rispetto a uno shock in <lit>y2</lit>,
	  con un intervallo di confidenza del 90 per cento. In questo
	  caso, la matrice risultato avrà 9 colonne: ogni IRF occupa
	  tre colonne adiacenti, con stima puntuale e limiti della
	  banda di confidenza.  Nell'ultimo esempio, la matrice
	  prodotta ha 27 colonne: 3 per ogni IRF per tutte le
	  variabilli per tutti gli shock.
	</para>
	<code>
	  var 4 y1 y2 y3
	  matrix ir1 = irf(1, 0)
	  matrix ir2 = irf(0, 2, 0.1)
	  matrix ir3 = irf(0, 0, 0.1)
	</code>
	<para>
	  Il numero di periodi (righe) su cui sono calcolate le
	  risposte è determinato automaticamente sulla base della
	  frequenza delle osservazioni, ma questa impostazione può
	  essere modificata attraverso il comando <cmdref
	  targ="set"/>, ad esempio <lit>set horizon 10</lit>.
	</para>
	<para>
	  Gli intervalli di confidenza, se prodotti, sono generati
	  tramite il bootstrap, ricampionando i residui originali.  Si
	  assume che l'ordine del modello sia sufficiente ad eliminare
	  la correlazione seriale nei residui. Il numero di default di
	  replicazioni bootstrap è 1999, ma è possibile modificarlo
	  usando il comando <cmdref targ="set"/>, come nel seguente
	  esempio:
	</para>
	<code>
	  set boot_iters 2999
	</code>
	<para>
	  <seelist>
	    <fncref targ="fevd"/>
	    <fncref targ="vma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il tasso interno di rendimento (Internal Rate of
	  Return) per <argname>x</argname>, considerata come una
	  sequenza di pagamenti (valori negativi) e riscossioni
	  (valori positivi).
	  <seelist>
            <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iscomplex" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Controlla se <argname>nome</argname> è il nome di una
	  matrice complessa. Ritorna uno dei seguenti valori:
	</para>
	<para>
	  <lit>NA</lit>: <argname>nome</argname> non è una matrice.
	</para>
	<para>
	  <lit>0</lit>: <argname>nome</argname> è una matrice composta
	  interamente di numeri reali in doppia precisione.
	</para>
	<para>
	  <lit>1</lit>: <argname>nome</argname> è una matrice solo
	  <quote>nominalmente</quote> complessa, che contiene solo
	  numeri in cui la parte immaginaria è zero.
	</para>
	<para>
	  <lit>2</lit>: la matrice in questione contiene almeno un
	  elemento complesso <quote>per davvero</quote>, in cui la
	  parte immaginaria è non-zero.
	</para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">panel-code</fnarg>
      </fnargs>
      <description>
	<para>
	  Quando il secondo argomento (opzionale) non è specificato,
	  produce 1 se <argname>y</argname> ha un valore costante per
	  il campione corrente (o lungo tutta la sua lunghezza se
	  <argname>y</argname> è un vettore), 0 altrimenti.
	</para>
	<para>
	  Il secondo argomento è accettato solo nel caso in cui il
	  dataset corrente sia un panel e <argname>y</argname> sia una
	  variabile.  In questo caso un valore
	  <argname>panel-code</argname> pari a 0 richiede un controllo
	  per invarianza nel tempo, mentre un valore pari a 1 richiede
	  un controllo di invarianza tra le unità cross-section
	  (ossia, in ciascun istante temporale il valore di
	  <argname>y</argname> è lo stesso per tutti i gruppi).
	</para>
	<para>
	  Se <argname>y</argname> è una variabile, i valori mancanti
	  sono ignorati durante il controllo.
	</para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>nome</argname> è l'identificatore per una serie
	  esistente, ritorna 1 se la serie è stata dichiarata come
	  discreta e 0 altrimenti. Se <argname>nome</argname>
	  non identifica una serie, ritorna <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se tutti i valori contenuti in <argname>x</argname> sono 0 o
	  1 (o mancanti), ritorna il numero di 1, altrimenti 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Dato un argomento scalare, restituisce 1 se <argname>x</argname>
	  è <quote>Not a Number</quote> (NaN), 0 altrimenti. Se
	  l'argomento è una matrice produce una matrice delle stesse
	  dimensioni contenente 1 nelle posizioni in cui l'elemento
	  corrispondente della matrice di input è NaN e 0 altrimenti.
	</para>
      </description>
    </function>

    <function name="isoconv" section="calendar" output="int">
      <fnargs>
	<fnarg type="series">date</fnarg>
	<fnarg type="seriesref">&amp;year</fnarg>
	<fnarg type="seriesref">&amp;month</fnarg>
	<fnarg type="seriesref" optional="true">&amp;day</fnarg>
      </fnargs>
      <description>
	<para>
	  Data una variabile <argname>date</argname> contenente date nel
	  formato <quote>base</quote> ISO 8601 (<lit>YYYYMMDD</lit>),
	  questa funzione scrive l'anno, il mese e (opzionale) il giorno
	  corrispondenti nella variabile nominata nel secondo e nei
	  successivi argomenti.  Un esempio, assumendo che la variabile
	  <lit>dates</lit> contenga valori a 8 cifre appropriati:
	</para>
	<code>
	  series y, m, d
	  isoconv(dates, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  Il valore prodotto da questa funzione è 0 se completata con
	  successo; altrimenti, sarà generato un errore.
	</para>
      </description>
    </function>

    <function name="isocountry" section="strings" output="asinput">
      <fnargs>
	<fnarg type="string-or-strings">paese</fnarg>
	<fnarg type="int" optional="true">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione fornisce corrispondenze fra i quattro modi
	  possibili di indicare un paese previsti nella norma ISO
	  3166, e cioè
	</para>
	<nlist>
	  <li><para>
	    Nome paese (in inglese)
	  </para></li>
	  <li><para>
	    Codice Alpha-2 (due lettere maiuscole)
	  </para></li>
	  <li><para>
	    Codice Alpha-3 (tre lettere maiuscole)
	  </para></li>
	  <li><para>
	    Codice numerico (a 3 cifre)
	  </para></li>
	</nlist>
	<para>
	  Partendo da una delle 4 forme, la funzione restituisce una
	  delle altre, a seconda dell'argomento
	  <argname>tipo</argname>, che deve andare da 1 a 4; se
	  l'argomento è omesso, la conversione avviene come segue:
	  quando <argname>paese</argname> è il nome di un paese, il
	  valore di ritorno è il codice Alpha-2; altrimenti, viene
	  ritornato il nome del paese. Qui di seguito sono illustrate
	  alcune chiamate alla funzione in modalità interattiva.
	</para>
	<code>
	  ? eval isocountry("Bolivia")
	  BO
	  ? eval isocountry("Bolivia", 3)
	  BOL
	  ? eval isocountry("GB")
	  United Kingdom of Great Britain and Northern Ireland
	  ? eval isocountry("GB", 3)
	  GBR
	  ? strings S = defarray("ES", "DE", "SD")
	  ? strings C = isocountry(S)
	  ? print C
	  Array of strings, length 3
	  [1] "Spain"
	  [2] "Germany"
	  [3] "Sudan"
	  ? matrix m = {4, 840}
	  ? C = isocountry(m)
	  ? print C
	  Array of strings, length 2
	  [1] "Afghanistan"
	  [2] "United States of America"
	</code>
	<para>
	  L'argomento <argname>paese</argname> nella forma 4 (codice
	  numerico), può essere contenuto in una stringa o in un array
	  di stringhe (ad esempio, <quote>032</quote> per
	  l'Argentina), così come in una variabile numerica. In questo
	  caso, <argname>paese</argname> può essere una serie o un
	  vettore, ma se c'è almeno un valore al di fuori del campo da
	  0 a 999, la funzione darà errore.
	</para>
	<para>
	  Il valore di ritorno è in ogni caso una stringa o un array
	  di stringhe; queste, volendo, possono essere convertite in
	  valori numerici per mezzo della funzione <fncref
	  targ="atof"/>.  Se <argname>paese</argname> non viene
	  trovato nella tavola ISO 3166, il valore restituito dalla
	  funzione è una stringa vuota, e viene stampato un avviso.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  L'argomento <argname>ed</argname> è interpretato come una
	  data in formato <quote>epoch</quote> (uguale a 1 per il
	  primo gennaio nell'anno 1 AD). Il risultato di default
	  &mdash; dello stesso tipo di <argname>ed</argname> &mdash; è
	  un numero a 8 cifre, o una serie di tali numeri, del tipo
	  <lit>YYYYMMDD</lit> (formato <quote>base</quote> ISO 8601),
	  che fornisce la data di calendario gregoriano corrispondente
	  al giorno epoch.
	</para>
	<para>
	  Se il secondo argomento opzionale
	  <argname>as-string</argname> è diverso da zero, il valore
	  restituito non è numerico, bensì una stringa del tipo
	  <lit>YYYY-MM-DD</lit> (formato ISO 8601
	  <quote>extended</quote>), o una serie con valori di stringa
	  se <argname>ed</argname> è una serie, o un array di stringhe
	  se <argname>ed</argname> è un vettore. Per ottenere
	  rappresentazioni di stringa dei giorni dell'epoca in modo
	  più flessibile, si veda <fncref targ="strfday"/>.
        </para>
	<para>
	  Per la funzione inversa, si veda <fncref targ="epochday"/>.
	</para>
      </description>
    </function>

    <function name="isoweek" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">anno</fnarg>
	<fnarg type="scalar-or-series">mese</fnarg>
	<fnarg type="scalar-or-series">giorno</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna il numero di settimana secondo lo standard ISO
	  8601, corrispondente alla data specificata nei tre argomenti, o <lit>NA</lit>
	  se la data non è valida. Si noti che tutti e tre gli
	  argomenti devono essere dello stesso tipo, cioè scalari
	  (interi) oppure serie.
	</para>
	<para>
	  Le settimane ISO sono numerate da 01 a 53; per lo più, ogni
	  anno ne ha 52, ma su 400 un certo numero (in media 71) ne ha
	  53.
	  Secondo la definizione ISO 8601, la settimana 01 è quella
	  che contiene il primo giovedì dell'anno, secondo il
	  calendario gregoriano. Per maggiori dettagli, si veda
	  <url>https://en.wikipedia.org/wiki/ISO_week_date</url>.
	</para>
	<para>
	  Un modo alternativo di usare questa funzione è darle un solo
	  argomento, che è inteso come una data (o una serie di date)
	  in formato ISO 8601 <quote>basico</quote>, cioè
	  <lit>YYYYMMDD</lit>. Le due espressioni seguenti
	  restituiscono lo stesso risultato, cioè 13.
       </para>
       <code>
	 eval isoweek(2022, 4, 1)
	 eval isoweek(20220401)
       </code>
      </description>
    </function>

    <function name="iwishart" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Data <argname>S</argname> (una matrice positiva definita <by r="p"
	  c="p"/>), restituisce un'estrazione dalla distribuzione inversa di
	  Wishart con <argname>v</argname> gradi di
	  libertà. La matrice che ne risulta è anch'essa <by r="p" c="p"/>.
	  Utilizza l'algoritmo di <cite key="odell-feiveson66">Odell e Feiveson
	  (1966)</cite>.
	</para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">path</fnarg>
	<fnarg optional="true" type="scalarref">&amp;nread</fnarg>
      </fnargs>
      <description>
	<para>
	  L'argomento <argname>buf</argname> deve essere un buffer
	  JSON, così come vien letto da un server attraverso la
	  funzione <fncref targ="curl"/>, mentre l'argomento
	  <argname>path</argname> dev'essere una specificazione
	  JsonPath.
	</para>
	<para>
	  Questa funzione restituisce una stringa con i dati trovati
	  nel buffer al path specificato. Sono supportati i tipi di
	  dato <quote>double</quote> (decimale), <quote>int</quote>
	  (intero) e <quote>string</quote> (stringa). Nel caso di
	  argomenti numerici, viene restituita la loro
	  rappresentazione stringa (con le convenzioni
	  <quote>C</quote> per i double).  Se l'oggetto a cui
	  <argname>path</argname> fa riferimento è un array, i suoi
	  membri vengono stampati uno per linea nella stringa
	  risultato.
	</para>
	<para>
	  Per default, se <argname>path</argname> non viene trovato nel
	  buffer JSON si verifica un errore, ma questo può essere
	  evitato passano il terzo argomento (opzionale): così
	  facendo, l'argomento restituisce il numero di corrispondenze
	  trovate. Se non ce ne sono, la funzione restituisce una
	  stringa vuota. Ad esempio:
	</para>
	<code>
	  ngot = 0
	  ret = jsonget(jbuf, "$.some.thing", &amp;ngot)
	</code>
	<para>
	  Tuttavia se la query non rispetta lo standard, viene
	  ritornato ugualmente un errore.
	</para>
	<para>
	  Per maggiori dettagli sulla sintassi JsonPath, si veda ad
	  esempio
	  <url>http://goessner.net/articles/JsonPath/</url>. Tuttavia,
	  si noti che il modulo di gretl per <lit>jsonget</lit> è
	  fornito dalla libreria esterna <lit>json-glib</lit>, la
	  quale non necessariamente supporta tutti gli elementi di
	  JsonPath. Inoltre, la funzionalità precisa di
	  <lit>json-glib</lit> può dipendere dalla versione installata
	  sul vostro sistema. Per maggiori dettagli, vedi
	  <url>http://developer.gnome.org/json-glib/</url>.
	</para>
	<para>
	  Ciò premesso, <lit>jsonget</lit> dovrebbe mettere a
	  disposizione i seguenti operatori:
	</para>
	<ilist>
	  <li>
            <para>
	      nodo radice, attraverso il carattere <lit>$</lit>
            </para>
	  </li>
	  <li>
            <para>
	      operatore di discesa ricorsiva: <lit>..</lit>
            </para>
	  </li>
	  <li>
            <para>
	      operatore wildcard: <lit>*</lit>
            </para>
	  </li>
	  <li>
            <para>
	      operatore pedice : <lit>[]</lit>
            </para>
	  </li>
	  <li>
            <para>
	      operatore di sottoinsieme, p. es. <lit>[i,j]</lit>
            </para>
	  </li>
	  <li>
            <para>
	      operatore di slice (fetta): <lit>[start:end:step]</lit>
            </para>
	  </li>
	</ilist>

      </description>
    </function>

    <function name="jsongetb" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string" optional="true">percorso</fnarg>
      </fnargs>
      <description>
	<para>
	  L'argomento <argname>buf</argname> dev'essere un buffer
	  JSON, così come ad esempio può esser preso da un sito
	  attraverso la funzione <fncref targ="curl"/>. L'argomento opzionale
	  <argname>percorso</argname> è discusso più sotto.
	</para>
	<para>
	  La funzione restituisce un bundle la cui struttura riproduce
	  quella dell'input: gli oggetti JSON diventano bundle e gli
	  array JSON diventano array gretl, contenenti stringhe o a
	  loro volta bundle. I nodi JSON <quote>valore</quote>
	  diventano membri di bundle o elementi di array; nel secondo
	  caso, i valori numerici sono convertiti in stringhe via
	  <lit>sprintf</lit>.  Si noti che, dal momento che in gretl
	  gli array non possono essere annidati, l'input per questa
	  funzione è un po' più restrittivo della specificazione JSON
	  completa, in cui ciò è possibile.
	</para>
	<para>
	  L'argomento opzionale <argname>percorso</argname> viene usato
	  per limitare gli elementi JSON compresi nel bundle. Si noti
	  che questo non è un <quote>JsonPath</quote> come descritto
	  alla funzione <fncref targ="jsonget"/>; invece, è un
	  semplice costrutto descritto qui nel seguito.
	</para>
	<ilist>
	  <li>
	    <para>
	      <argname>path</argname> è una stringa contenente
	      elementi separati da una barra (<quote>/</quote>) che
	      indica il movimento <quote>in profondità</quote>
	      nell'albero JSON contenuto in
	      <argname>buf</argname>. Il percorso inizia
	      implicitamente dal nodo radice, per cui una barra
	      iniziale è ammessa ma non richiesta. Il percorso non può
	      contenere spazi.
	    </para>
	  </li>
	  <li>
	    <para>
	      Ogni elemento del percorso deve essere formato in uno
	      dei seguenti tre modi: (a) un nome, nel qual caso il
	      bundle conterrà solo l'elemento JSON di nome
	      corrispondente a quel dato livello; oppure (b) <quote>*</quote>
	      (asterisco), che indica l'inclusione di tutti gli
	      elementi a quel livello; o infine (c), una lista di
	      elementi separati da virgole, compresa fra graffe (<quote>{</quote> e
	      <quote>}</quote>), nel qual caso verranno inclusi solo
	      quei certi elementi JSON.
	    </para>
	  </li>
	</ilist>
        <para>
          Vedi anche la funzione stringa <fncref targ="jsonget"/>;
          ognuna di queste due può essere più utile dell'altra, a
          seconda dei casi.
        </para>
      </description>
    </function>

    <function name="juldate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">come-stringa</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione opera esattamente come  <fncref
	  targ="isodate"/>, con l'unica differenza che viene usato il
	  calendario giuliano anziché quello gregoriano.
	</para>
      </description>
    </function>

    <function name="kdensity" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-list-or-mat">x</fnarg>
	<fnarg type="scalar" optional="true">scale</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la stima della densità kernel per l'argomento
	  <argname>x</argname>, che può essere una serie, una lista, o
	  una matrice con una o più colonne. La matrice che ne risulta
	  ha <math>k</math> + 1 colonne, dove <math>k</math> è il
	  numero di elementi (serie o colonne) in
	  <argname>x</argname>. La prima contiene un insieme di valori
	  in ascissa equispaziati e le altre riportano le stime della
	  densità in ciascuno di questi punti.
        </para>
	<para>
	  La formula utilizzata per calcolare la densità stimata in
	  ciascun punto di riferimento, <math>x</math>, è
	  <equation status="display"
              tex="\[f(x)=(1/nh) \sum_{t-1}^{n} k\left((x-x_t)/h\right)\]"
              ascii="f(x) = (1/nh) sum(t=1 to n) k((x - x(t)) / h)"
              graphic="kernel1"/>
	  dove <math>n</math> indica il numero dei dati,
	  <math>h</math> è una larghezza di banda e <math>k</math>() è
	  la funzione kernel.  Maggiore è il valore del parametro
	  della larghezza di banda, più liscia sarà la densità
	  stimata.
	</para>
	<para>
	  Il parametro opzionale <argname>scale</argname> può essere
	  utilizzato per adattare il grado di lisciaggio rispetto al
	  valore di default di 1.0, che usa la regola proposta da
	  <cite key="silverman86">Silverman (1986)</cite>, e cioè
	  <equation status="display"
	     tex="\[h=0.9 {\rm min}(s, {\rm IQR}/1.349) n^{-1/5}\]"
	     ascii="h = 0.9 min(s, IQR/1.349) n^{-1/5}"
	     graphic="kernel2"/>
	  dove <math>s</math> è lo scarto quadratico medio dei dati e
	  IQR è il range interquartile. Il parametro
	  <argname>control</argname> è booleano: si utilizza il kernel
	  Gaussiano quando <argname>control</argname> è pari 0 (il
	  valore di default); altrimenti, si utilizza il kernel di
	  Epanechnikov.
	</para>
	<para>
	  Un grafico del risultato può essere ottenuto utilizzando il
	  comando <cmdref targ="gnuplot"/>, come segue. Si noti che la
	  colonna contenente le ascisse deve essere specificata per
	  ultima.
	</para>
	<code>
	  matrix d = kdensity(x)
	  # se x ha un solo elemento
	  gnuplot 2 1 --matrix=d --with-lines --fit=none
	  # se x ha due elementi
	  gnuplot 2 3 1 --matrix=d --with-lines --fit=none
	</code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Effettua il <quote>disturbance smoothing</quote> per un
	  bundle tipo Kalman inizializzato in precedenza con la
	  funzione <fncref targ="ksetup"/>; restituisce 0 se il
	  comando va a buon fine e 1 se ci sono stati problemi
	  numerici. È consigliabile controllare l'output della
	  funzione prima di utilizzarne i risultati.
	</para>
	<para>
	  Se l'esecuzione va a buon fine, i disturbi stimati
	  <quote>lisciati</quote> saranno disponibili sotto
	  <lit>Mod.smdist</lit>.
	</para>
	<para>
	  L'argomento opzionale <argname>MSE</argname> determina il
	  contenuto di <lit>Mod.smdisterr</lit>. Se esso è 0 od
	  omesso, questa matrice conterrà gli errori standard non
	  condizionali dei disturbi, che sono di solito usati per
	  produrre i cosiddetti <emphasis>residui
	  ausiliari</emphasis>. Altrimenti, <lit>Mod.smdisterr</lit>
	  conterrà la stima degli scarti quadratici medi dei residui
	  ausiliari dal loro vero valore.
	</para>
	<para>
	  Per più dettagli, vedi <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Effettua un passaggio di filtraggio in avanti su un bundle
	  di tipo Kalman, creato in precedenza per mezzo della
	  funzione <fncref targ="ksetup"/>; ritorna 0 se l'esecuzione
	  va a buon fine o 1 quando si incontrino problemi numerici.
	</para>
	<para>
	  Se l'esecuzione va a buon fine, l'elemento
	  <lit>Mod.prederr</lit> conterrà gli errori di previsione a
	  un passo, assieme alla sequenza delle rispettive matrici di
	  covarianza in <lit>Mod.pevar</lit>. Inoltre, l'elemento
	  <lit>Mod.llt</lit> conterrà un vettore di dimensione T,
	  contenente la log-verosimiglianza per osservazione.
	</para>
	<para>
	  Per ulteriori dettagli, vedi <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kmeier" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Dato un campione di dati di durata, <argname>d</argname>, ed
	  eventualmente una variabile di censura,
	  <argname>cens</argname>, questa funzione calcola lo
	  stimatore nonparametrico di Kaplan&ndash;Meier della
	  funzione di sopravvivenza (<cite key="kaplan-meier">Kaplan
	  and Meier, 1958</cite>). La matrice risultato ha tre
	  colonne, contenenti (nell'ordine) i valori in
	  <argname>d</argname>, ordinati, la funzione di sopravvivenza
	  stimata e il suo errore standard asintotico, calcolato col
	  metodo di <cite key="greenwood26">Greenwood (1926)</cite>.
	</para>
	<para>
	  Se l'argomento <argname>cens</argname> non viene omesso, il
	  valore 0 indica che l'osservazione non è censurata, mentre
	  il valore 1 denota una censura a destra (e cioè che il
	  periodo di osservazione dell'individuo in questione si è
	  concluso prima che la durata fosse registrata come
	  conclusa). Se <argname>cens</argname> è omesso, si assume
	  che le osservazioni siano non censurate. (Nota: le
	  convenzioni su <argname>cens</argname> potranno subire
	  modifiche in futuro per coprire altri tipi di censura.)
	</para>
	<para>
	  <seelist>
            <fncref targ="naalen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">trend</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore riga contenente i valori critici al
	  10, 5 e 1 percento per il test di stazionarietà
	  KPSS. <argname>T</argname> deve contenere il numero di
	  osservazioni e <argname>trend</argname> dev'essere 1 se il
	  test include un trend e 0 altrimenti.
	</para>
	<para>
	  I valori critici sono basati sulle superfici di risposta
	  stimate da <cite key="sephton95">Sephton (Economics
	  Letters, 1995)</cite>. Vedi anche il comando <cmdref
	  targ="kpss"/>.
 	</para>
      </description>
    </function>

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">Z</fnarg>
	<fnarg type="scalar-or-matrix">T</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">C</fnarg>
	<fnarg optional="true" type="matrix">R</fnarg>
      </fnargs>
      <description>
	<para>
	  Imposta un bundle di tipo Kalman, ossia un oggetto
	  contenente le informazioni necessarie a definire un modello
	  lineare in spazio degli stati della seguente forma:
	  <equation status="display"
		    tex="\[y_t= Z \alpha_t + u_t\]"
		    ascii="y(t) = Z a(t) + u(t)"
		    graphic="kalman1"/>
          con equazione di transizione
	  <equation status="display"
		    tex="\[\alpha_{t+1} = T \alpha_t + v_t\]"
		    ascii="a(t+1) = T a(t) + v(t)"
		    graphic="kalman2"/>
		    dove var<math>v = Q</math>.
        </para>
	<para>
	  Gli oggetti così creati possono poi essere usati con le
	  funzioni dedicate <fncref targ="kfilter"/> per il
	  filtraggio, <fncref targ="ksmooth"/> e <fncref
	  targ="kdsmooth"/> per il lisciaggio
	  (<emphasis>smoothing</emphasis>) e <fncref targ="ksimul"/>
	  per effettuare simulazioni.
	</para>
	<para>
	  La classe dei modelli gestibili è, in realtà, molto più
	  ampia di quanto implicato dalla rappresentazione qui sopra:
	  si possono creare modelli con matrici di sistema variabili
	  nel tempo, modelli con prior diffuse, variabili esogene
	  nell'equazione di misura e modelli con innovazioni correlate
	  fra loro. Per ulteriori dettagli, si veda <guideref
	  targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="kdsmooth"/>
	    <fncref targ="kfilter"/>
	    <fncref targ="ksmooth"/>
	    <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksimul" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="bool" optional="true">extra</fnarg>
      </fnargs>
      <description>
	<para>
	  Usa un bundle di tipo Kalman, creato in precedenza con
	  <fncref targ="ksetup"/> per simulare dei dati, prendendo i
	  disturbi dalla matrice <argname>U</argname>. Per default, la
	  matrice restituita (che avrà tante righe quante
	  <argname>U</argname>) contiene valori simulati delle
	  osservabili, ma se viene specificato un valore diverso da
	  zero per <argname>extra</argname> viene inclusa anche la
	  simulazione degli stati. In quest'ultimo caso, ogni riga
	  contiene prima gli stati, poi le osservabili.
	</para>
	<para>
	  Per maggiori dettagli, vedi <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="ksetup"/>
	    <fncref targ="kfilter"/>
	    <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksmooth" section="sspace" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Effettua un passaggio di filtraggio all'indietro su un
	  bundle di tipo Kalman, creato in precedenza per mezzo della
	  funzione <fncref targ="ksetup"/>; ritorna 0 se l'esecuzione
	  va a buon fine o 1 quando si incontrino problemi numerici. È
	  consigliabile controllare l'output della funzione prima di
	  utilizzarne i risultati.
	</para>
	<para>
	  Se l'esecuzione va a buon fine, l'elemento
	  <lit>Mod.state</lit> conterrà gli stati lisciati, assieme
	  alla sequenza delle rispettive matrici di covarianza in
	  <lit>Mod.stvar</lit>.  Per maggiori dettagli, si veda
	  <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="kdsmooth"/>
	    <cmdref targ="kalman"/>
	    <fncref targ="kfilter"/>
	    <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce il coefficiente di curtosi (in eccesso) della
	  variabile <argname>x</argname>, calcolato non considerando i
	  valori mancanti.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list-or-mat">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="series-or-list">y</fnarg>
	<fnarg type="bool" optional="true">bylag</fnarg>
      </fnargs>
      <description>
	<para>
	  Se il primo argomento è uno scalare, genera i ritardi da 1 a
	  <argname>p</argname> della variabile <argname>y</argname>, o se
	  <argname>y</argname> è una lista, di tutte le variabili nella
	  lista.  Se <argname>p</argname> = 0, e <argname>y</argname> è
	  una serie o una lista, il ritardo massimo è pari alla
	  periodicità dei dati; altrimenti, <argname>p</argname> deve
	  essere positivo.
	</para>
	<para>
	  Se il primo argomento è un vettore, vengono generati i ritardi
	  specificati in esso. Ad esempio, un tipico uso di questa
	  possibilità sarebbe specificare <argname>p</argname> come
	  <lit>seq(3,7)</lit>, il che equivale ad omettere il primo e il
	  secondo ritardo. Non c'è problema nell'usare vettori con
	  <quote>buchi</quote>, come ad esempio in <lit>{3,5,7}</lit>, ma
	  in questi case i ritardi devono essere dati in ordine
	  ascendente.
	</para>
	<para>
	  Nel caso l'output sia una lista, alle variabili così generate è
	  automaticamente attribuito un nome sulla base del formato
	  <repl>varname</repl><lit>_</lit><repl>i</repl> dove
	  <repl>varname</repl> è il nome della variabile originale e
	  <repl>i</repl> è il valore del ritardo.  Se necessario la parte
	  originale del nome è troncata e può essere aggiustata in caso di
	  ripetizioni nell'insieme dei nomi delle variabili così
	  costruite.
	</para>
	<para>
	  Quando <argname>y</argname> è una lista e l'ordine di ritardo è
	  maggiore di 1, l'ordinamento di default dei termini della lista
	  che ne risulta è per variabile: tutti i ritardi della prima
	  variabile nella lista in input sono seguiti da tutti i ritardi
	  della seconda variabile, e così via. Il terzo argomento
	  (opzionale) può essere utilizzato per cambiare tale
	  impostazione: se <argname>bylag</argname> è diverso da zero i
	  termini sono ordinati per ritardo: il primo ritardo di tutte le
	  variabili in input, poi il secondo ritardo, e così via.
	</para>
	<para>
	  Vedi anche <fncref targ="mlag"/> per l'uso con matrici.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">insample</fnarg>
      </fnargs>
      <description>
	<para>
	  Ultimo valore non-mancante per la variabile
	  <argname>y</argname>. Si noti che se si sta operando su un
	  sottocampione ristretto, il valore prodotto può essere
	  maggiore della variabile dollaro <fncref targ="$t2"/>. Se però
	  l'argomento <argname>insample</argname> è nonzero, viene
	  considerato solo il sottocampione attualmente in vigore.
	  <seelist>
	    <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce il logaritmo naturale del determinante di
	  <math>A</math>, calcolato attraverso la fattorizzazione
	  LU. Questa funzione è più efficiente del calcolo del
	  logaritmo del risultato di <fncref targ="det"/>. Fra
	  l'altro, in alcuni casi <lit>ldet</lit> restituisce un
	  risultato valido anche quando il determinante di
	  <math>A</math> è numericamente <quote>infinito</quote> (nel
	  senso che eccede il massimo consentito dalla precisione
	  dell'elaboratore).
	  <seelist>
	    <fncref targ="det"/>
	    <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le differenze logaritmiche; i valori iniziali sono posti uguali a
	  <lit>NA</lit>.
	</para>
	<para>
	  Quando viene restituita una lista alle singole variabili così generate
	  è automaticamente attribuito un nome sulla base del formato
	  <lit>ld_</lit><repl>varname</repl> dove
	  <repl>varname</repl> è il nome della variabile originale.
	  Se necessario il nome viene troncato e può essere modificato
	  in caso di ripetizioni nell'insieme dei nomi delle variabili
	  così costruite.
	</para>
	<para>
	  <seelist>
	    <fncref targ="diff"/>
	    <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola una nuova variabile ottenuta come combinazione
	  lineare delle variabili nella lista <argname>L</argname>.  I
	  coefficienti sono dati dal vettore <argname>b</argname>, che
	  deve avere lunghezza uguale al numero di variabili in
	  <argname>L</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="linearize" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Richiede che TRAMO sia installato. Restituisce una versione
	  <quote>linearizzata</quote> della serie in input, ossia una
	  serie in cui le osservazioni mancanti vengono sostituite da
	  valori interpolati e gli outlier vengono aggiustati. A tal
	  fine, viene usato il meccanismo automatico di TRAMO; per
	  maggiori dettagli, si consulti la documentazione di TRAMO.
	</para>
	<para>
	  Si noti che, se la serie in input non contiene osservazioni
	  mancanti né valori che TRAMO considera outlier, la funzione
	  ritorna una copia della serie originale.
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la statistica Q di Ljung&ndash;Box per la serie y
	  <argname>y</argname> usando <argname>p</argname> ritardi e
	  il campione corrente. L'ordine di ritardo deve essere maggiore o uguale a 1 e
	  inferiore al numero di osservazioni disponibili.
	</para>
	<para>
	  Questa statistica può essere confrontata con la distribuzione chi-quadro con
	  <argname>p</argname> gradi di libertà per sottoporre a test
	  l'ipotesi che la variabile <argname>y</argname> sia
	  serialmente incorrelata.
	  <seelist>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Logaritmo della funzione gamma di <argname>x</argname>.
	</para>
	<para>
	  Vedi anche <fncref targ="bincoeff"/> e <fncref targ="gammafun"/>.
	</para>
      </description>
    </function>

    <function name="loess" section="nonparam" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robust</fnarg>
      </fnargs>
      <description>
	<para>
	  Effettua una regressione polinomiale ponderata localmente e
	  restituisce una variabile contenente i valori previsti di
	  <argname>y</argname> per ogni elemento non mancante di
	  <argname>x</argname>.  Viene usato il metodo descritto in
	  <cite key="cleveland79">William Cleveland (1979)</cite>.
	</para>
	<para>
	  Gli argomenti opzionali <argname>d</argname> e
	  <argname>q</argname> specificano rispettivamente l'ordine
	  del polinomio in <argname>x</argname> e la proporzione di
	  punti da usare nella stima locale.  I valori predefiniti
	  sono <argname>d</argname> = 1 e <argname>q</argname> =
	  0.5. Gli altri valori consentiti per <argname>d</argname>
	  sono 0 e 2. Con <argname>d</argname> = 0 la regressione
	  locale si riduce a una forma di media mobile. Il valore di
	  <argname>q</argname> dev'essere compreso fra 0 e 1; più
	  grande è il valore, più liscia sarà la stima.
	</para>
	<para>
	  Assegnando all'argomento <argname>robust</argname> un valore
	  non-zero, le regressioni locali sono effettuate due volte,
	  con pesi modificati sulla base dei residui dell'iterazione
	  precedente per ridurre l'effetto degli outlier.
	</para>
	<para>
	  Si vedano anche <fncref targ="nadarwat"/> e <guideref
	  targ="chap:nonparam"/> per maggiori dettagli sui metodi
	  nonparametrici.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Logaritmo naturale di <argname>x</argname>; genera
	  <lit>NA</lit> per valori non positivi. Nota: <lit>ln</lit>
	  può essere usato al posto di di <lit>log</lit>.
	</para>
	<para>
	  Quando restituisce una lista, alle singole variabili viene
	  automaticamente assegnato un nome sulla base del formato
	  <lit>l_</lit><repl>varname</repl> dove <repl>varname</repl>
	  è il nome della variabile originale.  Se necessario il nome
	  viene troncato e può essere modificato in caso di
	  ripetizioni nell'insieme dei nomi delle variabili così
	  costruite.
	</para>
	<para>
	  Si noti che in caso di input matriciale la funzione agisce
	  elemento per elemento. Per la funzione logaritmo matriciale,
	  si veda <fncref targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Logaritmo in base 10 di <argname>x</argname>; produce <lit>NA</lit> per valori
	  non positivi.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Logaritmo in base 2 di <argname>x</argname>; produce <lit>NA</lit> per valori
	  non positivi.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Restituisce la funzione logistica calcolata nell'argomento
	  <argname>x</argname>: $\Lambda(x) = e^x/(1+e^x)$. Se
	  <argname>x</argname> è una matrice, la funzione è applicata
	  elemento per elemento.
	</para>
	<para context="notex">
	  Restituisce la funzione logistica calcolata nell'argomento
	  <argname>x</argname>: <math>e</math><sup>x</sup>/(1 +
	  <math>e</math><sup>x</sup>).  Se <argname>x</argname> è una
	  matrice, la funzione è applicata elemento per elemento.
	</para>
      </description>
    </function>

    <function name="lpsolve" section="math" output="bundle">
      <fnargs>
	<fnarg type="bundle">specs</fnarg>
      </fnargs>
      <description>
	<para>
	  Risolve numericamente un problema di programmazione lineare
	  usando la libreria <lit>lpsolve</lit>. Si veda
	  <doc>gretl-lpsolve.pdf</doc> (in inglese) per dettagli ed
	  esempi d'uso.
	</para>
      </description>
    </function>

    <function name="lower" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce una matrice <by r="n" c="n"/> triangolare inferiore: gli elementi
	  sulla diagonale o sotto di essa sono uguali al valore corrispondente in
	  <argname>A</argname>; i restanti valori sono pari a zero.
	</para>
	<para context="tex">
	  Restituisce una matrice $n\times n$ triangolare inferiore <math>B</math>
	  tale che $B_{ij} = A_{ij}$ se $i \ge j$, e 0 altrimenti.
	</para>
	<para>
	  <seelist>
	    <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrcovar" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="bool" optional="true">centra</fnarg>
      </fnargs>

      <description>
	<para>
	  Restituisce la matrice varianze-covarianze di lungo periodo
	  delle colonne di <argname>A</argname>. Le colonne vengono
	  centrate a meno che il secondo argomento (opzionale) non sia
	  zero. Il tipo di kernel e il parametro di troncamento
	  (ampiezza della finestra) vengono scelti tramite le
	  opportune opzioni offerte dal comando <cmdref targ="set"/>,
	  quali <lit>hac_kernel</lit>, <lit>hac_lag</lit> e
	  <lit>hac_prewhiten</lit>. Si veda la sezione su dati in
	  serie storiche e matrici di covarianze robuste in <guideref
	  targ="chap:robust_vcv"/> per più dettagli.
	</para>

	<para>
	  <seelist>
	    <fncref targ="lrvar"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="lrvar" section="timeseries" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
	<fnarg type="scalar" optional="true">mu</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la varianza di lungo periodo di <argname>y</argname>
	  calcolata utilizzando il kernel di Bartlett con finestra
	  <argname>k</argname>. Se il secondo argomento è omesso o
	  negativo l'ampiezza della finestra è pari alla parte intera
	  della radice cubica dell'ampiezza campionaria.
	</para>
	<para context="tex">
	  In formule:
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \mu) (y_{t-i} - \bar{Y})
	  \right] \]
	  con
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
	<para>
	  Nel calcolo della varianza, la serie <argname>y</argname> viene
	  centrata sul parametro opzionale <argname>mu</argname>; se
	  questo è omesso o <lit>NA</lit>, viene usata la media
	  campionaria.
	</para>
	<para>
	  Per l'equivalente multivariato, si veda <fncref
	  targ="lrcovar"/>.
	</para>
      </description>
    </function>

    <function name="Lsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">L</fnarg>
	<fnarg type="matrix">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Risolve l'equazione <math>Ax = b</math> per <math>x</math>,
	  dove <argname>L</argname> è il fattore di Cholesky
	  (triangolare bassa) della matrice definita positiva
	  <math>A</math>. Matrici <argname>L</argname> siffatte
	  vengono ottenute a partire da una matrice definita positiva
	  per mezzo della funzione <fncref targ="cholesky"/>.
	</para>
	<para>
	  Le due espressioni seguenti dovrebbero produrre lo stesso
	  risultato (salvo la precisione macchina); tuttavia, la
	  variante basata su <lit>Lsolve</lit> permette di
	  riutilizzare un fattore di Cholesky già calcolato e quindi
	  ottimizza i tempi di calcolo per una data matrice
	  <math>A</math> e diversi valori di <math>b</math>. Il
	  guadagno sarà tanto più grande quanto più alta è la
	  dimensione di <math>A</math>.
	</para>
	<code>
	  # variante 1
	  matrix L = cholesky(A)
	  matrix x = Lsolve(L, b)
	  # variante 2
	  matrix x = A \ b
	</code>
      </description>
    </function>

    <function name="mat2list" section="data-utils" output="list">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="string">prefisso</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione costruisce una lista di serie a partire
	  dalle colonne di una matrice. La matrice
	  <argname>X</argname> deve avere un numero di righe pari alla
	  lunghezza del dataset corrente, o al numero di osservazioni
	  nel sottocampione corrente.
	</para>
	<para>
	  I nomi delle serie risultanti sono assegnati nel modo
	  seguente. Se l'argomento opzionale
	  <argname>prefisso</argname> è specificato, la serie
	  create dalla colonna <math>i</math> di <argname>X</argname>
	  prenderà quel nome con l'aggiunta di <math>i</math>, come ad
	  esempio in <lit>pippo1</lit>, <lit>pippo2</lit> e così via.
	  Altrimenti, se <argname>X</argname> ha dei nomi di colonna (vedi
	  <fncref targ="cnameset"/>) vengono usati questi.  Infine,
	  se nessuna delle due condizioni è vera, i nomi sono
	  <lit>column1</lit>, <lit>column2</lit> e così via. Si noti
	  che questo può avere l'effetto di sovrascrivere serie
	  esistenti; per evitare che ciò accada si possono
	  nominare le colonne esplicitamente usando
	  <lit>cnameset</lit>, oppure usare l'argomento <argname>prefix</argname>.
	</para>
	<para>
	  Quello che segue è un piccolo esempio:
	</para>
	<code>
	  matrix X = mnormal($nobs, 8)
	  list L = mat2list(X, "xnorm")
	  # or alternativamente, se non serve salvare X separatamente
	  list L = mat2list(mnormal($nobs, 8), "xnorm")
	</code>
	<para>
	  Questo codice aggiungerà al dataset otto serie chiamate
	  <lit>xnorm1</lit>, <lit>xnorm2</lit> eccetera.
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="depends">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
        <fnarg optional="true" type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione ha due modalità principali più un caso particolare.
	</para>
	<para>
	  La prima modalità è relativa al caso in cui ci sia un solo
	  argomento, di tipo scalare, serie o matrice: il valore
	  restituito è uno scalare, il massimo valore valido
	  <quote>all'interno</quote> dell'argomento: se
	  <argname>x</argname> è una serie, il suo valore massimo
	  all'interno dell'intervallo di campionamento corrente, o se
	  <argname>x</argname> è una matrice, il suo elemento più
	  grande (i valori mancanti vengono ignorati). Il caso di un
	  argomento scalare è supportato per completezza; si ottiene
	  solo il suo valore.
	</para>
	<para>
	  La seconda modalità viene attivata se gli argomenti sono
	  due. Gli argomenti <argname>x</argname> e
	  <argname>y</argname> devono essere dello stesso tipo e
	  devono essere scalari, serie o matrici (e se sono matrici,
	  devono avere le stesse dimensioni). Il valore restituito è
	  un oggetto dello stesso tipo degli argomenti, contenente il
	  massimo o i massimi <quote>tra le due</quote>. Se gli argomenti
	  sono scalari, ritorna il maggiore dei due; se sono serie,
	  ritorna una serie contenente il maggiore dei valori delle
	  due serie a ogni osservazione nell'intervallo di
	  campionamento corrente; se sono matrici, ritorna una matrice
	  contenente il maggiore dei loro elementi in ogni riga e
	  colonna. In ambo i casi, se uno dei valori è mancante, il
	  risultato sarà anch'esso mancante.
	</para>
	<subhead>Il caso particolare</subhead>
	<para>
	  Il caso particolare si dà quando l'unico argomento è una
	  lista. Il valore restituito è una serie, contenente a ogni
	  osservazione nell'intervallo di campionamento corrente il
	  maggiore dei valori nella lista a quell'osservazione.
	</para>
	<para>
	  <seelist>
	    <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="scalar">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce i massimi per colonna di
	  <argname>X</argname>. Per colonne contenenti <lit>NA</lit>
	  il risultato è <lit>NA</lit> a meno che il parametro
	  opzionale <argname>skip_na</argname> sia diverso da zero,
	  nel qual caso il risultato è il massimo fra i valori validi.
	</para>
	<seelist>
	  <fncref targ="imaxc"/>
	  <fncref targ="maxr"/>
	  <fncref targ="minc"/>
	</seelist>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="scalar">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce i massimi per riga di <argname>X</argname>. Per
	  righe contenenti <lit>NA</lit> il risultato è <lit>NA</lit>
	  a meno che il parametro opzionale <argname>skip_na</argname>
	  sia diverso da zero, nel qual caso il risultato è il massimo
	  fra i valori validi.
	</para>
	<seelist>
	  <fncref targ="imaxr"/>
	  <fncref targ="maxc"/>
	  <fncref targ="minr"/>
	</seelist>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la matrice di correlazione di Pearson considerando ogni
	  colonna di <argname>X</argname> come una variabile.
	</para>
	<para>
	  <seelist>
	    <fncref targ="corr"/>
	    <fncref targ="cov"/>
	    <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int" optional="true">dfcorr</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la matrice di covarianza considerando ogni colonna di
	  <argname>X</argname> come una variabile. Il divisore è
	  <math>n</math> &minus; 1, dove <math>n</math> è il numero di
	  righe di <argname>X</argname>; se però l'argomento opzionale
	  <argname>dfcorr</argname> è 0, viene usato <math>n</math>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="corr"/>
	    <fncref targ="cov"/>
	    <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la matrice covariogramma corrispondente a una
	  matrice <by r="T" c="k"/> <argname>X</argname> (di solito
	  contenente regressori), un vettore (opzionale)
	  <math>T</math>-variato <argname>u</argname> (di solito
	  contenente i residui), un vettore (opzionale) di dimensione
	  (<math>p</math>+1) di pesi <argname>w</argname> e un
	  ordine di ritardo scalare <argname>p</argname> che deve
	  essere maggiore o uguale a 0.
	</para>
	<para context="tex">
	  La matrice prodotta è data da
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t' u_t
	  u_{t-j} X_{t-j})\]
	</para>
	<para context="notex">
	  La matrice prodotta è data dalla somma per <math>j</math> che va
	  da <math>-p</math> a <math>p</math> di <math>w(|j|) *
	  X(t)X(t-j)' * u(t)u(t-j)</math>, dove <math>X(t)'</math> è la
	  <math>t</math>-esima riga di <argname>X</argname>.
	</para>
	<para context="notex">
	  sum_{j=-p}^p sum_j w_{|j|} (X_t' u_t u_{t-j} X_{t-j})
	</para>
	<para>
	  Se <argname>u</argname> è specificato come <lit>null</lit>
	  il termine <math>u</math> è omesso, e se
	  <argname>w</argname> è <lit>null</lit> tutti i pesi
	  sono considerati pari a 1.0.
	</para>
	<para>
	  Ad esempio, il seguente frammento di codice
	</para>
	<code>
	  set seed 123

	  X    = mnormal(6,2)
	  Lag  = mlag(X,1)
	  Lead = mlag(X,-1)

	  print X Lag Lead

	  eval X'X
	  eval mcovg(X, , , 0)

	  eval X'(X + Lag + Lead)
	  eval mcovg(X, , , 1)
	</code>
	<para>
	  produce
	</para>
	<code>
	  X (6 x 2)

	  -0.76587      -1.0600
	  -0.43188      0.30687
	  -0.82656      0.40681
	  0.39246      0.75479
	  0.36875       2.5498
	  0.28855     -0.55251

	  Lag (6 x 2)

	  0.0000       0.0000
	  -0.76587      -1.0600
	  -0.43188      0.30687
	  -0.82656      0.40681
	  0.39246      0.75479
	  0.36875       2.5498

	  Lead (6 x 2)

	  -0.43188      0.30687
	  -0.82656      0.40681
	  0.39246      0.75479
	  0.36875       2.5498
	  0.28855     -0.55251
	  0.0000       0.0000

	  1.8295       1.4201
	  1.4201       8.7596

	  1.8295       1.4201
	  1.4201       8.7596

	  3.0585       2.5603
	  2.5603       10.004

	  3.0585       2.5603
	  2.5603       10.004
	</code>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> è una variabile, restituisce la
	  media campionaria (scalare) calcolata non considerando le
	  osservazioni mancanti (se presenti).
	</para>
	<para>
	  Se <argname>x</argname> è una lista, produce una variabile
	  <math>y</math> tale che <math>y</math><sub>t</sub> è la
	  media dei valori delle variabili nella lista per
	  l'osservazione <math>t</math>, o <lit>NA</lit> se ci sono
	  valori mancanti in <math>t</math>. Per default, la funzione
	  ritorna <lit>NA</lit> se ci si sono dei missing a
	  <math>t</math>, ma se si passa un valore non-zero come opzione
	  <argname>partial</argname> la statistica sarà calcolata sui
	  soli dati validi.
	</para>
	<para>
	  L'esempio seguente illustra la funzione:
	</para>
	<code>
	  open denmark.gdt
	  eval mean(LRM)
	  list L = dataset
	  eval mean(L)
	</code>
	<para>
	  La prima chiamata restituisce la media (scalare) della serie
	  <lit>LRM</lit>, mentre la seconda ritorna una serie.
	</para>
	<para>
	  <seelist>
            <fncref targ="median"/>
            <fncref targ="sum"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
            <fncref targ="sd"/>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le medie per colonna di <argname>X</argname>, senza
	  saltare osservazioni mancanti. Se viene
	  specificato un valore non-zero per il secondo argomento
	  (opzionale), i valori mancanti vengono ignorati, altrimenti
	  il ​​risultato è <lit>NA</lit> per tutte le colonne che
	  contengono valori mancanti.
	</para>
	<para>
	  Ad esempio, il codice seguente
	</para>
	<code>
		matrix m = mnormal(5, 2)
		m[1,2] = NA
		print m
		eval meanc(m)
	</code>
	<para>
	  produce questo output:
	</para>
	<code>
		? print m
		m (5 x 2)

	   -0.098299          nan
	      1.1829      -1.2817
	     0.46037     -0.92947
	      1.4896     -0.91970
	     0.91918      0.47748

		? eval meanc(m)
	     0.79075          nan
	</code>
	<para>
	  <seelist>
	    <fncref targ="meanr"/>
	    <fncref targ="sumc"/>
            <fncref targ="maxc"/>
            <fncref targ="minc"/>
            <fncref targ="sdc"/>
            <fncref targ="prodc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le medie per riga di <argname>X</argname>. Se viene
	  specificato un valore non-zero per il secondo argomento
	  (opzionale), i valori mancanti vengono ignorati, altrimenti
	  il ​​risultato è <lit>NA</lit> per tutte le righe che
	  contengono valori mancanti.
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> è una serie, calcola la mediana
	  delle osservazioni non mancanti.
	</para>
	<para>
	  Se <argname>x</argname> è una lista, ritorna una serie
	  <math>y</math> tale per cui <math>y</math><sub>t</sub> è la
	  mediana dei valori delle variabili nella lista
	  all'osservazione <math>t</math>, o <lit>NA</lit> se c'è
	  almeno un valore mancante all'osservazione <math>t</math>.
	</para>
	<para>
	  L'esempio seguente illustra l'usa della funzione
	</para>
	<code>
	  set verbose off
	  open denmark.gdt
	  eval median(LRM)
	  list L = dataset
	  series m = median(L)
	</code>
	<para>
	  La prima chiamata restituisce la mediana (scalare) della
	  serie <lit>LRM</lit>; la seconda ritorna una serie.
	</para>
	<para>
	  <seelist>
            <fncref targ="mean"/>
            <fncref targ="sum"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
            <fncref targ="sd"/>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola l'esponenziale della matrice <argname>A</argname>.Se
	  <argname>A</argname> è una matrice reale, la funzione
	  usa l'algoritmo 11.3.1 di <cite key="golub96">Golub and
	  Van Loan (1996)</cite>. Se invece è complessa, viene usato
	  un algoritmo basato sugli autovalori e la matrice deve
	  essere diagonalizzabile.
	</para>
	<para context="tex">
	  Esponenziale di una matrice,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\]
	  (La convergenza di questa serie è garantita.) Se
	  <argname>A</argname> è una matrice reale, la funzione
	  usa l'algoritmo 11.3.1 di <cite key="golub96">Golub and
	  Van Loan (1996)</cite>. Se invece è complessa, viene usato
	  un algoritmo basato sugli autovalori e la matrice deve
	  essere diagonalizzabile.
	</para>
	<para>
	  Vedi anche <fncref targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="mgradient" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Derivate analitiche per parametrizzazioni MIDAS. Sia
	  <math>k</math> il numero di elementi del vettore di
	  iperparametri <repl>theta</repl>.  Questa funzione produce
	  il gradiente dei pesi (calcolati da <fncref
	  targ="mweights"/>) rispetto agli elementi <repl>theta</repl>
	  in una matrice <by r="p" c="k"/>. Il primo argomento
	  rappresenta l'ordine dei ritardi desiderato e l'ultimo il
	  tipo di parameterizzazione. Vedi <lit>mweights</lit> per una
	  discussione dei valori accettabili per <repl>tipo</repl>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="midasmult"/>
	    <fncref targ="mlincomb"/>
            <fncref targ="mweights"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="midasmult" section="midas" output="matrix">
      <fnargs>
	<fnarg type="bundle">mod</fnarg>
	<fnarg type="bool">cumulate</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola i moltiplicatori MIDAS. L'argomento
	  <argname>mod</argname> dev'essere un bundle contenente un
	  modello MIDAS, così come quello disponibile sotto <fncref
	  targ="$model"/> dopo l'esecuzione del comando <cmdref
	  targ="midasreg"/>. La funzione resituisce una matrice con i
	  moltiplicatori MIDAS impliciti per la variabile
	  <argname>v</argname> nella prima colonna e i relativi errori
	  standard nella seconda. Se l'argomento
	  <argname>cumulate</argname> è non-zero, i moltiplicatori
	  vengono cumulati.
	</para>
	<para>
	  Si noti che la matrice risultato possiede automaticamente
	  delle etichette riga appropriate, cosicché la si può usare
	  come argomento del comando <cmdref targ="modprint"/>. Ad
	  esempio, il codice
	</para>
	<code>
	  open gdp_midas.gdt
	  list dIP = ld_indpro*
	  smpl 1985:1 ;
	  midasreg ld_qgdp 0 ; mds(dIP, 0, 6, 2)
	  matrix ip_m = midasmult($model, 0, 1)
	  modprint ip_m
	</code>
	<para>
	  produce il seguente risultato:
	</para>
	<code>
             coefficient   std. error      z       p-value
  ---------------------------------------------------------
  dIP_0      0.343146      0.0957752     3.583     0.0003   ***
  dIP_1      0.402547      0.0834904     4.821     1.43e-06 ***
  dIP_2      0.176437      0.0673776     2.619     0.0088   ***
  dIP_3      0.0601876     0.0621927     0.9678    0.3332
  dIP_4      0.0131263     0.0259137     0.5065    0.6125
  dIP_5      0.000965260   0.00346703    0.2784    0.7807
  dIP_6      0.00000       0.00000      NA        NA
	</code>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
            <fncref targ="mweights"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="depends">
      <fnargs>
        <fnarg type="anyfloat">x</fnarg>
        <fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
          Vedi la pagina di aiuto per <fncref targ="max"/>; questa
          funzione fa esattamente la stessa cosa, a parte che ritorna
          i minimi anziché i massimi.
	</para>
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="scalar">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola i minimi delle colonne di <argname>X</argname>. Per
	  colonne contenenti <lit>NA</lit> il risultato è <lit>NA</lit>
	  a meno che il parametro opzionale <argname>skip_na</argname>
	  sia diverso da zero, nel qual caso il risultato è il minimo
	  fra i valori validi.
	</para>
	  <seelist>
	    <fncref targ="iminc"/>
	    <fncref targ="maxc"/>
	    <fncref targ="minr"/>
	  </seelist>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="scalar">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola i minimi delle righe di <argname>X</argname>. Per
	  righe contenenti <lit>NA</lit> il risultato è <lit>NA</lit>
	  a meno che il parametro opzionale <argname>skip_na</argname>
	  sia diverso da zero, nel qual caso il risultato è il minimo
	  fra i valori validi.
	</para>
	  <seelist>
	    <fncref targ="iminr"/>
	    <fncref targ="maxr"/>
	    <fncref targ="minc"/>
	  </seelist>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Crea una variabile binaria uguale a 1 se
	  <argname>x</argname> è <lit>NA</lit>. Se
	  <argname>x</argname> è una serie, il confronto viene
	  effettuato elemento per elemento; se <argname>x</argname> è
	  una lista di variabili, il risultato è una serie con
	  elementi pari a 1 per le osservazioni per le quali almeno
	  una delle variabili incluse nella lista ha valore mancante,
	  e 0 altrimenti. Ad esempio, il codice
	</para>
	<code>
		nulldata 3
		series x = normal()
		x[2] = NA
		series x_ismiss = missing(x)
		print x x_ismiss --byobs
	</code>
	<para>
	  imputa un valore mancante alla seconda osservazione di
	  <argname>x</argname> e crea una nuova dummy
	  <argname>y</argname> che identifica il dato mancante
	</para>
	<code>
		             y     y_ismiss

		1    -1.551247            0
		2                         1
		3    -2.244616            0
	</code>
	<para>
	  <seelist>
	    <fncref targ="misszero"/>
	    <fncref targ="ok"/>
	    <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converte gli <lit>NA</lit> in zeri. Se <argname>x</argname>
	  è una serie la conversione è effettuata elemento per
	  elemento. Ad esempio, il codice seguente
	</para>
	<code>
		nulldata 3
		series x = normal()
		x[2] = NA
		y = misszero(x)
		print x y --byobs
	</code>
	<para>
	 imputa un valore mancante alla seconda osservazione di
	 <argname>x</argname> e crea una nuova serie
	 <argname>y</argname> nella quale il dato mancante è
	 rimpiazzato con zero:
	</para>
	<code>
	             x            y

		1    0.7355250    0.7355250
		2                     0.000
		3   -0.2465936   -0.2465936
	</code>
	<para>
	  <seelist>
	    <fncref targ="missing"/>
	    <fncref targ="ok"/>
	    <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Sposta in alto o in basso le righe di <argname>X</argname>. Se
	  <argname>p</argname> è uno scalare positivo, restituisce una matrice
	  nella quale le colonne di <argname>X</argname> sono spostate verso
	  il basso di <argname>p</argname> righe e le prime
	  <argname>p</argname> righe sono riempite con il valore
	  <argname>m</argname>. Se <argname>p</argname> è un numero negativo,
	  <argname>X</argname> è spostata verso l'alto e le ultime righe
	  sono riempite con il valore <argname>m</argname>. Se
	  <argname>m</argname> viene omesso, al suo posto si utilizza un
	  valore nullo.
	</para>
	<para context="tex">
	  Sposta in alto o in basso le righe di <argname>X</argname>. Se
	  $p$ è uno scalare positivo, il risultato è una matrice $Y$ di elementi
	  $Y_{i,j} = X_{i-p,j}$ per $i \ge p$ e zero altrimenti. In
	  altre parole, le colonne di
	  <argname>X</argname> vengono spostate verso il basso di
	  <argname>p</argname> righe e le prime <argname>p</argname>
	  righe sono riempite con il valore <argname>m</argname>. Se
	  <argname>p</argname> è un numero negativo,
	  <argname>X</argname> viene spostata verso l'alto e le ultime righe
	  sono riempite con il valore <argname>m</argname>. Se
	  <argname>m</argname> è omesso, al suo posto si utilizza
	  lo zero.
	</para>
	<para>
	  Se <argname>p</argname> è un vettore, l'operazione
	  precedente è svolta per ciascun elemento di
	  <argname>p</argname>, unendo le matrici così ottenute in
	  senso orizzontale. Il codice seguente illustra questa forma
	  di uso, con un input <argname>X</argname> di due colonne e
	  <argname>p</argname> che richiede i ritardi 1 e
	  2. Contrariamente al default, i valori mancanti sono
	  impostati a NA anziché 0.
	</para>
	<code>
	matrix X = mnormal(5, 2)
	print X
	eval mlag(X, {1, 2}, NA)
	</code>
	<code>
	m (5 x 2)

      1.5953    -0.070740
    -0.52713     -0.47669
     -2.2056     -0.28112
     0.97753       1.4280
     0.49654      0.18532

         nan          nan          nan          nan
      1.5953    -0.070740          nan          nan
    -0.52713     -0.47669       1.5953    -0.070740
     -2.2056     -0.28112     -0.52713     -0.47669
     0.97753       1.4280      -2.2056     -0.28112
	</code>
	<para>
	  Vedi anche <fncref targ="lags"/>.
	</para>
      </description>
    </function>

    <function name="mlincomb" section="midas" output="series">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è pensta primariamente per la scrittura di
	  modelli MIDAS, e combina in una sola funzione <fncref
	  targ="lincomb"/> e <fncref targ="mweights"/>.  Data una
	  lista <repl>hfvars</repl>, costruisce una serie con la somma
	  ponderata degli elementi della lista, dove i pesi sono
	  basati sul vettore di iperparametri <repl>theta</repl>, per
	  una paramterizzazione dettata dall'argomento
	  <repl>tipo</repl>: si veda <lit>mweights</lit> per maggiori
	  dettagli. Si noti che una lista con le caratteristiche
	  necessarie ad essere usate come primo argomento viene, per
	  solito, creata usando la funzione <fncref targ="hflags"/>.
	</para>
	<para>
	  Tanto per essere espliciti, la chiamata
	</para>
	<code>
	  series s = mlincomb(hfvars, theta, 2)
	</code>
	<para>
	  è equivalente a
	</para>
	<code>
	  matrix w = mweights(nelem(hfvars), theta, 2)
	  series s = lincomb(hfvars, w)
	</code>
	<para>
	  ma l'uso di <lit>mlincomb</lit> rende il codice più snello e
	  marginalmente più efficiente.
	</para>
      </description>
    </function>

    <function name="mlog" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola il logaritmo matriciale di <argname>A</argname>.
	  L'algoritmo utilizzato si basa sulla decomposizione spettrale,
	  la quale richiede che<argname>A</argname>sia
	  diagonalizzabile. Si veda anche <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice di <argname>r</argname> righe e
	  <argname>c</argname> colonne, contenente numeri pseudocasuali
	  generati da una normale standardizzata.
	  <seelist>
	    <fncref targ="normal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice <by r="k" c="n"/> di stime di
	  parametri ottenute con la regressione dei minimi quadrati
	  ordinari della matrice <by r="T" c="n"/>
	  <argname>Y</argname> sulla matrice <by r="T" c="k"/>
	  <argname>X</argname>.
	</para>
	<para>
	  Se il terzo argomento non è <lit>null</lit>, la matrice <by
	  r="T" c="n"/> <argname>U</argname> contiene i residui. Se
	  l'ultimo argomento viene indicato e non è <lit>null</lit>,
	  la matrice <by r="k" c="k"/> <argname>V</argname> conterrà
	  (a) la matrice di covarianza delle stime dei parametri, se
	  <argname>Y</argname> ha una sola colonna, o (b)
	  <math>X'X</math><sup>-1</sup> se <argname>Y</argname> ha più
	  colonne.
	</para>
	<para>
	  Di default, le stime sono ottenute usando una scomposizione
	  di Cholesky, ricorrendo alla scomposizione QR se le colonne
	  di <argname>X</argname> sono quasi collineari.  E' possibile
	  imporre l'uso della scomposizione SVD usando il comando
	  <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mpols"/>
	    <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">mese</fnarg>
	<fnarg type="scalar-or-series">anno</fnarg>
	<fnarg type="int">gioset</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di giorni (rilevanti) in un dato mese
	  e anno secondo il calendario gregoriano prolettico;
	  l'argomento <argname>gioset</argname> può essere 5, 6 o 7, e
	  indica il numero di giorni nella settimana da contare (il 6
	  omette le domeniche, il 5 anche i sabati).
	</para>
	<para>
	  la funzione ritorna uno scalare se gli argomenti
	  <argname>mese</argname> e <argname>anno</argname> sono
	  entrambi scalari;altrimenti, ritorna una serie.
	</para>
	<para>
	  Ad esempio: se si ha un dataset mensile aperto, l'istruzione
	</para>
	<code>
	  series wd = monthlen($obsminor, $obsmajor, 5)
	</code>
	<para>
	  produrrà una serie contenente il numero di giorni lavorativi
	  per ciascun mese nel campione.
	</para>
      </description>
    </function>

    <function name="movavg" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
	<fnarg type="scalar" optional="true">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  A seconda del parametro <argname>p</argname>, calcola una media
	  mobile semplice o con pesi esponenziali della variabile input
	  <argname>x</argname>.
	</para>
	<para context="notex">
	  Se <argname>p</argname> &gt; 1, viene calcolata una media mobile
	  semplice a <argname>p</argname> termini; in altre parole, la
	  media aritmetica da x(t) a x(t+p-1). Se viene indicato un valore
	  non nullo per il parametro opzionale <argname>control</argname>
	  la media mobile è centrata, in caso contrario è
	  <quote>retrospettiva</quote> (usa solo l'osservazione corrente e
	  quelle passate, ma non quelle future). L'argomento opzionale
	  <argname>y0</argname> viene ignorato.
	</para>
	<para context="tex">
	  Se $p&gt;1$, viene calcolata una media mobile semplice a
	  <argname>p</argname> termini, ossia $\frac{1}{p}
	  \sum_{i=0}^{p-1} x_{t-i}$. Se viene indicato un valore non nullo
	  per il parametro opzionale <argname>control</argname> la media
	  mobile è centrata, altrimenti è <quote>retrospettiva</quote>
	  (usa solo l'osservazione corrente e quelle passate, ma non
	  quelle future). L'argomento opzionale <argname>y0</argname>
	  viene ignorato.
	</para>
	<para context="notex">
	  Se <argname>p</argname> è una frazione positiva viene
	  calcolata una media mobile esponenziale:
	</para>
	<para context="notex">
	  <math>y(t) = p*x(t) + (1-p)*y(t-1)</math>
	</para>
	<para context="notex">
	  Di default la variabile risultato, <math>y</math>, è
	  inizializzata usando il primo valore valido di
	  <argname>x</argname>, ma il parametro <argname>control</argname>
	  può essere usato per specificare il numero di osservazioni
	  iniziali che dovrebbero essere incluse nella media usata per
	  calcolare <math>y(0)</math>.  Un valore nullo di
	  <argname>control</argname> indica che dovrebbero essere usate
	  tutte le osservazioni. In alternativa, si può specificare un
	  valore iniziale con l'argomento opzionale <argname>y0</argname>;
	  in tal caso, l'argomento <argname>control</argname> viene
	  ignorato.
	</para>
	<para context="tex">
	  Se $0 &lt; p &lt; 1$, viene calcolata una media mobile
	  esponenziale: \[y_t = p x_t + (1-p)y_{t-1}\] (vedi <cite
	  key="roberts59">Roberts, 1959</cite>). Di default, la variabile
	  calcolata, $y$, è inizializzata usando il primo valore valido di
	  $x$, ma il parametro <argname>control</argname> può essere usato
	  per specificare il numero di osservazioni iniziali che
	  dovrebbero essere incluse nella media usata per calcolare $y_0$.
	  Un valore nullo di <argname>control</argname> indica che devono
	  essere usate tutte le osservazioni. In alternativa, si può
	  specificare un valore iniziale con l'argomento opzionale
	  <argname>y0</argname>; in tal caso, l'argomento
	  <argname>control</argname> viene ignorato.
	</para>
      </description>
    </function>

    <function name="mpiallred" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;object</fnarg>
	<fnarg type="string">op</fnarg>
      </fnargs>
      <description>
	<para>
	  Disponibile solo se gretl è in modalità MPI (si veda <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Deve essere chiamata da
	  tutti i processi. Questa funzione funziona come <fncref
	  targ="mpireduce"/> ad eccezione del fatto che tutti i
	  processi, non solamente il processo root, ottengono una
	  copia dell'oggetto <quote>ridotto</quote> al posto
	  dell'originale. E' quindi equivalente a <lit>mpireduce</lit>
	  seguito da <fncref targ="mpibcast"/>, ma più efficiente.
	</para>
      </description>
    </function>

    <function name="mpibarrier" section="mpi" output="int">
      <description>
	<para>
	  Disponibile solo se gretl è in modalità MPI (si veda<mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Non richiede
	  argomenti. Rafforza la sincronizzazione dei processi MPI: nessun
	  processo può superare la barriera se non è stata raggiunta
	  da tutti gli altri.
	</para>
	<code>
	  # nessuno supera questo punto finchè tutti non sono qui
	  mpibarrier()
	</code>
      </description>
    </function>

    <function name="mpibcast" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;object</fnarg>
	<fnarg type="int" optional="true">root</fnarg>
      </fnargs>
      <description>
	<para>
	  Disponibile solo se gretl è in modalità MPI (si veda<mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Deve essere chiamata da
	  tutti i processi. Trasmette l'argomento
	  <argname>object</argname>, che deve essere dato in forma di
	  puntatore, a tutti i processi. L'oggetto in questione
	  (matrice, bundle, scalare, array, stringa o lista) deve
	  essere dichiarato in tutti i processi precedentemente alla
	  trasmissione. Nessun processo può proseguire oltre una
	  chiamata a <lit>mpibcast</lit>finché tutti i processi non
	  l'abbiano eseguita correttamente.
	</para>
	<para>
	  Di default <quote>root</quote>, la sorgente della trasmissione,
	  è il processo MPI con rango 0, ma questo può essere modificato
	  tramite il secondo argomento (opzionale), il quale deve essere un intero
	  compreso tra 0 e il numero dei processi MPI meno 1.
	</para>
	<para>
	  Di seguito un semplice esempio. Se la funzione svolge il suo
	  compito con successo, ogni processo avrà una copia della
	  matrice<lit>X</lit> definita dal processo a rango 0.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	  X = mnormal(T, k)
	  endif
	  mpibcast(&amp;X)
	</code>
      </description>
    </function>

    <function name="mpirecv" section="mpi" output="object">
      <fnargs>
	<fnarg type="int">src</fnarg>
      </fnargs>
      <description>
	<para>
	  Disponibile solo se gretl è in modalità MPI (si veda<mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Si veda <fncref
	  targ="mpisend"/>, con la quale <lit>mpirecv</lit> deve in ogni caso
	  essere accoppiata, per una spiegazione. L'argomento <argname>src</argname>
	  specifica il rango del processo dal quale
	  l'oggetto deve essere ricevuto, all'interno dell'intervallo che va
	  da 0 al numero dei processi MPI meno 1.
	</para>
      </description>
    </function>

    <function name="mpireduce" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;object</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">root</fnarg>
      </fnargs>
      <description>
	<para>
	  Disponibile solo se gretl è in modalità MPI (si veda<mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Deve essere chiamata da
	  tutti i processi. questa funzione raccoglie oggetti (solo scalari o
	  matrici) dal nome specifico,dati in forma di puntatore,
	  da tutti i processi e li <quote>riduce</quote> in un singolo
	  oggetto al nodo root.
	</para>
	<para>
	  L'argomento <lit>op</lit> specifica l'operazione o metodo
	  di riduzione. I metodi supportati per gli scalari sono
	  <lit>sum</lit>, <lit>prod</lit> (prodotto), <lit>max</lit>
	  e <lit>min</lit>. Per le matrici i metodi sono
	  <lit>sum</lit>, <lit>prod</lit> (prodotto di Hadamard),
	  <lit>hcat</lit> (concatenazione orizzontale) e
	  <lit>vcat</lit> (concatenazione verticale).
	</para>
	<para>
	  Di default <quote>root</quote>, il destinatario della riduzione,
	  è il processo MPI con rango 0, ma questo può essere modificato
	  tramite il terzo argomento (opzionale), il quale deve essere un intero
	  compreso tra 0 e il numero dei processi MPI meno 1.
	</para>
	<para>
	  Di seguito un esempio. Se la funzione svolge il suo compito con successo,
	  il processo root avrà una matrice <lit>X</lit> che è la somma
	  delle matrici	<lit>X</lit> di tutti i processi.
	</para>
	<code>
	  matrix X
	  X = mnormal(T, k)
	  mpireduce(&amp;X, sum)
	</code>
      </description>
    </function>

    <function name="mpiscatter" section="mpi" output="int">
      <fnargs>
	<fnarg type="matrixref">&amp;M</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">root</fnarg>
      </fnargs>
      <description>
	<para>
	  Disponibile solo quando gretl è in modalità MPI (si veda <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Deve essere chiamata da tutti
	  i processi. Questa funzione distribuisce parti di una matrice nel
	  processo root di tutti i processi. La matrice deve
	  essere dichiarata in tutti i processi prima della chiamata di
	  <lit>mpiscatter</lit>, e deve essere data in forma di puntatore.
	</para>
	<para>
	  L'argomento <lit>op</lit> deve essere <lit>byrows</lit>
	  oppure <lit>bycols</lit>. Sia <math>q</math> il quoziente tra
	  il numero di righe della matrice da dividere e il
	  numero di processi. Nel caso <lit>byrows</lit> la root
	  mandale prime <math>q</math> righe al processo 0, le successive
	  <math>q</math> al processo 1, e così via. Se c'è un
	  resto alla divisione delle righe, esso è assegnato all'ultimo
	  segmento. Il caso <lit>bycols</lit> è analogo ma
	  la matrice si divide per colonne.
	</para>
	<para>
	  Di seguito un esempio. Se ci sono 4 processi, ognuno
	  (root incluso) riceverà una parte <by r="2500" c="10"/>
	  dell'originale <lit>X</lit> così come era definita nel
	  processo root. Se si vuole preservare l'intera matrice nel processo root
	  è necessario crearne una copia prima d chiamare
	  <lit>mpiscatter</lit>.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	  X = mnormal(10000, 10)
	  endif
	  mpiscatter(&amp;X, byrows)
	</code>
      </description>
    </function>

    <function name="mpisend" section="mpi" output="int">
      <fnargs>
	<fnarg type="object">object</fnarg>
	<fnarg type="int">dest</fnarg>
      </fnargs>
      <description>
	<para>
	  Disponibile solo quando gretl è in modalità MPI (si veda <mnu
	  targ="gretlMPI">gretl + MPI</mnu>). Manda l'oggetto nominato
	  (che deve essere una matrice, bundle, vettore o scalare) dal processo
	  corrente a quello identificato dall'intero
	  <argname>dest</argname> (da 0 al numero di processi MPI
	  meno 1).
	</para>
	<para>
	  L chiamata di questa funzione deve essere sempre accoppiata con una chiamata a
	  <fncref targ="mpirecv"/> nel processo <argname>dest</argname>,
	  come nel seguente esempio che manda una matrice dal rango2 al rango 3.
	</para>
	<code>
	  if $mpirank == 2
	  matrix C = cholesky(A)
	  mpisend(C, 3)
	  elif $mpirank == 3
	  matrix C = mpirecv(2)
	  endif
	</code>
      </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funziona esattamente come <fncref targ="mols"/>, tranne che i calcoli
	  sono effettuati in precisione multipla usando la libreria GMP.
	</para>
	<para>
	  Di default GMP usa 256 bit per ogni numero a virgola mobile, ma
	  questa convenzione può essere modificata usando la variabile d'ambiente
	  <lit>GRETL_MP_BITS</lit>, &eg; <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-matrix">p1</fnarg>
	<fnarg type="scalar-or-matrix" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">righe</fnarg>
	<fnarg type="int">colonne</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
        <example>matrix D = mrandgen(dir, {0.5,1,2,4}, 30)</example>
      </examples>
      <description>
	<para>
	  Con una eccezione (vedi sotto), funziona come <fncref
	  targ="randgen"/> tranne che il valore calcolato è una
	  matrice anziché una variabile. Gli argomenti iniziali di
	  questa funzione (il cui numero dipende dalla distribuzione
	  specificata) sono come quelli descritti per
	  <lit>randgen</lit>, ma devono essere seguiti da due interi
	  per specificare il numero di righe (<argname>r</argname>) e
	  colonne (<argname>c</argname>) della matrice casuale
	  desiderata. Se <argname>p1</argname> o <argname>p2</argname>
	  sono matrici, devono avere un numero di elementi pari al
	  prodotto di <argname>righe</argname> per
	  <argname>colonne</argname>.
	</para>
	<para>
	  L'unica eccezione a quanto sopra è la distribuzione di
	  Dirichlet; poiché questa è una distribuzione multivariata,
	  invocando <lit>mrandgen</lit> con <quote>dir</quote> come primo
	  parametro si attiva una sintassi speciale: l'argomento 2
	  deve essere un vettore positivo di <math>k</math> elementi
	  <lit>a</lit> e l'argomento 3 deve essere uno scalare
	  <lit>r</lit>. La funzione restituirà una matrice <by r="r"
	  c="k"/> in cui ogni riga è un'estrazione indipendente da una
	  distribuzione di Dirichlet con parametro <lit>a</lit>.
	</para>
	<para>
	  Il primo esempio fornito sopra calcola un vettore colonna
	  casuale uniforme di 50 elementi, mentre il secondo specifica
	  una matrice casuale <by r="20" c="20"/> con elementi tratti
	  dalla distribuzione <math>t</math> con 14 gradi di
	  libertà. Il terzo restituisce una matrice <by r="30" c="4"/>
	  in cui ogni riga è estratta dalla distribuzione di Dirichlet
	  specificata.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mnormal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="string">nomefile</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Legge una matrice da un file di nome
	  <argname>nomefile</argname>.  Se il nome di file non
	  contiene un percorso completo, il file verrà cercato in
	  varie sottodirectory <quote>probabili</quote> a partire dal
	  valore corrente di <cmdref targ="workdir"/>.  Se però viene
	  indicato un valore non nullo per l'argomento opzionale
	  <argname>import</argname>, la ricerca del file di input
	  avviene all'interno della directory <quote>dot</quote>
	  dell'utente. Questa funzione è pensata per essere usata in
	  combinazione con le funzioni che esportano matrici
	  illustrate nel contesto del comando <cmdref
	  targ="foreign"/>.  In questo caso l'argomento
	  <argname>fname</argname> dovrebbe essere semplicemente un
	  nome di file, senza indicazione del percorso.
	</para>

	<para>Al momento, sono riconosciuti quattro formati di file:
	</para>

	<subhead>Formato di testo nativo</subhead>
	<para>
	  Questi file sono identificati dall'estensione
	  <quote><lit>.mat</lit></quote> e sono compatibili col
	  formato di file matrice usato da Ox.  Se il file ha
	  estensione <quote><lit>.gz</lit></quote>, si assume che il
	  file sia stato creato con compressione gzip.

	  Si assume che il file contenga testo, conforme alla seguenti
	  specifiche:
	</para>
	<ilist>
	  <li>
	    <para>
	      Il file in questione può iniziare con un numero
	      di commenti qualsiasi, definiti come linee che iniziano
	      con il carattere <lit>#</lit>; queste linee sono ignorate.
	    </para>
	  </li>
	  <li>
	    <para>
	      La prima riga non commentata deve contenere due interi,
	      separati da uno spazio o un tabulatore, che indicano
	      rispettivamente il numero di righe e di colonne.
	    </para>
	  </li>
	  <li>
	    <para>
	      Le colonne sono separate da tabulazioni.
	    </para>
	  </li>
	  <li>
	    <para>
	      Il separatore decimale deve essere il punto,
	      <quote><lit>.</lit></quote>.
	    </para>
	  </li>
	</ilist>

	<subhead>File binari</subhead>
	<para>
	  File con l'estensione <quote><lit>.bin</lit></quote> sono
	  trattati come file in formato binario, eentualmente
	  compressi se hanno anche il suffisso
	  <quote><lit>.gz</lit></quote>.  I primi 19 byte contengono
	  la stringa <lit>gretl_binary_matrix</lit>, i successivi 8
	  contengono due interi da 32 bit coi numeri di righe e
	  colonne, e il resto contiene gli elementi della matrice in
	  numeri in doppia precisione (little-endian, ordine per
	  colonna). Se gretl viene eseguito su un sistema operativo
	  big-endian, la conversione viene effettuata automaticamente
	  in lettura e scrittura.
	</para>

	<subhead>File di testo delimitati</subhead>
	<para>
	  Se il file ha estensione <quote><lit>.csv</lit></quote>, la
	  funzione opera in modo completamente diverso, e più
	  flessibile. In questo caso, i dati <emphasis>non</emphasis>
	  devono essere preceduti dalla linea contenete i numeri di
	  righe e di colonne. Gretl cercherà di capire quale
	  delimitatore viene usato (virgola, punto e virgola o spazio
	  --- mamma mia, sembra Totò e Peppino) con regole euristiche
	  e cercherà di importare la matrice usando la virgola come
	  separatore decimale se necessario. Si noti che il
	  delimitatore non può essere la tabulazione, per evitare
	  confusioni col formato <quote>nativo</quote> di gretl.
	</para>

	<subhead>Dataset in formato gretl</subhead>
	<para>
	  File con estensione <quote><lit>.gdt</lit></quote> o
	  <quote><lit>.gdtb</lit></quote> vengono trattati come
	  dataset in formato gretl, così come creati dal comando
	  <cmdref targ="store"/>. In tal caso, la matrice restituita
	  dalla funzione contiene i valori numerici delle serie del
	  dataset, una per colonna.  Si noti che serie con valori
	  stringa non sono lette come tali, ma la matrice conterrà
	  solo le corrispondenti codifiche numeriche.
	</para>

	<para>
	  <seelist>
	    <fncref targ="bread"/>
	    <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">bycol</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice in cui le righe di
	  <argname>X</argname> (o le colonne se l'argomento
	  <argname>bool</argname> è non-zero) sono in ordine inverso.
	</para>
      </description>
    </function>

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Minimi quadrati vincolati: calcola una matrice <by r="k" c="n"/>
	  di stime dei parametri ottenute regredendo con il metodo dei
	  minimi quadrati
	  la matrice <by r="T" c="n"/> <argname>Y</argname> sulla matrice
	  <by r="T" c="k"/> m<argname>X</argname> sotto i vincoli lineari
	  <math>RB</math> = <math>q</math>, dove
	  <math>B</math> indica il vettore dei coefficienti incolonnati.
	  <argname>R</argname> deve avere <math>k</math> *
	  <math>n</math> colonne; ogni riga della matrice rappresenta
	  un vincolo lineare. Il numero di righe di <argname>q</argname>
	  deve essere pari al numero di righe di <argname>R</argname>.
	</para>
	<para>
	  Se il quinto argomento non è <lit>null</lit>, la matrice <by r="T"
	  c="n"/> <argname>U</argname> contiene i residui. Se viene indicato
	  l'ultimo argomento e non è
	  <lit>null</lit>, la matrice <by r="k" c="k"/>
	  <argname>V</argname> contiene la versione vincolata della matrice
	  <math>X'X</math><sup>-1</sup>. La matrice di varianza delle stime
	  dell'equazione <math>i</math> può essere costruita moltiplicando
	  la sottomatrice opportuna di
	  <argname>V</argname> per una stima della varianza dell'errore
	  di quell'equazione.
	</para>
      </description>
    </function>

    <function name="mshape" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Riorganizza gli elementi di <argname>X</argname> in una matrice con
	  <argname>r</argname> righe e <argname>c</argname> colonne.
	  Gli elementi vengono
	  letti da <argname>X</argname> e inseriti nel risultato della funzione
	  in ordine di colonna. Se <argname>X</argname> contiene meno di
	  <math>k</math> = <math>rc</math> elementi, questi ultimi vengono
	  ripetuti ciclicamente; in caso contrario, se
	  <argname>X</argname> ha più elementi ne vengono usati solo i
	  primi <math>k</math>.
	</para>
	<para>
	  Se l'argomento <argname>c</argname> viene omesso, il default
	  è 1 se <argname>X</argname> è <by r="1" c="1"/>; in caso
	  contrario, <argname>c</argname> sarà uguale a
	  <math>N</math>/<argname>r</argname>, dove <math>N</math> è
	  il numero totale di elementi in <argname>X</argname>. In
	  quest'ultimo caso, la funzione produce un errore se
	  <math>N</math> non è un multiplo intero di
	  <argname>r</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="cols"/>
	    <fncref targ="rows"/>
	    <fncref targ="unvech"/>
	    <fncref targ="vec"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice nella quale le righe di
	  <argname>X</argname> sono riordinate per valore crescente degli
	  elementi nella colonna <argname>j</argname>. Il riordinamento è
	  stabile: le righe che contengono lo stesso valore nella colonna
	  <argname>j</argname> mantengono l'ordinamento relativo
	  preesistente.
	</para>
      </description>
    </function>

    <function name="msplitby" section="matrix" output="matrices">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-matrix">v</fnarg>
	<fnarg type="bool">bycol</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna un array di matrici, il risultato della divisione,
	  orizzontale o verticale, di <argname>X</argname> sotto il
	  controllo degli argomenti <argname>v</argname> e
	  <argname>bycol</argname>. Se quest'ultimo è non-zero, la
	  matrice sarà divisa per colonne; altrimenti, per righe.
	</para>
	<para>
	  L'argomento <argname>v</argname> deve essere un vettore o
	  uno scalare.
	</para>
	<ilist>
	  <li>
	    <para>
	      Nel primo caso, il vettore deve essere di lunghezza
	      uguale alla dimensione rilevante (righe o colonne) di
	      <argname>X</argname>, e dovrà contenere valori interi
	      positivi, Il massimo indica il numero di elementi
	      dell'array risultato. Ogni elemento di
	      <argname>v</argname> indica l'indice della matrice al
	      quale la corrispondente riga di <argname>X</argname>
	      dovrà essere assegnata.
	    </para>
	  </li>
	  <li>
	    <para>
	      Nel secondo caso, in cui <argname>v</argname> è uno
	      scalare, la dimensione rilevante (righe o colonne) di
	      deve essere un multiplo esatto di <argname>v</argname>.
	      <argname>X</argname> verrà divisa in blocchi di
	      <argname>v</argname> righe/colonne (a seconda del valore
	      di <argname>bycol</argname>).
	    </para>
	  </li>
	</ilist>
	<para>
	  Nel seguente esempio si divide una matrice <by r="4" c="3"/>
	  in tre matrici: le prime due righe sono assegnate alla prima
	  matrice; la seconda matrice è lasciata vuota; la terza
	  matrice e la quarta ricevono riga 3 e 4 rispettivamente
	  di <argname>X</argname>.
	</para>
	<code>
	  matrix X = {1,2,3; 4,5,6; 7,8,9; 10,11,12}
	  matrices M = msplitby(X, {1,1,3,4})
	  print M
	</code>
	<para>
	  L'output recita:
	</para>
	<code>
	  Vettore di marici, lunghezza 3
	  [1] 2 x 3
	  [2] null
	  [3] 1 x 3
	  [4] 1 x 3
	</code>
	<para>
	  In questo esempio, invece, la matrice <argname>X</argname>
	  è divisa in blocchi di dimensione uguale:
	</para>
	<code>
	  matrix X = {1,2,3; 4,5,6; 7,8,9; 10,11,12}
	  matrices MM = msplitby(X, 2)
	  print MM[1]
	  print MM[2]
	</code>
	<para>
	  che produce
	</para>
	<code>
	  ? print MM[1]
	  1   2   3
	  4   5   6

	  ? print MM[2]
	  7    8    9
	  10   11   12
	</code>
	<para>
	  Si veda <fncref targ="flatten"/> per l'operazione inversa.
	</para>
      </description>
    </function>


    <function name="muniform" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice di <argname>r</argname> righe e
	  <argname>c</argname> colonne contenente numeri pseudocasuali
	  estratti da una uniforme (0,1). Nota: per generare uno
	  scalare pseudocasuale uniforme è consigliabile usare la
	  funzione <fncref targ="randgen1"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mnormal"/>
	    <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mweights" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Produce un vettore a <math>p</math> elementi di pesi MIDAS,
	  da applicare a <math>p</math> ritardi di una serie ad alta
	  frequenza, partendo dal vettore di iperparametri
	  <repl>theta</repl>.
	</para>
	<para>
	  L'argomento <repl>tipo</repl> identifica il tipo di
	  parameterizzazione, che a sua volta determina
	  <math>k</math>, il numero di elementi di <repl>theta</repl>:
	  1 = Almon esponenziale normalizzata (<math>k</math> almeno 1,
	  di solito 2); 2 = beta normalizzata con zero in fondo
	  (<math>k</math> = 2); 3 = beta normalizzata senza zero in
	  fondo  (<math>k</math> = 3); e 4 = polinomio di Almon
	  (<math>k</math> almeno 1). Si noti che per la beta
	  normalizzata i primi due elementi di <repl>theta</repl>
	  devono essere positivi.
	</para>
	<para>
	  Il parametro <repl>tipo</repl> può essere fornito sotto
	  forma di un intero, come mostrato sopra, oppure come
	  stringa, come segue: <lit>nealmon</lit>, <lit>beta0</lit>,
	  <lit>betan</lit>, <lit>almonp</lit>. Se si opta per una
	  stringa, essa dev'essere racchiusa fra virgolette. Ad
	  esempio, le due formulazioni seguenti sono equivalenti:
	</para>
	<code>
	  W = mweights(8, theta, 2)
	  W = mweights(8, theta, "beta0")
	</code>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
	    <fncref targ="midasmult"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Copia la matrice <argname>X</argname> in un file di nome
	  <argname>fname</argname>, di regola un file di testo. Nella
	  prima riga il file contiene due interi, separati da un
	  tabulatore, corrispondenti ai numeri di righe e di colonne;
	  nelle linee seguenti sono indicati gli elementi della
	  matrice in notazione scientifica, separati da tabulatori
	  (una riga per ciascuna linea). Al fine di evitare confusione
	  in lettura, è consigliabile dare al file il suffisso
	  <quote><lit>.mat</lit></quote>. Per formati alternativi,
	  vedi più avanti.
	</para>
	<para>
	  Se il file <argname>fname</argname> esiste già, verrà
	  sovrascritto.  Il valore restituito è 0 in caso l'esecuzione
	  venga portata a termine correttamente; altrimenti, per
	  esempio quando il file non può essere sovrascritto, verrà
	  generato un errore.
	</para>
	<para>
	  Il file verrà scritto nella directory corrispondente a <cmdref
	  targ="workdir"/>, a meno che la stringa <repl>filename</repl>
	  non contenga un percorso completo.  Se viene indicato un valore
	  non nullo per l'argomento <argname>export</argname>, il file di
	  output sarà salvato nella directory <quote>dot</quote>
	  dell'utente, e ad esso per default sarà possibile accedere
	  usando le funzioni che caricano matrici descritte nell'ambito
	  del comando <cmdref targ="foreign"/>. In questo caso è
	  necessario indicare come secondo argomento il nome del file
	  privo del percorso.
	</para>
	<para>
	  Le matrici memorizzate usando il comando <lit>mwrite</lit>
	  possono essere facilmente lette da altri programmi; v.
	  <guideref targ="chap:matrices"/> per ulteriori dettagli.
	</para>
	<para>
	  Sono disponibili due estensioni (mutuamente esclusive) del
	  comportamento base di questa funzione.
	</para>
	<ilist>
	  <li>
	    <para>
	      Se <argname>fname</argname> ha estensione
	      <quote><lit>.gz</lit></quote>, il file viene salvato
	      usando la compressione gzip.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se <argname>fname</argname> ha il suffisso
	      <quote><lit>.bin</lit></quote>, il file viene salvato in
	      formato binario. In tal caso, i primi 19 byte
	      contengono la stringa <lit>gretl_binary_matrix</lit>,
	      i successivi 8 contengono due interi da 32 bit coi
	      numeri di righe e colonne, e il resto contiene gli
	      elementi della matrice in numeri in doppia precisione
	      (little-endian, ordine per colonna). Se gretl viene
	      eseguito su un sistema operativo big-endian, la
	      conversione viene effettuata automaticamente in lettura
	      e scrittura.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se <argname>fname</argname> ha il suffisso
	      <quote><lit>.csv</lit></quote> la matrice sarà scritta in
	      valori separati da virgole, senza una linea iniziale che
	      specifichi il numero di righe e colonne. Questo formato
	      può rendere più semplice la lettura del file da parte di
	      altri programmi, ma non se il file deve poi essere
	      riletto da gretl.
	    </para>
	  </li>
	</ilist>
	<para>
	  Si noti che se il file dev'essere letto da un altro
	  programma, l'uso delle opzioni gzip o binarie è
	  sconsigliato. Tuttavia, se il file dev'essere riletto da
	  gretl, i formati alternativi producono un sensibile
	  risparmio di spazio e il formato binario è anche molto più
	  veloce in lettura. Per matrici molto grandi, sconsigliamo
	  l'uso del formato gzip, che tende ad essere piuttosto lento.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mread"/>
	  </seelist>
	  Per salvare una matrice come dataset, si veda anche <cmdref
	  targ="store"/>.
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice contenente una tabella a doppia entrata
	  dei valori contenuti in <argname>x</argname> (nel senso delle
	  righe) e <argname>y</argname> (nel senso delle colonne). I due
	  argomenti devono essere dello stesso tipo (entrambe variabili e
	  entrambi vettori colonna), e visto l'uso che tipicamente viene
	  fatto di questa funzione si assume che contengano solo valori
	  interi.
	</para>
	<para>
	  <seelist>
	    <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="naalen" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Dato un campione di dati di durata, <argname>d</argname>, ed
	  eventualmente una variabile di censura,
	  <argname>cens</argname>, questa funzione calcola lo
	  stimatore nonparametrico di Nelson&ndash;Aalen della
	  funzione di rischio (<cite key="nelson72">Nelson,
	  1972</cite>; <cite key="aalen78">Aalen, 1978)</cite>). La
	  matrice risultato ha tre colonne, contenenti (nell'ordine) i
	  valori in <argname>d</argname>, ordinati, la funzione di
	  sopravvivenza stimata e la stima del suo scarto quadratico medio.
	</para>
	<para>
	  Se l'argomento <argname>cens</argname> non viene omesso, il
	  valore 0 indica che l'osservazione non è censurata, mentre
	  il valore 1 denota una censura a destra (e cioè che il
	  periodo di osservazione dell'individuo in questione si è
	  concluso prima che la durata fosse registrata come
	  conclusa). Se <argname>cens</argname> è omesso, si assume
	  che le osservazioni siano non censurate. (Nota: le
	  convenzioni su <argname>cens</argname> potranno subire
	  modifiche in futuro per coprire altri tipi di censura.)
	</para>
	<para>
	  <seelist>
	    <fncref targ="kmeier"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="nonparam" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar" optional="true">h</fnarg>
	<fnarg type="bool" optional="true">LOO</fnarg>
	<fnarg type="scalar" optional="true">trim</fnarg>
      </fnargs>
      <description>
	<para>
	  Stima nonparametrica della media condizionale di
	  <argname>y</argname> dato <argname>x</argname> col metodo di
	  Nadaraya&ndash;Watson. Restituisce una variabile contenente la stima
	  nonparametrica di
	  <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  per ogni elemento non mancante della variabile
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[
	  m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i -
	  x_j)} {\sum_{j=1}^{n} K_h(x_i - x_j)}
	  \]
	  dove la funzione kernel <math>K_h(\cdot)</math> è data da
	  \[
	  K_h(x) = \exp\left(-\frac{x^2}{2h}\right)
	  \]
	  per $|x| &lt; \tau$ e 0 altrimenti ($\tau$ è il cosiddetto
	  parametro di trimming).
	</para>
	<para context="notex">
	  La funzione kernel <math>K</math> è data da <math>K =
	  exp(-x</math><sup>2</sup><math> / 2h)</math> per <math>|x|
	  &lt; T</math> e 0 altrimenti.
	</para>
	<para>
	  I tre parametri opzionali determinano il risultato come spiegato
	  qui di seguito.
	</para>
	<subhead>Ampiezza di banda</subhead>
	<para>
	  L'argomento <argname>h</argname>, l'ampiezza di banda, è un
	  numero positivo, di solito piccolo.  Più esso è grande, più il
	  risultato <math>m(x)</math> sarà liscio. Comunemente, si sceglie
	  <argname>h</argname> in modo che sia proporzionale a
	  <math>n</math><sup>-0.2</sup>. Se <argname>h</argname> è omesso
	  o pari a zero, la scelta di default usa un valore determinato
	  sulla base della dispersione di <argname>x</argname>, così come
	  misurata dallo scarto quadratico medio o dal range
	  interquartile; vedi <guideref targ="chap:nonparam"/> per
	  maggiori dettagli.
	</para>
	<subhead>Leave-one-out</subhead>
	<para>
	  <quote>Leave-one-out</quote> è una variante dell'algoritmo che
	  omette l'<math>i</math>-esima osservazione nel calcolo
	  di <math>m(x</math><sub>i</sub><math>)</math>. Questo rende lo
	  stimatore Nadaraya&ndash;Watson più robusto numericamente ed è
	  in genere consigliato quando la stima viene fatta a fini
	  inferenziali. Questa variante non è di default, ma viene
	  attivata se l'argomento <argname>LOO</argname> è non-zero.
	</para>
	<para context="tex">
	  In formule, questo stimatore è
	  \[
	  m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i -
	  x_j)} {\sum_{j \ne i} K_h(x_i - x_j)}
	  \]
	</para>
	<subhead>Trimming</subhead>
	<para>
	  Il parametro <argname>trim</argname> viene usato per
	  controllare il livello di <quote>taglio</quote>, al fine di
	  prevenire problemi numerici quando la funzione kernel è
	  valutata troppo lontano da 0. Questo parametro è espresso
	  come multiplo di <argname>h</argname>, e il default è 4. In
	  certi casi, un valore maggiore di 4 potrebbe essere
	  preferibile. Di nuovo, si veda <guideref
	  targ="chap:nonparam"/> per dettagli.
	</para>
	<para>
	  Vedi anche <fncref targ="loess"/>.
	</para>
      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di elementi nell'argomento, che può
	  essewre una lista, una matrice, un bundle, una array o una
	  stringa, ma non una serie. Se l'argomento è una stringa, il
	  risultato è dato dal numero di byte, che può essere maggiore
	  del numero di caratteri (vedi anche <fncref
	  targ="strlen"/>).
	</para>
      </description>
    </function>

    <function name="ngetenv" section="programming" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se è stata definita una variabile d'ambiente
	  <argname>s</argname> e le è stato assegnato un valore numerico,
	  restituisce tale valore; in caso contrario restituisce NA.
	  V anche <fncref targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna un conteggio delle linee di testo complete (ossia,
	  linee che terminano con un carattere di <quote>a
	  capo</quote>) nel buffer <argname>buf</argname>.
	</para>
	<para>
	  Ad esempio:
	</para>
	<code>
	  string web_page = readfile("http://gretl.sourceforge.net/")
	  scalar number = nlines(web_page)
	  print number
	</code>
      </description>
    </function>

    <function name="NMmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="int">maxfeval</fnarg>
      </fnargs>
      <description>
	<para>
	  Massimizzazione numerica col metodo del simplesso di
	  Nelder&ndash;Mead (ameba). In ingresso, il vettore
	  <argname>b</argname> contiene i valori iniziali di un
	  insieme di parametri, mentre la stringa <argname>s</argname>
	  deve specificare la chiamata a una funzione che calcola il
	  criterio (scalare) da massimizzare, dati i valori correnti
	  dai parametri e qualsiasi altro dato rilevante. In caso di
	  successo, <lit>NMmax</lit> restituisce il valore
	  massimizzato del criterio, e <argname>b</argname> contiene i
	  valori dei parametri associati al valore del criterio
	  restituito.
	</para>
	<para>
	  Il terzo argomento opzionale permette di scegliere il numero
	  massimo di volte che la funzione viene calcolata; se è 0, o
	  viene omesso, si prende 2000 come default. Si può anche
	  specificare un valore negativo per
	  <argname>maxfeval</argname>.In questo caso, viene usato il
	  valore assoluto, ma <lit>NMmax</lit> restituirà un errore se
	  il valore trovato non risulta essere un ottimo
	  globale. Altrimenti, la non convergenza non viene
	  considerata un errore.
	</para>
	<para>
	  Se l'oggetto è di fatto una minimizzazione, la funzione
	  criterio può essere ridefinita cambiando il segno del
	  risultato, oppure <lit>NMmax</lit> può essere chiamata col
	  suo alias <lit>NMmin</lit>.
	</para>
	<para>
	  Per ulteriori dettagli ed esempi, vedi <guideref
	  targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NMmin" section="numerical" output="scalar">
      <description>
	<para>
	  Come <fncref targ="NMmax"/>, ma risolve un problema di
	  minimo anziché di massimo.
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> è una serie, restituisce il numero di
	  osservazioni non mancanti nella selezione corrente del
	  campione.
	</para>
	<para>
	  Se <argname>x</argname> è una lista, restituisce una serie
	  <math>y</math> in cui <math>y</math><sub>t</sub> è il
	  numero di elementi della lista che hanno un valore valido
	  all'osservazione <math>t</math>.
       </para>
       <para>
	 <seelist>
	   <fncref targ="pnobs"/>
	   <fncref targ="pxnobs"/>
	 </seelist>
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Genera una sequenza di numeri pseudo-casuali tratti dalla
	  distribuzione normale di media &mu; e deviazione standard
	  &sigma;. Se non vengono forniti gli argomenti vengono generate
	  realizzazioni tratte dalla distribuzione <math>N</math>(0,1). I
	  valori sono prodotti usando il metodo Ziggurat <cite
	  key="marsaglia00" p="true">(Marsaglia e Tsang, 2000)</cite>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="randgen"/>
	    <fncref targ="mnormal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normtest" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Esegue un test di normalità su <argname>y</argname>. Di
	  default, quello di Doornik&ndash;Hansen; tuttavia, si può
	  usare l'argomento opzionale <argname>method</argname> per le
	  alternative disponibili: <lit>swilk</lit> per il test di
	  Shapiro&ndash;Wilk test, <lit>jbera</lit> per quello di
	  Jarque&ndash;Bera, oppure <lit>lillie</lit> per il test di
	  Lilliefors.
	</para>
	<para>
	  Il secondo argomento può essere fornito con o senza
	  virgolette. Nel secondo caso, tuttavia, se l'argomento
	  corrisponde al nome di una variabile stringa esistente,
	  verrà usato il valore di tale variabile. L'esempio seguente
	  mostra tre modi possibili di eseguire un test di
	  Shapiro&ndash;Wilk:
	</para>
	<code>
	  matrix nt = normtest(y, swilk)
	  matrix nt = normtest(y, "swilk")
	  string testtype = "swilk"
	  matrix nt = normtest(y, testtype)
	</code>
	<para>
	  La matrice risultato è <by r="1" c="2"/>; contiene la
	  statistica test  e il suo p-value. Vedi anche il
	  comando <cmdref targ="normtest"/>.
	</para>
      </description>
    </function>

    <function name="npcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola una misura di correlazione fra <argname>x</argname>
	  e <argname>y</argname> con un metodo nonparametrico. Se il
	  terzo argomento non viene omesso, dev'essere
	  <lit>kendall</lit> (per la tau di Kendall, versione b, che è
	  il metodo di default) oppure <lit>spearman</lit> (per la rho
	  di Spearman).
	</para>
	<para>
	  La funzione restituisce un vettore a 3 elementi contenente
	  l'indice di correlazione nonché una statistica test (con
	  p-value associato), relativa all'ipotesi di non
	  correlazione. Si noti che se il campione è troppo piccolo,
	  la statistica test e/o il p-value potrebbero essere
	  <lit>NaN</lit>.
	</para>
	<para>
	  Vedi anche <fncref targ="corr"/> per la correlazione di Pearson.
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il Valore Attuale Netto (VAN) di
	  <argname>x</argname>, considerato come una sequenza di
	  esborsi (se negativi) e introiti (se positivi), valutati a
	  un tasso d'interesse annuo <argname>r</argname>;
	  <argname>r</argname> dev'essere espresso in valore non
	  percentuale (5<lit>%</lit> = 0.05).  Il primo valore è considerato
	  come riferito al periodo <quote>presente</quote> e non viene
	  scontato.  Per emulare una funzione che calcola il VAN
	  scontando anche il primo valore, inserite uno zero
	  all'inizio della sequenza degli input.
	</para>
	<para>
	  La funzione può gestire frequenze di osservazione
	  annuali, trimestrali, mensili e prive di data (le osservazioni
	  prive di data sono considerate annuali).
	</para>
	<para>
	  <seelist>
	    <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Massimizzazione numerica mediante il metodo di
	  Newton&ndash;Raphson. Il vettore <argname>b</argname> deve
	  contenere i valori iniziali dei parametri, e l'argomento
	  <argname>f</argname> deve specificare una funzione che calcola
	  il criterio (scalare) da massimizzare, dati i valori correnti
	  dei parametri e altre informazioni rilevanti.  Se l'obiettivo è
	  di minimizzare il criterio, la funzione deve restituire il
	  criterio cambiato di segno.  Se l'esecuzione viene completata
	  con successo, <lit>NRmax</lit> restituisce il valore
	  massimizzato del criterio e <argname>b</argname> contiene i
	  valori dei parametri corrispondenti al massimo.
	</para>
	<para>
	  Gli argomenti opzionali in terza e in quarta posizione
	  permettono di specificare rispettivamente le derivate analitiche
	  e una matrice Hessiana analitica (negativa). Le funzioni
	  indicate come <argname>g</argname> e <argname>h</argname> devono
	  assumere come primo argomento una matrice predefinita con le
	  stesse dimensioni rispettivamente del gradiente e dell'Hessiana,
	  indicati sotto forma di puntatore. Devono inoltre accettare il
	  vettore dei parametri come argomento (sotto forma di puntatore o
	  altro). Gli altri argomenti sono opzionali. Se si omette uno o
	  entrambi gli argomenti opzionali viene utilizzata
	  un'approssimazione numerica.
	</para>
	<para>
	  Per maggiori dettagli ed esempi si veda il capitolo
	  relativo ai metodi numerici in <guideref targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
	    <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmin" section="numerical" output="scalar">
      <description>
	<para>
	  Come <fncref targ="NRmax"/>, ma risolve un problema di
	  minimo anziché di massimo.
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola lo spazio nullo destro di <argname>A</argname>
	  usando la scomposizione a valori singolari (SVD); il
	  risultato è una matrice <math>B</math> tale che il prodotto
	  <math>AB</math> è una matrice nulla, tranne quando
	  <argname>A</argname> è di rango colonna pieno, caso in cui
	  viene restituita una matrice vuota. In caso contrario, se
	  <argname>A</argname> è <by r="m" c="n"/>, <math>B</math>
	  sarà <math>n</math> per (<math>n</math> &minus;
	  <math>r</math>), dove <math>r</math> è il rango di
	  <argname>A</argname>.
	</para>
	<para context="notex">
	  Se il rango colonna di <argname>A</argname> non è pieno, la
	  concatenazione verticale di <argname>A</argname> e
	  <argname>B</argname> trasposto produce una matrice di rango
	  pieno.
	</para>
	<para context="tex">
	  Calcola lo spazio nullo a destra di <argname>A</argname>,
	  usando la scomposizione a valori singolari: il risultato è
	  una matrice $B$ tale che
	  \begin{itemize}
	  \item $AB=[0]$, tranne quando $A$ è di rango colonna pieno, caso
	  in cui viene restituita una matrice vuota. In caso contrario, se
	  $A$ è $m \times n$, $B$ sarà una matrice $n \times (n-r)$, dove
	  $r$ è il rango di $A$.
	  \item Se il rango colonna di $A$ non è pieno, la
	  concatenazione verticale di $A$ e $B'$ produce una matrice di rango
	  pieno.
	  \end{itemize}
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  A = mshape(seq(1,6),2,3)
	  B = nullspace(A)
	  C = A | B'

	  print A B C

	  eval A*B
	  eval rank(C)
	</code>
	<para>
	  produce
	</para>
	<code>
	  ? print A B C
	  A (2 x 3)

	  1   3   5
	  2   4   6

	  B (3 x 1)

	  -0.5
	  1
	  -0.5

	  C (3 x 3)

	  1      3      5
	  2      4      6
	  -0.5      1   -0.5

	  ? eval A*B
	  -4.4409e-16
	  -4.4409e-16

	  ? eval rank(C)
	  3
	</code>
	<para>
	  <seelist>
	    <fncref targ="rank"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="numhess" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola un'approssimazione numerica alla matrice hessiana
	  della funzione specificata dall'argomento
	  <argname>fcall</argname> nel punto dato dal vettore a
	  <math>n</math> dimensioni <argname>b</argname>.  La funzione
	  deve avere <argname>b</argname> come suo primo argomento (in
	  forma di puntatore o meno), seguito da quanti parametri si
	  voglia; deve ritornare uno scalare. Se la funzione va a buon
	  fine <lit>numhess</lit> restituisce una matrice <by r="n"
	  c="n"/> contenente l'hessiana, che è per costruzione
	  esattamente simmetrica.
	</para>
	<para>
	  Il metodo usato è l'estrapolazione di Richardson a quattro
	  passi. Il terzo argomento (opzionale) si usa per assegnare
	  un valore alla frazione <math>d</math> del parametro, che
	  viene usata per la lunghezza di passo iniziale; se omesso,
	  il valore di default è <math>d</math> = 0.01.
	</para>
	<para>
	  Un esempio:
	</para>
	<code>
	  matrix H = numhess(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  <seelist>
	    <fncref targ="BFGSmax"/>
	    <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Restituisce una serie di interi consecutivi, partendo da 1 in
	  corrispondenza con l'inizio del dataset. Si noti che il
	  risultato è indipendente dal sottocampionamento. Questa
	  funzione è particolarmente utile con dataset di serie
	  storiche. Nota: la funzione <lit>t</lit> è un sinonimo
	  perfetto di <lit>obs</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string">
      <fnargs>
	<fnarg type="scalar-or-vec">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>t</argname> è uno scalare, restituisce
	  l'etichetta per la <argname>t</argname>-esima osservazione.
	  La funzione inversa è <fncref targ="obsnum"/>.
	</para>
	<para>
	  Se <argname>t</argname> è un vettore, restituisce un array
	  di stringhe, le etichette per le osservazioni date dagli
	  elementi di <argname>t</argname>.
	</para>
	<para>
	  In ambo i casi, i valori <argname>t</argname> devono essere
	  interi, validi come indici delle osservazioni nel dataset
	  corrente; altrimenti, viene prodotto un errore.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un intero corrispondente all'osservazione
	  specificata dalla stringa <math>s</math>. Si noti che il
	  risultato è invariante al sottocampionamento. Questa
	  funzione è particolarmente utile con campioni di serie
	  storiche. Ad esempio, il codice
	</para>
	<code>
	  open denmark
	  k = obsnum(1980:1)
	</code>
	<para>
	  produce <lit>k = 25</lit>, ciò che indica che il primo
	  trimestre 1980 è la venticinquesima osservazione nel dataset
	  <lit>denmark</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="obs"/>
	    <fncref targ="obslabel"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> è uno scalare, la funzione
	  restituisce 1 se <argname>x</argname> non è <lit>NA</lit>,
	  altrimenti 0. Se <argname>x</argname> è una variabile la
	  funzione restituisce una serie contenente valore 1 per le
	  osservazioni non mancanti e zero altrimenti.  Se
	  <argname>x</argname> è una lista il risultato è una
	  variabile con zero in corrispondenza delle osservazioni per
	  le quali almeno una variabile nella lista ha un valore
	  mancante e 1 altrimenti.
	</para>
	<para>
	  Se <argname>x</argname> è una matrice il comportamento è
	  leggermente diverso, dato che le matrici non possono
	  contenere <lit>NA</lit>: la funzione restituisce una matrice
	  delle stesse dimensioni di <argname>x</argname>, con
	  elementi pari a 1 nelle posizioni corrispondenti a elementi
	  di <argname>x</argname> finiti, e 0 di quelli non finiti (o
	  infiniti o not-a-number, in conformità con lo standard IEEE
	  754).
	</para>
	<para>
	  <seelist>
	    <fncref targ="missing"/>
	    <fncref targ="misszero"/>
	    <fncref targ="zeromiss"/>
	  </seelist>
	  Notare che queste funzioni non possono essere applicate a matrici.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce la norma-1 della matrice <argname>X</argname>;
	  in altre parole, il massimo fra le colonne di
	  <argname>X</argname> della somma dei valori assoluti degli
	  elementi della colonna.
	</para>
	<para context="tex">
	  Restituisce la norma-1 della matrice $r \times c$
	  <argname>X</argname>:
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="infnorm"/>
	    <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice con <math>r</math> righe e <math>c</math>
	  colonne con elementi tutti pari a 1.
	</para>
	<para>
	  <seelist>
	    <fncref targ="seq"/>
	    <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  La funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola le deviazioni ortogonali in avanti
	  della variabile <argname>y</argname>.
	</para>
	<para context="tex">
	  La funzione è applicabile solo se il dataset corrente ha una
	  struttura panel. Calcola le deviazioni ortogonali in avanti
	  della variabile <argname>y</argname>; in altre parole,
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t + 1}{T_i - t}} \left( y_{i,t} -
	  \frac{1}{T_i - t - 1} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  Talvolta questa trasformazione viene utilizzata talvolta al posto delle
	  differenze per rimuovere gli effetti individuali da dati panel. Per assicurare
	  la compatibilità con le differenze prime, le deviazioni sono memorizzate
	  alla data successiva a quella che corrisponde alla loro effettiva collocazione
	  temporale (in altre parole, il valore alla data
	  <math>t</math> è la deviazione che in realtà si riferisce alla data
	  <math>t</math> &minus; 1).  In questo modo viene  persa la prima osservazione di
	  ogni serie storica e non l'ultima.
	  <seelist>
	    <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, shape, scale, y)</example>
      </examples>
      <description>
	<para>
	  Calcola funzioni di densità o di probabilità. Restituisce la
	  densità (se continue) o la probabilità (se discrete) in
	  <argname>x</argname> della distribuzione identificata dal
	  carattere <argname>c</argname>.  Si veda <fncref targ="cdf"/>
	  per dettagli sugli argomenti.  Le distribuzioni supportate
	  dalla funzione <lit>pdf</lit> sono la normale,
	  <math>t</math> di Student, chi-quadro, <math>F</math>,
	  gamma, Weibull, Generalized Error, binomiale and Poisson. Si
	  noti che per la binomiale e la Poisson ciò che viene
	  calcolato è in effetti la probabilità nel punto specificato.
	  Per la <math>t</math> di Student, la chi quadro e la
	  <math>F</math> tanche le varianti non centrali sono ammesse.
	</para>
	<para>
	  Per la normale, si veda anche la funzione <fncref
	  targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">bandwidth</fnarg>
      </fnargs>
      <description>
	<para>
	  Se viene fornito solo il primo argomento la funzione calcola
	  il periodogramma campionario per la variabile o il vettore indicati.
	  Se viene fornito anche il secondo argomento, la funzione calcola
	  una stima dello spettro di <argname>x</argname> usando una finestra
	  di ritardi di Bartlett con la banda indicata, fino a un massimo pari alla
	  metà delle osservazioni (<math>T</math>/2).
	</para>
	<para>
	  Restituisce una matrice con due colonne e <math>T</math>/2 righe:
	  la prima colonna contiene la frequenza, &omega;, da 2&pi;/<math>T</math>
	  a &pi;, e la seconda la densità spettrale corrispondente.
	</para>
      </description>
    </function>

    <function name="pexpand" section="panel" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
        <fnarg type="bool" optional="true">per_unita</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione può essere applicata solo se il dataset
	  corrente ha struttura panel.  Per default, effettua
	  l'operazione inversa di <fncref targ="pshrink"/>. Vale a
	  dire, dato un vettore di lunghezza uguale al numero di
	  individui nel campione panel vigente, restituisce una serie
	  in cui ogni valore è ripetuto <math>T</math> volte, dove
	  <math>T</math> è la lunghezza temporale del panel. La serie
	  risultante è, di conseguenza, invariante nel tempo.
	</para>
	<para>
	  Se l'argomento
	  <argname>per_unita</argname> è nonzero, la lunghezza di
	  <argname>v</argname> deve essere pari a <math>T</math> e la
	  ripetizione avviene per le unità del panel.
	</para>
      </description>
    </function>

    <function name="pmax" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione può essere applicata solo se il dataset corrente
	  ha struttura panel. Restituisce una variabile contenente i massimi
	  della variabile
	  <argname>y</argname> per ciascuna unità cross-section (ripetuti
	  per tutti i periodi temporali).
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  per le quali il valore di <argname>mask</argname> è 0 vengono
	  ignorate.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pmin"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pxsum"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente
	  ha struttura panel. Calcola la media per ciascuna unità della
	  variabile
	  <argname>y</argname>; in altre parole, la somma delle osservazioni
	  valide relative a ciascuna unità divisa per il loro numero.
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la media per ciascuna unità della
	  variabile
	  <argname>y</argname>; in altre parole,
	  \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\]
	  dove $T_i$ è il numero di osservazioni valide per l'unità $i$.
	</para>
	<para>
	  Se viene indicato il secondo parametro opzionale le
	  osservazioni corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pmax"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pxsum"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente i minimi della
	  variabile
	  <argname>y</argname> per ciascuna unità della cross-section (replicati
	  per ogni periodo temporale).
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pmax"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente il numero
	  di osservazioni valide della variabile <argname>y</argname> per
	  ciascuna unità della cross-section (replicato per ogni periodo
	  temporale).
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pmax"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pmean"/>
	    <fncref targ="psd"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="math" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le radici di un polinomio. Se il polinomio è
	  di grado <math>p</math>, il vettore  <argname>a</argname> deve contenere
	  <math>p</math> + 1 coefficienti in ordine crescente, &ie; partendo
	  dalla costante e terminando con il coefficiente di
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  Se tutte le radici sono reali vengono restituite in un vettore colonna
	  di lunghezza <math>p</math>; in caso contrario viene restituita una
	  matrice <by r="p" c="2"/> con la parte reale delle radici nella prima colonna
	  e la parte immaginaria nella seconda.
	</para>
      </description>
    </function>

    <function name="polyfit" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Interpola con il metodo dei polinomi ortogonali un trend
	  polinomiale di ordine <argname>q</argname> alla variabile <argname>y</argname>
	  in input. La variabile contiene i valori interpolati.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">covmat</fnarg>
      </fnargs>
      <description>
	<para>
	  Data la matrice <argname>X</argname> di dimensioni <by r="T"
	  c="k"/>, contenente <math>T</math> osservazioni su
	  <math>k</math> variabili, e un intero positivo <argname>p</argname>
	  inferiore o uguale a
	  <math>k</math>, questa funzione restituisce una matrice <by
	  r="T" c="p"/> <math>P</math>, contenente le prime
	  <math>p</math> componenti principali di
	  <argname>X</argname>.
	</para>
	<para>
	  Il terzo parametro è opzionale e ha l'effetto di una condizione logica:
	  se non nullo le componenti principali vengono calcolate
	  sulla base della matrice di covarianza delle colonne di <argname>X</argname>
	  (il default è usare la matrice di correlazione).
	</para>
	<para context="notex">
	  Gli elementi di <math>P</math> sono calcolati come la somma
	  da <math>i</math> a <math>k</math> di <math>Z</math><sub>ti</sub>
	  per <math>v</math><sub>ji</sub>, dove
	  <math>Z</math><sub>ti</sub> è il valore standardizzato della variabile
	  <math>i</math> all'osservazione <math>t</math> e
	  <math>v</math><sub>ji</sub> è l'autovettore <math>j</math> della
	  matrice di correlazione (o covarianza) delle <math>X</math><sub>i</sub>,
	  con autovettori ordinati in ordine decrescente degli autovalori
	  corrispondenti.
	</para>
	<para context="tex">
	  Gli elementi di $P$ sono calcolati come
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \]
	  dove $Z_{ti}$ è il valore standardizzato della variabile
	  $i$ all'osservazione $t$, $Z_{ti} = (X_{ti} -
	  \bar{X}_i) / \hat{\sigma}_i$, e $v^{(j)}$ è l'autovettore $j$
	  della matrice di correlazione (o covarianza) delle
	  $X_i$, con autovettori ordinati in senso decrescente
	  degli autovalori corrispondenti.
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il prodotto degli elementi di <argname>X</argname>,
	  per colonna. Se viene specificato un
	  valore diverso da zero per il secondo argomento opzionale, i
	  valori mancanti vengono ignorati, altrimenti il ​​risultato è
	  <lit>NA</lit> per tutte le colonne che contengono valori
	  mancanti. Quindi, specificare <argname>skip_na</argname>
	  equivale a trattare i valori mancanti come se fossero 1.
	  <seelist>
	    <fncref targ="prodr"/>
	    <fncref targ="meanc"/>
	    <fncref targ="sdc"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il prodotto degli elementi di
	  <argname>X</argname>, per riga. Se viene specificato un
	  valore diverso da zero per il secondo argomento opzionale, i
	  valori mancanti vengono ignorati, altrimenti il ​​risultato è
	  <lit>NA</lit> per tutte le righe che contengono valori
	  mancanti. Quindi, specificare <argname>skip_na</argname>
	  equivale a trattare i valori mancanti come se fossero 1.
	  <seelist>
	    <fncref targ="prodc"/>
	    <fncref targ="meanr"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente la
	  deviazione standard campionaria della variabile <math>y</math>
	  per ciascuna unità della cross-section (con valori ripetuti per
	  ciascuna data). Il denominatore utilizzato è la numerosità
	  campionaria per ciascuna unità meno 1, a meno che il numero di
	  osservazioni valide per l'unità in questione sia 1 (nel qual
	  caso viene restituito uno zero) o 0 (nel qual caso viene
	  <lit>NA</lit>).
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la deviazione standard campionaria per
	  ciascuna unità della cross-section della variabile
	  <math>y</math>; in altre parole, \[ \sigma_i =
	  \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} - \bar{y}_i)^2
	  } \]. La formula precedente vale per $T_i\ge 2$, dove $T_i$ è il
	  numero di osservazioni valide per l'unità $i$; se $T_i = 0$, la
	  funzione restituisce <lit>NA</lit>; se $T_i = 1$, la funzione
	  restituisce 0.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  Nota: questa funzione rende possibile controllare se
	  una certa variabile (per esempio <lit>X</lit>) è costante nel tempo usando la condizione
	  <lit>max(psd(X)) = 0</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pmax"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="bool" optional="true">psdcheck</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola una variante generalizzata della scomposizione di
	  Cholesky della matrice <argname>A</argname>, che deve essere
	  semidefinita positiva (ma può essere singolare). Se la
	  matrice in input non è quadrata la funzione genera un
	  messaggio d'errore, ma la simmetria viene data per scontata,
	  e non viene verificata; la funzione legge solo il triangolo
	  inferiore di <argname>A</argname>.  Il risultato è una
	  matrice triangolare inferiore <math>L</math> che soddisfa la
	  condizione <equation status="inline" ascii="A = LL'" tex="$A
	  = LL'$"/>. Gli elementi indeterminati della soluzione
	  vengono posti pari a zero.
	</para>
	<para>
	  Per forzare un controllo sulla definitezza di
	  <argname>A</argname>, si può usare un valore non-zero per il
	  secondo argomento (opzionale). In tal caso, verrà prodotto
	  un errore se il minimo valore assoluto di <equation
	  status="inline" ascii="A &minus; LL'" tex="$A - LL'$"/>
	  eccede 1.0e-8. Per effettuare lo stesso controllo a mano:
	</para>
	<code>
	  L = psdroot(A)
	  chk = maxc(maxr(abs(A - L*L')))
	</code>
	<para>
	  Nel caso in cui <argname>A</argname> sia definita positiva, v.
	  <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="panel" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce un vettore colonna contenente
	  la prima osservazione valide della serie
	  <argname>y</argname> per ciascuna unità in cross-section del
	  panel all'interno dell'intervallo campionario corrente. Le
	  unità che non hanno nessuna osservazione valida per la serie
	  in input vengono ignorate.
	</para>
	<para>
	  Questa funzione permette di compattare le variabili
	  create da funzioni come <fncref targ="pmax"/> e
	  <fncref targ="pmean"/>, che replicano per tutti i periodi temporali
	  un valore relativo a ogni unità della cross-section.
	</para>
      </description>
    </function>

    <function name="psum" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente la somma
	  rispetto al tempo della variabile <argname>y</argname> per ogni unità
	  della cross-section, replicando per tutti i periodi i valori così ottenuti.
	  Nel calcolo delle somme le osservazioni mancanti vengono ignorate.
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la somma rispetto al tempo della
	  variabile <argname>y</argname> per ogni unità della cross-section;
	  in altre parole,
	  \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\]
	  dove $T_i$ è il numero di osservazioni valide per l'unità $i$.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pmax"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pxsum"/>
	    <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  Calcola un <math>P</math>-value. Restituisce
	  <equation status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>,
	  dove la distribuzione <math>X</math> è determinata dal carattere
	  <argname>c</argname>. Fra gli argomenti
	  <argname>c</argname> e <argname>x</argname> è necessario indicare
	  zero o più argomenti aggiuntivi per specificare i parametri della
	  distribuzione; v. <fncref targ="cdf"/> per ulteriori dettagli.
	  Le distribuzioni che la funzione <lit>pval</lit> può gestire sono
	  la normale standard, <math>t</math>, chi quadrato, <math>F</math>,
	  gamma, binomiale, Poisson, Weibull e Generalized Error.
	</para>
	<para>
	  <seelist>
	    <fncref targ="critical"/>
	    <fncref targ="invcdf"/>
	    <fncref targ="urcpval"/>
	    <fncref targ="imhof"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxnobs" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente il
	  numero di valori validi per <argname>y</argname> rispetto
	  alle unità della cross-section in ciascun periodo,
	  replicando i valori così ottenuti per ciascuna unità.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  per le quali il valore di <argname>mask</argname> è 0 vengono
	  ignorate.
	</para>
	<para>
	  Si noti che questa funzione lavora lungo
	  una dimensione diversa da quella utilizzata dalla funzione
	  <fncref targ="pnobs"/>.
	</para>
      </description>
    </function>

    <function name="pxsum" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente
	  la somma dei valori di <argname>y</argname> rispetto alle unità della
	  cross-section in ciascun periodo, replicando i valori
	  così ottenuti per ciascuna unità.
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la somma in cross-section della variabile
	  <argname>y</argname> in ciascun periodo; in altre parole,
	  \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\]
	  dove $N$ è il numero di unità in cross-section.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  Si noti che questa funzione lavora lungo
	  una dimensione diversa da quella utilizzata dalla funzione
	  <fncref targ="pmean"/>.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola la forma quadratica <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>. L'uso di questa
	  funzione al posto della consueta moltiplicazione matriciale
	  garantisce maggiore velocità e accuratezza nel caso generico
	  in cui <argname>A</argname> sia una qualche matrice
	  simmetrica. Tuttavia, nel caso particolare in cui
	  <argname>A</argname> sia la matrice identità, la semplice
	  espressione <lit>x'x</lit> ha prestazioni molto migliori di
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Calcola la forma quadratica <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>. L'uso di questa
	  funzione al posto della consueta moltiplicazione matriciale
	  garantisce maggiore velocità e accuratezza nel caso generico
	  in cui <argname>A</argname> sia una qualche matrice
	  simmetrica. Tuttavia, nel caso particolare <equation
	  status="inline" ascii="A = I" tex="$A = I$"/>, la semplice
	  espressione <lit>x'x</lit> ha prestazioni molto migliori di
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	  Nel caso particolare in cui <argname>A</argname> sia
	  diagonale, il secondo argomento può essere un vettore di
	  dimensione appropriata, che viene interpretato come la
	  diagonale di <argname>A</argname>. Questo permette l'uso di
	  un algoritmo più efficiente.
	</para>
	<para>
	  Se le dimensioni di <argname>x</argname> e
	  <argname>A</argname> non sono compatibili o se
	  <argname>A</argname> non è simmetrica viene restituito un
	  messaggio d'errore.
	</para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">df</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-values per la statistica test QLR
	  sup-Wald,usata per la ricerca di un break strutturale ad un
	  punto ignoto (vedi <cmdref targ="qlrtest"/>), secondo <cite
	  key="hansen97">Hansen (1997)</cite>.
	</para>
	<para>
	  Il primo argomento, <argname>X2</argname>, denota la
	  statistica del massimo Wald test (nella forma chi-quadro) e
	  <argname>df</argname> denota i suoi gradi di libertà. Gli
	  argomenti 3 e 4 rappresentano, come numeri fra 0 e 1, il
	  punto iniziale e finale del sottocampione centrale delle
	  osservazioni su cui la successione di test di Wald viene
	  calcolata. Ad esempio, se viene adottato l'usuale approccio
	  di partire dal 15 per cento e fermarsi all'85, si userebbero
	  0.15 per <argname>p1</argname> e 0.85 per
	  <argname>p2</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce i quantili della normale standardizzata. Se
	  <argname>x</argname> non è fra 0 e 1, restituisce <lit>NA</lit>.
	  <seelist>
	    <fncref targ="cnorm"/>
	    <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
	<fnarg type="matrixref" optional="true">&amp;P</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la scomposizione QR di una matrice <by r="m" c="n"/>
	  <argname>X</argname>, in altre parole <math>X = QR</math>
	  dove <math>Q</math> è una matrice ortogonale <by r="m"
	  c="n"/> e <math>R</math> è una matrice triangolare superiore
	  <by r="n" c="n"/>. La matrice <math>Q</math> viene
	  restituita direttamente, mentre <math>R</math> può essere
	  recuperata usando il secondo argomento opzionale.
	</para>
	<para>
	  Se viene fornito il terzo argomento facoltativo, la
	  scomposizione impiega il pivoting delle colonne e, se tutto
	  va a buon fine, <argname>P</argname> contiene l'ordinamento
	  finale delle colonne sotto forma di vettore riga. Se le
	  colonne non vengono effettivamente riordinate,
	  <argname>P</argname> sarà uguale a <fncref
	  targ="seq"/><lit>(1, n)</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigengen"/>
	    <fncref targ="eigensym"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">type</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice <by r="n" c="2"/> da usare per la
	  quadratura di Gauss (integrazione numerica). La prima
	  colonna contiene i nodi o ascisse, la seconda colonna
	  contiene i pesi.
	</para>
	<para>
	  Il primo argomento specifica il numero dei punti (righe) da
	  calcolare. Il secondo argomento specifica il codice del tipo
	  di quadratura da utilizzare: 1 Gauss&ndash;Hermite
	  (predefinita); 2 Gauss&ndash;Legendre; 3
	  Gauss&ndash;Laguerre. Il significato dei parametri opzionali
	  <argname>a</argname> e <argname>b</argname> dipende dal
	  <argname>tipo</argname> selezionato, come spiegato sotto.
	</para>
	<para context="notex">
	  La quadratura di Gauss è un metodo per l'approssimazione
	  numerica di un integrale definito di una qualche funzione di
	  interesse. Si rappresenti la funzione come il prodotto
	  <math>f(x)W(x)</math>. I diversi tipi di quadratura
	  differiscono nella specificazione della componente
	  <math>W(x)</math>: nel caso di Hermite questa è uguale a
	  exp(&minus;<math>x</math><sup>2</sup>); nel caso di
	  Laguerre, è data da exp(&minus;<math>x</math>); infine, nel
	  caso di Legendre, si ha semplicemente <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  La quadratura di Gauss è un metodo di approssimazione
	  numerica di un integrale definito di una qualche funzione di
	  interesse. Si rappresenti la funzione come il prodotto
	  $f(x)W(x)$. I diversi tipi di quadratura differiscono nella
	  specificazione della componente $W(x)$: nel caso di Hermite
	  abbiamo $W(x) = \exp(-x^2)$; nel caso di Laguerre, $W(x) =
	  \exp(-x)$; nel caso di Legendre, semplicemente $W(x) = 1$.
	</para>
	<para context="notex">
	  Per ciascuna specificazione di <math>W</math>, si può
	  calcolare un insieme di nodi, <math>x</math><sub>i</sub>, e
	  pesi, <math>w</math><sub>i</sub>, tali che la somma da
	  <math>i</math>=1 a <math>n</math> di
	  <math>w</math><sub>i</sub><math>f</math>(<math>x</math><sub>i</sub>)
	  approssima l'integrale desiderato. Viene usato il metodo di
	  <cite key="golub69">Golub and Welsch (1969)</cite>.
	</para>
	<para context="tex">
	  Per ciascuna specificazione di $W(x)$, si può calcolare un
	  insieme di nodi, $x_i$, e pesi, $w_i$, tali che
	  $\sum_{i=1}^n f(x_i) w_i$ approssima l'integrale
	  desiderato. È usato il metodo di <cite key="golub69">Golub
	  and Welsch (1969)</cite>.
	</para>
	<para context="notex">
	  Quando si seleziona il metodo di Gauss&ndash;Legendre, gli
	  argomenti opzionali <argname>a</argname> e
	  <argname>b</argname> possono essere utilizzati per
	  controllare i limiti inferiore e superiore di
	  integrazione; i valori predefiniti sono &minus;1 e
	  1. (Nella quadratura di Hermite i limiti sono fissati a meno
	  e più infinito, mentre in quella di Laguerre sono fissati a
	  0 e infinito.)
	</para>
	<para context="tex">
	  Quando si seleziona il metodo di Gauss&ndash;Legendre, gli
	  argomenti opzionali <argname>a</argname> e
	  <argname>b</argname> possono essere utilizzati per
	  controllare i limiti, inferiore e superiore, di
	  integrazione, i valori predefiniti sono $-1$ e 1. (Nella
	  quadratura di Hermite i limiti sono fissati a $-\infty$ e
	  $+\infty$, mentre in quella di Laguerre sono fissati a 0 e
	  $\infty$.)
	</para>
	<para context="notex">
	  Nella quadratura di Hermite <argname>a</argname> e
	  <argname>b</argname> svolgono un ruolo differente: possono
	  essere utilizzati per sostituire la forma predefinita di
	  <math>W</math>(<math>x</math>) con la distribuzione normale
	  (strettamente associata) con media <argname>a</argname> e
	  deviazione standard <argname>b</argname>. Per esempio,
	  fornire valori 0 e 1 per questi parametri ha l'effetto di
	  trasformare <math>W</math>(<math>x</math>) nella funzione di
	  densità di una normale standard, il che è equivalente a
	  moltiplicare i nodi predefiniti per la radice quadrata di 2
	  e dividere i pesi per la radice quadrata di &pi;.
	</para>
	<para context="tex">
	  Nella quadratura di Hermite <argname>a</argname> e
	  <argname>b</argname> svolgono un ruolo differente: possono
	  essere utilizzati per sostituire la forma predefinita di
	  $W(x)$ con la distribuzione normale (strettamente associata)
	  con media <argname>a</argname> e deviazione standard
	  <argname>b</argname>. Per esempio, fornire valori 0 e 1 per
	  questi parametri ha l'effetto di trasformare $W(x)$ nella
	  funzione di densità di una normale standard, il che è
	  equivalente a moltiplicare i valori predefiniti $x_i$ per
	  $\sqrt{2}$ e dividere i pesi $w_i$ predefiniti per
	  $\sqrt{\pi}$.
	</para>
      </description>
    </function>

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>y</argname> è una serie, restituisce il suo
	  <argname>p</argname>-esimo quantile. Ad esempio, se
	  <math>p</math> = 0.5, si avrà la mediana.
	</para>
	<para>
	  Se l'argomento è invece una matrice, restituisce un vettore riga
	  contenente i <argname>p</argname>-esimi quantili per le
	  colonne di <argname>y</argname>; in pratica, ogni colonna è
	  trattata come se fosse una serie.
	</para>
	<para>
	  Inoltre, se <argname>y</argname> è una matrice, si può usare
	  una forma alternativa del secondo argomento:
	  <argname>p</argname> può essere un vettore. In tal caso, il
	  valore restituito è una matrice <by r="m" c="n"/>, dove
	  <repl>m</repl> è il numero di elementi in
	  <argname>p</argname> e <repl>n</repl> il numero di colonne
	  di <argname>y</argname>.
	</para>
	<para>
	  <cite key="hyndman96">Hyndman e Fan (1996)</cite>
	  descrivono nove metodi diversi per il calcolo dei quantili
	  campionari. Il metodo di default in gretl è quello indicato
	  come <math>Q</math><sub>6</sub> (che è anche il default in
	  Python). Volendo però optare per il metodo
	  <math>Q</math><sub>7</sub> (di default in R) o il
	  <math>Q</math><sub>8</sub> (quello consigliato da Hyndman
	  and Fan) può essere usato il comando <cmdref
	  targ="set"/>, per esempio così:
	</para>
	<code>
	  set quantile_type Q7 # or Q8
	</code>
	<para context="tex">
	  Il $p$-esimo quantile $Q_p$, per una serie $y$ di lunghezza
	  $n$ è definito come: \[Q_p = y_{[k]} + (h - k) (y_{[k+1]} -
	  y_{[k]})\] dove $k$ è la parte intera di $h$, un termine che
	  varia a seconda dei metodi---$h=(n+1)p$ per $Q_6$,
	  $(n-1)p+1$ per $Q_7$ e $(n+1/3)p + 1/3$ per $Q_8$---mentre
	  $y_{[i]}$ è l'$i$-esimo elemento della serie ordinata in
	  senso crescente.
	</para>
	<para>
	Ad esempio, il codice
	</para>
	<code>
	  set verbose off
	  matrix x = seq(1,7)'
	  set quantile_type Q6
	  printf "Q6: %g\n", quantile(x, 0.45)
	  set quantile_type Q7
	  printf "Q7: %g\n", quantile(x, 0.45)
	  set quantile_type Q8
	  printf "Q8: %g\n", quantile(x, 0.45)
	</code>
	<para>
	produce il seguente output:
	</para>
	<code>
	  Q6: 3.6
	  Q7: 3.7
	  Q8: 3.63333
	</code>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-series">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  Generatore di numeri casuali. L'argomento
	  <argname>d</argname> è una stringa (nella maggior parte dei
	  casi semplicemente un singolo carattere) che specifica la
	  distribuzione da cui i numeri pseudo-casuali sono
	  generati. Gli argomenti da <argname>p1</argname> a
	  <argname>p3</argname> specificano i parametri della
	  distribuzione selezionata. Il numero di tali parametri
	  dipende dalla distribuzione.
	</para>
	<para>
	  Per le distribuzioni diverse dalla beta-binomiale e della
	  discreta generica, i parametri <argname>p1</argname> e (se
	  applicabile) <argname>p2</argname> devono essere scalari o
	  variabili: se sono scalari, la serie generata è
	  identicamente distribuita; se al contrario almeno uno dei
	  due parametri in ingresso è una serie, per ciascuna
	  osservazione la distribuzione è condizionata al valore dei
	  parametri corrispondenti.
	</para>
	<para>
	  Per i due casi speciali, le specifiche sono le seguenti: 
	</para>
        <ilist>
          <li>
            <para>
              beta-binomiale: tutti e tre i parametri devono essere scalari.
            </para>
          </li>
          <li>
            <para>
              discreta generica: è richiesto un solo parametro, cioè
              un vettore a <math>k</math> elementi contentente le
              probabilità per una variabile casuale il cui supporto
              siano gli interi da 1 to <math>k</math>.
            </para>
          </li>
        </ilist>
	<para>
	  Le specifiche sono fornite sotto: il codice stringa per ogni
	  distribuzione è mostrato fra parentesi, seguito
	  dall'interpretazione dell'argomento <argname>p1</argname> e,
	  ove applicabile, <argname>p2</argname> e
	  <argname>p3</argname>.
	</para>

	<ilist context="notex">
	  <li>
	    <para>
	      Uniforme (continua) (u o U): minimo, massimo
	    </para>
	  </li>
	  <li>
	    <para>
	      Uniforme (discreta) (i): minimo, massimo
	    </para>
	  </li>
	  <li>
	    <para>
	      Normale (z, n, o N): media, deviazione standard
	    </para>
	  </li>
	  <li>
	    <para>
	      t di Student (t): gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      Chi quadro (c, x, o X): gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      F di Snedecor (f o F): gradi di libertà (num.), gradi di libertà (den.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Gamma (g o G): forma, scala
	    </para>
	  </li>
	  <li>
	    <para>
	      Binomiale (b o B): probabilità, numero di prove
	    </para>
	  </li>
	  <li>
	    <para>
	      Poisson (p o P): media
	    </para>
	  </li>
	  <li>
	    <para>
	      Esponenziale negativa (exp): scala
	    </para>
	  </li>
	  <li>
            <para>
              Logistica (lgt o s): posizione, scala
            </para>
	  </li>
	  <li>
	    <para>
	      Weibull (w o W): forma, scala
	    </para>
	  </li>
	  <li>
            <para>
              Laplace (l o L): media, scala
            </para>
	  </li>
	  <li>
	    <para>
	      Generalized Error (E): forma
	    </para>
	  </li>
	  <li>
	    <para>
	      Beta (beta): forma1, forma2
	    </para>
	  </li>
	  <li>
	    <para>
	      Beta-Binomiale (bb): prove, forma1, forma2
	    </para>
	  </li>
	  <li>
            <para>
              Discreta generica (disc): probabilità
            </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textbf{Distribuzione} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniforme (continua) &amp; \texttt{u} o \texttt{U} &amp; minimo &amp; massimo &amp; --\\
	  Uniforme (discreta) &amp; \texttt{i} &amp; minimo &amp; massimo &amp; --\\
	  Normale &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp; media &amp; deviazione standard &amp; --\\
	  $t$ di Student &amp; \texttt{t} &amp; gradi di libertà &amp; -- &amp; --\\
	  Chi quadro &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp; gradi di libertà &amp; -- &amp; --\\
	  $F$ di Snedecor &amp; \texttt{f} o \texttt{F} &amp; gradi di libertà (num.) &amp; gradi di libertà (den.) &amp; --\\
	  Gamma &amp; \texttt{g} o \texttt{G} &amp; forma &amp; scala &amp; --\\
	  Binomiale &amp; \texttt{b} o \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Esponenziale &amp; \texttt{exp} &amp; scala &amp; -- &amp; --\\
	  Logistica &amp; \texttt{s} &amp; posizione &amp; scala &amp; --\\
	  Poisson &amp; \texttt{p} o \texttt{P} &amp; media &amp; --  &amp; --\\
	  Weibull &amp; \texttt{w} o \texttt{W} &amp; forma &amp; scala &amp; --\\
	  Laplace &amp; \texttt{l} o \texttt{L} &amp; media &amp; scala &amp; --\\
	  Generalized Error &amp; \texttt{e} o \texttt{E} &amp; forma &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; forma1 &amp; forma1 &amp; --\\
	  Beta-Binomiale &amp; \texttt{bb} &amp; $n$ &amp; forma1 &amp; forma1
	  Generic discrete &amp; \texttt{disc} &amp; $\mathbf{p}$ &amp; -- &amp; --
	</tabular>
	<para>
	  <seelist>
	    <fncref targ="normal"/>
	    <fncref targ="uniform"/>
	    <fncref targ="mrandgen"/>
	    <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Funziona come <fncref targ="randgen"/> eccetto per il fatto
	  che il valore restituito è uno scalare invece di una variabile.
	</para>
	<para>
	  Il primo esempio sopra restituisce un valore da una
	  distribuzione normale standard, mentre il secondo
	  restituisce un valore generato da una distribuzione Gamma
	  con parametro di forma 3 e parametro di scala 2.5.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un numero pseudo-casuale intero nell'intervallo
	  chiuso [<argname>min</argname>, <argname>max</argname>].
	  <seelist>
	    <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>


    <function name="randperm" section="probdist" output="vector">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Se è dato solo il primo argomento, ritorna un vettore riga
	  contenente una permutazione casuale degli interi da 1 a
	  <argname>n</argname>, senza ripetizione degli elementi. Se il
	  secondo argomento non è omesso, deve essere un intero nell'intervallo da 1
	  a <argname>n</argname>; in questo caso la funzione ritorna
	  un vettore riga contenente
	  <argname>k</argname> interi selezionati casualmente da 1 a
	  <argname>n</argname> senza sostituzione.
	</para>
	<para>
	  Se si desidera campionare <math>k</math> righe da una matrice
	  <lit>X</lit> con <math>n</math> righe (senza sostituzione),
	  ciò può essere ottenuto come mostrato di seguito:
	</para>
	<code>
	  matrix S = X[randperm(n, k),]
	</code>
	<para>
	  E se si desidera conservare l'ordine originale delle righe nel campione:
	</para>
	<code>
	  matrix S = X[sort(randperm(n, k)),]
	</code>
	<para>
	  Si veda <fncref targ="resample"/> per il campionamento con sostituzione.
	</para>
      </description>
    </function>

    <function name="randstr" section="strings" output="string">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una stringa casuale di lunghezza
	  <argname>n</argname> byte. La stringa include i numeri da
	  <lit>0</lit> a <lit>9</lit> e le lettere minuscole da
	  <lit>a</lit> a <lit>f</lit> con uguale probabilità, e è
	  interpretabile come un numero intero
	  esadecimale. Tipicamente, stringhe di questo tipo sono
	  usate come identificatori univoci. Ad esempio, con
	  <argname>n</argname> = 16 la stringa sarà una delle oltre
	  10<sup>19</sup> possibilità e quindi unica con probabilità
	  vicina a 1.
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">tol</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il rango di una matrice <argname>X</argname>
	  avente dimensione <by r="r" c="c"/> , calcolato
	  numericamente mediante la scomposizione a valori singolari
	  (SVD).
	</para>
	<para>
  	  Il risultato dell'operazione dipende dal numero di valori
  	  singolari di <argname>X</argname> numericamente diversi da
  	  0. Il parametro opzionale <argname>tol</argname> regola
  	  precisamente questo aspetto, in quanto un valore singolare è
  	  definito nullo ogniqualvolta minore di <math>m &times; tol
  	  &times; s</math>, dove <math>m</math> è il massimo tra
  	  <math>r</math> e <math>c</math>, mentre <math>s</math> il
  	  valore singolare più grande. Se omesso,
  	  <argname>tol</argname> sarà pari a <fncref
  	  targ="$macheps"/>. In certi casi, può essere necessario impostare
  	  <argname>tol</argname> a un valore più grande
  	  (p. es. 1.0e-9) per evitare di sovrastimare il rango di
  	  <argname>X</argname>, ciò che può portare a risultati
  	  numericamente instabili.
  	</para>
	<para>
	  <seelist>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una variabile o un vettore con i ranghi di <math>y</math>. Il
	  rango di un'osservazione <math>i</math> è pari al numero di
	  elementi della variabile minori di <math>y</math><sub>i</sub>
	  più metà del numero di elementi della serie uguali a
	  <math>y</math><sub>i</sub>. (Intuitivamente, è possibile
	  pensare al punteggio negli scacchi, dove per ogni vittoria
	  si assegna un punto mentre per ogni patta si assegna mezzo
	  punto.) Al numero così calcolato si aggiunge uno, cosicché
	  al rango più basso è associato 1 invece di 0.
	</para>
	<para context="tex">
	  In termini formali,
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \]
	  dove $I$ è la funzione indicatrice.
	</para>
	<para>
	  <seelist>
	    <fncref targ="sort"/>
	    <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il reciproco del numero di condizionamento
	  di <argname>A</argname> rispetto alla norma-1. In molte circostanze,
	  questa grandezza è migliore del determinante come misura di
	  sensibilità di <argname>A</argname> a operazioni numeriche
	  come l'inversione.
	</para>
	<para context="notex">
	  Il valore è calcolato come il reciproco del prodotto della
	  norma-1 di <argname>A</argname> per la norma-1 dell'inversa
	  di <argname>A</argname>.
	</para>
	<para context="tex">
	  Poiché <math>A</math> è invertibile, è possibile definire
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\]
	  Questa funzione restituisce $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
	    <fncref targ="det"/>
	    <fncref targ="ldet"/>
	    <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="Re" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna una matrice reale delle stesse dimensioni di
	  <argname>C</argname>, contenente la parte reale
	  della matrice. Si veda anche <fncref targ="Im"/>.
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg type="string" optional="true">codeset</fnarg>
      </fnargs>
      <description>
	<para>
	  Se un file di nome <argname>fname</argname> esiste ed è
	  leggibile, restituisce una stringa con il contenuto del
	  file. In caso contrario restituisce un errore.
	</para>
	<para>
	  Nel caso in cui <argname>fname</argname> inizia con
	  l'identificatore di un protocollo internet supportato
	  (<lit>http://</lit>, <lit>ftp://</lit>,
	  <lit>https://</lit>), la funzione richiama libcurl per
	  scaricare la risorsa.
	</para>
	<para>
	  Se il testo da leggere non ha una codifica UTF-8, gretl
	  cerca di ricodificarlo a partire dalla codifica locale, nel
	  caso non sia UTF-8, o da ISO-8859-15 in caso contrario. Se
	  questo comportamento predefinito non si adatta alle vostre
	  esigenze è possibile utilizzare il secondo argomento
	  opzionale per specificare la codifica. Per esempio, nel caso
	  si desideri leggere un testo nella codifica Microsoft codepage
	  1251, diversa dal sistema in uso in locale, è
	  possibile fornire come secondo argomento
	  <lit>"cp1251"</lit>.
	</para>
	<para>
	  Esempi:
	</para>
	<code>
	  string web_page = readfile("http://gretl.sourceforge.net/")
	  print web_page

	  string current_settings = readfile("@dotdir/.gretl2rc")
	  print current_settings
	</code>
	<para>
	  Si vedano anche le funzioni <fncref targ="sscanf"/> e
	  <fncref targ="getline"/>.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="string">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string">match</fnarg>
	<fnarg type="string">repl</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> è una stringa, restituisce una copia
	  di <argname>s</argname> in cui tutte le occorrenze del tipo
	  <argname>match</argname> sono sostituite con
	  <argname>repl</argname>. Gli argomenti
	  <argname>match</argname> e <argname>repl</argname> sono
	  interpretati come espressioni regolari in stile Perl. Se
	  <argname>s</argname> è un array o una serie a valori
	  stringa, l'operazione è effettuata su tutti i suoi elementi.
	</para>
	<para>
	  Si veda anche <fncref targ="strsub"/> per semplici
	  sostituzioni di stringhe letterali.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>
      <description>
	<para>
	  Se il file <argname>fname</argname> esiste e l'utente ha i
	  permessi di scrittura, lo cancella. Restituisce 0 se il comando
	  è andato a buon fine, non-zero se il file non esiste o non
	  può essere cancellato.
	</para>
	<para>
	  Se <argname>fname</argname> invece
	  non contiene un percorso completo, gretl darà per scontato
	  che il nome file è relativo alla <cmdref targ="workdir"/>
	  attuale.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">find</fnarg>
	<fnarg type="scalar-or-vec">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  Sostituisce ogni elemento di <argname>x</argname> uguale
	  all'<math>i</math>-esimo elemento di <argname>find</argname>
	  con il corrispondente elemento di <argname>subst</argname>.
	</para>
	<para>
	  Se <argname>find</argname> è uno scalare, anche
	  <argname>subst</argname> deve essere uno scalare. Se
	  <argname>find</argname> e <argname>subst</argname> sono
	  entrambi vettori, devono avere lo stesso numero di
	  elementi. Se infine <argname>find</argname> è un vettore e
	  <argname>subst</argname> uno scalare, tutte le
	  corrispondenze saranno sostituite con
	  <argname>subst</argname>.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  find = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, find, subst)
	  print a b
	</code>
	<para>
	  genera
	</para>
	<code>
	  a (2 x 3)

	  1   2   3
	  3   4   5

	  b (2 x 3)

	  -1    2   -8
	  -8    0    5
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">b</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
      </fnargs>
      <description>
	<para>
	  La descrizione iniziale di questa funzione pertiene al caso
	  cross-sezionale o di serie storiche; per il caso di dati
	  panel, vedi più sotto.
	</para>
	<para>
	  Ricampiona da <argname>x</argname> con reintroduzione. Nel
	  caso in cui l'argomento sia una variabile, ciascun valore della
	  variabile restituita, <math>y</math><sub>t</sub>, è estratto da
	  tutti i valori di <math>x</math><sub>t</sub> con uguale
	  probabilità. Quando l'argomento è una matrice, ciascuna riga
	  della matrice restituita è estratta dalle righe di
	  <argname>x</argname> con uguale probabilità.
	</para>
	<para>
	  L'argomento opzionale <argname>b</argname>, che deve essere
	  un numero intero maggiore o uguale a 2, indica la lunghezza
	  del blocco nel ricampionamento a blocchi mobili (moving
	  blocks). L'effetto è che l'output generato è il risultato di
	  un'estrazione casuale con reintroduzione dall'insieme di
	  tutte le possibili sequenze contigue di lunghezza
	  <argname>b</argname> nell'input. (Nel caso l'input sia una
	  matrice, i blocchi estratti sono sequenze contigue di righe
	  della matrice.) Se la lunghezza dei dati non è un multiplo
	  della lunghezza del blocco, l'ultimo blocco estratto è
	  troncato per adattarlo.
	</para>
	<subhead>Numero di estrazioni</subhead>
	<para>
	  Il default per il numero di osservazioni ricampionato in
	  output è uguale a quello dell'input&mdash; se
	  <argname>x</argname> è una serie, l'ampiezza del campione
	  attualmente in vigore; se <argname>x</argname> è una
	  matrice, il numero di righe.  Nel caso matriciale,
	  <emphasis>solo</emphasis> questo è aggiustabile tramite il
	  terzo argomento, che deve essere un intero positivo.
	  Nota: se <argname>b</argname> è maggiore di 1,
	  <argname>d</argname> si riferisce al numero di singole
	  osservazioni, non di blocchi.
	</para>
	<subhead>Panel data</subhead>
	<para>
	  Se l'argomento <argname>x</argname> è una serie e il dataset
	  è di tipo panel, il ricampionamento per blocchi mobili non è
	  previsto. Esso è disponibile solo nella sua forma più
	  semplice: i dati sono ricampionati <quote>per
	  unità</quote>. Ad esempio, in un panel con 100 unità
	  osservate su 5 periodi, la serie risultante dalla funzione
	  sarà essa stessa composta da 100 blocchi di 5 osservazioni:
	  ogni blocco sarà estratto con pari probabilità dalle 100
	  serie storiche individuali, preservandone l'ordine interno.
	</para>
      </description>
    </function>

    <function name="rgbmix" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="string">colore1</fnarg>
	<fnarg type="string">colore2</fnarg>
	<fnarg type="matrix">f</fnarg>
	<fnarg type="bool" optional="true">mostra</fnarg>
      </fnargs>
      <description>
	<para>
	  Dati due colori e un vettore <argname>f</argname> di
	  lunghezza <math>n</math> contenente valori in [0,1], questa
	  funzione restituisce un array di stringhe <math>n</math>, il
	  cui elemento <math>i</math>-esimo contiene il codice RGB
	  esadecimale per una combinazione della forma
	  (1-<math>f</math><sub>i</sub>) &times; <lit>colore1</lit> +
	  <math>f</math><sub>i</sub> &times; <lit>colore2</lit>. La
	  media ponderata viene rilevata sui canali Rosso, Verde e Blu
	  dei colori di input.
	</para>
	<para>
	  Gli argomenti colore possono essere specificati con nomi
	  conosciuti da <cmdref targ="gnuplot"/>, o come valori
	  esadecimali nella forma <lit>0xrrggbb</lit> o
	  <lit>#rrggbb</lit>. I valori esadecimali nella prima di
	  queste forme possono essere forniti numericamente,
	  altrimenti va usata una stringa. Se viene fornito un valore
	  diverso da zero per l'argomento <argname>mostra</argname>,
	  viene prodotto un grafico che mostra le miscele di colori.
	</para>
	<para>
	  Questa funzione offre un mezzo per generare un insieme di
	  colori correlati quando si creano dei grafici. Il caso d'uso
	  principale è quando si hanno più bande in un grafico (ad
	  esempio, per indicare intervalli di confidenza a più di un
	  livello). Seguono tre esempi: il primo produce tinte sempre
	  più chiare di un blu iniziale; il secondo un rosa sempre più
	  scuro e il terzo una transizione dal rosso al giallo.
	</para>
	<code>
	  f = {0, 0.5, 0.75, 0.875, 0.9375}
	  mixes = rgbmix(0x1b43dc, "white", f, 1)
	  print mixes
	  f = {0, 0.1, 0.2, 0.3, 0.4}
	  rgbmix(0xefd0d3, "black", f, 1)
	  f = {0, 0.2, 0.4, 0.6, 0.8, 1}
	  rgbmix("red", "yellow", f, 1)
	</code>
	<para>
	  L'output del comando <lit>print</lit> nel primo esempio è
	</para>
	<code>
	  [1] "0x1b43dc"
	  [2] "0x8da1ee"
	  [3] "0xc6d0f6"
	  [4] "0xe2e8fb"
	  [5] "0xf1f3fd"
	</code>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Approssima all'intero più vicino. Si noti che, quando
	  <math>x</math> si trova esattamente nel mezzo tra due numeri
	  interi, la funzione restituisce l'intero più distante da
	  zero. Così, per esempio, 2.5 è approssimato a 3, ma
	  <lit>round(-3.5)</lit> restituisce &minus;4. Questa è la
	  convenzione di solito seguita nei fogli di calcolo, anche se
	  altri programmi possono seguire convenzioni diverse.
	  <seelist>
	    <fncref targ="ceil"/>
	    <fncref targ="floor"/>
	    <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Se viene dato l'argomento <argname>r</argname>, ritorna il
	  nome per quella riga della matrice
	  <argname>M</argname>. Se <argname>M</argname> non ha nomi di
	  riga viene restituita una stringa vuota; si ha errore se
	  <argname>col</argname> non è un numero di riga.
	</para>
	<para>
	  Se il secondo argomento non viene fornito, il risultato è un
	  array di stringhe coi nomi di riga di
	  <argname>M</argname> se ne ha, altrimenti un array vuoto.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  rnameset(A, "Uno Due")
	  string name = rnameget(A, 2)
	  print name
	</code>
	<para>
	  <seelist>
	    <fncref targ="rnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameset" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Attribuisce dei nomi alle righe della matrice
	  <argname>M</argname> di dimensioni <by r="m" c="n"/>.  Se
	  <argname>s</argname> è una lista, i nomi sono copiati da quelli
	  delle variabili; la lista deve avere tanti elementi quante sono
	  le righe di <argname>M</argname>. Se <argname>S</argname> è un
	  array di stringhe, deve contenere <math>m</math> elementi; se
	  invece è una sola stringa, deve contenere <math>m</math>
	  sub-stringhe separate da spazi.
	</para>
	<para>
	  Restituisce 0 se la funzione è andata a buon fine;
	  altrimenti, sarà generato un errore. Si veda anche <fncref
	  targ="cnameset"/>.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  matrix M = {1,2;2,1;4,1}
	  strings S = array(3)
	  S[1] = "Row1"
	  S[2] = "Row2"
	  S[3] = "Row3"
	  rnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="rows" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di righe della matrice
	  <argname>X</argname>.
	  <seelist>
	    <fncref targ="cols"/>
	    <fncref targ="mshape"/>
	    <fncref targ="unvech"/>
	    <fncref targ="vec"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="schur" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;Z</fnarg>
	<fnarg type="matrixref" optional="true">&amp;w</fnarg>
      </fnargs>
      <description>
	<para>
	  Esegue la decomposizione di Schur della matrice complessa
	  <argname>A</argname>, ritornando una matrice complessa triangolare
	  alta <math>T</math>. Se è inserito il secondo argomento ed
	  esso non è <lit>null</lit> la funzione ritorna una matrice complessa
	  <math>Z</math> contenente i vettori di Schur associati ad
	  <math>A</math> e <math>T</math>, tale che <math>A</math>
	  = <math>ZTZ</math><sup>H</sup>. Se è inserito un terzo
	  argomento ritorna gli autovalori di <math>A</math> in un
	  vettore colonna complesso.
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> è una variabile, restituisce l'errore
	  quadratico medio campionario (scalare) saltando i valori
	  mancanti.
	</para>
	<para>
	  Se, invece, <argname>x</argname> è una lista, restituisce
	  una variabile <math>y</math> tale per cui
	  <math>y</math><sub>t</sub> è l'errore quadratico medio delle
	  variabili nella lista all'osservazione <math>t</math>, o
	  <lit>NA</lit> se ci sono dei valori mancanti
	  <math>t</math>. Per default, la funzione ritorna
	  <lit>NA</lit> se ci si sono dei missing a <math>t</math>, ma
	  se si passa un valore non-zero come opzione
	  <argname>partial</argname> la statistica sarà calcolata sui
	  soli dati validi.
	</para>
	<para>
	  <seelist>
	    <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce le deviazioni standard delle colonne di
	  <argname>X</argname>. Se <argname>df</argname> è positivo, è
	  utilizzato come divisore nel calcolo delle varianze delle
	  colonne, in caso contrario il divisore utilizzato è il
	  numero di righe di <argname>X</argname> (in altre parole non
	  viene applicata nessuna correzione per i gradi di
	  libertà). Se viene specificato un valore diverso da zero per
	  il terzo argomento opzionale, i valori mancanti vengono
	  ignorati, altrimenti il ​​risultato è <lit>NA</lit> per tutte
	  le colonne che contengono valori mancanti.
	</para>
	<para>
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola le differenze stagionali: <equation status="inline"
	  ascii="y(t) - y(t-k)" tex="$y_t - y_{t-k}$"/>, dove
	  <math>k</math> è la periodicità del dataset corrente (si
	  veda <fncref targ="$pd"/>). I valori iniziali sono fissati a
	  <lit>NA</lit>.
	</para>
	<para>
	  Quando viene restituita una lista alle singole variabili viene
	  automaticamente assegnato un nome secondo il formato
	  <lit>sd_</lit><repl>varname</repl>, dove <repl>varname</repl> è
	  il nome della variabile originaria. Se necessario il nome viene
	  troncato e può essere modificato in caso di non unicità
	  all'interno dell'insieme di nomi costruiti in questo modo.
	</para>
	<para>
	  <seelist>
	    <fncref targ="diff"/>
	    <fncref targ="ldiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">baseline</fnarg>
	<fnarg optional="true" type="bool">center</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente è
	  di tipo temporale ed ha una periodicità maggiore di
	  1. ritorna una lista di variabili dummy per i sottoperiodi,
	  chiamate <lit>S1</lit>, <lit>S2</lit> eccetera.
	</para>
	<para>
	  L'argomento <argname>baseline</argname> (opzionale) serve ad
	  escludere un sottoperiodo. Ad esempio, con
	  <argname>baseline</argname> uguale ad 1 e dati trimestrali
	  la lista risultato conterrà dummy per il 2°, 3° e 4°
	  trimestre.  Se questo argomento è zero o omesso, verrò
	  creata l'intera lista; se non-zero, dev'essere un intero
	  compreso fra 1 e la periodicità dei dati.
	</para>
	<para>
	  L'argomento <argname>center</argname>, se non-zero, fa sì
	  che vengano generate dummy centrate. Per esempio, con dati
	  trimestrali le dummy centrate assumono valori di &minus;0,25
	  e 0,75 anziché 0 e 1.
	</para>
	<para>
	  Con dati settimanali l'effetto dipende a seconda se i dati
	  sono datati o no. Se sì, venfono create fino a 53 serie
	  stagionali, sulla base del numero progressivo ISO 8601 (si
	  veda la funzione <fncref targ="isoweek"/>); altrimenti, il
	  numero massimo di serie è 52 (cosicché nel lungo termine
	  le dummy <quote>stagionali</quote> finiranno fuori sincrono
	  con l'anno). Nel caso datato, per creare dummy mensili si
	  può fare così:
	</para>
	<code>
	  series month = $obsminor
	  list months = dummify(month)
	</code>
	<para>
	  Si veda <fncref targ="dummify"/> per maggiori dettagli.
	</para>
      </description>
    </function>

    <function name="selifc" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Seleziona da <argname>A</argname> solo le colonne per le
	  quali l'elemento corrispondente di <argname>b</argname> è
	  non nullo. <argname>b</argname> deve essere un vettore riga
	  con lo stesso numero di colonne di <argname>A</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Seleziona da <argname>A</argname> solo le righe per le quali
	  l'elemento corrispondente di <argname>b</argname> è
	  non nullo. <argname>b</argname> deve essere un vettore
	  colonna con lo stesso numero di righe di
	  <argname>A</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifc"/>
	    <fncref targ="trimr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matrix" output="rvec">
      <fnargs>
	<fnarg type="int">a</fnarg>
	<fnarg type="int">b</fnarg>
	<fnarg optional="true" type="int">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Con due soli argomenti, restituisce un vettore riga di
	  interi consecutivi, con <argname>a</argname> come primo
	  elemento e <argname>b</argname> come ultimo. Se
	  <argname>a</argname> è maggiore di <argname>b</argname>, la
	  sequenza sarà decrescente. L'eventuale parte non intera
	  viene ignorata per entrambi gli argomenti.
	</para>
	<para>
	  In caso sia presente il terzo argomento, la funzione
	  restituisce un vettore riga contenente una sequenza di
	  interi che inizia con <argname>a</argname> e in
	  ciascun passaggio è incrementata
	  (o diminuita, nel caso in cui <argname>a</argname> sia
	  maggiore di <argname>b</argname>) di <argname>k</argname>.
	  Il valore finale è il più grande elemento
	  della sequenza minore o uguale a <argname>b</argname> (o
	  mutatis mutandis, nel caso in cui <argname>a</argname> sia
	  maggiore di <argname>b</argname>). L'argomento
	  <argname>k</argname> deve essere positivo; nel caso non sia
	  un intero la parte decimale è ignorata.
	</para>
	<para>
	  <seelist>
	    <fncref targ="ones"/>
	    <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
	<fnarg type="string">note</fnarg>
      </fnargs>
      <description>
	<para>
	  Imposta una nota descrittiva per l'oggetto identificato
	  dalla chiave <argname>key</argname> nel bundle
	  <argname>b</argname>.  Essa verrà mostrata quando il comando
	  <lit>print</lit> viene applicato al bundle. Questa funzione
	  restituisce 0 se è andata a buon fine e non nullo in caso
	  contrario (ad esempio, se nel bundle <argname>b</argname> non esiste un
	  oggetto associato alla chiave <argname>key</argname>).
	</para>
      </description>
    </function>

    <function name="sgn" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna il segno di <argname>x</argname>, ossia
	  0 se <argname>x</argname> è zero, 1 se <argname>x</argname> è
	  positivo, &minus;1 se <argname>x</argname> è negativo, o
	  <lit>NA</lit> se <argname>x</argname> è un non-numero (Not a
	  Number).
	</para>
      </description>
    </function>

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Implementa il simulated annealing (letteralmente "ricottura
	  simulata", che prende il nome dal processo di ricottura
	  utilizzato per migliorare le caratteristiche delle leghe
	  metalliche), che può essere utile nel migliorare
	  l'inizializzazione nei problemi di ottimizzazione numerica.
	</para>
	<para>
	  Il primo argomento deve contenere il valore iniziale di un
	  vettore di parametri. Il secondo argomento specifica la
	  funzione da chiamare che restituisce il valore (scalare)
	  da massimizzare. Il terzo argomento, opzionale, specifica il
	  massimo numero di iterazioni (il valore predefinito è
	  1024). In caso di successo, <lit>simann</lit> restituisce il
	  valore finale del massimando.
	</para>
	<para>
	  Per maggiori dettagli ed esempi si veda il capitolo sui
	  metodi numerici in <guideref targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
	    <fncref targ="NRmax"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione seno di <argname>x</argname>.
	  <seelist>
	    <fncref targ="cos"/>
	    <fncref targ="tan"/>
	    <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il seno iperbolico di <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="asinh"/>
	    <fncref targ="cosh"/>
	    <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il valore dell'indice di asimmetria per la serie
	  <argname>x</argname>, non considerando le osservazioni
	  mancanti.
	</para>
      </description>
    </function>

    <function name="sleep" section="programming" output="scalar">
      <fnargs>
	<fnarg type="int">ns</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione probabilmente inutile in circostanze normali, ma
	  non per testare metodi parallelizzati. Questa funzione
	  <quote>narcotizza</quote> il thread corrente per
	  <argname>ns</argname> secondi. Al risveglio, la funzione
	  restituisce 0.
	</para>
      </description>
    </function>

    <function name="smplspan" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">inizio</fnarg>
	<fnarg type="string">fine</fnarg>
	<fnarg type="int">pd</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna il numero di osservazioni che separano
	  <argname>inizio</argname> da <argname>fine</argname>
	  (estremi inclusi) per un dataset di serie storiche con
	  frequenza <argname>pd</argname>.
	</para>
	<para>
	  I primi due argomenti devono essere forniti nella forma
	  usata in gretl per dati annuali, trimestrali o mensili
	  &mdash; ad esempio, <lit>1970</lit>, <lit>1970:1</lit> o
	  <lit>1970:01</lit>, rispettivamente; in alternativa, possono
	  essere usate date in formato ISO 8601,
	  <lit>YYYY-MM-DD</lit>.
	</para>
	<para>
	  L'argomento <argname>pd</argname> può essere pari a 1, 4 o
	  12 (annuale, trimestrale, mensile), una delle frequenze
	  giornaliere (5, 6, 7), oppure 52 (settimanale). Se
	  <argname>pd</argname> è 1, 4 o 12, date ISO 8601 sono
	  accettate come primi due argomenti solo se indicano l'inizio
	  del periodo in questione. Ad esempio,
	  <lit>2015-04-01</lit> è un sostituto accettabile di
	  <lit>2015:2</lit> per il secondo trimestre 2015.
	</para>
	<para>
	  Se si ha già un dataset di periodicità <argname>pd</argname>
	  con abbastanza osservazioni, il risultato di questa funzione
	  può essere facilmente emulato usando  <fncref
	  targ="obsnum"/>. Il vantaggio di <lit>smplspan</lit> sta nel
	  fatto che è facile calcolare il risultato anche senza avere
	  un dataset aperto, cosa che può essere comoda nel creare
	  dataset vuoti o artificiali. Segue un esempio:
	</para>
	<code>
	  scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  nulldata T
	  setobs 7 2010-01-01
	</code>
	<para>
	  produce
	</para>
	<code>
	  ? scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  Generato lo scalare T = 1565
	  ? nulldata T
	  Periodicità: 1, oss. max.: 1565
	  Intervallo delle osservazioni: 1-1565
	  ? setobs 5 2010-01-01
	  Campione completo dei dati: 2010-01-01 - 2015-12-31 (n = 1565)
	</code>
	<para>
	  Dove il fatto che l'ultima osservazione creata dal comando
	  <cmdref targ="nulldata"/> sia <lit>2015-12-31</lit> è
	  garantito per costruzione. Si noti che il numero 1565 non
	  sarebbe stato banale da calcolare con altri metodi.
	</para>
      </description>
    </function>

    <function name="sort" section="matrix" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordina <argname>x</argname> in senso crescente. Se
	  <math>x</math> è una serie, le osservazioni mancanti sono
	  saltate. Se invece è un vettore sono poste in fondo.
	  <seelist>
	    <fncref targ="dsort"/>
	    <fncref targ="values"/>
	  </seelist>
	  In particolare, per le matrici si veda <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una variabile contenente gli elementi di
	  <argname>y2</argname> ordinati per valore crescente del
	  primo argomento, <argname>y1</argname>.
	  <seelist>
	    <fncref targ="sort"/>
	    <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sphericorr" section="stats" output="matrix">
      <fnargs>
       <fnarg type="matrix">X</fnarg>
       <fnarg type="int">mode</fnarg>
       <fnarg type="matrixref" optional="true">&amp;J</fnarg>
      </fnargs>
      <description>
       <para>
	 Calcola la rappresentazione in coordinate sferiche di una
	 matrice di correlazione o la sua inversa, a seconda del
	 parametro <argname>mode</argname>.
       </para>
       <para>
	 Quando <argname>mode</argname> è 0 oppure omesso,
	 <argname>X</argname> deve essere una matrice di correlazione
	 <by r="n" c="n"/>. In quetso caso, la funzione restituisce un
	 vettore di <math>n(n-1)/2</math> tra 0 e &pi; L'argomento
	 <argname>&amp;J</argname>, se presente, viene ignorato.
       </para>
       <para>
	 L'operazione inversa si ha quando <argname>mode</argname> è 1
	 o 2, e quindi <argname>X</argname> deve essere un vettore di
	 <math>n(n-1)/2</math> elementi fra 0 e &pi;. La matrice
	 risultato dipende dall'argomento <argname>mode</argname>. Se
	 <argname>mode</argname> è 1, il risultato sarà la matrice di
	 correlazione <math>R</math>; se <argname>mode</argname> è 2,
	 la sua scomposizione di Cholesky <math>K</math>. Il parametro
	 <argname>&amp;J</argname>, se presente, conterrà la jacobiana
	 di <math>vech(R)</math> o <math>vech(K)</math> (a seconda del
	 valore di <argname>mode</argname>) rispetto a <math>X</math>.
       </para>
       <para>
	 Si noti che la  rappresentazione in coordinate sferiche rende
	 molto semplice ed efficiente il calcolo del log-determinante
	 di <math>R</math>:
	</para>
       <code>
	 omega = sphericorr(R)
	 log_det = 2 * sum(log(sin(omega)))
	</code>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">formato</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Ritorna una stringa contenente la stampa dei valori degli
	  argomenti successivi, indicati dai puntini, sotto il
	  controllo della stringa <argname>formato</argname>. Questa
	  funzione fornisce un metodo molto potente e flessibile per
	  creare stringhe. la stringa <argname>formato</argname>
	  fornisce la chiave per definire precisamente il modo con cui
	  gli argomenti vengono stampati.
	</para>
	<para>
	  In generale, <argname>formato</argname> dev'essere
	  un'espressione che ritorna una stringa, ma di solito è una
	  costante (una sequenza alfanumerica racchiusa fra virgolette
	  doppie). Alcune sequenze hanno un significato speciale:
	  quelle che cominciano con un percento (%) sono interpretate
	  come <quote>segnaposto</quote> per gli elementi contenuti
	  nella lista degli argomenti; inoltre, caratteri speciali
	  come il segno di <quote>a capo</quote> vengono rappresentati
	  con una barra rovesciata.
	</para>
	<para>
	  Ad esempio, il codice
	</para>
	<code>
	  scalar x = sqrt(5)
	  string claim = sprintf("la radice di %d è più o meno %6.4f.\n", 5, x)
	  print claim
	</code>
	<para>
	  darà
	</para>
	<code>
	  la radice di 5 è più o meno 2.2361.
	</code>
	<para>
	  dove <lit>%d</lit> indica che vogliamo un intero in quel
	  punto dell'output; poiché tale espressione è il
	  <quote>percento</quote> più a sinistra, essa viene associata
	  al primo argomento, ossia 5. La seconda sequenza speciale è
	  <lit>%6.4f</lit>, che indica un valore decimale con 4 cifre
	  dopo il separatore decimale e larga almeno 6 cifre. Il
	  numero di tali sequenza deve coincidere col numero di
	  argomenti dopo la stringa di formato.
	</para>
	<para>
	  Per maggiori dettagli sulla sintassi delle stringhe di
	  formato, si veda l'help del comando <cmdref targ="printf"/>.
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Radice quadrata di <argname>x</argname>; genera <lit>NA</lit> in
	  caso di valori negativi.
	</para>
	<para>
	  Si noti che se l'argomento è una matrice l'operazione viene
	  effettuata elemento per elemento. Per la <quote>radice quadrata
	  matriciale</quote>, v. <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">cross-products</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna una lista contenente le variabili nella lista
	  <argname>L</argname> al quadrato, con nomi basati sul
	  modello <lit>sq_</lit><repl>varname</repl>.  Se il secondo
	  argomento (opzionale) è presente e ha valore non-zero,
	  vengono inclusi anche i prodotti incrociati delle variabili
	  in <argname>L</argname>; i nomi sono basati sul modello
	  <repl>var1</repl><lit>_</lit><repl>var2</repl>.  I nomi
	  delle serie risultato potrebbero venir troncati se troppo
	  lunghi, e aggiustati per evitare duplicazioni.
	</para>
	<para>
	  Si noti che le variabili dummy verranno saltate durante il
	  calcolo dei quadrati per evitare di produrre una serie
	  identica, ma verrà calcolato il loro prodotto (anche noto
	  come <quote>interazione</quote>) con le altre serie nella lista
	  di input <argname>L</argname>.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string">src</fnarg>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Legge valori da <argname>src</argname> seguendo il formato
	  <argname>format</argname> e assegna questi valori a uno o
	  più degli q argomenti seguenti, rappresentati dai
	  punti. Restituisce il numero di valori assegnati. Questa
	  funzione rappresenta una versione semplificata della
	  funzione <lit>sscanf</lit> usata nel linguaggio di
	  programmazione C.
	</para>
	<para>
	  La <repl>stringa</repl> può essere una stringa vera e
	  propria, racchiusa tra virgolette doppie, o il nome di una
	  variabile stringa predefinita. <repl>format</repl> è
	  definito in modo simile alla stringa di formato del comando
	  <cmdref targ="printf"/> (si veda oltre). <repl>args</repl> è
	  una lista separata da virgole che contiene i nomi di
	  variabili predefinite cui verranno assegnati i valori letti
	  da <repl>src</repl>. (Per chi conosce C: è possibile ma non
	  indispensabile prefissare con <lit>&amp;</lit> i nomi delle
	  variabili numeriche).
	</para>
	<para>
	  Le regole specificate in <repl>format</repl> vengono usate
	  per analizzare <repl>src</repl>. Le specifiche iniziano con
	  un carattere <lit>%</lit>, e comprendono <lit>%f</lit>,
	  <lit>%g</lit> o <lit>%lf</lit> per i numeri a virgola
	  mobile; <lit>%d</lit> per gli interi; <lit>%s</lit> per le
	  stringhe, e <lit>%m</lit> per le matrici. È possibile
	  inserire un numero intero positivo dopo il carattere
	  percentuale per impostare il numero massimo di caratteri da
	  leggere per ogni tipo di specifica (o il numero massimo di
	  righe nel caso di conversione in matrici). In alternativa, è
	  possibile inserire un carattere <lit>*</lit> dopo il
	  percentuale per sopprimere la conversione di un certo numero
	  di caratteri della stringa (e saltando così eventuali
	  caratteri che in caso contrario verrebbero convertiti per un
	  certo tipo). Ad esempio, <lit>%3d</lit> converte i 3
	  caratteri successivi di <repl>src</repl> in un numero
	  intero, se possibile; <lit>%*g</lit> salta tutti i caratteri
	  in <repl>src</repl> che potrebbero essere convertiti in un
	  numero a virgola mobile.
	</para>
	<para>
	  Oltre alla conversione di <lit>%s</lit> per le stringhe, è
	  disponibile anche una versione semplificata del formato C
	  <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit>.
	  In questo formato, <repl>N</repl> è il numero massimo di
	  caratteri da leggere, e <repl>chars</repl> è un insieme di
	  caratteri accettabili, racchiusi tra parentesi quadre; la
	  lettura si ferma se si raggiunge il limite di <repl>N</repl>
	  o se si incontra un carattere non compreso nell'insieme
	  ammissibile. La funzione dell'insieme <repl>chars</repl> può
	  essere invertita specificando un accento circonflesso
	  <lit>^</lit> come primo carattere dell'insieme; in questo
	  caso, la lettura si ferma se si incontra un carattere
	  dell'insieme specificato. Al contrario del C, il carattere
	  trattino non ha alcuna funzione speciale in questo contesto.
	</para>
	<para>
	  Se la stringa <repl>src</repl> non è pienamente conforme al
	  formato, il numero di conversioni effettuate potrà essere
	  minore del numero di argomenti. Dal punto di vista di gretl,
	  questo non è un errore di per sé.  Tuttavia, è consigliabile
	  controllare il numero di conversioni effettivamente portate
	  a termine, che è dato dal valore in uscita della
	  funzione. Ad esempio:
	</para>
	<code>
	  # lettura di scalari
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)
	  # lettura di stringhe
	  string s = "uno due"
	  string s1
	  string s2
	  sscanf(s, "%s %s", s1, s2)
	  print s1 s2
	</code>
	<subhead>Matrici</subhead>
	<para>
	  La lettura di matrici è attivata dalla specifica di
	  conversione <quote><lit>%m</lit></quote>. Inserendo un
	  intero fra il segno <quote><lit>%</lit></quote> e il
	  carattere <quote><lit>m</lit></quote> si può limitare il
	  numero di righe da leggere. Esistono due varianti:
	  quella in cui <argname>src</argname> è un'unica stringa che
	  contiene la matrice, e quella in cui <argname>src</argname>
	  è un array di stringhe. Segue la loro descrizione.
	</para>
	<para>
	  Se <argname>src</argname> è una stringa singola, la
	  conversione in matrici funziona così: viene letta ogni riga
	  dell'input e vengono contati i campi numerici (separati da
	  spazi o tabulatori). In questo modo viene definito il numero
	  di colonne della matrice.  Vengono quindi lette tutte le
	  righe seguenti che contengono lo stesso numero di colonne
	  numeriche, ma è comunque possibile limitare il numero
	  massimo di righe da leggere procedendo come descritto sopra.
	</para>
	<para>
	  Se <argname>src</argname> è un array di stringhe, l'output
	  è necessariamente un vettore colonna, in cui ogni elemento è
	  la conversione numerica dell'elemento corrispondente dell'array, o
	  <lit>NA</lit> se la stringa non è numerica. Ecco alcuni
	  semplici esempi.
	</para>
	<code>
	  # una singola stringa
	  string s = sprintf("1 2 3 4\n5 6 7 8")
	  print s
	  matrix m
	  sscanf(s, "%m", m)
	  print m
	  # un array di stringhe
	  strings S = defarray("1.1", "2.2", "3.3", "4.4", "5.5")
	  sscanf(S, "%4m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la somma dei quadrati degli scarti dalla media per le
	  osservazioni valide nella variabile <argname>y</argname>.
	  <seelist>
	    <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="stack" section="panel" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Usato per manipolare dati nel formato <quote>serie storiche
	  sovrapposte</quote> richiesto da gretl per dati
	  panel. Ritorna una serie ottenuta accostando
	  <quote>verticalmente</quote> <argname>n</argname> osservazioni
	  da ogni serie nella lista <argname>L</argname>. Per default,
	  le prime <argname>n</argname> osservazioni vengono usate
	  (quando <argname>offset</argname> = 0), ma il punto di
	  partenza può essere spostato verso il basso usando dando un
	  valore positivo a <argname>offset</argname>. Se la seri
	  risultate è più lunga del dataset in uso, vengono
	  autometicamente aggiunte le osservazioni che mancano.
	</para>
	<para>
	  Questa funzione serve a gestire sia il caso in cui un file
	  di dati contiene tante serie temporali quante sono le unità
	  cross-sezionali, sia il caso in cui il tempo scorre
	  <quote>orizzontalmente</quote> e ogni riga è un'unità
	  cross-sezionale.
	</para>
	<para>
	  Si veda la sezione <quote>Panel data specifics</quote>
	  in <guideref targ="chap:datafiles"/> per dettagli ed esempi.
	</para>
      </description>
    </function>

    <function name="stdize" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-list-or-mat">X</fnarg>
	<fnarg type="int" optional="true">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Di default ritorna una versione standardizzata della serie,
	  lista o matrice: l'input è centrato e diviso dalla sua
	  deviazione standard campionaria (con una correzione di
	  gradi di libertà di 1). I risultati sono calcolati in colonna nel
	  caso di una matrice.
	</para>
	<para>
	  Il secondo argomento (opzionale) può essere utilizzato per
	  influenzare il risultato.Un valore non negativo di <argname>v</argname>
	  imposta la correzione di gradi di libertà usata  nella deviazione
	  standard, cosicché <argname>v</argname> = 0 dia lo stimatore di
	  massima verosimiglianza. Come caso speciale, se
	  <argname>v</argname> è uguale a &minus;1 è eseguita solo
	  la centratura.
	</para>
	<para>
	  Per default, i valori mancanti vengono automaticamente
	  saltati se l'input è una serie o una lista, ma non se è una
	  matrice. Per ignorare i valori mancanti in questo ultimo
	  caso, va fornito un valore non-zero per
	  <argname>skip_na</argname>.
	</para>
      </description>
    </function>

    <function name="strfday" section="calendar" output="depends">
      <fnargs>
	<fnarg type="anyfloat">eday</fnarg>
	<fnarg type="string" optional="true">formato</fnarg>
      </fnargs>
      <description>
	<para>
	 Questa funzione è quasi uguale a <fncref targ="strftime"/>,
	 nel senso che converte un valore numerico a una stringa
	 usando il parametro <argname>formato</argname>. In questa
	 funzione, tuttavia, l'input è un numero in formato
	 <quote>epoch</quote>, per la cui definizione si veda <fncref
	 targ="epochday"/>.  Poiché la risoluzione è giornaliera, sono
	 gestiti solo formati con specificatorei di data; quel che
	 succede con specificatori di ora non è definito.
	</para>
        <para>
          Se il secondo argomento è omesso, il formato di default è lo
          ISO 8601 esteso, <lit>YYYY-MM-DD</lit>.
        </para>
      </description>
    </function>

    <function name="strftime" section="calendar" output="string">
      <fnargs>
	<fnarg type="scalar">tm</fnarg>
	<fnarg optional="true" type="string">formato</fnarg>
	<fnarg optional="true" type="scalar">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  L'argomento <argname>tm</argname> viene utilizzato per
	  fornire lo <quote>Unix time</quote>, il numero di secondi
	  dall'inizio dell'anno 1970 secondo UTC, e il valore
	  restituito è una stringa che fornisce la data e/o l'ora
	  corrispondente, in un formato specificato tramite il secondo
	  argomento facoltativo o, per default, la
	  <quote>rappresentazione di data e ora preferita per le
	  impostazioni locali correnti</quote> come determinato dalla
	  libreria C di sistema. Si veda sotto per più dettagli
	  sul formato.
	</para>
	<para>
	  L'argomento facoltativo <argname>offset</argname> può essere
	  utilizzato per specificare un divario in secondi rispetto a
	  UTC, selezionando così un fuso orario diverso da quello
	  predefinito, che è sempre l'ora locale. Ad esempio, un
	  offset di 3600 seleziona il fuso orario dell'Europa
	  centrale, mentre 0 seleziona GMT. Il valore assoluto di
	  <argname>offset</argname> non deve superare 86400 (24
	  ore). </para>
	<para>
	  Il tipo dell'output dipende da quello di
	  <argname>tm</argname>: se <argname>tm</argname> è uno
	  scalare, un vettore o una serie, l'output è,
	  rispettivamente, una singola stringa, un array di stringhe o
	  una serie con valori stringa.
	</para>
	<para>
	  I valori di <argname>tm</argname> adatti all'uso con questa
	  funzione possono essere ottenuti tramite l'accessore <fncref
	  targ="$now"/> o la funzione <fncref targ="strptime"/>.
	</para>
	<para>
	  Nota che mentre <argname>tm</argname> è preso come relativo
	  a UTC, l'output di questa funzione è per impostazione
	  predefinita <quote>locale</quote>, relativo all'impostazione
	  del fuso orario sul computer host. Un dato
	  <argname>tm</argname> mostrerà quindi un orario diverso e
	  forse una data diversa, in fusi orari diversi. Se si
	  desidera una stringa che rappresenti l'UTC anziché l'ora
	  locale, vedi sotto.
	</para>
	<subhead>Opzioni di formato</subhead>
	<para>
	  Le opzioni di formattazione standard possono essere trovate
	  consultando la pagina di manuale <lit>strftime</lit>, sui
	  sistemi che hanno tali pagine, o tramite uno dei tanti siti
	  web che presentano informazioni rilevanti, come
	  <url>https://devhints.io/strftime</url>. Oltre ai formati
	  standard, gretl riconosce un'opzione speciale: se
	  <argname>format</argname> è semplicemente
	  <quote><lit>8601</lit></quote>, la data e l'ora vengono
	  mostrate nel formato ISO 8601.
	</para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Serve a definire valori di stringa per la serie
	  <argname>y</argname>. Affinché la cosa funzioni, ci sono due
	  condizioni: la serie risultante deve contenere solo interi
	  maggiori o uguali a 1, e l'array <argname>S</argname> deve
	  contenere almeno <math>n</math> elementi, dove
	  <math>n</math> è il massimo valore in <argname>y</argname>.
	  In più, ogni elemento di <argname>S</argname> deve contenere
	  caratteri validi secondo la codifica UTF-8. Se la funzione
	  bva a uon fine, ritorna 0.
	</para>
       <para>
	 In certi contesti può essere utile un'alternativa a
	 <lit>stringify</lit>, che consiste nell'assegnazione diretta
	 di un array di stringhe a una serie: il risultato conterrà le
	 stringhe presenti nell'array, in sequenza, ripetute se
	 serve. Il numero di elementi dell'array deve essere pari alla
	 dimensione complessiva del dataset o al numero di
	 osservazioni del sottocampione corrente.
       </para>
	  <seelist>
	    <fncref targ="strvals"/>
	    <fncref targ="strvsort"/>
	  </seelist>
      </description>
    </function>


    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string-or-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> è una stringa, restituisce il numero
	  di caratteri di cui è composta. Si noti che questo può non
	  coincidere col numero di byte se sono presenti caratteri al
	  di fuori del campo ASCII stampabile (ad esempio, lettere
	  accentate); il numero effettivo di byte può essere ricavato
	  tramite la funzione <fncref targ="nelem"/>. Ad esempio:
	</para>
	<code>
	  string s = "¡Olé!"
	  printf "strlen(s) = %d, nelem(s) = %d\n", strlen(s), nelem(s)
	</code>
	<para>
	  should return
	</para>
	<code>
	  strlen(s) = 5, nelem(s) = 7
	</code>
	<para>
	  Se l'argomento è un array di stringhe, il valore ritornato è
	  un vettore colonna col numero di caratteri per ognuna di
	  esse.  Se, infine, l'argomento è una serie i cui valori
	  hanno una codifica come stringa, il valore ritornato è esso
	  stesso una serie contenente la lunghezza delle stringhe nel
	  sottocampione attualmente in uso.
	</para>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Confronta le due stringhe fornite come argomenti e restituisce
	  un intero minore, uguale, o maggiore di zero se
	  <argname>s1</argname> risulta rispettivamente essere
	  minore, combaciare, o essere maggiore di
	  <argname>s2</argname>, fino ai primi <argname>n</argname>
	  caratteri.  Se <argname>n</argname> è omesso, il confronto
	  procede fin dove possibile.
	</para>
	<para>
	  Si noti che per verificare l'uguaglianza di due stringhe
	  non è necessaria alcuna funzione, come in <lit>if (s1
	  == s2) ...</lit>
	</para>
      </description>
    </function>


    <function name="strpday" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string" optional="true">formato</fnarg>
      </fnargs>
      <description>
	<para>
	 Questa funzione è quasi uguale a <fncref targ="strptime"/>, a
	 parte il fatto che il valore restituito in output è un
	 <quote>epoch day</quote>, per la cui definizione si rimanda a
	 <fncref targ="epochday"/>.  Visto che la risoluzione è a
	 livello di giorno, qualsiasi informazione infragiornaliera
	 (come ad esmepio le ore) in <argname>s</argname> viene
	 ignorata.
	</para>
      </description>
    </function>

    <function name="strptime" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="int-or-string">s</fnarg>
	<fnarg type="string" optional="true">formato</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è l'inverso di <fncref targ="strftime"/>;
	  analizza la stringa <argname>s</argname> come data/ora usando
	  il <argname>formato</argname> specificato e restituisce  il
	  numero di secondi dall'inizio del 1970 (UTC).
	</para>
	<para>
	  Se l'argomento <argname>formato</argname> viene omesso, il
	  default è il formato ISO 8601 <quote>esteso</quote>, e cioè
	  <lit>YYYY-MM-DD</lit> (che sarebbe
	  <quote><lit>%Y-%m-%d</lit></quote> come formato
	  <argname>strptime</argname>).  In alternativa, il primo
	  argomento può essere un intero ad 8 cifre conforme alla
	  specificazione ISO 8601 <quote>di base</quote>,
	  <lit>YYYYMMDD</lit> (per esempio, 20221220). In questo case
	  l'argomento <argname>formato</argname> deve essere omesso.
	</para>
	<para>
	  Si noti il valore restituito da questa funzione dipende dal
	  settaggio di fuso orario del sistema su cui si sta
	  lavorando. Ad esempio, l'output di 
	</para>
	<code>
	  strptime("13/02/2009 23:31.30", "%d/%m/%Y %H:%M.%S")
	</code>
	<para>
	  sarà 1234567890 solo se l'ora è impostata a UTC. Se invece,
	  per esempio, l'ora è impostata alla zona pacifica degli USA
	  (ad esempio, la California), l'output sarà 1234596690.
	</para>
	<para>
	  Attenzione: a causa di differenze nell'implementazione,
	  questa funzione si comporta in modo diverso su sistemi
	  Windows e Unix-like per date precedenti al 1 gennaio
	  1970. Su sistemi Unix-like (Linux, Mac) saranno generate
	  cifre negative in secondi; su windows, il risultato sarà NA.
	</para>
	<para>
	  Le opzioni per il <argname>formato</argname> sono elencate sulla
	  pagina di manuale per <lit>strptime</lit>, sui sistemi che
	  la offrono, oppure su uno dei tanti siti che contengono tale
	  informazione, come ad esempio
	  <url>http://man7.org/linux/man-pages/man3/strptime.3.html</url>.
	</para>
	<para>
	  L'esempio qui sotto mostra come convertire una data da un
	  formato all'altro.
	</para>
	<code>
	  scalar tm = strptime("Thursday 02/07/19", "%A %m/%d/%y")
	  eval strftime(tm) # default output
	  eval strftime(tm, "%d %B, %Y")
	</code>
	<para>
	  Se la lingua di sistema è l'italiano, il risultato è
	</para>
	<code>
	  ? scalar tm = strptime("Thursday 02/07/19", "%A %m/%d/%y")
	  Sostituito lo scalare tm = 1.54949e+009
	  ? eval strftime(tm) # default output
	  07/02/2019 00:00:00
	  ? eval strftime(tm, "%d %B, %Y")
	  07 febbraio, 2019
	</code>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg optional="true" type="int">i</fnarg>
	<fnarg optional="true" type="string">sep</fnarg>
      </fnargs>
      <description>
	<para>
	  Nel suo uso base, con un solo argomento, restituisce un
	  array di stringhe risultante dalla divisione di
	  <argname>s</argname> per spazi bianche (ossia qualsiasi
	  combinazione di spazi, tabulazioni e a capo).
	</para>
	<para>
	  Se il secondo argomento è un intero positivo, viene
	  ritornata una stringa singola, cioè
	  l'<argname>i</argname>-esimo elemento della divisione di cui
	  sopra. Se <argname>i</argname> è minore di 1 verrà segnalato
	  un errore, ma se <argname>i</argname>
	  è più grande del numero di elementi che risulterebbe dalla
	  divisione viene ritornata una stringa vuota.
	</para>
	<para>
	  Il terzo argomento può essere usato per specificare il
	  delimitatore col quale <argname>s</argname> verrà divisa. Ad
	  esempio
	</para>
	<code>
	  string basket = "banana,apple,jackfruit,orange"
	  strings S = strsplit(basket,,",")
	</code>
	<para>
	  dividerà l'input in un array di 4 stringhe in base alle
	  virgole. la virgola <quote>extra</quote> nell'input indica
	  che l'argomento <argname>i</argname> è omesso, ma non è
	  strettamente necessario a meno che non si voglia estrarre
	  un solo elemento; se il secondo argomento è una stringa e la
	  funzione viene invocata con due soli argomenti si intende
	  che il secondo argomento sia <argname>sep</argname> anziché
	  <argname>i</argname>. Per cui
	</para>
	<code>
	  strings S = strsplit(basket, ",")
	</code>
	<para>
	  è altrettanto corretto.
	</para>
	<para>
	  Le sequenze di escape <quote><lit>\n</lit></quote>,
	  <quote><lit>\r</lit></quote> e <quote><lit>\t</lit></quote>
	  rappresentano rispettivamente l'a capo, CR e la tabulazione
	  nell'argomento <argname>sep</argname>. Per usare la barra
	  rovesciata come separatore bisogna raddoppiarla, così:
	  <quote><lit>\\</lit></quote>. Per esempio:
	</para>
	<code>
	  string s = "c:\fiddle\sticks"
	  strings S = strsplit(s, "\\")
	</code>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="bool">ign_case</fnarg>
      </fnargs>
      <description>
	<para>
	  Cerca all'interno della stringa <argname>s1</argname> un'occorrenza
	  della stringa <argname>s2</argname>.  Nel caso venga trovata
	  una corrispondenza la funzione restituisce una copia della
	  porzione di <argname>s1</argname> che inizia con
	  <argname>s2</argname>; in caso contrario, la funzione
	  restituisce una stringa vuota.
	</para>
	<para>
	  Esempi:
	</para>
	<code>
	  string s1 = "Gretl is an econometrics package"
	  string s2 = strstr(s1, "an")
	  print s2
	</code>
	<para>
	  Se l'argomento opzionale <argname>ign_case</argname> è
	  nonzero, la ricerca è insensibile a maiuscole/minuscole. Ad
	  esempio,
	</para>
	<code>
	  strstr("Trieste", "t")
	</code>
	<para>
	  restituisce <quote>te</quote>, ma
	</para>
	<code>
	  strstr("Trieste", "t", 1)
	</code>
	<para>
	  restituisce <quote>Trieste</quote>.
	</para>
	<para>
	  Per un semplice controllo vero/falso se <argname>s1</argname>
	  contiene <argname>s2</argname>, vedi <fncref targ="instring"/>.
	</para>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una copia dell'argomento <argname>s</argname> da
	  cui sono stati rimossi gli spazi bianchi iniziali e finali.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  string s1 = "    A lot of white space.  "
	  string s2 = strstrip(s1)
	  print s1 s2
	</code>

      </description>
    </function>

    <function name="strsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string-or-strings">s</fnarg>
	<fnarg type="string">find</fnarg>
	<fnarg type="string">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui tutte
	  le occorrenze di <argname>find</argname> sono sostituite con
	  <argname>subst</argname>. V. anche <fncref targ="regsub"/> per
	  una funzione più complessa che permette di sostituire stringhe sulla
	  base di espressioni regolari.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  string s1 =  "Ciao, Gretl!"
	  string s2 = strsub(s1, "Gretl", "Hansl")
	  print s2
	</code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg optional="true" type="bool">subsample</fnarg>
      </fnargs>
      <description>
	<para>
	  Se la serie <argname>y</argname> contiene stringhe,
	  restituisce un array contenente tutti i suoi valori distinti
	  (indipendentemente da quale sia il campione attualmente in
	  vigore), ordinati per il valore numerico associato, partendo
	  da 1. Se il dataset è limitato a un sottocampione, dando un
	  valore non-zero al secondo argomento la funzione restituirà
	  un array con le sole stringhe corrispondenti al
	  sottocampione selezionato.
	</para>
	<para>Se invece <argname>y</argname> non contiene stringhe,
	  viene restituito un array vuoto.
	  <seelist>
	    <fncref targ="stringify"/>
	  </seelist>
	</para>
       <para>
	 In certi contesti può essere utile un'alternativa a
	 <lit>strvals</lit>, che consiste nell'assegnazione diretta di
	 una serie con valori stringa a un array: in questo caso,
	 il risultato conterrà non solo i valori distinti, ma tutte le
	 stringhe nel campione corrente.
       </para>
      </description>
    </function>


    <function name="strvsort" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg optional="true" type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Esegue uno di due tipi di riorganizzazione della serie
	  <argname>y</argname>, che deve avere valori di stringa. Il
	  valore di ritorno nominale è 0 se la funzione va a buon fine.
	</para>
	<para>
	  Metodo 1: Se il secondo argomento non viene fornito,
	  l'effetto è di ordinare <argname>y</argname> in questo
	  senso: i distinti valori di stringa vengono messi in ordine
	  alfabetico e quindi la serie viene ricodificata in modo tale
	  che venga assegnato 1 per la prima stringa, 2 per la seconda
	  e così via. Ciò può essere utile, ad esempio, per garantire
	  una codifica uniforme per più serie che condividono lo
	  stesso insieme di valori stringa.
	</para>
	<para>
	  Metodo 2: se viene fornito il secondo argomento, esso deve
	  essere un array che contiene esattamente i valori stringa
	  distinti di <argname>y</argname> (che può essere creato
	  tramite <fncref targ="strvals"/>), ma ricombinati in un
	  ordine preferito. L'effetto è quindi di ricodificare la
	  serie in modo tale che venga assegnato il valore 1 alla
	  prima stringa in <argname>S</argname>, il valore 2 alla
	  seconda e così via. Ciò può essere utile per garantire che i
	  codici numerici <quote>abbiano senso</quote> quando i valori
	  delle stringhe possono essere considerati come ordinati in
	  modo naturale.
	</para>
	<para>
	  Il caso d'uso principale di questi metodi è la gestione di
	  serie con valori stringa importate da origini di terze parti
	  come ad esempio file CSV. Per tali dati, gretl assegna
	  codici numerici basati semplicemente sull'ordine in cui
	  compaiono le stringhe nelle righe del file. Quindi in una
	  serie con valori <lit>basso</lit>, <lit>medio</lit> e
	  <lit>alto</lit>, a <lit>alto</lit> verrà assegnato il codice
	  1 questa stringa è trovata per prima, anziché 3, il che
	  sarebbe chiaramente più <quote>naturale</quote>. Questo
	  problema può essere risolto utilizzando il Metodo
	  2. Inoltre, se due o più serie condividono gli stessi valori
	  di stringa, essi verranno codificati in modo diverso a meno
	  che i loro valori distinti non appaiano nello stesso ordine
	  nel file di dati. Questo problema potrebbe essere risolto
	  con entrambi i metodi.
	</para>
	<para>
	  <seelist>
	    <fncref targ="stringify"/>
	    <fncref targ="strvals"/>
	  </seelist>
	</para>
      </description>
    </function>
    
    <function name="substr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="int">start</fnarg>
	<fnarg type="int">end</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la sottostringa di <argname>s</argname> dal
	  carattere <argname>start</argname> al carattere
	  <argname>end</argname> compresi. L'indicizzazione è a base 1.
	</para>
	<para>
	  Ad esempio, il codice seguente
	</para>
	<code>
	  string s1 = "Ciao, Gretl!"
	  string s2 = substr(s1, 7, 11)
	  string s3 = substr("Ciao, Gretl!", 7, 11)
	  print s2
	  print s3
	</code>
	<para>
	  ritorna:
	</para>
	<code>
	  ? print s2
	  Gretl
	  ? print s3
	  Gretl
	</code>
	<para>
	  In certi casi, si possono preferire costrutti meno espliciti ma
	  più compatti, che fanno uso degli operatori di indicizzazione e
	  di incremento, come nel caso seguente:
	</para>
	<code>
	  string s1 = "Ciao, Gretl!"
	  string s2 = s1[7:11]
	  string s3 = s1 + 6
	  print s2
	  print s3
	</code>
	<para>
	  in cui l'output sarebbe
	</para>
	<code>
	  ? print s2
	  Gretl
	  ? print s3
	  Gretl!
	</code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> è una variabile restituisce la somma
	  (scalare) delle osservazioni non mancanti in
	  <argname>x</argname>. Si veda anche <fncref targ="sumall"/>.
	</para>
	<para>
	  Se <argname>x</argname> è una matrice restituisce la somma
	  degli elementi della matrice.
	</para>
	<para>
	  Se <argname>x</argname> è una lista, restituisce una
	  variabile <math>y</math> tale che <math>y</math><sub>t</sub>
	  è la somma dei valori delle variabili nella lista
	  all'osservazione <math>t</math>, o <lit>NA</lit> se ci sono
	  valori mancanti all'osservazione <math>t</math>. Per
	  default, la funzione ritorna <lit>NA</lit> se ci si sono dei
	  missing a <math>t</math>, ma se si passa un valore non-zero
	  come opzione <argname>partial</argname> la statistica sarà
	  calcolata sui soli dati validi.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la somma delle osservazioni di
	  <argname>x</argname> nel campione corrente, o <lit>NA</lit>
	  se ci sono valori mancanti.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce le somme per colonna di <argname>X</argname>. Se
	  viene specificato un valore non-zero per il secondo
	  argomento facoltativo, i valori mancanti vengono ignorati,
	  altrimenti il ​​risultato è <lit>NA</lit> per tutte le colonne
	  che contengono valori mancanti.
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">skip_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce le somme per riga di <argname>X</argname>. Se
	  viene specificato un valore non-zero per il secondo
	  argomento facoltativo, i valori mancanti vengono ignorati,
	  altrimenti il ​​risultato è <lit>NA</lit> per tutte le righe
	  che contengono valori mancanti.
	  <seelist>
	    <fncref targ="meanr"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Esegue la scomposizione a valori singolari (SVD) della
	  matrice <argname>X</argname>.
	</para>
	<para context="tex">
	  Esegue la scomposizione a valori singolari (SVD) della
	  matrice $r \times c$ $X$:
	  \[ X = U \left[
	  \begin{array}{cccc}
	  \sigma_1 \\
	  &amp; \sigma_2 \\
	  &amp; &amp; \ddots \\
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \]
	  dove $n = \min(r,c)$. $U$ è $r \times n$ e $V$ è $n \times c$,
	  con $U'U = I$ e $VV' = I$.
	</para>
	<para>
	  I valori singolari sono restituiti in un vettore riga.  I
	  vettori singolari sinistri e/o destri <math>U</math> e
	  <math>V</math> possono essere ottenuti fornendo valori
	  non nulli per, rispettivamente, gli argomenti 2 e 3. Per una
	  matrice <lit>A</lit>, il codice
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V)
	  B = (U .* s) * V
	</code>
	<para>
	  dovrebbe generare <lit>B</lit> identica ad <lit>A</lit>
	  (precisione numerica a parte).
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigengen"/>
	    <fncref targ="eigensym"/>
	    <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svm" section="nonparam" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="bundle">param</fnarg>
	<fnarg type="bundleref" optional="true">bmod</fnarg>
	<fnarg type="bundleref" optional="true">bprob</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione abilita il training di un modello SVM
	  (Support Vector Machine) e le relative previsioni; il
	  backend utilizzato è LIBSVM. La lista passata come argomento
	  <argname>L</argname> deve includere la variabile dipendente,
	  seguita dalle variabili indipendenti, mentre il bundle
	  <argname>param</argname> è usato per passare opzioni alla
	  SVM. La funzione restituisce una serie contenente le
	  previsioni. I due parametri opzionali aggiuntivi sono
	  puntatori a bundle per raccogliere informazioni aggiuntive
	  sul training e/o la previsione.
	</para>
	<para>
	  Per maggiori dettagli, consultare la documentazione PDF:
	  <mnu targ="gretlSVM">gretl + SVM</mnu>.
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione tangente di <argname>x</argname>.
	  <seelist>
	    <fncref targ="atan"/>
	    <fncref targ="cos"/>
	    <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la tangente iperbolica di <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="atanh"/>
	    <fncref targ="cosh"/>
	    <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tdisagg" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="series-or-mat">Y</fnarg>
	<fnarg optional="true" type="series-list-or-mat">X</fnarg>
	<fnarg type="scalar">s</fnarg>
	<fnarg optional="true" type="bundle">opts</fnarg>
	<fnarg optional="true" type="bundle">results</fnarg>
      </fnargs>
      <description>
	<para>
	  Effettua la disaggregazione temporale (conversione ad alta
	  frequenza) dei dati di serie storiche in
	  <argname>Y</argname>. L'argomento <argname>s</argname>
	  indica il fattore di espansione (ad esempio, 3 da
	  trimestrale a mensile). L'argomento <argname>X</argname> può
	  contenere una o più covariate ad alta frequenza sulla base
	  delle quali procedere alla disaggregazione. L'argomento
	  <argname>opts</argname> serve a passare opzioni più
	  dettagliate; dettagli sui risultati sono disponibili nel
	  bundle <argname> results</argname>.
	</para>
	<para>
	  Vedi <guideref targ="chap:tdisagg"/> per maggiori dettagli.
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
	<fnarg optional="true" type="scalarref">&amp;det</fnarg>
      </fnargs>
      <description>
	<para>
	  Risolve un sistema di Toeplitz di equazioni lineari, cioè
	  <math>Tx = b</math> dove <math>T</math> è una matrice
	  quadrata il cui elemento <math>T</math><sub>i,j</sub> è
	  uguale a <math>c</math><sub>i-j</sub> per <equation
	  status="inline" ascii="i&gt;=j" tex="$i\ge j$"/> e a
	  <math>r</math><sub>j-i</sub> per <equation status="inline"
	  ascii="i&lt;=j" tex="$i\le j$"/>. Si noti che i primi
	  elementi di <math>c</math> e <math>r</math> devono essere
	  uguali; in caso contrario la funzione restituisce un
	  errore. In caso di successo, la funzione restituisce il
	  vettore <math>x</math>.
	</para>
	<para>
	  L'algoritmo usato sfrutta la speciale struttura della
	  matrice <math>T</math>, che lo rende molto più efficiente di
	  altri algoritmi meno specifici, specialmente per sistemi di
	  grandi dimensioni. Attenzione: in certi casi, la funzione
	  può restituire un errore di singolarità anche se la matrice
	  <math>T</math> non è effettivamente singolare; questo
	  problema tuttavia non si presenta quando <math>T</math> è
	  definita positiva.
	</para>
	<para>
	  Se l'argomento opzionale <argname>det</argname> è presente
	  (come puntatore), esso conterrà in uscita il determinante di
	  <math>T</math>. Per esempio, il codice:
	</para>
	<code>
	  A = unvech({3;2;1;3;2;3})    # Build a 3x3 Toeplitz matrix
	  x = ones(3,1)                # and a 3x1 vector
	  print A x
	  eval A\x                     # solution via generic inversion
	  eval det(A)                  # print the determinant
	  a = A[1,]
	  d = 0
	  eval toepsolv(a, a, x, &amp;d)   # use the dedicated function
	  print d
	</code>
	<para>
	  produce
	</para>
	<code>
A (3 x 3)

  3   2   1 
  2   3   2 
  1   2   3 

x (3 x 1)

  1 
  1 
  1 

     0.25000 
 -3.3307e-17 
     0.25000 

8
     0.25000 
  2.7756e-17 
     0.25000 


d =  8.0000000
	</code>
      </description>
    </function>

    <function name="tolower" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui ogni
	  lettera maiuscola è convertita in minuscola.
	</para>
	<para>
	  Esempi:
	</para>
	<code>
	  string s1 = "Ciao, Gretl!"
	  string s2 = tolower(s1)
	  print s2

	  string s3 = tolower("Ciao, Gretl!")
	  print s3
	</code>
      </description>
    </function>

    <function name="toupper" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui ogni
	  lettera minuscola è convertita in maiuscola.
	</para>
	<para>
	  Esempi:
	</para>
	<code>
	  string s1 = "Ciao, Gretl!"
	  string s2 = toupper(s1)
	  print s2

	  string s3 = toupper("Ciao, Gretl!")
	  print s3
	</code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la traccia della matrice <argname>A</argname>,
	  ovvero la somma degli elementi lungo la diagonale.
	  <seelist>
	    <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Trasposizione della matrice <argname>X</argname>. Si noti che per
	  ottenere la trasposta di una matrice nella maggior parte dei casi è
	  possibile utilizzare l'operatore apice: <lit>X'</lit>.
	</para>
      </description>
    </function>


    <function name="trigamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce la funzione trigamma di <argname>x</argname>,
	  cioè la derivata seconda del logaritmo della funzione Gamma.
	</para>
	<para context="tex">
	  Restituisce la funzione trigamma di $x$, cioè
	  $\frac {\mathrm{d}?2} {\mathrm{d} x^2}\, \log \Gamma(x)$.
	</para>
	<para>
	  <seelist>
            <fncref targ="lngamma"/>
            <fncref targ="digamma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="trimr" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">ttop</fnarg>
	<fnarg type="int">tbot</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice che è una copia di
	  <argname>X</argname> con <argname>ttop</argname> righe
	  eliminate partendo dall'alto e <argname>tbot</argname> righe
	  eliminate partendo dal basso. Gli ultimi due argomenti
	  devono essere non-negativi e la somma dei due deve essere
	  minore del numero totale di righe di <argname>X</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typename" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
          Se <argname>nome</argname> è l'identificativo di un oggetto
          definito, la funzione ritorna il tipo di oggetto come
          stringa: <lit>scalar</lit>, <lit>series</lit>,
          <lit>matrix</lit>, <lit>string</lit>, <lit>bundle</lit>, o
          uno dei tipi di array: <lit>matrices</lit>,
          <lit>bundles</lit>, <lit>strings</lit>, <lit>lists</lit> o
          <lit>arrays</lit>.  Se non esiste un oggetto con quel nome,
          vene ritornata la stringa <lit>null</lit>.
        </para>
        <subhead>Compatibilità</subhead>
        <para>
          Questa funzione rappresenta una miglioria rispetto alle
          vecchie funzioni <fncref targ="typeof"/> e <fncref
          targ="typestr"/>, che però per il momento sono ancora
          valide.
        </para>
      </description>
    </function>
    
    <function name="typeof" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">espressione</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un codice numerico di tipo per
	  <argname>espressione</argname>, che è l'identificativo di un
	  qualche oggetto. I codici sono: 1 = scalare, 2 = serie, 3 =
	  matrice, 4 = stringa, 5 = bundle, 6 = array e 7 = lista.
	  Per avere la stringa corrispondente al codice, si può usare
	  la funzione <fncref targ="typestr"/>. Se l'oggetto non è
	  definito (o più in generale se un'assegnazione con
	  <argname>espressione</argname> produce un errore), ritorna
	  0.
	</para>
	<para>
	  Qui di seguito, qualche esempio:
	</para>
	<code>
	  strings S = defarray("foo", "bar")
	  eval typeof(S)            # ritorna 6 (array)
	  eval typeof(S[1])	    # ritorna 4 (stringa)
	  eval typeof(S[7])	    # ritorna 0 (indice non valido)
	  eval typeof(S[x])	    # ritorna 0 (indice non valido)
	  eval typeof(1+1)	    # ritorna 1 (scalare)
	  eval typeof(sqrt("foo"))  # ritorna 0 (non valido)
	</code>
	<para>
	  La funzione <fncref targ="typestr"/> può essere utilizzata
	  per ottenere la stringa corrispondente al valore restituito
	  da <lit>typeof</lit>, ma se si desidera solo il risultato
	  della stringa <fncref targ="typename"/> potrebbe essere
	  preferibile.
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">typecode</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione obsoleta: vedi <fncref targ="typename"/> per
	  un'alternativa migliore.  Restituisce il nome del tipo di
	  dati di gretl corrispondente a
	  <argname>typecode</argname>. È utilizzata insieme alla
	  funzione <fncref targ="inbundle"/>. Il valore restituito è:
	  <quote>scalar</quote>, <quote>series</quote>,
	  <quote>matrix</quote>, <quote>string</quote>,
	  <quote>bundle</quote>, <quote>array</quote> o
	  <quote>null</quote>.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Genera una serie di numeri pseudo-casuali uniformi
	  nell'intervallo (<argname>a</argname>,
	  <argname>b</argname>), oppure, in assenza di argomenti,
	  nell'intervallo (0,1). L'algoritmo usato è il Mersenne
	  Twister sviluppato da <cite key="saito_matsumoto08">Saito and
	  Matsumoto (2008)</cite>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="randgen"/>
	    <fncref targ="normal"/>
	    <fncref targ="mnormal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore che contiene gli elementi non-missing
	  distinti di <argname>x</argname>, non ordinati ma
	  nell'ordine in cui compaiono. Si veda <fncref
	  targ="values"/> per una variante che ordina gli elementi.
	</para>
      </description>
    </function>

    <function name="unvech" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Se il secondo argomento è omesso, restituisce una matrice
	  simmetrica <by r="n" c="n"/> ottenuta riordinando gli
	  elementi di <math>v</math>. Il numero di elementi in
	  <math>v</math> deve essere un intero triangolare, ossia un
	  numero <math>k</math> che può essere scritto come <equation
	  status="inline" ascii="k = n(n+1)/2" tex="$k = n(n+1)/2$"/>,
	  con <math>n</math> intero. Questa funzione è l'inversa della
	  funzione <fncref targ="vech"/>.
	</para>
	<para>
	  Se invece l'argomento <argname>d</argname> è presente, la
	  funzione restituisce una matrice <by r="(n+1)" c="(n+1)"/> i
	  cui elementi extradiagonali sono presi da <math>v</math>
	  come sopra. Gli elementi della diagonale sono posti uguali a
	  <argname>d</argname>.
       </para>
    <para>
        Per esempio:
    </para>
    <code>
        v = {1;2;3}
        matrix one = unvech(v)
        matrix two = unvech(v, 99)
        print one two
    </code>
    <para>
      produce
    </para>
    <code>
      one (2 x 2)

      1   2
      2   3

      two (3 x 3)

      99     1     2
       1    99     3
       2     3    99
    </code>
	<para>
	  <seelist>
	    <fncref targ="mshape"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce una matrice triangolare superiore <by r="n"
	  c="n"/>: gli elementi sulla e sopra la diagonale sono uguali
	  ai corrispondenti elementi di <argname>A</argname>; i
	  restanti elementi sono zero.
	</para>
	<para context="tex">
	  Restituisce una matrice triangolare superiore $n\times n$
	  <math>B</math> per cui $B_{ij} = A_{ij}$ se $i \le j$ e 0
	  altrimenti.
	</para>
	<para>
	  <seelist>
	    <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-value della statistica test per il test di radici
	  unitarie di Dickey&ndash;Fuller e del test di cointegrazione di
	  Engle&ndash;Granger, calcolato usando il metodo proposto da
	  <cite key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  Gli argomenti sono i seguenti: <argname>tau</argname> indica
	  la statistica test; <argname>n</argname> è il numero di
	  osservazioni (o 0 per il risultato asintotico);
	  <argname>niv</argname> è il numero di variabili
	  potenzialmente cointegrate nel test di cointegrazione (o 1
	  per il test univariato di radici unitarie);
	  <argname>itv</argname> è il codice di specificazione del
	  modello: 1 per il modello senza costante, 2 per il modello
	  con costante inclusa, 3 per il modello con costante e trend
	  lineare, 4 per il modello con costante e trend quadratico.
	</para>
	<para>
	  Si noti che se il test è <quote>aumentato</quote> con i
	  ritardi della variabile dipendente, si deve fornire un
	  valore 0 all'argomento <argname>n</argname> per ottenere il
	  risultato asintotico.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore contenente gli elementi distinti di
	  <argname>x</argname> ordinati in senso crescente. I valori
	  mancanti vengono ignorati. Se si desidera troncare
	  all'intero i valori prima di applicare questa funzione è
	  possibile usare l'espressione <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="uniq"/>
	    <fncref targ="dsort"/>
	    <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> è una variabile, restituisce la sua
	  varianza campionaria (uno scalare), saltando i valori mancanti.
	</para>
	<para>
	  Se <argname>x</argname> è una lista, restituisce una variabile
	  <math>y</math> tale che <math>y</math><sub>t</sub> è la
	  varianza campionaria dei valori delle variabili nella lista
	  all'osservazione <math>t</math>, o <lit>NA</lit> se ci sono
	  valori mancanti a <math>t</math>. Per default, la funzione
	  ritorna <lit>NA</lit> se ci si sono dei missing a
	  <math>t</math>, ma se si passa un valore non-zero come opzione
	  <argname>partial</argname> la statistica sarà calcolata sui
	  soli dati validi.
	</para>
	<para>
	  In ogni caso, la somma delle deviazioni al quadrato dalla
	  media è divisa per (<math>n</math> &minus; 1) se
	  <math>n</math> &gt; 1. In caso contrario, la varianza
	  restituita è nulla se <math>n</math> = 1, o <lit>NA</lit> se
	  <math>n</math> = 0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Se l'argomento è uno scalare restituisce il nome della
	  variabile con numero ID <argname>v</argname> o genera un
	  errore nel caso in cui una tale variabile non esista.
	</para>
	<para>
	  Se l'argomento è una lista restituisce una stringa
	  contenente i nomi delle variabili nella lista, separati da
	  virgole. Se la lista fornita è vuota, la stringa
	  restituita sarà vuota.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  open broiler.gdt
	  string s = varname(7)
	  print s
	</code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un array di stringhe contenente i nomi delle
	  variabili nella lista <argname>L</argname>. Se quest'ultima
	  è vuota, lo sarà anche l'array risultato.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  open keane.gdt
	  list L = year wage status
	  strings S = varnames(L)
	  eval S[1]
	  eval S[2]
	  eval S[3]
	</code>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">varname</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero ID della variabile
	  <argname>varname</argname>, o NA se tale variabile non esiste.
	</para>
      </description>
    </function>

    <function name="varsimul" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Simula un VAR di ordine <math>p</math> con
	  <math>n</math> variabili, cioè
	  <equation status="inline"
		    ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)."
		    tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
          La matrice dei coefficienti <argname>A</argname> è formata
          accostando orizzontalmente le matrici
          <math>A</math><sub>i</sub>. Si tratta di una matrice <by
          r="n" c="np"/>, con una riga per ogni equazione. Ciò
          corrisponde alle prime <math>n</math> righe della matrice
          <lit>$compan</lit> fornita dai comandi <lit>var</lit> e
          <lit>vecm</lit> di gretl.
	</para>
	<para>
	  I vettori <math>u_t</math> sono contenuti (sotto forma di righe)
	  nella matrice <argname>U</argname> (<by r="T" c="n"/>). I
	  valori iniziali sono in <argname>y0</argname> (<by r="p"
	  c="n"/>).
	</para>
	<para>
	  Se il VAR contiene termini deterministici e/o regressori
	  esogeni, essi possono essere gestiti racchiudendoli nella
	  matrice <argname>U</argname>: ciascuna riga di
	  <argname>U</argname> diventa allora
	  <equation status="inline"
		    ascii="u(t) = B' x(t) + e(t)."
		    tex="$u_t = B' x_t + e_t$."/>
        </para>
	<para>
	  La matrice in uscita ha<math>T</math> + <math>p</math> righe
	  e <math>n</math> colonne; contiene i <math>p</math> valori
	  iniziali delle variabili endogene più i <math>T</math>
	  valori simulati.
	</para>
	<para>
	  <seelist>
	    <fncref targ="$compan"/>
	    <cmdref targ="var"/>
	    <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matrix" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce le colonne di <argname>X</argname> una sotto
	  l'altra in un vettore colonna.
	  <seelist>
	    <fncref targ="mshape"/>
	    <fncref targ="unvech"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matrix" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
 	<fnarg optional="true" type="bool">omit-diag</fnarg>
     </fnargs>
      <description>
	<para>
	  Restituisce, sotto forma di vettore colonna, gli elementi di
	  <argname>A</argname> sulla diagonale e al di sopra di
	  essa, a meno che l'argomento <argname>omit-diag</argname>
	  sia nonzero, nel qual caso vengono considerati solo gli
	  elementi al di sopra della diagonale.
	  </para>
	  <para>
	    L'uso tipico di questa funzione è con matrici simmetriche,
	    nel qual caso la sua funzione inversa è <fncref
	    targ="unvech"/>. Se la matrice <argname>A</argname> non
	    fosse simmetrica, e ciò che si desidera è il triangolo
	    inferiore, si può usare <lit>vech(A')</lit> (ma potrebbe
	    essere necessario riordinare gli elementi).
	  <seelist>
	    <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vma" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix" optional="true">K</fnarg>
	<fnarg type="int" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione calcola la rappresentazione VMA di un
	  sistema VAR: se <equation status="inline" ascii="y(t) = A1
	  y(t-1) + ... + Ap y(t-p) + u(t)" tex="$y_t = \sum_{i=1}^p
	  A_i y_{t-i} + u_t$"/>, dove <math>u</math><sub>t</sub> sono
	  gli errori di previsione a un passo, la rappresentazione VMA
	  corrispondente è <equation status="inline" ascii="y(t) = C0
	  e(t) + C1 e(t-1) + ..."  tex="$y_t = C_0 e_t + C_1 e_{t-1} +
	  \ldots$."/>, dove la relazione fra errori di previsione
	  <math>u</math><sub>t</sub> e shock strutturali
	  <math>e</math><sub>t</sub> è data da <equation status="inline"
	  ascii="u(t) = K e(t)" tex="$u_t = K e_t$"/>.
        </para>
        <para>
          La matrice dei coefficienti <argname>A</argname> è formata
          accostando orizzontalmente le matrici
          <math>A</math><sub>i</sub>. Si tratta di una matrice <by
          r="n" c="np"/>, con una riga per ogni equazione. Ciò
          corrisponde alle prime <math>n</math> righe della matrice
          <lit>$compan</lit> fornita dai comandi <lit>var</lit> e
          <lit>vecm</lit> di gretl. L'argomento <argname>K</argname> è
	  opzionale; se omesso, è la matrice identità.
	</para>
        <para>
          La matrice risultato avrà <argname>h</argname> righe e
	  <math>n</math><sup>2</sup> colonne: la sua
	  <math>i</math>-esima riga contiene la vettorizzazione di
	  <math>C</math><sub>i-1</sub>. Se <argname>h</argname> è
	  omesso, il valore di default è 24.
	</para>
	<para>
	  <seelist>
            <fncref targ="irf"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">anno</fnarg>
	<fnarg type="scalar-or-series">mese</fnarg>
	<fnarg type="scalar-or-series">giorno</fnarg>
      </fnargs>
      <description>
	<para>
	  Fornisce il giorno della settimana (da domenica = 0 a sabato
	  = 6) corrispondente alla data specificata dai tre argomenti,
	  o <lit>NA</lit> se la data non è valida. Si noti che i tre
	  argomenti devono essere dello stesso tipo: o scalari
	  (interi), oppure serie.
	</para>
	<para>
	  Un modo alternativo di usare questa funzione è darle un solo
	  argomento, che è inteso come una data (o una serie di date)
	  in formato ISO 8601 <quote>basico</quote>, cioè
	  <lit>YYYYMMDD</lit>. Le due espressioni seguenti
	  restituiscono lo stesso risultato, cioè 2.
	</para>
	<code>
	  eval weekday(1990, 5, 1)
	  eval weekday(19900501)
	</code>
	<para>
	  Una convenzione alternativa prevede che la domenica sia
	  identificata col 7 anziché con lo 0. In questo caso, se
	  <lit>wd</lit> è il risultato della funzione, la conversione
	  può essere portata a termine con
	</para>
	<code>
	  altwd = wd == 0 ? 7 : wd
	</code>
	<para>
	  Si noti che la semplice aggiunta di 1 a <lit>wd</lit>
	  produce una numerazione valida, ma non standard, da
	  domenica = 1 a sabato = 7.
	</para>
      </description>
    </function>

    <function name="wmean" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una variabile <math>y</math> tale che
	  <math>y</math><sub>t</sub> è la media ponderata dei valori
	  delle variabili nella lista <argname>Y</argname>
	  all'osservazione <math>t</math>; i rispettivi pesi devono
	  essere contenuti nella lista <argname>W</argname> e
	  possono quindi cambiare nel tempo. Le due liste
	  <argname>Y</argname> e <argname>W</argname> devono avere lo
	  stesso numero di elementi ed i pesi devono essere
	  non-negativi.
	</para>
	<para>
	  Per default, la funzione ritorna <lit>NA</lit> se ci si sono
	  dei missing a <math>t</math>, ma se si passa un valore
	  non-zero come opzione <argname>partial</argname> la
	  statistica sarà calcolata sui soli dati validi.
	</para>
	<para>
	  <seelist>
	    <fncref targ="wsd"/>
	    <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wsd" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una variabile <math>y</math> tale che
	  <math>y</math><sub>t</sub> è l'errore quadratico medio
	  ponderato dei valori delle variabili nella lista
	  <argname>Y</argname> all'osservazione <math>t</math>; i
	  rispettivi pesi devono essere contenuti nella lista
	  <argname>W</argname>, e possono quindi cambiare nel
	  tempo. Le due liste <argname>Y</argname> e
	  <argname>W</argname> devono avere lo stesso numero di
	  elementi ed i pesi devono essere non-negativi.
	</para>
	<para>
	  Per default, la funzione ritorna <lit>NA</lit> se ci si sono
	  dei missing a <math>t</math>, ma se si passa un valore
	  non-zero come opzione <argname>partial</argname> la
	  statistica sarà calcolata sui soli dati validi.
	</para>
	<para>
	  <seelist>
	    <fncref targ="wmean"/>
	    <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wvar" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">partial</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una variabile <math>y</math> tale che
	  <math>y</math><sub>t</sub> è la varianza campionaria
	  ponderata dei valori delle variabili nella lista
	  <argname>Y</argname> all'osservazione <math>t</math>; i
	  rispettivi pesi devono essere contenuti nella lista
	  <argname>W</argname>, e possono quindi cambiare nel
	  tempo. Le due liste <argname>Y</argname> e
	  <argname>W</argname> devono avere lo stesso numero di
	  elementi ed i pesi devono essere non-negativi.
	</para>
	<para>
	  Per default, la funzione ritorna <lit>NA</lit> se ci si sono
	  dei missing a <math>t</math>, ma se si passa un valore
	  non-zero come opzione <argname>partial</argname> la
	  statistica sarà calcolata sui soli dati validi.
	</para>
	<para context="tex">
	  La varianza ponderata è calcolata come
	  \[
	  s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i}
	  \]
	  dove $n'$ è il numero di pesi non nulli e $\bar{x}_w$ è la
	  media ponderata.
	</para>
	<para>
	  <seelist>
	    <fncref targ="wmean"/>
	    <fncref targ="wsd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmlget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string-or-strings">percorso</fnarg>
	<fnarg optional="true" type="scalarref">&amp;trovati</fnarg>
      </fnargs>
      <description>
	<para>
	  L'argomento <argname>buf</argname> dev'essere un buffer XML,
	  così come risulta dal comando <fncref targ="curl"/> su un
	  sito appropriato, o letto da un file con <fncref
	  targ="readfile"/>; l'argomento <argname>percorso</argname> deve
	  contenere una o più specificazioni XPath (come array se
	  multiple).
	</para>
	<para>
	  Questa funzione restituisce una stringa coi dati trovati nel
	  buffer XML al percorso specificato. Se l'espressione
	  corrisponde a più di un nodo, i contenuti sono stampati uno
	  per riga nella stringa risultato. Se il secondo argomento è
	  un array di percorsi, la stringa risultato conterrà un
	  buffer separato da virgole, dove la colonna <math>i</math>
	  contiene in risultati del percorso <math>i</math>. Se le
	  stringhe così ottenute contengono virgole, esse sono
	  racchiuse da virgolette doppie.
	</para>
	<para>
	  Se <argname>path</argname> non viene trovata nel buffer XML,
	  di default viene generato un errore, ma questo comportamento
	  può essere modificato passando il terzo argomento
	  (opzionale): il tal caso, l'argomento restituisce il
	  conteggio delle chiavi trovate e se non ne è stata trovata
	  nessuna, la funzione ritorna una stringa vuota. Per esempio:
	</para>
	<code>
	  ngot = 0
	  ret = xmlget(xbuf, "//some/thing", &amp;ngot)
	</code>
	<para>
	  Tuttavia, nel caso di una query non correttamente formata
	  sarà comunque generato un errore.
	</para>
	<para>
	  Per una buona introduzione a XPath e alla sua sintassi, si
	  veda
	  <url>https://www.w3schools.com/xml/xml_xpath.asp</url>. L'implementazione
	  di <lit>xmlget</lit> è quella contenuta nel corrispondente
	  modulo di libxml2, che supporta XPath 1.0 ma non XPath 2.0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="jsonget"/>
	    <fncref targ="readfile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeromiss" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converte gli zeri in <lit>NA</lit>s. Se <argname>x</argname>
	  è una variabile la conversione viene fatta elemento per
	  elemento.
	  <seelist>
	    <fncref targ="missing"/>
	    <fncref targ="misszero"/>
	    <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Genera una matrice di zero con <math>r</math> righe e
	  <math>c</math> colonne.
	  <seelist>
	    <fncref targ="ones"/>
	    <fncref targ="seq"/>
	  </seelist>
	</para>
      </description>
    </function>

  </funclist>
</funcref>
