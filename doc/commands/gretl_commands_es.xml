<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE commandref SYSTEM "gretl_commands.dtd">

<commandref language="spanish">

<?PSGML NOFILL label code altforms altform menu-path equation other-access?>

  <command name="add" section="Tests" label="Añadir variables a un modelo">

	  <usage>
	    <arguments>
	      <argument>listavariables</argument>
	    </arguments>
	    <options>
	<option>
	  <flag>--lm</flag>
	  <effect>Hace un contraste de ML; solo con MCO</effect>
	</option>
	<option>
	  <flag>--auto</flag>
	  <optparm>criterio</optparm>
	  <effect>Progresivo hacia adelante, solo MCO</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Presenta solo los resultados básicos del contraste</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas del modelo ampliado</effect>
	</option>
	<option>
	  <flag>--both</flag>
	  <effect>Solo para estimación VI; mira abajo</effect>
	</option>
	    </options>
	    <examples>
	      <example>add 5 7 9</example>
	      <example>add xx yy zz --quiet</example>
	      <example>add xlist --auto=BIC</example>
	    </examples>
	  </usage>

    <description>
      <para context="cli">
	Debes solicitar esta instrucción después de ejecutar una instrucción
	de estimación. Si no se indica ninguna de las opciones <opt>lm</opt>
	o <opt>auto</opt>, esta instrucción realiza un contraste conjunto
	sobre la adición de las variables expresadas en el argumento, al último
	modelo estimado. Se estima una versión ampliada del modelo original,
	incluyendo las variables de <repl>listavariables</repl>, y se realiza
	un contraste de Wald sobre el modelo ampliado. Este substituye al
	original como el <quote>último modelo</quote> con el propósito, por
	ejemplo, de recuperar los errores mediante el accesor <fncref targ="$uhat"/>
	o de hacer otros contrastes. Los resultados del contraste de Wald
	pueden recuperarse utilizando los accesores <fncref targ="$test"/> y
	<fncref targ="$pvalue"/>.
      </para>
      <para context="cli">
	La opción <opt>both</opt> se aplica solo cuando se estima el último
	modelo mediante Mínimos Cuadrados en 2 Etapas. Indica que las
	nuevas variables deben añadirse tanto a la lista de los instrumentos,
	como a la lista de los regresores, añadiéndose por defecto solo a
	la lista de regresores.
      </para>
      <subhead context="cli">La opción lm</subhead>
      <para context="cli">
	Si indicas la opción <opt>lm</opt> (solo disponible para modelos estimados
	mediante MCO), se hace un contraste de Multiplicadores de Lagrange. Para
	ello, se ejecuta una regresión auxiliar en la que el error de estimación
	del último modelo se toma como variable dependiente; y las variables
	independientes son las de ese último modelo más las de <repl>listavariables</repl>.
	Bajo la hipótesis nula de que las variables añadidas no tienen una capacidad
	predictiva adicional, el estadístico formado multiplicando el tamaño de la
	muestra por el R-cuadrado de esta regresión, tiene una distribución Chi-cuadrado
	con tantos grados de libertad como el número de regresores añadidos. Con esta
	opción, el modelo original no se substituye por el modelo de la regresión auxiliar.
      </para>
      <subhead context="cli">La opción auto</subhead>
      <para context="cli">
	La opción <opt>auto</opt> (que no se puede combinar con la opción
	<opt>lm</opt>) solicita que se haga la regresión progresiva hacia
	adelante, utilizando el algoritmo QR tal como se describe en
	<cite key="hastie20">Hastie et al (2020)</cite>. En este caso, se interpreta
	<repl>listavariables</repl> como una lista de <emphasis>candidatos</emphasis>
	a ser añadidos al modelo original. En cada etapa, el método determina
	qué candidato ofrece la mayor mejora del ajuste, de acuerdo con el
	<lit>criterio</lit> (indicado como un parámetro de esa opción).
	El algoritmo se detiene cuando no es posible una mejora adicional.
	El criterio debe tener una de estas formas:
      </para>
      <ilist context="cli">
	<li>
	  <para>
	    Un Criterio de Información: <lit>AIC</lit>, <lit>BIC</lit> o
	    <lit>HQC</lit>. El <quote>mejor</quote> candidato en cada etapa
	    es entonces el que proporciona la mayor mejora (reducción) del
	    criterio seleccionado.
	  </para>
	</li>
	<li>
	  <para>
	    Un valor &alpha; (fracción decimal positiva). En este caso, el factor
	    de relevancia es la suma de cuadrados de los errores. El algoritmo
	    se detiene cuando ningún candidato de los que queden proporcione
	    una reducción en la SCE que sea estadísticamente significativa a un
	    nivel &alpha; en un contraste Chi-cuadrado.
	  </para>
	</li>
      </ilist>
      <para context="gui">
	Aquí dispones de tres opciones:
      </para>
      <ilist context="gui">
	<li>
	  <para>
	    Contraste de Wald: Las variables seleccionadas se añaden al modelo
	    previo, y se estima el modelo ampliado. Se presenta un estadístico
	    de prueba de Wald sobre la significación conjunta de las variables
	    añadidas, junto con su valor p.
	  </para>
	</li>
	<li>
	  <para>
	    Contraste de ML (LM): Se realiza un contraste de Multiplicadores de
	    Lagrange sobre la significación conjunta de las variables añadidas,
	    sin estimar el modelo ampliado.
	  </para>
	</li>
	<li>
	  <para>
	    Adición progresiva: Las variables adicionales se añaden de forma
	    secuencial. En cada etapa, se añade la variable que proporciona
	    la mayor mejora en el ajuste, deteniéndose el proceso cuando
	    ninguna de las candidatas restantes proporcione una mejora. En
	    este caso, es necesario que elijas un criterio: uno de los Criterios
	    de Información (AIC, BIC, HQC) o SCE. Si elijes SCE, también es
	    necesario que especifiques un nivel &alpha; de significación para
	    contrastar si cada variable merece su inclusión.
	  </para>
	</li>
      </ilist>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contrastes/Añadir variables</menu-path>
    </gui-access>

  </command>

  <command name="addline" section="Graphs" label="Añadir una línea a un gráfico"
    context="gui">

    <description>
      <para>
	Esta caja de diálogo te permite añadirle a un gráfico, una línea
	definida mediante una fórmula que debe ser una expresión
	admisible para Gnuplot. Debes usar <lit>x</lit> para denotar el valor de la
	variable del eje de abscisas. Ten en cuenta que Gnuplot utiliza <lit>**</lit>
	para elevar a la potencia, y que el carácter decimal debe indicarse
	con <quote>.</quote>. Ejemplos:
      </para>
      <code>
	10+0.35*x
	100+5.3*x-0.12*x**2
	sin(x)
	exp(sqrt(pi*x))
      </code>
    </description>
  </command>

  <command name="adf" section="Tests" label="Contraste aumentado de Dickey-Fuller">

    <usage>
      <arguments>
        <argument>orden</argument>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>Sin constante</effect>
	</option>
	<option>
	  <flag>--c</flag>
	  <effect>Con constante</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>Con constante más tendencia</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>Con constante, más tendencia cuadrática</effect>
	</option>
	<option>
	  <flag>--seasonals</flag>
	  <effect>Incluye variables ficticias estacionales</effect>
	</option>
	<option>
	  <flag>--gls</flag>
	  <effect>Detrae la media o la tendencia usando MCG</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Muestra los resultados de la regresión</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>Usa las primeras diferencias de la variable</effect>
	</option>
	<option>
	  <flag>--test-down</flag>
	  <optparm optional="true">criterio</optparm>
	  <effect>Orden de retardos automático</effect>
	</option>
	<option>
	  <flag>--perron-qu</flag>
	  <effect>Mira abajo</effect>
	</option>
      </options>
      <examples>
	<example>adf 0 y</example>
        <example>adf 2 y --nc --c --ct</example>
        <example>adf 12 y --c --test-down</example>
	<demos>
	  <demo>jgm-1996.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Esta instrucción necesita que indiques el orden de retardos con un
	número entero; si el orden es cero, se ejecuta el contraste estándar
	(no aumentado) de Dickey&ndash;Fuller. Se calcula uno o más contrastes de
	Dickey&ndash;Fuller sobre la(s) variable(s) del argumento, siendo la
	hipótesis nula la existencia de una raíz unitaria. (Ahora bien, cuando
	escoges la opción 'difference', se calcula la primera diferencia de la(s)
	variable(s) antes de hacer el contraste, y la discusión de abajo debes
	entenderla como referida a la(s) variable(s) transformada(s).)
      </para>

      <para context="cli">
	Las opciones que se muestran abajo y la discusión que sigue, se
	corresponden sobre todo con el uso de la instrucción <lit>adf</lit>
	con datos de típicas series temporales. Para utilizar esta instrucción
	con datos de panel, mira más abajo la sección titulada
	<quote>Datos de panel</quote>.
      </para>

      <para context="cli">
	Esta instrucción calcula un conjunto de contrastes de Dickey&ndash;Fuller
	sobre cada una de las variables del argumento, siendo la hipótesis nula
	la existencia de una raíz unitaria. (Ahora bien, cuando escoges la opción
	<opt>difference</opt>, se calcula la primera diferencia de la(s) variable(s)
	antes de hacer el contraste, y la discusión de abajo debes entenderla
	como referida a la(s) variable(s) transformada(s).)
      </para>

      <para context="cli">
	Por defecto, se muestran dos variantes del contraste: una basada en
	una regresión que utiliza una constante, y otra que utiliza una
	constante más una tendencia lineal. Puedes controlar las variantes
	que se presentan especificando uno o más de los indicadores de
	opción: <opt>nc</opt>, <opt>c</opt>, <opt>ct</opt>, o <opt>ctt</opt>.
      </para>

      <para context="cli">
	Puedes usar la opción <opt>gls</opt> con las opciones <opt>c</opt> y
  <opt>ct</opt> (con constante, y con constante más tendencia). El efecto
  de esta opción es que la serie que se quiere contrastar, se detrae de la
  media o de la tendencia usando el procedimiento de Mínimos Cuadrados
	Generalizados propuesto <cite key="ERS96">Elliott, Rothenberg y Stock (1996)</cite>,
	que proporciona un contraste de mayor potencia que la aproximación
	estándar de Dickey&ndash;Fuller. Esta opción no es compatible
	con <opt>nc</opt>, <opt>ctt</opt> ni <opt>seasonals</opt>.
      </para>

      <para>
	En todos los casos, la variable dependiente en la regresión del contraste,
	es la primera diferencia de la serie especificada (<math>y</math>), y la
	variable independiente clave es el primer retardo de <math>y</math>. La
	regresión se forma de modo que el coeficiente de la variable <math>y</math>
	retardada, es igual a la raíz en cuestión, &agr;, menos 1. Por ejemplo,
	el modelo con constante puede escribirse como
	<equation status="display"
	tex="\[(1-L)y_t=\beta_0+(\alpha-1)y_{t-1}+\epsilon_t\]"
	ascii="(1 - L)y(t) = b0 + (a-1)y(t-1) + e(t)" graphic="adf1"/>
	Bajo la hipótesis nula de existencia de una raíz unitaria, el coeficiente
	de la variable <math>y</math> retardada es igual a cero. Bajo la hipótesis
	alternativa de que <math>y</math> es estacionaria, este coeficiente es
	negativo. Entonces el contraste es propiamente de una cola.
      </para>

      <subhead context="cli">Selección del orden de retardos</subhead>

      <para context="cli">
	La versión más simple del contraste de Dickey&ndash;Fuller asume que
	la perturbación aleatoria de la regresión que se utiliza en el contraste
	no presenta autocorrelación. En la práctica, esto no es probable que
	suceda por lo que la especificación de la regresión a menudo se amplía
	incluyendo uno o más retardos de la variable dependiente, proporcionando
	un contraste de Dickey&ndash;Fuller aumentado (ADF). El argumento
	<repl>orden</repl> controla el número de esos retardos (<math>k</math>),
	eventualmente dependiendo del tamaño de la muestra (<math>T</math>).
      </para>
      <ilist context="cli">
	<li>
	  <para>
	    Para usar un valor fijo de <math>k</math>, especificado por el
	    usuario: indica un valor no negativo para <repl>orden</repl>.
	  </para>
	</li>
	<li>
	  <para>
	    Para usar un valor de <math>k</math> dependiente de <math>T</math>:
	    indica <repl>orden</repl> igual a &minus;1. Así el orden se establece
	    según lo aconsejado por <cite key="schwert89">Schwert (1989)</cite>:
	    concretamente se toma la parte entera de calcular
	    12(<math>T</math>/100)<sup>0.25</sup>.
	  </para>
	</li>
      </ilist>

      <para context="cli">
	Sin embargo, en general no se sabe cuantos retardos serán necesarios
	para poder <quote>blanquear</quote> el residuo de la regresión de
	Dickey&ndash;Fuller. Por consiguiente, es habitual especificar el
	<emphasis>máximo</emphasis> valor de <math>k</math>, y dejar que los
	datos 'decidan' el número concreto de retardos que se van a incluir.
	Esto se puede hacer por medio de la opción <opt>test-down</opt>.
	Y también puedes establecer el criterio con el que se determine un
	valor óptimo para <math>k</math>, utilizando el parámetro para esta
	opción que deberá ser uno de entre <lit>AIC</lit> (por defecto),
	<lit>BIC</lit> o <lit>tstat</lit>.
      </para>

      <para context="gui">
	Si el orden de retardos (<math>k</math>) es mayor que 0, entonces se incluyen
	<math>k</math> retardos de la variable dependiente en el lado derecho de cada
	una de las regresiones necesarias para calcular los estadísticos de los contrastes,
	sujeto esto al siguiente requisito. Cuando marcas el cuadradito de
	<quote>Contrastar desde el máximo orden de retardos hacia abajo</quote>,
	el orden de retardos que indicas se toma como máximo, y el orden de retardos
	concreto que se utilizará, se obtiene probando hacia abajo (mediante el
	criterio que elijas en la lista desplegable adjunta).
      </para>

      <para context="cli">
	Cuando pides que se compruebe hacia atrás mediante AIC o BIC, el
	orden de retardo final para la ecuación ADF es el que optimiza el
	criterio de información que elijas (de Akaike o Bayesiano de Schwarz).
	El procedimiento exacto dependerá de si indicas o no la opción
	<opt>gls</opt>. Cuando se especifica GLS (MCG), los criterios AIC
	y BIC son las versiones <quote>modificadas</quote> descritas en
	<cite key="ng-perron01">Ng y Perron (2001)</cite>; en otro caso, son
	las versiones estándar. En caso de MCG, dispones de un refinamiento.
	Cuando indicas la opción adicional <opt>perron-qu</opt>, la selección del
	orden de retardo se realiza mediante el método revisado que recomendaron
	<cite key="perron-qu07">Perron y Qu (2007)</cite>. En este caso, los
	datos se detraen primero mediante OLS (MCO) de la media o de la
	tendencia; GLS (MCG) se aplica una vez que ya se haya determinado
	el orden de retardo.
      </para>

      <para context="gui">
	Cuando pides que se pruebe hacia atrás mediante AIC o BIC, el orden
	de retardos final para la ecuación ADF es el que optimiza el criterio
	de información escogido (de Akaike o Bayesiano de Schwarz).
      </para>
	
      <para>
	Cuando pides que se pruebe hacia atrás mediante el método del estadístico
	<math>t</math>, el procedimiento es como se indica a continuación:
      </para>
      <nlist>
	<li><para>
	Se estima la regresión de Dickey&ndash;Fuller utilizando <math>k</math> retardos de la variable dependiente.
      </para>
	</li>
	<li><para>
	¿Es significativo el último retardo? Si lo es, se ejecuta el contraste con un orden de retardos
	<math>k</math>. Si no lo es, se hace que <math>k</math> = <math>k</math> &minus; 1,
	y se vuelve al paso 1 con un retardo menos. El proceso se repite hasta que sea significativo
	el último retardo de una regresión, o hasta que <math>k</math> sea 0 (se haría el contraste con un orden de retardos igual a 0).
	    </para>
	</li>
      </nlist>
      <para>
	En el contexto del paso 2 de arriba, <quote>significativo</quote>
	quiere decir que el estadístico <math>t</math> del último retardo
	tiene un valor <emphasis>p</emphasis> asintótico de dos colas igual
	o menor que 0.10, frente a la distribución Normal.
      </para>

      <para context="cli">
	En resumen, si admitimos los diferentes argumentos de Perron, Ng, Qu
	y Schwert indicados arriba, la instrucción preferible para comprobar
	una serie <lit>y</lit> es probable que sea:
      </para>
      <code context="cli">
	adf -1 y --c --gls --test-down --perron-qu
      </code>
      <para context="cli">
	(O sustituyendo <opt>ct</opt> en lugar de <opt>c</opt> si la serie parece
	tener una tendencia.) El orden de retardo para el contraste será entonces
	determinado probándolo hacia atrás, mediante los cambios en AIC a partir
	del máximo de Schwert, con el refinamiento de Perron&ndash;Qu.
      </para>

      <para>
	Los valores <emphasis>P</emphasis> para los contrastes de
	Dickey&ndash;Fuller están basados en estimaciones de tipo superficie
	de respuesta. Cuando no se aplica MCG (GLS), se toman de
	<cite key="mackinnon96">MacKinnon (1996)</cite>. De lo contrario, se
	toman de <cite key="cottrell15">Cottrell (2015)</cite> o, cuando se
	prueba hacia atrás, de <cite key="sephton21">Sephton (2021)</cite>.
	Los valores <emphasis>P</emphasis> son específicos para el tamaño
	de la muestra, excepto que estén etiquetados como asintóticos.
      </para>

      <subhead context="cli">Datos de Panel</subhead>

      <para context="cli">
	Cuando se utiliza la instrucción <lit>adf</lit> con datos de panel para
	hacer un contraste de raíz unitaria de panel, las opciones aplicables y
	los resultados que se muestran son algo diferentes.
      </para>
      <para context="cli">
	Primero, mientras que puedes indicar una lista de variables para
	probar en el caso de series temporales típicas, con datos de panel solo
	puedes contrastar una variable por cada instrucción. Segundo, las opciones
	que manejan la inclusión de términos determinísticos pasan a ser
	mutuamente excluyentes: debes escoger una entre sin constante,
	con constante, y con constante más tendencia; por defecto es con
	constante. Además, la opción <opt>seasonals</opt> no está
	disponible. Tercero, la opción <opt>verbose</opt> aquí tiene un
	significado diferente: produce un breve informe del contraste para cada
	serie temporal individual (siendo este por defecto una presentación
	solo del resultado global).
      </para>
      <para context="cli">
	Se calcula el contraste global (Hipótesis nula: La serie en cuestión
	tiene una raíz unitaria para todas las unidades del panel)
	de una o las dos formas siguientes: utilizando el método de
	<cite key="IPS03">Im, Pesaran y Shin (Journal of Econometrics, 2003)</cite>
	o la de
	<cite key="choi01">Choi (Journal of International Money and Finance, 2001)</cite>
	El contraste de Choi requiere que estén disponibles las probabilidades asociadas
	(valores <emphasis>P</emphasis>) para los contrastes individuales; si este no
	es el caso (dependiendo de las opciones escogidas), se omite. El estadístico
	concreto proporcionado para el contraste de Im, Pesaran y Shin varía del modo
	siguiente: si el orden de retardo para el contraste no es cero, se muestra su
	estadístico <math>W</math>; por otro lado, si las longitudes de las series
	de tiempo difieren de un individuo a otro, se muestra su estadístico
	<math>Z</math>; en otro caso, se muestra su estadístico <math>t</math>-barra.
	Consulta también la instrucción <cmdref targ="levinlin"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Contrastes de raíz unitaria/Contraste aumentado de Dickey-Fuller</menu-path>
    </gui-access>

  </command>

  <command name="anova" label="ANOVA" section="Statistics">
    <usage>
      <arguments>
        <argument>respuesta</argument>
        <argument>tratamiento</argument>
        <argument optional="true">control</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
      </options>
    </usage>
    <description>
      <para>
	Análisis de la Varianza: El argumento <repl>respuesta</repl> deberá ser
	una serie que mida algún efecto de interés, y <repl>tratamiento</repl>
	deberá ser una variable discreta que codifique dos o más tipos
	de tratamiento (o no tratamiento). Para un ANOVA de dos factores,
	la variable <repl>control</repl> (que también será discreta) deberá
	codificar los valores de alguna variable de control.
      </para>
      <para context="cli">
	Excepto cuando indicas la opción <opt>quiet</opt>, esta instrucción presenta
	una tabla mostrando las sumas de cuadrados y los cuadrados de la media junto
	con un contraste <math>F</math>. Puedes recuperar el estadístico del contraste
	<math>F</math> y su probabilidad asociada, utilizando los accesores
	<fncref targ="$test"/> y <fncref targ="$pvalue"/>, respectivamente.
      </para>
      <para>
	La hipótesis nula del contraste <math>F</math> es que la respuesta media es
	invariante con respecto al tipo de tratamiento o, en otras palabras,
	que el tratamiento no tiene efecto. Hablando estrictamente, el contraste solo
	es válido cuando la varianza de la respuesta es la misma para todos los tipos
	de tratamiento.
      </para>
      <para>
	Ten en cuenta que los resultados que muestra esta instrucción son de hecho un
	subconjunto de la información ofrecida por el siguiente procedimiento, que puedes
	preparar fácilmente en el GRETL. (1) Genera un conjunto de variables ficticias que
	codifiquen todos los tipos de tratamiento excepto uno. Para un ANOVA de dos factores,
	genera además un conjunto de variables ficticias que codifiquen todos los bloques
	de <quote>control</quote> excepto uno. (2) Haz la regresión de <repl>respuesta</repl>
	sobre una constante y las variables ficticias utilizando <cmdref targ="ols"/>.
	Con un único factor, se presenta la tabla ANOVA mediante la opción <opt>anova</opt> en esa
	función <lit>ols</lit>. En caso de dos factores, el contraste <math>F</math>
	relevante lo encuentras utilizando la instrucción <cmdref targ="omit"/> luego de la regresión.
	Por ejemplo, (asumiendo que <repl>respuesta</repl> es <lit>y</lit>, que <lit>xt</lit>
	codifica el tratamiento, y que <lit>xb</lit> codifica los bloques de <quote>control</quote>):
      </para>
      <code>
	# Un factor
	list Fict_xt = dummify(xt)
	ols y 0 Fict_xt --anova
	# Dos factores
	list Fict_xb = dummify(xb)
	ols y 0 Fict_xt Fict_xb
	# Contraste de significación conjunta de Fict_xt
	omit Fict_xt --quiet
      </code>
    </description>

    <gui-access>
      <menu-path>/Modelo/Otros modelos lineales/ANOVA</menu-path>
    </gui-access>

  </command>

  <command name="append" section="Dataset" label="Añadir datos" context="cli">

    <usage>
      <arguments>
        <argument>nombrearchivo</argument>
      </arguments>
      <options>
	<option>
	  <flag>--time-series</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--fixed-sample</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--update-overlap</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Presenta menos detalles de confirmación; mira abajo</effect>
	</option>
	<optnote>Mira abajo para opciones adicionales especiales</optnote>
      </options>
    </usage>

    <description>
      <para>
	Abre un archivo de datos y agrega el contenido al conjunto vigente
	de datos, si los nuevos datos son compatibles. El programa intentará
	detectar el formato del archivo de datos (propio, texto plano, CSV,
	Gnumeric, Excel, etc.). Por favor, ten en cuenta que dispones de la
	instrucción <cmdref targ="join"/> que ofrece un control mucho mayor para
	hacer coincidir los datos adicionales con la base de datos vigente.
	Observa también que añadir datos a un conjunto de datos ya existente es
	potencialmente bastante complicado; en ese sentido, consulta más abajo
	la sección titulada <quote>Datos de panel</quote>.
      </para>
      <para>
	Los datos añadidos pueden tener el formato de observaciones adicionales
	sobre series ya presentes en el conjunto de datos, y/o el formato de
	nuevas series. En caso de añadir series, la compatibilidad requiere
	(a) que el número de observaciones de los nuevos datos sea igual al
	número de datos actuales, o (b) que los nuevos datos conlleven una
	clara información de las observaciones de modo que GRETL pueda
	deducir como colocar los valores. Ten en cuenta que si hay una
	<quote>coincidencia perfecta</quote> de la información de las observaciones
	(es decir, cando ambas condiciones (a) y (b) se satisfacen), se asume
	que se van a añadir las series, más que las observaciones. Y si sucede
	que no hay nombres de las series en el archivo cuyos datos se van a
	añadir y que aún no están presentes en el conjunto de datos vigente,
	entonces no se hace nada y se muestra una advertencia.
      </para>
      <para>
	Un caso que no se admite es aquel en el que los nuevos datos comienzan
	antes y acaban después que los datos originales. Para añadir series
	en esa situación, puedes utilizar la opción <opt>fixed-sample</opt>;
	esto tiene como efecto que se suprime la adición de observaciones,
	por lo que así, la operación se restringe únicamente a añadir series
	nuevas.
      </para>
      <para>
	Cuando se selecciona un archivo de datos para agregar, puede
	haber un área de solapamiento con el conjunto de datos existente;
	es decir, una o más series pueden tener una o más observaciones
	en común entre los dos orígenes. Cuando indicas la opción
	<opt>update-overlap</opt>, la instrucción <lit>append</lit>
	substituye cualquier observación solapada con los valores del archivo
	de datos escogido; en otro caso, los valores que en ese momento ya
	están en su sitio no se ven afectados.
      </para>
      <para>
	Las opciones especiales adicionales <opt>sheet</opt>, <opt>coloffset</opt>,
	<opt>rowoffset</opt> y <opt>fixed-cols</opt> funcionan del mismo modo
	que con <cmdref targ="open"/>; consulta esa instrucción para obtener más
	explicaciones.
      </para>
      <para>
	Por defecto, se presenta alguna información sobre el conjunto de datos
	agregado. La opción <opt>quiet</opt> reduce esa informacióna a un
	simple mensaje confirmatorio que solo indica la ruta hasta el archivo.
	Si quieres que la operación se complete de modo silencioso, indica la
	instrucción <lit>set verbose off</lit> antes de agregar los datos, en
	combinación con la opción <opt>quiet</opt>.
      </para>
      <subhead>Datos de panel</subhead>
      <para>
	Cuando los datos se añaden a un conjunto de datos de panel, el resultado
	tan solo va a ser correcto si coinciden de forma apropiada tanto las
	<quote>unidades</quote> o <quote>individuos</quote>, como los períodos
	de tiempo.
      </para>
      <para>
	La instrucción <lit>append</lit> debería manejar correctamente dos
	situaciones relativamente simples. Sirva <math>n</math> para denotar el
	número de unidades atemporales y <math>T</math> para denotar el número
	de períodos de tiempo del panel vigente; y sirva <math>m</math> para
	denotar el número de observaciones de los nuevos datos. Si <math>m = n</math>,
	los nuevos datos se consideran invariantes en el tiempo, y se copian
	repetidos para cada período de tiempo. Por otro lado, si
	<math>m = T</math> los datos se tratan como invariantes entre
	las unidades atemporales, y se copian repetidos para cada unidad
	atemporal. Si el panel es <quote>cuadrado</quote>, y <math>T = n</math>
	aparece una ambigüedad. Por defecto, en este caso se tratan los nuevos
	datos como invariantes en el tiempo, pero puedes forzar a que GRETL los
	trate como series temporales (invariantes entre las unidades) con la
	opción <opt>time-series</opt>.
      </para>
      <para>
	Cuando se reconoce tanto al conjunto de datos vigente como a los datos
	que se van a añadir como datos de panel, aparecen dos situaciones.
	(1) La longitud de las series de tiempo, <math>T</math>, es diferente
	entre los dos. Entonces se presenta un fallo. (2) <math>T</math> coincide.
	En ese caso se hace un supuesto muy simple, en particular que las
	unidades coinciden, <emphasis>empezando por la primera unidad</emphasis>
	en ambos conjuntos de datos. Si ese supuesto no es correcto, deberás
	utilizar la instrucción <cmdref targ="join"/> en lugar de <lit>append</lit>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Archivo/Añadir datos</menu-path>
    </gui-access>

  </command>

  <command name="ar" section="Estimation" label="Estimación autorregresiva">

    <usage>
      <arguments>
        <argument>retardos</argument>
	      <argument separated="true">depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta las estimaciones de los parámetros</effect>
	</option>
      </options>
      <examples>
        <example>ar 1 3 4 ; y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcula las estimaciones de los parámetros utilizando el procedimiento iterativo
	generalizado de Cochrane&ndash;Orcutt; consulta la Sección 9.5 de
	<cite key="ramanathan02">Ramanathan (2002)</cite>. Las iteraciones acaban
	cuando la sucesión de sumas de errores cuadrados no difiere de un término al
	siguiente en más del 0.005 por ciento, o después de 20 iteraciones.
      </para>

      <para context="gui">
	Con la <quote>Lista de retardos AR</quote> especificas la estructura
	del proceso generador del término de perturbación. Por ejemplo, la
	indicación <quote>1 3 4</quote> se corresponde con el proceso:
	<equation status="display"
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
    ascii="u(t) = rho1*u(t-1) + rho3*u(t-3) + rho4*u(t-4)"
    graphic="arlags"/>
      </para>

      <para context="cli">
	Con <repl quote="true">retardos</repl> tienes que indicar una lista de
	retardos del término de perturbación, acabada en un punto y coma.
	En el ejemplo de arriba, el término de perturbación se especifica como
	<equation status="display"
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
    ascii="u(t) = rho(1)*u(t-1) + rho(3)*u(t-3) + rho(4)*u(t-4)"
    graphic="arlags"/>
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelo/Series temporales univariantes/Errores AR (MCG)</menu-path>
    </gui-access>

  </command>

  <command name="ar1" section="Estimation" label="Estimación AR(1)">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--hilu</flag>
	  <effect>Utiliza el procedimiento de Hildreth&ndash;Lu</effect>
	</option>
	<option>
	  <flag>--pwe</flag>
	  <effect>Utiliza el estimador de Prais&ndash;Winsten</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--no-corc</flag>
	  <effect>No afina los resultados con Cochrane-Orcutt</effect>
	</option>
	<option>
	  <flag>--loose</flag>
	  <effect>Utiliza un criterio de convergencia menos preciso</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
	</option>
      </options>
      <examples>
        <example>ar1 1 0 2 4 6 7</example>
	<example>ar1 y 0 xlista --pwe</example>
	<example>ar1 y 0 xlista --hilu --no-corc</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcula estimaciones MCG que sean viables para un modelo
	en el que el término de perturbación se asume que sigue un proceso
	autorregresivo de primer orden.
      </para>
      <para>
	El método utilizado por defecto es el procedimiento iterativo de
	Cochrane&ndash;Orcutt; por ejemplo, consulta la sección 9.4
	de <cite key="ramanathan02">Ramanathan (2002)</cite>. El
	criterio para lograr la convergencia es que las estimaciones
	sucesivas del coeficiente de autocorrelación, no difieran en
	más de 1e-6 o, cuando indicas la opción <opt>loose</opt>,
	en más de 0.001. Si esto no se alcanza antes de que se
	hagan las 100 iteraciones, se muestra un fallo.
      </para>
      <para>
	Cuando indicas la opción <opt>pwe</opt>, se utiliza el estimador
	de Prais&ndash;Winsten. Esto implica una iteración similar
	a la de Cochrane&ndash;Orcutt; la diferencia está en que mientras
	que el método de Cochrane&ndash;Orcutt descarta la primera
	observación, el método de Prais&ndash;Winsten hace uso de ella.
	Para obtener más detalles consulta, por ejemplo, el capítulo 13
	de <cite key="greene00">Greene (2000)</cite>.
      </para>
      <para>
	Cuando indicas la opción <opt>hilu</opt>, se utiliza el procedimiento
	de búsqueda de Hildreth&ndash;Lu. En ese caso, se afinan los
	resultados utilizando el método de Cochrane&ndash;Orcutt,
	excepto que especifiques la opción <opt>no-corc</opt>.
	Esta opción <opt>no-corc</opt> se ignora para estimadores
	diferentes al del método de Hildreth&ndash;Lu.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Series temporales univariantes/Errores AR (MCG)</menu-path>
    </gui-access>

  </command>

  <command name="arch" section="Estimation" label="Modelo ARCH">

    <usage>
      <arguments>
        <argument>orden</argument>
        <argument>depvar</argument>
      	<argument>indepvars</argument>
      </arguments>
      <options>
      <option>
	    <flag>--quiet</flag>
	    <effect>No presenta nada</effect>
	    </option>
      </options>
      <examples>
        <example>arch 4 y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	En este momento, esta instrucción se mantiene por compatibilidad con
	versiones anteriores, pero sales ganando si utilizas el estimador
	máximo verosímil que ofrece la instrucción <cmdref targ="garch"/>.
	Si quieres estimar un modelo ARCH sencillo, puedes usar el GARCH
	haciendo que su primer parámetro sea 0.
      </para>
      <para>
	Estima la especificación indicada del modelo permitiendo ARCH
	(Heterocedasticidad Condicional Autorregresiva). Primero,
	se estima el modelo mediante MCO, y luego se ejecuta una regresión
	auxiliar, en la que se regresa el error cuadrado de la primera sobre
	sus propios valores retardados. El paso final es la estimación por
	mínimos cuadrados ponderados, utilizando como ponderaciones las
	inversas de las varianzas de los errores ajustados con la regresión auxiliar.
	(Si la varianza que se predice para alguna observación de la regresión
	auxiliar, no es positiva, entonces se utiliza en su lugar el error cuadrado
	correspondiente).
      </para>
      <para>
	Los valores <lit>alpha</lit> presentados debajo de los coeficientes
	son los parámetros estimados del proceso ARCH con la regresión
	auxiliar.
      </para>
      <para>
	Consulta también <cmdref targ="garch"/> y <cmdref targ="modtest"/>
	(opción <opt>arch</opt>).
      </para>
    </description>

  </command>

  <command name="arima" section="Estimation" label="Modelo ARIMA">

    <usage>
      <arguments>
	<argblock>
	  <argument>p</argument>
	  <argument>d</argument>
	  <argument>q</argument>
	</argblock>
	<argblock separated="true" optional="true">
	  <argument>P</argument>
	  <argument>D</argument>
	  <argument>Q</argument>
	</argblock>
	<argument separated="true">depvar</argument>
	<argument optional="true">indepvars</argument>
      </arguments>
      <options>
	      <option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	      </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--hessian</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--opg</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--nc</flag>
	  <effect>Sin constante</effect>
        </option>
        <option>
	  <flag>--conditional</flag>
	  <effect>Utiliza Máxima Verosimilitud condicional</effect>
        </option>
        <option>
	  <flag>--x-12-arima</flag>
	  <effect>Utiliza ARIMA X-12 o X-13 en la estimación</effect>
        </option>
	<option>
	  <flag>--lbfgs</flag>
	  <effect>Utiliza el maximizador L-BFGS-B</effect>
	</option>
	<option>
	  <flag>--y-diff-only</flag>
	  <effect>ARIMAX especial; mira abajo</effect>
	</option>
	<option>
	  <flag>--lagselect</flag>
	  <effect>Mira abajo</effect>
	</option>
	      </options>
      <examples>
        <example>arima 1 0 2 ; y</example>
	<example>arima 2 0 2 ; y 0 x1 x2 --verbose</example>
	<example>arima 0 1 1 ; 0 1 1 ; y --nc</example>
	<demos>
	<demo>armaloop.inp</demo>
	<demo>auto_arima.inp</demo>
	<demo>bjg.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>

      <para>
	Advertencia: <lit>arma</lit> es un alias aceptable para esta instrucción.
      </para>
      <para context="cli">
	Cuando no indicas la lista <repl>indepvars</repl>, se estima
	un modelo univariante ARIMA (Autorregresivo, Integrado, de
	Medias móviles). Los valores <repl>p</repl>, <repl>d</repl>
	y <repl>q</repl> representan el orden autorregresivo (AR), el
	orden de diferenciación y el orden de medias móviles (MA),
	respectivamente. Puedes indicar estos valores en formato
	numérico, o como nombres de variables escalares ya existentes.
	Por ejemplo, un valor de 1 para <repl>d</repl> significa que,
	antes de estimar los parámetros del ARMA, debe tomarse
	la primera diferencia de la variable dependiente.
      </para>
      <para context="cli">
	Si quieres incluir en el modelo solo retardos AR o MA específicos (en
	contraposición a todos los retardos hasta un orden indicado) puedes
	substituir por <repl>p</repl> y/o <repl>q</repl> bien (a) el nombre
	de una matriz definida previamente que contiene un conjunto de valores
	enteros, o bien (b) una expresión tal como <lit>{1,4}</lit>; es decir,
	un conjunto de retardos separados con comas y puestos entre llaves.
      </para>
      <para context="cli">
	Los valores enteros <repl>P</repl>, <repl>D</repl> y
	<repl>Q</repl> (opcionales) representan el orden AR estacional,
	el orden de diferenciación estacional y el orden MA estacional,
	respectivamente. Estos órdenes solo los puedes aplicar cuando los
	datos tienen una frecuencia mayor que 1 (por ejemplo, con
	datos trimestrales o mensuales); y puedes indicarlas en formato
	numérico o como variables escalares.
      </para>
      <para context="cli">
	En el caso univariante, por defecto se incluye en el modelo
	una ordenada en el origen, pero puedes eliminar esto por medio de la
	opción <opt>nc</opt>. Cuando añades <repl>indepvars</repl>,
	el modelo se convierte en un ARMAX; en este caso, debes incluir la
	constante explícitamente si quieres tener la ordenada en el origen
	(como en el segundo ejemplo de arriba).
      </para>
      <para context="cli">
	Dispones de una forma alternativa de sintaxis para esta instrucción:
	si no quieres aplicar diferencias (ni estacionales ni no estacionales),
	puedes omitir los dos campos <repl>d</repl> y <repl>D</repl> a la vez,
	mejor que introducir explícitamente 0. Además, <lit>arma</lit>
	es un alias o sinónimo de <lit>arima</lit> y así, por ejemplo, la
	siguiente instrucción es un modo válido de especificar un modelo
	ARMA(2, 1):
      </para>
      <code context="cli">
	arma 2 1 ; y
      </code>
      <para context="gui">
	Estima un modelo ARMA, con o sin regresores exógenos. Si
	el orden de diferenciación es mayor que cero, el modelo se convierte
	en un ARIMA. Cuando los datos tienen una frecuencia mayor que 1,
	se te presenta la posibilidad de que incluyas una componente
	estacional.
      </para>
      <para context="gui">
	Si quieres incluir en el modelo únicamente retardos AR o MA específicos (en
	contraposición a incluir todos los retardos hasta un orden indicado), marca
	el cuadradito a la derecha del botón con flechas arriba/abajo y teclea una lista
	de retardos en el campo de anotación, separados por espacios. De forma
	alternativa, si tienes definida una matriz que contiene el conjunto de retardos
	que deseas, puedes teclear su nombre en el campo de anotación.
      </para>
      <para>
	Por defecto, se utiliza la funcionalidad ARMA <quote>propia</quote> de
	GRETL, con la estimación Máximo Verosímil (MV) exacta; pero dispones de
	la opción de hacer la estimación mediante MV condicional. (Si el programa
	<program>ARIMA X-12</program> está instalado en el ordenador, tienes la
	posibilidad de utilizarlo en vez del código propio. Ten en cuenta que,
	de igual modo, el más reciente <program>X13</program> puede funcionar
	como un recambio automático.) Para otros detalles relacionados con
	estas opciones, consulta <guideref targ="chap:timeseries"/>.
      </para>
      <para context="cli">
	Cuando se utiliza código propio de MV exacta, las desviaciones
	típicas estimadas se basan por defecto en una aproximación numérica a la
	(inversa negativa de la) matriz Hessiana, con un último recurso al Producto
	Externo del vector Gradiente (PEG) si el cálculo de la matriz Hessiana
	numérica pudiera fallar. Puedes utilizar dos indicadores de opción
	(mutuamente excluyentes) para forzar esta cuestión: mientras que la
	opción <opt>opg</opt> fuerza la utilización del método PEG, sin intentar
	calcular la matriz Hessiana, la opción <opt>hessian</opt> inhabilita
	el último recurso a PEG. Ten en cuenta que un fallo en el cálculo de la matriz
	Hessiana numérica, generalmente es un indicador de que un modelo está
	mal especificado.
      </para>
      <para context="cli">
	La opción <opt>lbfgs</opt> es específica de la estimación que utiliza
	código ARMA propio y Máxima Verosimilitud exacta; y solicita
	que se utilice el algoritmo de <quote>memoria limitada</quote>
	L-BFGS-B en lugar del maximizador BFGS habitual. Esto puede ser de
	ayuda en algunos casos en los que la convergencia es difícil de lograr.
      </para>
      <para context="cli">
	La opción <opt>y-diff-only</opt> es específica de la estimación de modelos
	ARIMAX (modelos con orden de integración no nulo, en los que se incluyen
	regresores exógenos) y se aplica solo cuando se utiliza la Máxima Verosimilitud
	exacta propia de GRETL. Para esos modelos, el comportamiento por defecto
	consiste en calcular las primeras diferencias tanto de la variable dependiente
	como de los regresores; pero cuando indicas esta opción, solo se calcula para
	la variable dependiente, quedando los regresores en niveles.
      </para>
      <para>El valor del AIC de Akaike indicado en conexión
	con modelos ARIMA, se calcula de acuerdo con la definición que
	utiliza el <program>ARIMA X-12</program>, concretamente
	  <equation status="display"
	  tex="\[\mbox{AIC}=-2\ell + 2k\]"
	  ascii="AIC = -2L + 2k"
	  graphic="aic"/> donde 
	<equation status="inline"
	  tex="$\ell$" ascii="L"
	  graphic="ell"/> es el
	logaritmo de la verosimilitud y <math>k</math> es el número total de
	parámetros estimados. Observa que el <program>ARIMA X-12</program>
	no produce criterios de información tales como AIC cuando la estimación
	es por Máxima Verosimilitud condicional.
      </para>
      <para context="tex">
	Las raíces AR y MA mostradas en conexión con la estimación
	ARMA se basan en la siguiente representación de un proceso
	ARMA($p,q$):
	  \[
	   (1-\phi_1 L - \phi_2 L^2 - \cdots - \phi_p L^p)Y =
      c + (1 + \theta_1 L + \theta_2 L^2 + \cdots +
      \theta_q L^q)\varepsilon_t
    \]
	Por lo tanto, las raíces AR son las soluciones a
    \[
     1 - \phi_1 z - \phi_2 z^2 - \cdots - \phi_p L^p = 0
    \]
	y la estabilidad requiere que estas raíces se encuentren
	fuera del círculo de radio unitario.
      </para>
      <para context="tex">
	La cantidad <quote>Frecuencia</quote> presentada en
	conexión con las raíces AR y MA, es el valor $\lambda$ que
	soluciona $z=re^{i2\pi\lambda}$, donde $z$ es la raíz en
	cuestión y $r$ es su módulo.
      </para>
      <para context="notex">
	Las raíces AR y MA mostradas en conexión con la estimación
	ARMA se basan en la siguiente representación de un proceso
	ARMA(p, q):
      </para>
      <mono context="notex">
      	(1 - a_1*L - a_2*L^2 - ... - a_p*L^p)Y =
        c + (1 + b_1*L + b_2*L^2 + ... + b_q*L^q) e_t
      </mono>
      <para context="notex">
	Por lo tanto, las raíces AR son las soluciones a
      </para>
      <mono context="notex">
       1 - a_1*z - a_2*z^2 - ... - a_p*L^p = 0
      </mono>
      <para context="notex">
	y la estabilidad requiere que estas raíces se encuentren
	fuera del círculo de radio unitario.
      </para>
      <para context="notex">
	La cantidad <quote>Frecuencia</quote> presentada en conexión con las
	raíces AR y MA, es el valor &lgr; que soluciona <math>z</math> =
	<math>r</math> * exp(i*2*&pi;*&lgr;) donde <math>z</math> es la raíz
	en cuestión, y <math>r</math> es su módulo.
      </para>

      <subhead context="cli">Lag selection</subhead>
      <para context="cli">
	Cuando se indica la opción <opt>lagselect</opt>, esta instrucción no
	proporciona estimaciones concretas, sino que en su lugar produce
	una tabla que presenta criterios de información y el logaritmo de la
	verosimilitud para ciertas especificaciones ARMA o ARIMA. Los órdenes de
	retardo <math>p</math> y <math>q</math> se consideran como máximos;
	y cuando se indica una especificación estacional, <math>P</math> y
	<math>Q</math> también se consideran como máximos. En todo caso, el orden
	mínimo se considera que es 0, y los resultados se muestran para todas las
	especificaciones desde la mínima hasta la máxima. Los grados de diferenciación
	en la instrucción, <math>d</math> y/o <math>D</math>, se respetan pero
	no se tratan como objeto de investigación. Puedes obtener una matriz que
	contenga los resultados mediante el accesor <fncref targ="$test"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Series temporales univariantes/ARIMA</menu-path>
    </gui-access>

  </command>

  <command name="arma" section="Estimation" label="Modelo ARMA">
    <description>
      <para>
	Consulta <cmdref targ="arima"/>; <lit>arma</lit> es un alias.
      </para>
    </description>
  </command>

  <command name="ARMA-lagselect" section="Tests" context="gui"
    label="Selección del orden de retardo de un AR(I)MA">

    <description>
      <para>
	En esta caja de diálogo, se especifica un modelo ARMA o ARIMA como se hace
	habitualmente; pero los órdenes de retardo que indiques se toman como máximos.
      </para>
      <para>
	La salida de resultados consiste en una tabla que muestra los valores
	de los Criterios de Información de Akaike (AIC), de Schwarz (BIC) y de
	Hannan&ndash;Quinn (HQC), así como el logaritmo de la verosimilitud,
	calculados para las especificaciones que van desde los mínimos hasta
	los máximos. Esto está pensado para ayudar en la selección de los
	órdenes óptimos de retardo.
      </para>
    </description>
  </command>

  <command name="bds" section="Tests" label="Contraste BDS de no linealidad">
    <usage>
      <arguments>
        <argument>orden</argument>
	<argument>x</argument>
      </arguments>
      <options>
        <option>
	  <flag>--corr1</flag>
	  <optparm>rho</optparm>
	  <effect>Mira abajo</effect>
        </option>
	<option>
	  <flag>--sdcrit</flag>
	  <optparm>multiple</optparm>
	  <effect>Mira abajo</effect>
        </option>
	<option>
	  <flag>--boot</flag>
	  <optparm>N</optparm>
	  <effect>Mira abajo</effect>
        </option>
	<option>
	  <flag>--matrix</flag>
	  <optparm>m</optparm>
	  <effect>Utiliza una entrada matricial</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Suprime la presentación de resultados</effect>
        </option>
      </options>
      <examples>
        <example>bds 5 x</example>
	<example>bds 3 --matrix=m</example>
	<example>bds 4 --sdcrit=2.0</example>
      </examples>
    </usage>
    <description>
      <para context="cli">
	Lleva a cabo el contraste BDS
	(<cite key="brock-etal96">Brock, Dechert, Scheinkman y LeBaron, 1996</cite>)
	de no linealidad para la serie <repl>x</repl>. En el contexto econométrico, esto
	se aplica habitualmente para comprobar si los residuos de una regresión incumplen
	la condición IID (distribución idéntica e independiente). El contraste se basa
	en un conjunto de integrales de correlación, preparadas para detectar la no
	linealidad de dimensión progresivamente mayor; y se establece el número de esas
	integrales con el argumento <argname>orden</argname>. Estas deben ser por lo
	menos 2; con la primera integral se establece una referencia de partida, pero sin
	que permita un contraste. El contraste BDS es de tipo <quote>portmanteau</quote>:
	adecuado para detectar toda clase de desviaciones respecto a la linealidad,
	pero no esclarecedor del modo exacto en el que se incumple la condición.
      </para>
      <para context="gui">
	El contraste BDS
	(<cite key="brock-etal96">Brock, Dechert, Scheinkman y LeBaron, 1996</cite>)
	comprueba la no linealidad de una serie temporal. En el contexto econométrico, esto
	se aplica habitualmente para comprobar si los residuos de una regresión incumplen
	la condición IID (distribución idéntica e independiente). El contraste se basa
	en un conjunto de integrales de correlación, preparadas para detectar la no
	linealidad de dimensión progresivamente mayor; el número de esas integrales
	se elige mediante el control <quote>Dimensión máxima</quote>. Estas deben ser por lo
	menos 2; con la primera integral se establece una referencia de partida, pero sin
	que permita un contraste. El contraste BDS es de tipo <quote>portmanteau</quote>:
	adecuado para detectar toda clase de desviaciones respecto a la linealidad,
	pero no esclarecedor del modo exacto en el que se incumple la condición.
      </para>
      <para context="cli">
	En lugar de indicar <repl>x</repl> como serie, puedes utilizar la
	opción <opt>matrix</opt> para especificar una matriz como entrada,
	la cual debe tener forma de vector (columna o fila).
      </para>
      <subhead>Criterio de proximidad</subhead>
      <para context="cli">
	Las integrales de correlación están basadas en una medida de
	<quote>proximidad</quote> entre los puntos de datos, de forma
	que se consideran próximos a dos de esos puntos si están situados
	uno del otro a menos de &egr;. Dado que el contraste necesita que se
	especifique &egr;, por defecto, GRETL sigue la recomendación de
	<cite key="kanzler99">Kanzler (1999)</cite>: &egr; se escoge de modo que
	la integral de correlación de primer orden esté en torno a 0.7. Una
	alternativa habitual (que necesita menos cálculos) consiste en especificar
	&egr; como un múltiplo de la desviación típica de la serie de interés.
	La opción <opt>sdcrit</opt> permite este último método;
	así, en el tercer ejemplo indicado más arriba, &egr; se determina que
	sea igual a dos veces la desviación típica de <repl>x</repl>.
	La opción <opt>corr1</opt> implica la utilización del método de Kanzler
	pero permite otra correlación objetivo diferente de 0.7. Deberías
	tener claro que estas dos opciones se excluyen mutuamente.
      </para>
      <para context="gui">
	Las integrales de correlación están basadas en una medida de
	<quote>proximidad</quote> entre los puntos de datos, de forma
	que se consideran próximos a dos de esos puntos si están situados
	uno del otro a menos de &egr;. Dado que el contraste necesita que se
	especifique &egr;, por defecto, GRETL sigue la recomendación de
	<cite key="kanzler99">Kanzler (1999)</cite>: &egr; se escoge de modo que
	la integral de correlación de primer orden esté en torno a 0.7. Una
	alternativa habitual (que necesita menos cálculos) consiste en especificar
	&egr; como un múltiplo de la desviación típica de la serie de interés.
      </para>
      <subhead context="cli">Muestreo repetido</subhead>
      <para context="cli">
	Los estadísticos del contraste BDS tienen distribución asintótica de
	tipo <math>N</math>(0,1), pero el contraste rechaza demasiado la hipótesis
	nula de modo muy notable con muestras de tamaño entre pequeño y moderado.
	Por ese motivo, los valores <math>P</math> se obtienen por defecto
	mediante muestreo repetido (bootstrapping) cuando <argname>x</argname>
	tiene una longitud menor que 600 (y con referencia a la distribución
	Normal, en caso contrario). Si quieres utilizar el muestreo repetido
	con muestras más largas, puedes forzar esta cuestión indicando un
	valor no nulo para la opción <opt>boot</opt>. Por el contrario, si no
	quieres que se haga el muestreo repetido con las muestras más
	pequeñas, indica un valor de cero para <opt>boot</opt>.
      </para>
      <subhead context="gui">Valores p</subhead>
      <para context="gui">
	Los estadísticos del contraste BDS tienen distribución asintótica de
	tipo <math>N</math>(0,1), pero el contraste rechaza demasiado la hipótesis
	nula de modo muy notable con muestras de tamaño entre pequeño y moderado.
	Por ese motivo, los valores <math>P</math> se obtienen por defecto
	mediante muestreo repetido (bootstrapping) cuando <argname>x</argname>
	tiene una longitud menor que 600 (y con referencia a la distribución
	Normal, en caso contrario).
      </para>
      <para context="cli">
	Cuando se hace el muestreo repetido, el número de iteraciones por
	defecto es de 1999; pero puedes especificar un número diferente
	indicando un valor mayor que 1 con la opción <opt>boot</opt>.
      </para>
      <subhead context="cli">Matriz accesoria matrix</subhead>
      <para context="cli">
	Cuando se completa con éxito la ejecución de esta instrucción,
	<fncref targ="$result"/> proporciona los resultados del contraste en
	forma de una matriz con dos filas y <argname>orden</argname> &minus; 1
	columnas. La primera fila contiene los estadísticos de contraste y la
	segunda los valores <math>P</math>, de cada uno de los contrastes por
	dimensión, bajo la hipótesis nula de que <argname>x</argname> es lineal/IID.
      </para>
    </description>
  </command>

  <command name="bfgs-config" section="Estimation" label="Opciones de BFGS"
    context="gui">
    <description>
      <para>
	Este diálogo te permite controlar algunos aspectos del funcionamiento del
	maximizador BFGS. En caso de que el maximizador falle en la convergencia,
	puede mejorar la cosa (en algunos casos) al aumentar el número de iteraciones
	permitidas y/o al aumentar (hacer más permisiva) la tolerancia de la
	convergencia. Sin embargo, debes sospechar de los resultados que obtengas
	utilizando una tolerancia elevada y considerar la posibilidad de que el
	modelo que estimas esté mal especificado.
      </para>
      <para>
	Para la mayoría de las aplicaciones, te recomendamos que utilices el
	maximizador BFGS habitual pero, para algunos problemas, la variante
	del algoritmo con <quote>memoria limitada</quote> L-BFGS-B, puede
	producir una convergencia más rápida. Cuando seleccionas L-BFGS-B,
	tienes la posibilidad de establecer el número de correcciones utilizadas en la
	matriz de memoria limitada (entre 3 y 20, con 8 por defecto).
      </para>
    </description>
  </command>

  <command name="biprobit" section="Estimation" label="Modelo Probit bivariante"
    context="cli">
    <usage>
      <arguments>
        <argument>depvar1</argument>
	      <argument>depvar2</argument>
        <argument>indepvars1</argument>
	      <argument separated="true" optional="true">indepvars2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para aclaración</effect>
        </option>
	<option>
	  <flag>--opg</flag>
	  <effect>Mira abajo</effect>
        </option>
	<option>
	  <flag>--save-xbeta</flag>
	  <effect>Mira abajo</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta información adicional</effect>
        </option>
      </options>
      <examples>
        <example>biprobit y1 y2 0 x1 x2</example>
	<example>biprobit y1 y2 0 x11 x12 ; 0 x21 x22</example>
	<demos>
	  <demo>biprobit.inp</demo>
	</demos>
      </examples>
    </usage>
    <description>
      <para>
	Estima un modelo probit bivariante utilizando el método de
	Newton&ndash;Raphson para maximizar la verosimilitud.
      </para>
      <para>
	La lista de argumentos comienza con las dos variables (binarias)
	dependientes, seguidas de una lista de regresores. Cuando indicas
	una segunda lista (separada por un punto y coma) se
	entiende como un grupo de regresores específicos de la segunda
	ecuación, siendo <repl>indepvars1</repl> específica de la primera
	ecuación; en otro caso, <repl>indepvars1</repl> se considera
	que representa un conjunto de regresores común.
      </para>
      <para>
	Por defecto, las desviaciones típicas se calculan utilizando la matriz
	Hessiana analítica al converger. Pero si indicas la opción <opt>opg</opt>,
	la matriz de covarianzas se basa en el Producto Externo del vector
	Gradiente (PEG o OPG); o si indicas la opción <opt>robust</opt>, se
	calculan las desviaciones típicas cuasi máximo verosímiles (QML),
	utilizando un <quote>emparedado</quote> entre la inversa de la matriz
	Hessiana y el PEG.
      </para>
      <para>
	Observa que la estimación de rho, la correlación de los términos de
	error entre las dos ecuaciones, se incluye en el vector de coeficientes;
	es el último elemento de los accesores <lit>coeff</lit>,
	<lit>stderr</lit> y <lit>vcv</lit>.
      </para>
      <para>
	Luego de una estimación correcta, el accesor <lit>$uhat</lit>
	permite recuperar una matriz con 2 columnas que contiene los
	errores generalizados de las dos ecuaciones; es decir, los valores
	esperados de las perturbaciones condicionadas a los resultados
	observados y a las variables covariantes. Por defecto, <lit>$yhat</lit>
	permite recuperar una matriz con 4 columnas que contiene las
	probabilidades estimadas de los 4 posibles resultados conjuntos para
	(<math>y</math><sub>1</sub>, <math>y</math><sub>2</sub>), en el
	orden (1,1), (1,0), (0,1), (0,0). Alternativamente, cuando indicas
	la opción <opt>save-xbeta</opt>, entonces <lit>$yhat</lit> tiene 2 columnas
	y contiene los valores de las funciones índice de las ecuaciones respectivas.
      </para>
      <para>
	El resultado incluye un contraste de la hipótesis nula de que las
	perturbaciones de las dos ecuaciones no están correlacionadas. Este es
	un test de razón de verosimilitudes excepto que se solicite el estimador
	cuasi máximo verosímil (QML) de la varianza, en cuyo caso se usa el test de Wald.
      </para>
    </description>
  </command>

  <command name="bkw" section="Tests" context="cli"
	   label="Diagnósticos de Multicolinealidad">
    <usage>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
        </option>
      </options>
	<examples>
	<demos>
	  <demo>longley.inp</demo>
	</demos>
    </examples>
    </usage>

    <description>
      <para>
	Debe ir después de la estimación de un modelo que contenga al
	menos dos variables explicativas. Calcula y presenta información
	de diagnóstico en relación a la multicolinealidad, en concreto la
	Tabla BKW que está basada en el trabajo de
	<cite key="belsley-etal80">Belsley, Kuh y Welsch (1980)</cite>.
	Esta tabla presenta un sofisticado análisis del grado y de las causas de
	la multicolinealidad, mediante el examen de los autovalores de la inversa
	de la matriz de correlaciones. Para tener una explicación en detalle del
	enfoque BKW en relación a GRETL, y con diversos ejemplos, consulta
	<cite key="adkins15">Adkins, Waters y Hill (2015)</cite>.
      </para>
      <para>
	Después de utilizar esta instrucción, puedes usar el accesor
	<fncref targ="$result"/> para recuperar la tabla BKW en forma de
	matriz. Consulta también la instrucción <cmdref targ="vif"/> para
	obtener un enfoque más sencillo del diagnóstico de la multicolinealidad.
      </para>
      <para>
	Hay también una función denominada <fncref targ="bkw"/> que ofrece
	una mayor flexibilidad.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Análisis/Colinealidad</menu-path>
    </gui-access>

  </command>

  <command name="bootstrap" section="Tests" label="Opciones de Bootstrap"
    context="gui">

    <description>

      <para>En esta caja de diálogo vas a elegir:</para>

      <ilist>
	<li>
	    <para>
	    La variable o el coeficiente a examinar. (Utilizando este método,
	    solo puedes probar un coeficiente de cada vez .)
	    </para>
	</li>
	<li>
	    <para>
	    El tipo de análisis a realizar. El intervalo de confianza por defecto
	    (del 95 por ciento) se basa directamente en los cuantiles de las estimaciones
	    de los coeficientes mediante bootstrap. La versión del intervalo
	    <quote>studentizado</quote> es conforme a Davidson y MacKinnon,
	    <cite key="davidson-mackinnon04">Economic Theory and Methods</cite>
	    (ETM, capítulo 5): en cada repetición del bootstrap se forma
	    un ratio <math>t</math> que se calcula cogiendo la
	    diferencia entre la estimación de los coeficientes obtenida mediante
	    bootstrap y la de partida, y dividiéndola entre la desviación
	    típica de bootstrap. El intervalo de confianza 
	    se basa entonces en los cuantiles de este ratio <math>t</math>
	    de bootstrap, como se explica en el citado ETM. La opción valor p
	    se basa en la distribución del ratio <math>t</math> de bootstrap:
	    es la proporción de las repeticiones en las que el valor absoluto
	    de este estadístico excede el valor absoluto del ratio
	    <math>t</math> de partida.
	    </para>
	</li>
	<li>
	    <para>
	    El tipo de método Bootstrap. Bajo la primera opción, se vuelve a renovar
	    la muestra de los errores de la estimación original, con substitución
	    (luego de volverlos a escalar como se sugiere en ETM). Bajo la
	    segunda, se vuelve a renovar la muestra con substitución de los
	    <quote>pares</quote> o <quote>casos</quote>; es decir, las
	    filas de datos (<math>y</math>, <math>X</math>). En la tercera
	    opción, los errores originales se transforman primero conforme a
	    <cite key="davidson-flachaire01">Davidson y Flachaire (2001)</cite>;
	    entonces, en cada repetición del bootstrap, cada error transformado
	    se multiplica por 1 o &minus;1, con probabilidad igual
	    a 0.5 en cada caso. En la opción final, se generan valores
	    normales pseudoaleatorios utilizando la varianza de los errores
	    originales.
	    </para>
	</li>
	<li>
	    <para>
	    El número de repeticiones a realizar. Ten en cuenta que cuando
	    estás construyendo un intervalo con el 95 por ciento de confianza,
	    es deseable que 0.05(<math>B</math> + 1)/2 sea un entero
	    (donde <math>B</math> es el número de repeticiones). Así, GRETL
	    puede ajustar el número de repeticiones que escojas para
	    garantizar que este es el caso.
	    </para>
	</li>
	<li>
	    <para>
	    Produce o no un gráfico de la distribución bootstrap. Esta
	    opción utiliza el servicio de estimación de la densidad del
	    kernel de GRETL.
	    </para>
	</li>
      </ilist>

    </description>
  </command>

  <command name="boxplot" section="Graphs" label="Gráficos de caja">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--notches</flag>
	  <effect>Muestra el intervalo del 90 por ciento para la mediana</effect>
	</option>
	<option>
	  <flag>--factorized</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--panel</flag>
	  <effect>Mira abajo</effect>
	</option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nombre</optparm>
	  <effect>Representa las columnas de la matriz indicada</effect>
        </option>
	<option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el resultado al archivo especificado</effect>
	</option>
      </options>
    </usage>

    <description>

      <para>
	Estos gráficos muestran la distribución de una variable. Una
	caja central encierra el 50 por ciento central de los datos; &ie;
	está deslindada por el primer y el tercer cuartiles. Un
	<quote>bigote</quote> se extiende desde cada límite de la caja con un
	rango igual a 1.5 veces el rango intercuartil. Las observaciones
	que están fuera de ese rango se consideran valores atípicos y
	se representan mediante puntos. Se dibuja una línea a lo ancho
	de la caja en la mediana. El signo <quote>+</quote> se utiliza para
	indicar la media. Si escoges la opción de mostrar un intervalo de
	confianza para la mediana, este se calcula mediante el método
	bootstrap y se muestra con formato de líneas con rayas horizontales
	por arriba y/o abajo de la mediana.
      </para>

      <para context="gui">
	La opción <quote>factorized</quote> te permite examinar la distribución
	de la variable elegida condicionada al valor de algún factor discreto.
	Por ejemplo, si un conjunto de datos contiene una variable con los salarios
	y una variable ficticia con el género, puedes escoger la de los salarios como
	objetivo y la del género como el factor, para ver así los gráficos de
	cajas de salarios de hombres y mujeres, uno al lado del otro.
      </para>

      <para context="cli">
	La opción <opt>factorized</opt> te permite examinar la distribución
	de la variable elegida condicionada al valor de algún factor discreto.
	Por ejemplo, si un conjunto de datos contiene una variable con los salarios
	y una variable ficticia con el género, puedes escoger la de los salarios como
	objetivo y la del género como el factor, para ver así los gráficos de
	cajas de salarios de hombres y mujeres, uno al lado del otro, como en
      </para>
      <code context="cli">
	boxplot salario genero --factorized
      </code>
      <para context="cli">
	Ten en cuenta que en este caso debes especificar exactamente solo
	dos variables, con el factor indicado en segundo lugar.
      </para>

      <para context="cli">
	Cuando tienes un conjunto vigente de datos de panel y especificas solo una
	variable, la opción <opt>panel</opt> produce una serie de gráficos
	de cajas (uno al lado del otro) en la que cada uno se corresponde
	con un grupo o <quote>unidad</quote> del panel.
      </para>

      <para context="cli">
	Generalmente se requiere el argumento <repl>listavariables</repl> que se refiere
	a una o más series del conjunto vigente de datos (indicadas bien
	por el nombre o bien por el número ID). Pero si, mediante la opción
	<opt>matrix</opt>, indicas una matriz ya definida, este argumento se convierte
	en opcional pues, por defecto, se dibuja un gráfico para cada columna
	de la matriz especificada.
      </para>

      <para context="cli">
	Los gráficos de cajas en GRETL se generan utilizando la instrucción
	<program>gnuplot</program>, y resulta posible especificar con
	mayor detalle el gráfico añadiendo instrucciones adicionales de Gnuplot,
	puestas entre llaves. Para obtener más detalles, consulta la ayuda
	para la instrucción <cmdref targ="gnuplot"/>.
      </para>

      <para context="cli">
	En modo interactivo, el resultado se muestra inmediatamente. En modo de
	procesamiento por lotes, el proceder por defecto consiste en escribir un
	archivo de instrucciones de Gnuplot en el directorio de trabajo del usuario,
	con un nombre con el patrón <filename>gpttmpN.plt</filename>, comenzando con
	N = <lit>01</lit>. Puedes generar los gráficos más tarde utilizando el
	<program>gnuplot</program> (o bien <program>wgnuplot</program>
	bajo MS Windows). Puedes modificar este comportamiento mediante
	el uso de la opción <opt>output=</opt><repl>nombrearchivo</repl>. Si
	quieres obtener más detalles, consulta la instrucción
	<cmdref targ="gnuplot"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Ver/Gráficos/Gráficos de caja</menu-path>
    </gui-access>

  </command>

  <command name="break" section="Programming"
    label="Salir de un bucle" context="cli">
    <description>
      <para>
	Salida de un bucle. Puedes utilizar esta instrucción solo dentro de un bucle; eso
	provoca que la ejecución de instrucciones salga del bucle actual (del más interior,
	si hay varios anidados). Consulta también <cmdref targ="loop"/>, <cmdref targ="continue"/>.
      </para>
    </description>
  </command>

  <command name="bwfilter" section="Transformations" context="gui"
    label="El filtro de Butterworth">

    <description>
      <para>
	El filtro de Butterworth es una aproximación a un filtro ideal de ondas
	cuadradas, que permite pasar con total potencia a las frecuencias que
	superan un cierto rango, mientras detiene todas las otras.
      </para>
      <para>
	En principio, los valores más elevados del parámetro de orden
	(<math>n</math>) producen una aproximación más precisa al
	filtro ideal, pero con el posible coste de tener inestabilidad
	numérica. El valor <quote>de corte</quote> establece el
	límite entre la banda de paso y la banda de parada; se expresa
	en grados, y debe ser mayor que 0 y menor que 180&deg;
	(o &pi; radianes, correspondiéndose este con la mayor frecuencia
	de los datos). Los valores más pequeños del valor de corte
	producen una tendencia más suave.
      </para>
      <para>
	Cuando quieras aplicar este filtro, resulta un preámbulo muy útil que
	revises antes el periodograma de la serie que te interesa. Consulta
	<guideref targ="chap:genr"/> para obtener más detalles.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Filtrar/Butterworth</menu-path>
    </gui-access>

  </command>

  <command name="catch" section="Programming"
    label="Capturar fallos" context="cli">
    <usage>
      <syntax><lit>catch </lit><repl>command</repl></syntax>
    </usage>
    <description>
      <para>
	Esta no es una instrucción por si misma, pero puedes utilizarla como prefijo en
	la mayoría de las instrucciones habituales: su efecto es el de prevenir que acabe
	un guion de instrucciones si ocurre un fallo al ejecutar una de ellas. Si aparece
	un fallo, esto se registra con un código de fallo interno al que puedes acceder
	con <fncref targ="$error"/> (un valor de 0 indica éxito). Inmediatamente
	después de utilizar <lit>catch</lit> deberías verificar siempre cual es el valor
	de <lit>$error</lit>, y realizar una acción adecuada si falló una de las instrucciones.
      </para>
      <para>
	No puedes utilizar la palabra clave <lit>catch</lit> antes de <lit>if</lit>,
	<lit>elif</lit> o <lit>endif</lit>. Además, no debe utilizarse en peticiones
	a funciones definidas por el usuario, pues se pretende utilizarla solo con las
	instrucciones de GRETL y con las peticiones a los operadores o funciones
	<quote>internos</quote>. Más aún, no puedes usar <lit>catch</lit> combinada
	con la asignación mediante <quote>flecha atrás</quote> de modelos o gráficos,
	a iconos de sesión (consulta <guideref targ="chap:modes"/>).
      </para>
    </description>
  </command>

  <command name="chow" section="Tests" label="Contraste de Chow">

    <usage>
      <altforms>
        <altform><lit>chow</lit> <repl>obs</repl></altform>
        <altform><lit>chow</lit> <repl>dummyvar</repl> <lit>--dummy</lit></altform>
      </altforms>
      <options>
	<option>
	  <flag>--dummy</flag>
	  <effect>Utiliza una variable ficticia ya existente</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta las estimaciones del modelo ampliado</effect>
	</option>
	<option>
	  <flag>--limit-to</flag>
	  <optparm>lista</optparm>
	  <effect>Limita el contraste a un subconjunto de regresores</effect>
	</option>
      </options>
      <examples>
        <example>chow 25</example>
        <example>chow 1988:1</example>
	<example>chow mujer --dummy</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Esta instrucción necesita un número de observación (o una fecha, si
	usas datos que las tengan), o bien el nombre de una variable ficticia.
      </para>

      <para>
	Debe ir a continuación de una regresión MCO (OLS). Si indicas un número
	de observación o una fecha, proporciona un contraste respecto a la hipótesis nula
	de que no existe cambio estructural en el punto de corte indicado. El procedimiento
	consiste en crear una variable ficticia que toma el valor 1 desde el punto
	de corte especificado por <repl>obs</repl> hasta el final de la muestra, y 0 en otro
	caso, así como generar términos de interacción entre esa ficticia y los regresores
	originales. Si indicas una ficticia, se contrasta esa hipótesis nula de homogeneidad
	estructural respecto a esa variable ficticia, y también se añaden términos de interacción.
	En cada caso se ejecuta una regresión ampliada incluyendo los términos adicionales.
      </para>
      <para>
	Por defecto, se calcula un estadístico <math>F</math>, considerando la
	regresión ampliada como el modelo sin restricciones y el modelo original
	como el restringido. Pero si el modelo original utilizó un estimador
	robusto para la matriz de covarianzas, el estadístico de contraste es uno de
	Wald con distribución chi-cuadrado; con su valor basado en un estimador
	robusto de la matriz de covarianzas de la regresión ampliada.
      </para>
      <para context="cli">
	Puedes utilizar la opción <opt>limit-to</opt> para limitar el conjunto de
	términos de interacción con la variable ficticia de corte, a un subconjunto
	de los regresores originales. El argumento para esta opción debe ser
	una lista ya definida en la que todos sus elementos estén entre los
	regresores originales, y no debe incluir la constante.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contrastes/Contraste de Chow</menu-path>
    </gui-access>
  </command>

  <command name="clear" section="Programming" context="cli">
    <usage>
      <options>
	<option>
	  <flag>--dataset</flag>
	  <effect>Elimina solo el conjunto de datos</effect>
	</option>
	<option>
	  <flag>--functions</flag>
	  <effect>Elimina las funciones (unicamente)</effect>
	</option>
	<option>
	  <flag>--all</flag>
	  <effect>Elimina todo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Por defecto, esta instrucción quita de la memoria el conjunto de datos
	vigente (si hay alguno), además de todas las variables guardadas
	(escalares, matrices, etc.). Ten en cuenta que también tienes este
	efecto al abrir un nuevo conjunto de datos, o al utilizar la instrucción
	<cmd>nulldata</cmd> para crear un conjunto de datos vacío; por eso
	normalmente no necesitas hace uso explícito de <cmd>clear</cmd>.
      </para>
      <para>
	Cuando indicas la opción <opt>dataset</opt>, entonces solo se elimina
	el conjunto de datos (más cualquier lista de series definida); otros
	objetos guardados como matrices, escalares o 'bundles', se van a
	conservar.
      </para>
      <para>
	Cuando indicas la opción <opt>functions</opt>, entonces se elimina de
	la memoria cualquier función definida por el usuario y cualquier función
	definida en los paquetes que tengas cargados. El conjunto de datos y
	otras variables no se ven afectados.
      </para>
      <para>
	Cuando indicas la opción <opt>all</opt>, entonces la eliminación es
	completa: el conjunto de datos, las variables guardadas de todo tipo,
	además de las funciones definidas por el usuario y en paquetes.
      </para>
    </description>
  </command>

  <command name="cluster" section="Estimation"
     label="Estimación con varianza robusta" context="gui">
    <description>
      <para>
	Si escoges la segunda opción, debes ofrecer el nombre de una
	variable de agrupación. Esta variable debería tener al menos
	dos valores diferentes, pero generalmente deberá tener un número
	de valores diferentes considerablemente menor que el número de
	observaciones que haya en el rango de la muestra.
      </para>
      <para>
	El estimador con varianza <quote>robusta por agrupación</quote> divide
	la muestra en un número de subconjuntos o grupos de acuerdo con el valor
	que tome la variable seleccionada. En lugar del supuesto clásico de que
	el término de perturbación está independiente e idénticamente distribuido,
	este estimador permite que las varianzas de las perturbaciones difieran por
	grupos, y también permite un grado de dependencia de la perturbación dentro
	de cada grupo.
      </para>
    </description>
  </command>

  <command name="coeffsum" section="Tests" label="Suma de coeficientes">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
	</option>
      </options>
      <examples>
        <example>coeffsum xt xt_1 xr_2</example>
	<demos>
	  <demo>restrict.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Esta instrucción necesita una lista de variables, seleccionadas de un conjunto de variables independientes de un modelo dado.
	    </para>
      <para context="gui">
	Calcula la suma de los coeficientes de las variables de la lista especificada.
	Presenta esta suma junto con su desviación típica y la probabilidad
	asociada al estadístico para contrastar la hipótesis nula de que la suma es cero.
      </para>
      <para context="cli">
	Debe ir después de una regresión. Calcula la suma de los coeficientes
	de las variables del argumento <repl>listavariables</repl>. Presenta esta suma
	junto con su desviación típica y la probabilidad asociada al
	estadístico para contrastar la hipótesis nula de que la suma es cero.
      </para>
      <para>
	Ten en cuenta la diferencia entre esto y la instrucción <cmdref targ="omit"/>,
	pues esta última te permite contrastar la hipótesis nula de que los
	coeficientes de un subconjunto especificado de variables independientes
	son <emphasis>todos</emphasis> nulos.
	    </para>
      <para context="cli">
	La opción <opt>quiet</opt> te puede ser de utilidad si únicamente
	deseas acceder a los valores de <fncref targ="$test"/> y de
	<fncref targ="$pvalue"/> que se registran después de terminar
	la estimación con éxito.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contrastes/Suma de los coeficientes</menu-path>
    </gui-access>

  </command>

  <command name="coint" section="Tests"
    label="Contraste de cointegración de Engle-Granger">

    <usage>
      <arguments>
        <argument>orden</argument>
        <argument>depvar</argument>
	      <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>Sin constante</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>Con constante y tendencia</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>Con constante más tendencia cuadrática</effect>
	</option>
	<option>
	  <flag>--seasonals</flag>
	  <effect>Con variables ficticias estacionales</effect>
	</option>
	<option>
	  <flag>--skip-df</flag>
	  <effect>Sin contrastes DF sobre las variables individuales</effect>
	</option>
	<option>
	  <flag>--test-down</flag>
	  <optparm optional="true">criterio</optparm>
	  <effect>Orden de retardos automático</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta detalles adicionales de las regresiones</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
	</option>
      </options>
      <examples>
	<example>coint 4 y x1 x2</example>
	<example>coint 0 y x1 x2 --ct --skip-df</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Contraste de cointegración de
	<cite key="engle-granger87">Engle&ndash;Granger (1987)</cite>. El proceso
	por defecto consiste en: (1) realizar los contrastes de Dickey&ndash;Fuller
	respecto a la hipótesis nula de que cada una de las variables enumeradas tiene
	una raíz unitaria; (2) estimar la regresión de cointegración; y (3) hacer
	un contraste DF respecto a los errores que comete la regresión de cointegración.
	Cuando se indica la opción <opt>skip-df</opt>, se omite el paso (1).
      </para>
      <para context="cli">
	Si el orden especificado de retardos es positivo, todos los contrastes de
	Dickey&ndash;Fuller usan ese orden pero con este requisito: cuando se
	indica la opción <opt>test-down</opt>, el valor indicado se toma como
	un máximo, y el orden concreto de retardos que se utilizará en cada caso
	se obtiene probando hacia abajo. Consulta la instrucción <cmdref targ="adf"/>
	para obtener más detalles sobre este procedimiento.
      </para>
      <para context="cli">
	Por defecto, la regresión de cointegración contiene una constante pero,
	si quieres eliminar la constante, añade la opción <opt>nc</opt>.
	Si quieres ampliar la lista de términos determinísticos en la regresión de
	cointegración con tendencia lineal (o cuadrática), añade la
	opción <opt>ct</opt> (o <opt>ctt</opt>). Estos indicadores de
	opción son mutuamente excluyentes. También tienes la posibilidad de
	añadir variables ficticias estacionales (en caso de utilizar datos
	trimestrales o mensuales).
      </para>

      <para context="gui">
	Contraste de cointegración de Engle&ndash;Granger. El proceso por defecto
	consiste en: (1) realizar los contrastes de Dickey&ndash;Fuller respecto
	a la hipótesis nula de que cada una de las variables enumeradas tiene una
	raíz unitaria; (2) estimar la regresión de cointegración; y (3) hacer
	un contraste DF respecto a los errores que comete la regresión de cointegración.
	Sin embargo, si marcas el cuadradito de <quote>Omitir los contrastes DF iniciales</quote>,
	el primero de estos pasos se omite.
      </para>
      <para context="gui">
	Si el orden de retardos (<math>k</math>) es mayor que 0, entonces se incluyen
	<math>k</math> retardos de la variable dependiente en el lado derecho de la
	regresión que se hace para cada contraste, excepto que marques el cuadradito titulado
	<quote>Contrastar desde el máximo orden de retardos hacia abajo</quote>. En ese
	caso, el orden de retardos que indicas se toma como máximo, y el orden concreto de
	retardos que se utilizará, se obtiene probando hacia abajo. Consulta la
	instrucción <cmdref targ="adf"/> para tener más detalles sobre este procedimiento.
      </para>
      <para context="gui">
	Por defecto, la regresión de cointegración contiene una constante. Si
	quieres eliminar la constante o añadir una tendencia lineal (o
	cuadrática) y/o variables ficticias estacionales, escoge la opción
	adecuada del conjunto que te ofrece el botón de selección en la caja
	de diálogo Cointegración.
      </para>

      <para>
	Los valores <emphasis>P</emphasis> (probabilidades asociadas) de este
	contraste se basan en <cite key="mackinnon96">MacKinnon (1996)</cite>.
	El código relevante se incluye con el amable permiso del propio autor.
      </para>
      <para>
	Para obtener los contrastes de cointegración de Søren Johansen,
	consulta <cmdref targ="johansen"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Series temporales multivariantes</menu-path>
    </gui-access>

  </command>

  <command name="compact" section="Dataset" context="gui"
    label="Compactar datos">

    <description>
      <para>
	Cuando añades una serie a un conjunto de datos que es de menor
	frecuencia, es necesario <quote>compactar</quote> la nueva serie.
	Por ejemplo, tendrás que compactar una serie mensual para adaptarla
	a un conjunto de datos trimestrales.
      </para>
      <para>
	Además, a veces puedes querer compactar un conjunto entero de
	datos para que tengan una frecuencia menor (quizás antes de añadir una
	variable de baja frecuencia al conjunto de datos).
      </para>
      <para>GRETL ofrece 5 opciones para compactar:</para>
      <ilist>
	<li><para>Con la media: El valor que se escribe en el conjunto de datos va a ser la
	    media aritmética de los valores de las series relevantes. Por ejemplo, el valor
	    que se escribe para el primer trimestre de 1990 va a ser la media aritmética
	    de los valores para los meses de enero, febrero y marzo de 1990.
	    </para>
	</li>
	<li><para>Sumando: El valor que se escribe en el conjunto de datos va a ser la
	    suma de los valores pertinentes de mayor frecuencia. Por ejemplo, el valor del
	    primer trimestre va a ser la suma de los valores de enero, febrero y marzo.
	    </para>
	</li>
	<li><para>Valores final-de-período: El valor que se escribe en el conjunto de
	    datos es el último valor pertinente de los datos de frecuencia mayor. Por
	    ejemplo, el primer trimestre de 1990 va a tener el valor de marzo de 1990.
	    </para>
	</li>
	<li><para>Valores principio-de-período: El valor que se escribe en el conjunto
	    de datos es el primer valor pertinente de los datos de frecuencia mayor. Por
	    ejemplo, el primer trimestre de 1990 va a tener el valor de enero de 1990.
	    </para>
	</li>
	<li>
	    <para>
	    <quote>Expandiendo</quote>: En este caso, no se pierde
	    ninguna información de la frecuencia mayor; más bien,
	    se expande en un conjunto de <math>m</math> series, donde
	    <math>m</math> es el ratio entre la frecuencia mayor y la menor.
	    Cada serie de ese conjunto contiene los valores de un determinado
	    subperíodo, que se identifica con un sufijo específico.
	    Por ejemplo, cuando se compacta una serie <lit>x</lit> de
	    mensual a trimestral, los nombres de las series generadas van ser
	    <lit>x_m01</lit>, <lit>x_m02</lit> y <lit>x_m03</lit>
	    para los tres meses de cada trimestre.
	    </para>
	</li>
      </ilist>

      <para>
	En caso de querer compactar un conjunto de datos entero, la elección
	que haces en esta caja de diálogo determina el método por defecto. Pero si
	has establecido un método para compactar una variable individual (en el
	menú <quote>Variable/Editar atributos</quote>), se va a usar ese método
	en lugar del establecido por defecto. Si ya has establecido el método
	para compactar en todas y cada una de las variables, no se te presenta
	la posibilidad de elegir un método por defecto para compactar.
      </para>

    </description>
  </command>

  <command name="continue" section="Programming"
    label="Saltar hacia adelante en un bucle" context="cli">
    <description>
      <para>
	Puedes usar esta instrucción solo dentro de un bucle; su efecto consiste
	en saltarse los enunciados posteriores que haya dentro de la iteración
	vigente del bucle (más interno) vigente. Consulta también
	<cmdref targ="loop"/>, <cmdref targ="break"/>.
      </para>
    </description>
  </command>

  <command name="controlled" section="Graphs" context="gui"
    label="Gráficos de dispersión con control">

    <description>
      <para>
	Esta instrucción requiere la selección de 3 variables: una para
	el eje X, otra para el eje Y, y otra para lo que quieres controlar
	(llamémosle Z). El gráfico muestra el Y axustado frente al X axustado,
	donde la versión axustada de la variable es el error de una regresión
	MCO sobre Z.
      </para>
      <para>
	Ejemplo: Tienes datos de salarios, experiencia laboral y nivel de educación para
	una muestra de personas. Quieres dibujar los salarios frente al nivel de
	educación, controlados por la experiencia. En ese caso, seleccionarías
	salarios para el eje Y, nivel de educación para el eje X y experiencia
	como control. El gráfico muestra los salarios frente al nivel de educación,
	con las dos variables <quote>depuradas</quote> del efecto de la experiencia.
      </para>
    </description>

  </command>

  <command name="corr" section="Statistics"
    label="Coeficientes de correlación">

    <usage>
      <altforms>
	<altform><lit>corr [</lit> <repl>listavariables</repl> ]</altform>
	<altform><lit>corr --matrix=</lit><repl>nombrematriz</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--uniform</flag>
	  <effect>Garantiza una muestra uniforme</effect>
	</option>
	<option>
	  <flag>--spearman</flag>
	  <effect>Rho de Spearman</effect>
	</option>
	<option>
	  <flag>--kendall</flag>
	  <effect>Tau de Kendall</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta jerarquías</effect>
	</option>
	<option>
	  <flag>--plot</flag>
	  <optparm>modo-o-nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
	</option>
	
	<option>
	  <flag>--triangle</flag>
	  <effect>Representa solo la mitad inferior, mira abajo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
	</option>
	
      </options>
      <examples>
        <example>corr y x1 x2 x3</example>
	<example>corr ylista --uniform</example>
	<example>corr x y --spearman</example>
	<example>corr --matrix=X --plot=display</example>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Presenta los coeficientes de correlación (correlación producto-momento
	de Pearson) por pares de las variables escogidas. El comportamiento por
	defecto de esta instrucción consiste en utilizar todas las observaciones
	disponibles para calcular cada coeficiente por parejas de variables,
	pero si marcas el cuadradito de opciones, la muestra se limita (si es necesario)
	de modo que se utiliza el mismo conjunto de observaciones para todos
	los coeficientes. Esta opción es adecuada solo cuando hay diferentes
	patrones de valores ausentes en las variables utilizadas.
      </para>
    </description>

    <description context="cli">
      <para>
	Por defecto, presenta los coeficientes de correlación (correlación
	producto-momento de Pearson) por pares de las variables de 
	<repl>listavariables</repl>, o de todas las variables del conjunto de datos
	si no indicas <repl>listavariables</repl>. El comportamiento típico de esta
	instrucción consiste en utilizar todas las observaciones disponibles
	para calcular cada coeficiente por parejas de variables, pero cuando
	indicas la opción <flag>--uniform</flag>, la muestra se limita (si es
	necesario) de modo que se utiliza el mismo conjunto de observaciones
	para todos los coeficientes. Esta opción es adecuada solo cuando hay un
	número diferente de valores ausentes en las variables utilizadas.
      </para>
      <para>
	Las opciones <opt>spearman</opt> y <opt>kendall</opt> (que son
	mutuamente excluyentes) permiten calcular, respectivamente, el
	coeficiente rho de correlación por rangos de Spearman y el
	coeficiente tau de correlación por rangos de Kendall en lugar
	del coeficiente de Pearson (por defecto). Cuando indicas alguna
	de estas opciones, <repl>listavariables</repl> debe contener solo dos variables.
      </para>
      <para>
	Cuando se calcula una correlación por rangos, puedes utilizar la
	opción <opt>verbose</opt> para presentar los datos originales y
	su jerarquía (en otro caso, esta alternativa se ignora).
      </para>
      <para>
	Si <repl>listavariables</repl> contiene más de dos series y GRETL no
	está en modo de procesamiento por lotes, se muestra un gráfico de
	<quote>mapa de calor</quote> de la matriz de correlaciones. Puedes ajustar
	esto mediante la opción <opt>plot</opt>, en la que los parámetros que se
	admiten son: <lit>none</lit> (para no mostrar el gráfico), <lit>display</lit>
	(para presentar el gráfico incluso cuando se esté en modo de procesamiento
	por lotes), o un nombre de archivo. El efecto de indicar un nombre de
	archivo es como el descrito para la opción <opt>output</opt> de la instrucción
	<cmdref targ="gnuplot"/>. Cuando activas la representación del gráfico,
	puedes utilizar la opción <opt>triangle</opt> para mostrar solo el mapa
	de calor del triángulo inferior de la matriz.
      </para>
      <para>
	Cuando indicas una forma alternativa, utilizando una matriz ya
	definida en lugar de una lista de series, las opciones <opt>spearman</opt>
	y <opt>kendall</opt> no están disponibles (pero consulta la función
	<fncref targ="npcorr"/>).
      </para>
      <para>
	Puedes usar el accesor <fncref targ="$result"/> para obtener las
	correlaciones en forma de matriz. Ten en cuenta que cuando esta
	es la <emphasis>matriz</emphasis> que te interese (y no solo los
	coeficientes de las parejas), entonces en caso de que haya valores
	ausentes se aconseja utilizar la opción <opt>uniform</opt>. A no ser
	que utilices una muestra común única, no se garantiza que la matriz
	de correlaciones sea semidefinida positiva, como debiera ser por
	construcción.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Matriz de correlación</menu-path>
      <other-access>Ventana principal: Menú emergente (tras selección múltiple)</other-access>
    </gui-access>

  </command>

  <command name="corrgm" section="Statistics" label="Correlograma">

    <usage>
      <arguments>
        <argument>y</argument>
        <argument optional="true">orden</argument>
      </arguments>
      <options>
	<option>
	  <flag>--bartlett</flag>
	  <effect>Utiliza las desviaciones típicas de Bartlett</effect>
	</option>
	<option>
	  <flag>--plot</flag>
	  <optparm>modo-o-nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
	</option>
	<option>
	  <flag>--acf-only</flag>
	  <effect>Omite las autocorrelaciones parciales</effect>
	</option>
      </options>
      <examples>
        <example>corrgm x 12</example>
        <example>corrgm GDP 12 --acf-only</example>
      </examples>
    </usage>

    <description>
      <para context="notex">
	Muestra y/o representa los valores de la función de autocorrelación (FAC)
	de la serie <repl>y</repl>, que puede especificarse por su nombre
	o por su número. Los valores se definen como
	&rgr;(<math>u</math><sub>t</sub>, <math>u</math><sub>t-s</sub>) donde
	<math>u</math><sub>t</sub> es la <math>t</math>-ésima observación
	de la variable <math>u</math>, y <math>s</math> denota el número de
	retardos.
      </para>
      <para context="tex">
	Muestra y/o representa los valores de la función de autocorrelación (FAC)
	de la serie <repl>y</repl>, que puede especificarse por su nombre
	o su número. Los valores se definen como
	$\hat{\rho}(u_t, u_{t-s})$, donde $u_t$ es la $t$-ésima observación
	de la variable $u$ y $s$ denota el número de
	retardos.
      </para>
      <para context="cli">
	A no ser que indiques la opción <opt>acf-only</opt>, también se presentan
	los coeficientes de la función de autocorrelación parcial (FACP,
	calculados utilizando el algoritmo de Durbin&ndash;Levinson), y que
	están libres de los efectos de los retardos intermedios.
      </para>
      <para context="gui">
	Por defecto, también se presentan los coeficientes de la función de
	autocorrelación parcial (FACP, calculados utilizando el algoritmo de
	Durbin&ndash;Levinson), y que están libres de los efectos de los
	retardos intermedios. Si lo deseas, puedes desactivar esto.
      </para>
      <para context="cli">
	Se utilizan asteriscos para indicar la significación estadística de las
	autocorrelaciones individuales. Por defecto, esto se evalúa utilizando
	una desviación típica igual al cociente entre 1 y la raíz cuadrada
	del tamaño de la muestra; pero cuando indicas la opción <opt>bartlett</opt>,
	entonces se utilizan las desviaciones típicas de Bartlett para la FAC. Si
	resulta aplicable, esta opción también determina la banda de confianza
	que se dibuja en el gráfico de la FAC. Además, se muestra el estadístico
	<math>Q</math> de Ljung&ndash;Box, que contrasta la hipótesis nula de que
	la serie es <quote>ruido blanco</quote> hasta el nivel de retardo indicado.
      </para>
      <para context="gui">
	Se utilizan asteriscos para indicar la significación estadística de las
	autocorrelaciones individuales. Por defecto, esto se evalúa utilizando
	una desviación típica igual al cociente entre 1 y la raíz cuadrada
	del tamaño de la muestra, pero tienes la opción de utilizar las desviaciones
	típicas de Bartlett para la FAC. Esta opción también determina la banda
	de confianza que se dibuja en el gráfico de la FAC. Además, se muestra el estadístico
	<math>Q</math> de Ljung&ndash;Box, que contrasta la hipótesis nula de que
	la serie es <quote>ruido blanco</quote> hasta el nivel de retardo indicado.
      </para>
      <para context="cli">
	Si especificas un valor para <repl>orden</repl>, la longitud
	del correlograma se limita hasta ese número de retardos como
	máximo; en otro caso, la longitud se determina automáticamente
	como una función de la frecuencia de los datos y del número de
	observaciones.
      </para>
      <subhead context="cli">Representación gráfica</subhead>
      <para context="cli">
	Por defecto, si GRETL no está en modo de procesamiento por lotes, se
	genera un gráfico del correlograma. Esto puedes ajustarlo mediante la
	opción <opt>plot</opt> en la que los parámetros que se admiten son:
	<lit>none</lit> (para no mostrar el gráfico), <lit>display</lit> (para
	presentar un gráfico incluso en modo de procesamiento por lotes);
	o un nombre de archivo. El efecto de indicar un nombre de archivo es
	como el descrito para la opción <opt>output</opt> de la instrucción
	<cmdref targ="gnuplot"/>.
      </para>
      <subhead context="cli">Accesores</subhead>
      <para context="cli">
	Cuando se complete con éxito esta instrucción, puedes usar los accesores
	<fncref targ="$test"/> y <fncref targ="$pvalue"/> para recuperar el
	estadístico <math>Q</math> y su Probabilidad Asociada
	(valor <math>P</math>), evaluados para el retardo de orden mayor. Ten
	en cuenta que si únicamente quieres este contraste, puedes utilizar en
	su lugar la función <fncref targ="ljungbox"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Correlograma</menu-path>
      <other-access>Ventana principal: Menú emergente (selección única)</other-access>
    </gui-access>

  </command>

  <command name="count-model" section="Estimation" context="gui"
    label="Modelos para datos de conteo">

    <description>
      <para>
	Se toma la variable dependiente para representar un conteo del número de
	veces que ocurre un suceso de algún tipo, y debe tener solo valores enteros
	no negativos. Por defecto, se utiliza la distribución de Poisson, pero el
	botón de la lista desplegable te da la opción de utilizar la distribución
	Binomial Negativa. (La variante NegBin 2 se utiliza habitualmente en
	Econometría, pero también está disponible la menos utilizada NegBin 1.)
      </para>
      <para>
	Opcionalmente, puedes añadir una variable de <quote>exposición</quote>
	a la especificación. Esta es una variable de escala, cuyo logaritmo se añade
	a la función de regresión lineal (implícitamente, con un coeficiente de 1). Esto
	es lógico si esperas que el número de veces que ocurra el suceso en cuestión
	sea proporcional a algún factor conocido (suponiendo lo demás constante).
	Por ejemplo, si asumes que el número de accidentes de tráfico es proporcional
	al volumen de tráfico (con lo demás constante), en ese caso puedes especificar
	el volumen de tráfico como una variable de <quote>exposición</quote> en un
	modelo para el ratio de accidentes. La variable de exposición debe ser
	estrictamente positiva.
      </para>
      <para>
	Por defecto, las desviaciones típicas se calculan utilizando una aproximación
	numérica a la matriz Hessiana en la convergencia. Pero si marcas el cuadradito de
	'Desviaciones típicas robustas', entonces se calculan las desviaciones típicas Cuasi
	Máximo Verosímiles (CMV o QML), utilizando un <quote>emparedado</quote>
	entre la inversa de la matriz Hessiana y el producto externo del vector gradiente.
      </para>
    </description>
  </command>

  <command name="curve" section="Graphs" label="Dibujar una curva"
    context="gui">

    <description>
      <para>
	Esta caja de diálogo te permite generar un gráfico de Gnuplot
	especificando una fórmula, que deberá ser una expresión que
	admita Gnuplot. Utiliza <lit>x</lit> para denotar la variable en el
	eje 'x'. Ten en cuenta que Gnuplot utiliza <lit>**</lit> para
	preceder a un exponente (elevar a la potencia) y que el carácter
	decimal debe indicarse con <quote>.</quote>. Ejemplos:
      </para>
      <code>
	10+0.35*x
	100+5.3*x-0.12*x**2
	sin(x)
	exp(sqrt(pi*x))
      </code>
      <para>
	Para poner una línea adicional en un gráfico generado de este modo, pulsa
	con el botón derecho del ratón en el gráfico y escoge <quote>Editar</quote>,
	selecciona la pestaña <quote>Líneas</quote> en el cuadro de diálogo de
	edición de gráficos, y utiliza el botón <quote>Añadir línea</quote>.
      </para>
    </description>
  </command>

  <command name="cusum" section="Tests" label="Contraste CUSUM">

    <usage>
      <options>
	<option>
	  <flag>--squares</flag>
	  <effect>Realiza el contraste CUSUMSQ</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Solo presenta el contraste de Harvey&ndash;Collier</effect>
	</option>
	<option>
	  <flag>--plot</flag>
	  <optparm>Modo-o-nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Debe ir después de la estimación de un modelo mediante MCO. Te
	permite realizar el contraste CUSUM de estabilidad de los parámetros
	(o el contraste CUSUMSQ si indicas la opción <opt>squares</opt>).
	Vas a obtener una serie con los errores de predicción adelantados un
	paso, ejecutando una serie de regresiones. En la primera
	regresión se utilizan las primeras <math>k</math> observaciones
	y te permite generar la predicción de la variable dependiente en la
	observación <math>k</math> + 1; en la segunda se utilizan las
	primeras <math>k</math> + 1 observaciones y se genera una
	predicción para la observación <math>k</math> + 2, y así
	sucesivamente (donde <math>k</math> es el número de parámetros
	del modelo original).
      </para>
      <para>
	Se presenta la suma acumulada de los errores de predicción escalados
	(o los cuadrados de estos errores). La hipótesis nula de estabilidad
	de los parámetros se rechaza con un nivel de significación del 5
	por ciento cuando la suma acumulada se separa de la banda de
	confianza del 95 por ciento.
      </para>
      <para>
	En el caso del contraste CUSUM, también se presenta el estadístico
	<math>t</math> de Harvey&ndash;Collier para contrastar la
	hipótesis nula de estabilidad de los parámetros. Consulta el
	libro <book>Econometric Analysis</book> de Greene para
	obtener más detalles. Para el contraste CUSUMSQ, se calcula la banda
	de confianza del 95 por ciento utilizando el algoritmo indicado
	en <cite key="edgerton94">Edgerton y Wells (1994)</cite>.
      </para>
      <para>
	Por defecto, cuando GRETL no está en modo de procesamiento por
	lotes, se muestra un gráfico con la serie acumulada y el intervalo de
	confianza. Puedes ajustar esto por medio de la opción <opt>plot</opt>.
	Los parámetros admisibles para esta opción son <lit>none</lit> (para
	omitir el gráfico); <lit>display</lit> (para visualizar un gráfico incluso
	en modo de procesamiento por lotes); o el nombre de un archivo. El
	efecto de proporcionar el nombre de un archivo es como el descrito para
	la opción <opt>output</opt> de la instrucción <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contrastes/Contraste CUSUM(SQ)</menu-path>
    </gui-access>

  </command>

  <command name="daily-purge" section="Dataset"
     label="Depurar datos diarios" context="gui">
    <description>
      <para>
	Cuando un conjunto de datos diarios está nominalmente en un
	calendario de 7 días, pero de hecho únicamente incluye datos de
	días laborables, se recomienda que elimines las filas en blanco
	de los días del fin de semana, pasando así a un calendario de 5 días.
      </para>
      <para>
	Cuando un conjunto de datos de días laborables contiene un número
	relativamente pequeño de filas sin datos (presuntamente debido a
	festivos comerciales) podrías querer eliminar esas filas. Esto
	significa, de hecho, tratar los valores ausentes por festividades como no
	existentes, más que como verdaderamente <quote>ausentes</quote>, y
	tratar los días comerciales como si formasen una serie temporal continua.
      </para>
      <para>
	Ten en cuenta que si coges cualquiera de estas opciones, aun así
	GRETL va a preservar la información de la fecha, y te va a ser posible
	reconstruir el conjunto de datos de calendario completo más
	tarde, si lo necesitas. Puedes hacer esto utilizando la instrucción
	<cmdref targ="dataset"/> con la opción <lit>pad-daily</lit>.
      </para>
    </description>
  </command>

  <command name="data" section="Dataset"
    label="Importar de una base de datos" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--compact</flag>
	  <optparm>método</optparm>
	  <effect>Especifica el método para compactar</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No muestra los resultados excepto en caso de fallo</effect>
	</option>
	<option>
	  <flag>--name</flag>
	  <optparm>identificador</optparm>
	  <effect>Renombra series importadas</effect>
	</option>
	<option>
	  <flag>--odbc</flag>
	  <effect>Importa de una base de datos ODBC</effect>
	</option>
	<option>
	  <flag>--no-align</flag>
	  <effect>Específico para ODBC, mira abajo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Lee las variables de <repl>listavariables</repl> de un archivo de base
	de datos (propio de GRETL, RATS 4.0 o PcGive) que debe abrirse
	previamente utilizando la instrucción <cmdref targ="open"/>. Puedes usar
	la instrucción <lit>data</lit> para importar series de DB.NOMICS o de
	una base de datos ODBC; para obtener detalles sobre estas variantes
	consulta <mnu targ="gretlDBN">gretl + DB.NOMICS</mnu> o
	<guideref targ="chap:odbc"/>, respectivamente.
      </para>
      <para>
  Puedes establecer la frecuencia de los datos y el rango de la muestra
  mediante las instrucciones <cmdref targ="setobs"/> y <cmdref targ="smpl"/>,
	antes de utilizar esta instrucción. Este es un ejemplo:
	    </para>
      <code>
	open fedstl.bin
	setobs 12 2000:01
	smpl ; 2019:12
	data unrate cpiaucsl
      </code>
      <para>
	Las instrucciones de arriba abren una base de datos (que se ofrece con
	GRETL) llamada <filename>fedstl.bin</filename>, determinan que los
	datos son mensuales, que empiezan en enero de 2000, que la muestra
	finaliza en diciembre de 2019, y que se importan las series denominadas
	<lit>unrate</lit> (tasa de desempleo) y <lit>cpiaucsl</lit> (IPC de todos).
	    </para>
      <para>
	Si no especificas <lit>setobs</lit> y <lit>smpl</lit> de este modo,
	la frecuencia de los datos y el rango de la muestra se establecen utilizando
	la primera variable que se lee de la base de datos.
      </para>
      <para>
	Si las series que se van a leer son de frecuencia mayor que el conjunto de datos de trabajo, puedes especificar un método para compactar como aquí debajo:
	    </para>
      <code>
	data LHUR PUNEW --compact=average
      </code>
      <para>
	Los cinco métodos que permiten compactar de los que dispones son
	estos: <quote>average</quote> (toma la media de las observaciones
	de alta frecuencia), <quote>last</quote> (utiliza la última
	observación), <quote>first</quote>, <quote>sum</quote> y
	<quote>spread</quote>, pero si no especificas ningún método,
	por defecto se utiliza la media. El método <quote>spread</quote>
	es especial pues con él no se pierde ninguna información, sino
	que más bien esta se expande entre varias series, una por cada
	subperíodo. Así con ella cuando añades, por ejemplo, una serie
	mensual a un conjunto de datos trimestrales, se generan 3 series
	(una por cada mes del trimestre) cuyos nombres contienen los sufijos
	<lit>m01</lit>, <lit>m02</lit> y <lit>m03</lit>.
      </para>
      <para>
	Cuando las series que se leen son de frecuencia <emphasis>menor</emphasis>
	que la del conjunto de datos de trabajo, los valores de los datos
	añadidos sencillamente se repiten según se necesite; pero ten en
	cuenta que puedes utilizar la función <fncref targ="tdisagg"/> para
	solicitar que se haga una distribución o una interpolación
	(<quote>desagregación temporal </quote>).
      </para>
      <para>
	En el caso de bases de datos propias (únicamente) de GRETL, puedes
	utilizar los caracteres <quote>genéricos</quote>, <lit>*</lit>
	y <lit>?</lit> en <repl>listavariables</repl> para importar series que
	coincidan con el patrón indicado. Por ejemplo, la siguiente expresión
	va a importar todas las series de la base de datos cuyos nombres
	comiencen por <lit>cpi</lit>:
      </para>
      <code>
	data cpi*
      </code>
      <para>
	Puedes usar la opción <opt>name</opt> para determinar un nombre
	distinto del nombre original en la base de datos, para la seire importada.
	El parámetro debe ser un identificador válido de GRETL. Esta opción
	se restringe al caso en el que especificas una única serie a
	importar.
      </para>
      <para>
	La opción <opt>no-align</opt> se aplica solo para importar series mediante
	ODBC. Por defecto, se necesita que la solicitud ODBC devuelva información
	que indique a GRETL en qué filas del conjunto de datos situar los datos que
	se reciben (o que el número de valores que se reciben coincida, al menos,
	bien con la extensión del conjunto de datos o bien con la extensión del
	rango de la muestra vigente). Determinando la opción <opt>no-align</opt>
	se relaja este requisito: si no se cumplen estas condiciones mencionadas,
	los valores que se reciben se colocan simplemente de forma consecutiva,
	comenzando en la primera fila del conjunto de datos. Si el número de
	esos valores es menor que el de filas en el conjunto de datos, las filas
	del final se rellenan con NAs; si el número es mayor que el de filas, se
	descartan los valores extra. Para obtener más información sobre cómo
	importar con ODBC, consulta <guideref targ="chap:odbc"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Archivo/Bases de datos</menu-path>
    </gui-access>

  </command>

  <command name="data-files" section="Programming"
     label="Archivos de datos" context="gui">
    <description>
      <para>
	Este diálogo te permite especificar archivos adicionales para
	incluir con un paquete de funciones. Si incluyes ese material, eso
	implica que el paquete va a tomar la forma de un archivo zip. Cuando
	GRETL vaya a crear el archivo zip para ti, todos los archivos
	a los que se hace referencia aquí deben estar presentes en el mismo
	directorio que el archivo gfn. Los subdirectorios pueden indicarse
	igual que archivos normales y, en ese caso, eso implica que todo
	su contenido deberá incluirse en el paquete zip.
      </para>
      <para>
	Hay dos intenciones principales para usar este servicio. En primer
	lugar, puedes incluir un archivo de datos para utilizar con el guion de
	muestra del paquete, si no es adecuado ninguno de los archivos de datos
	ofrecidos con la distribución de GRETL. En este caso, los datos deben
	estar en el formato propio de GRETL (<lit>gdt</lit> o <lit>gdtb</lit>
	binario). Segundo, si tu paquete precisa una matriz grande (por
	ejemplo, que contenga todos los puntos críticos de un estadístico de
	prueba especial), podrá ser más conveniente incluirla como un archivo
	matricial de GRETL (<lit>mat</lit>) que integrar la matriz mediante
	múltiples expresiones del lenguaje HANSL de GRETL.
      </para>
      <para>
	Para acceder a un archivo empaquetado <lit>gdt</lit> o
	<lit>gdtb</lit> desde un guion de muestra, utiliza la opción
	<opt>frompkg</opt> con la instrucción <lit>open</lit>, indicando
	el nombre del paquete como si fuese un parámetro, como en
      </para>
      <code>
	open almon.gdt --frompkg=almonreg
      </code>
      <para>
	Para leer un archivo matricial empaquetado desde dentro de tu código de
	paquete, utiliza la variable de cadena incorporada <lit>$pkgdir</lit>, como en
      </para>
      <code>
	string mname = sprintf("%s/A.mat", $pkgdir)
	matrix A = mread(mname)
      </code>
      <para>
	(Ten en cuenta que en las rutas de MS Windows funcionará correctamente
	<quote><lit>/</lit></quote> como separador.)
      </para>
    </description>
  </command>

  <command name="dataset" section="Dataset"
    label="Manipular el conjunto de datos" context="cli">

    <usage>
      <arguments>
        <argument>clave</argument>
	      <argument>parámetros</argument>
      </arguments>
      <options>
	<option>
	  <flag>--panel-time</flag>
	  <effect>Mira abajo 'addobs'</effect>
	</option>
      </options>
      <examples>
        <example>dataset addobs 24</example>
	<example>dataset addobs 2 --panel-time</example>
	<example>dataset insobs 10</example>
        <example>dataset compact 1</example>
        <example>dataset compact 4 last</example>
        <example>dataset expand</example>
        <example>dataset transpose</example>
	<example>dataset sortby x1</example>
	<example>dataset resample 500</example>
	<example>dataset renumber x 4</example>
	<example>dataset pad-daily 7</example>
        <example>dataset unpad-daily</example>
	<example>dataset clear</example>
      </examples>
    </usage>

    <description>
      <para>
	Realiza diversas operaciones en el conjunto de datos como un todo,
	dependiendo de la <repl>clave</repl> indicada, que debe
	ser: <lit>addobs</lit>, <lit>insobs</lit>, <lit>clear</lit>,
	<lit>compact</lit>, <lit>expand</lit>, <lit>transpose</lit>,
	<lit>sortby</lit>, <lit>dsortby</lit>, <lit>resample</lit>,
	<lit>renumber</lit>, <lit>pad-daily</lit> o <lit>unpad-daily</lit>.
	Advertencia: Con la excepción de la opción <lit>clear</lit>, estas
	acciones no están disponibles mientras tengas una submuestra del
	conjunto de datos, escogida por selección de los casos según algún
	criterio booleano.
      </para>
      <para>
	<lit>addobs</lit>: Debe estar seguido de un entero positivo, digamos
	<math>n</math>. Añade las <math>n</math> observaciones adicionales al
	final del conjunto de datos de trabajo. Esto está pensado principalmente
	con el propósito de hacer predicciones. Los valores de la mayoría de las
	variables a lo largo del rango añadido se van a estipular como ausentes,
	pero ciertas variables determinísticas se reconocen y su contenido se
	extiende al rango añadido; en concreto, las variables con tendencia lineal
	simple y las variables ficticias periódicas. Si el conjunto de datos tiene
	la estructura de un panel, la acción predeterminada consiste en añadir
	<math>n</math> unidades de sección cruzada al panel; pero si indicas
	la opción <opt>panel-time</opt>, el efecto consiste en añadir
	<math>n</math> observaciones a las series temporales para cada unidad.
      </para>
      <para>
	<lit>insobs</lit>: Debe estar seguido de un entero positivo (no
	mayor que el número vigente de observaciones) que especifica la posición
	en la que se inserta una única observación. Todos los datos posteriores
	se desplazan un lugar y el conjunto de datos se amplía en una observación.
	Excepto a la constante, se le dan valores ausentes a todas las variables en la
	nueva observación. Esta acción no está disponible para conjuntos de
	datos de panel.
      </para>
      <para>
	<lit>clear</lit>: No necesita ningún parámetro. Vacía todos los datos
	vigentes, devolviendo el GRETL a su estado <quote>vacío</quote> inicial.
      </para>
      <para>
	<lit>compact</lit>: Esta acción solo está disponible para datos de
	series temporales, y compacta todas las series del conjunto de datos a
	una frecuencia menor. Requiere un parámetro, un entero positivo que
	represente la nueva frecuencia de los datos. En general, debe ser menor
	que la frecuencia vigente (por ejemplo, indicar un valor de 4 cuando
	la frecuencia vigente es 12, indica que se van a compactar los datos de
	mensuales a trimestrales). La única excepción es una nueva frecuencia de
	52 (semanal) cuando los datos vigentes sean diarios (frecuencia 5, 6 o 7).
	También puedes indicar un segundo parámetro, en concreto uno de entre
	<lit>sum</lit>, <lit>first</lit>, <lit>last</lit> o <lit>spread</lit>.
	Estos permiten especificar qué se va a compactar utilizando, respectivamente:
	la suma de los valores de frecuencia mayor, el valor de inicio-de-período,
	el valor de fin-de-período, o expandiendo los valores de frecuencia mayor
	entre varias series (una por cada subperíodo), pues por defecto se hace
	usando la media.
      </para>
      <para>
	En caso de querer compactar (unicamente) de frecuencia diaria a
	semanal, tienes disponibles las dos opciones especiales <opt>repday</opt>
	y <opt>weekstart</opt>. La primera de ellas te permite seleccionar un
	<quote>día representativo</quote> de la semana que sirva como valor
	semanal. El parámetro de esta opción deberá consistir en un número entero
	entre 0 (Domingo) y 6 (Sábado), incluidos. Por ejemplo, indicando
	<opt>--repday=3</opt> estarás eligiendo el valor de los Miércoles como
	representativo del valor semanal. Si no indicas la opción <opt>repday</opt>,
	se necesita saber en que día de la semana pretendes comenzar, para alinear
	los datos correctamente. Con datos con frecuencia de 5 o de 6 días,
	siempre se toma el Lunes, pero con datos de 7 días tienes la posibilidad
	de elegir entre las opciones <opt>weekstart=0</opt> (Domingo) y
	<opt>weekstart=1</opt> (Lunes), en la que se toma el Lunes como
	la predeterminada.
      </para>
      <para>
	<lit>expand</lit>: Esta acción solo está disponible para datos de
	series temporales anuales o trimestrales, pues los datos anuales se pueden
	expandir a trimestrales o mensuales, y los datos trimestrales a mensuales.
	Todas las series del conjunto de datos se rellenan con la nueva frecuencia
	repitiendo los valores existentes. Si la base de datos original es anual,
	la expansión por defecto es la trimestral, pero la función
	<lit>expand</lit> puede estar seguida de <lit>12</lit> para solicitar que
	sea la mensual. Consulta la función <fncref targ="tdisagg"/> para obtener
	medios más sofisticados de convertir los datos a una frecuencia mayor.
      </para>
      <para>
	<lit>transpose</lit>: No necesita ningún parámetro adicional.
	Traspone el conjunto vigente de datos, es decir, cada observación
	(fila) del conjunto vigente de datos se va a tratar como una variable
	(columna), y cada variable como una observación. Esta acción te puede
	ser útil si los datos se leyeron de algún origen externo en el que
	las filas de la tabla de datos representan variables.
      </para>
      <para>
	<lit>sortby</lit>: Se requiere el nombre de una única serie o lista.
	Cuando indicas una serie, las observaciones de todas las variables del
	conjunto de datos se vuelven a ordenar según los valores ascendentes
	de la serie especificada. Cuando indicas una lista, la reordenación se hace
	jerárquicamente: si hay observaciones empatadas al reordenarse
	según la primera variable clave, entonces la segunda clave se utiliza
	para romper el empate, y así sucesivamente hasta que se rompa el empate
	o se agoten las claves. Ten en cuenta que esta acción está disponible
	solo para datos sin fecha.
      </para>
      <para>
	<lit>dsortby</lit>: Funciona como <lit>sortby</lit> excepto que la
	reordenación se hace según los valores descendientes de la serie clave.
      </para>
      <para>
	<lit>resample</lit>: Construye un nuevo conjunto de datos mediante
	muestreo aleatorio (con substitución) de las filas del conjunto
	vigente de datos, y requiere que indiques como argumento el
	número concreto de filas que quieres incluir. Este puede ser
	menor, igual o mayor que el número de observaciones de los datos
	originales. Puedes recuperar el conjunto original de datos
	mediante la instrucción <lit>smpl full</lit>.
      </para>
      <para>
	<lit>renumber</lit>: Requiere el nombre de una serie ya existente
	seguida de un número entero entre 1 y el número de series del
	conjunto de datos menos 1. Mueve la serie especificada a la
	posición indicada del conjunto de datos, volviendo a numerar
	las demás series conforme a esto. (La posición 0 se ocupa con la
	constante, que no puede moverse.)
      </para>
      <para>
	<lit>pad-daily</lit>: Válido solo cuando el conjunto vigente de datos
	contiene datos con fechas diarias con un calendario incompleto. Tiene como
	efecto llenar los datos en un calendario completo insertando filas en
	blanco (es decir, filas que no contienen nada excepto <lit>NA</lit>s).
	Esta opción requiere un número entero como parámetro, concretamente
	el número de días por semana (5, 6 o 7), y que debe ser mayor o
	igual que la frecuencia vigente de los datos. Cuando se completa con
	éxito, el calendario de datos va a estar <quote>completo</quote> en
	relación a este valor. Por ejemplo, si días-por-semana es igual a 5,
	entonces se representan todos los días laborables, haya o no algún dato
	disponible para esos días.
      </para>
      <para>
	<lit>unpad-daily</lit>: Válido solo cuando el conjunto vigente de datos
	contiene datos con fechas diarias, en cuyo caso esto realiza la operación
	inversa a <lit>pad-daily</lit>. Es decir, se elimina cualquier fila que
	no contenga <lit>NA</lit>s, mientras que se conserva la propiedad de
	series temporales del conjunto de datos junto con las fechas de las
	observaciones individuales.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos</menu-path>
    </gui-access>

  </command>

  <command name="datasort" section="Dataset" context="gui"
    label="Ordenar los datos">

    <description>
      <para>
	La variable escogida se utiliza como clave de ordenación para
	todo el conjunto de datos. Se vuelven a ordenar las observaciones
	de todas las variables según los valores en orden ascendente
	de la variable clave, o según los valores en orden decreciente
	si escoges la opción <quote>Descendente</quote>.
      </para>
    </description>
  </command>

  <command name="dbnomics" section="Utilities" label="Acceso a dbnomics" context="gui">
    <description>
      <para>
	Este diálogo te permite inspeccionar y descargar series de datos
	del servidor 'dbnomics'. Puedes visitar
	<url>https://db.nomics.world/</url> para obtener los
	identificadores o códigos de las series de interés. Estos tienen la
	forma de 'tripletes' (tres términos separados con barras). Por
	ejemplo
      </para>
      <code>
	ECB/IRS/M.IT.L.L40.CI.0000.EUR.N.Z
      </code>
      <para>
	El primer término identifica un provedor de datos, aquí <lit>ECB</lit>
	(el Banco Central Europeo). El segundo identifica una base de datos,
	aquí <lit>IRS</lit> (de estadísticas de tipos de interés). Y el tercero
	especifica una serie concreta de la base de datos, en este caso
	un tipo de interés italiano de 10 años.
      </para>
      <para>
	Si introduces un identificador de serie y pulsas <quote>OK</quote>,
	esto va a hacer que aparezca una ventana que mostrará información sobre la serie.
	Entonces, puedes utilizar los botones de la barra de herramientas de esa ventana
	para presentar los valores de la serie, dibujar la serie, o agregarla a la base
	de datos vigente (asumiendo que la serie es apropiada para la base de
	datos).
      </para>
    </description>
  </command>

  <command name="delete" section="Dataset"
    label="Eliminar variables" context="cli">

    <usage>
      <altforms>
        <altform><lit>delete</lit> <repl>listavariables</repl></altform>
        <altform><lit>delete</lit> <repl>nombrevar</repl></altform>
	      <altform><lit>delete --type=</lit><repl>tipo</repl></altform>
	      <altform><lit>delete</lit> <repl>nombrepaquete</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--db</flag>
	  <effect>Elimina series de la base de datos</effect>
	</option>
	<option>
	  <flag>--force</flag>
	  <effect>Mira abajo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Esta instrucción es un destructor. Deberías utilizarla con precaución
	pues no se pide confirmación.
      </para>
      <para>
	En la primera variante de arriba, <repl>listavariables</repl> es una lista de
	series, indicada por su nombre o número ID. Ten en cuenta que cuando
	eliminas series, se vuelve a numerar cualquier serie cuyo número ID sea
	mayor que los de las series de la lista que se elimina. Si indicas la opción
	<opt>db</opt>, las series de la lista no se eliminan con esta instrucción
	del conjunto vigente de datos, pero sí de la base de datos de GRETL
	(suponiendo que se abrió una de ellas y que el usuario tiene permisos para
	escribir en el archivo en cuestión). Consulta también la instrucción
	<cmdref targ="open"/>.
      </para>
      <para>
	En la segunda variante, puedes indicar el nombre de un escalar, de una matriz,
	de una cadena de texto o de un bundle, para que se elimine. La opción
	<opt>db</opt> no puede aplicarse en este caso. Ten en cuenta que no
	debes mezclar series y variables de diferentes tipos en una misma
	llamada a <lit>delete</lit>.
      </para>
      <para>
	En la tercera variante, la opción <opt>type</opt> debes
	acompañarla con alguno de los siguientes nombres de tipos: <lit>matrix</lit>,
	<lit>bundle</lit>, <lit>string</lit>, <lit>list</lit>, <lit>scalar</lit>
	o <lit>array</lit>; y su efecto consiste en eliminar todas las
	variables del tipo indicado. En este caso no debes indicar ningún
	argumento que no sea la opción.
      </para>
      <para>
	Puedes usar la cuarta variante para descargar un paquete de funciones.
	En este caso, debes proporcionar el sufijo <lit>.gfn</lit> como
	en
      </para>
      <code>
	delete somepkg.gfn
      </code>
      <para>
	Ten en cuenta que esto no elimina el archivo de paquete; únicamente
	descarga el paquete de la memoria.
      </para>

      <subhead>Eliminar variables en un bucle</subhead>
      <para>
	En general, no se permite eliminar variables en el contexto de un
	bucle, puesto que esto puede suponer un riesgo para la integridad
	del código del propio bucle. Sin embargo, si tienes total confianza
	en que la eliminación de una determinada variable va a ser inocua,
	puedes anular esta prohibición añadiendo la opción <opt>force</opt>
	a la instrucción <lit>delete</lit>.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana principal: Menú emergente (selección única)</menu-path>
    </gui-access>

  </command>

  <command name="density" section="Statistics" context="gui"
    label="Estimación de la densidad Kernel">

    <description>
      <para>
	La estimación de la densidad Kernel se realiza definiendo
	un conjunto de puntos de referencia separados de modo uniforme
	sobre un rango apropiado relacionado con el rango de los datos, y atribuyendo
	una densidad a cada punto de referencia basada en las observaciones
	presentes en su entorno.
      </para>
      <para>
	Se te ofrece la posibilidad de utilizar un Kernel Gaussiano
	(la densidad Normal estándar) o el Kernel de Epanechnikov.
	Por defecto, el ancho de banda es el sugerido como norma general por
	<cite key="silverman86">Silverman (1986)</cite>.
	Puedes ampliar o reducir el ancho de banda mediante el
	<quote>Factor de ajuste del ancho de banda</quote>, puesto que
	entonces el ancho real de banda que se va a utilizar, se obtiene
	multiplicando el valor de Silverman por el factor de ajuste.
      </para>
      <para>
	Para ver una buena discusión introductoria de la estimación de la densidad
	del Kernel, consulta el capítulo 15 del libro de Davidson y MacKinnon
	<book>Econometric Theory and Methods</book>.
      </para>
    </description>

  </command>

  <command name="dfgls" section="Tests" context="gui"
    label="El contraste ADF-GLS">

    <description>
      <para>
	El contraste ADF-GLS es una variante del contraste de raíz unitaria de
	Dickey&ndash;Fuller, para el caso en el que se asume que la variable
	que se contrasta tiene una media no nula o presenta una tendencia
	lineal. La diferencia está en que la detracción de la media o de la tendencia
	de la variable se hace utilizando el procedimiento MCG (GLS) sugerido
	por <cite key="ERS96">Elliott, Rothenberg y Stock (1996)</cite>.
	Esto proporciona un contraste con mayor potencia que el enfoque
	estándar de Dickey&ndash;Fuller.
      </para>
      <para>
	Cuando se prueba hacia abajo, a partir de un orden máximo de retardos que
	indiques, los criterios AIC y BIC <quote>modificados</quote> son como
	se describe en <cite key="ng-perron01">Ng y Perron (2001)</cite>,
	con o sin la corrección propuesta por
	<cite key="perron-qu07">Perron y Qu (2007)</cite>. Esta corrección
	implica utilizar datos con la tendencia detraída con MCO en la etapa de
	determinación del orden de retardos óptimo, y luego detraer la tendencia
	con MCG en el contraste final de raíz unitaria.
      </para>
      <para>
	Consulta también la instrucción <cmdref targ="adf"/> y la opción
	<opt>gls</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Contrastes de raíz unitaria/Contraste ADF-GLS</menu-path>
    </gui-access>

  </command>

  <command name="dialog" section="Estimation" context="gui"
    label="Caja de diálogo del modelo">

    <description>
      <para>
	Para escoger una variable como la dependiente, resalta esa
	variable en la lista de la izquierda y pulsa el botón <quote>Elegir</quote>
	que apunta al cuadrado de la variable Dependiente. Si marcas el cuadradito
	de <quote>Selección por defecto</quote>, la variable que escogiste
	se va a preseleccionar como la dependiente cuando se vuelva a abrir la caja
	de diálogo del modelo. Atajo: pulsa un doble clic en una variable de la
	izquierda para escogerla como la variable dependiente, y también fijarla
	por defecto.
      </para>
      <para>
	Para escoger las variables independientes, resáltalas en el lado
	izquierdo y pulsa el botón <quote>Añadir</quote> (o pulsa un
	clic con el botón derecho del ratón). Puedes resaltar varias variables
	contiguas arrastrando con el ratón, y puedes resaltar un grupo de
	variables no contiguas pulsando un clic en cada una de ellas
	mientras mantienes pulsada la tecla <lit>Ctrl</lit>.
      </para>
    </description>

  </command>

  <command name="diff" section="Transformations"
    label="Primeras diferencias" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
	<examples>
	<demos>
	  <demo>penngrow.inp</demo>
	  <demo>sw_ch12.inp</demo>
	  <demo>sw_ch14.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Con esta instrucción obtienes la primera diferencia de cada variable
	de <repl>listavariables</repl>, y el resultado se guarda en una nueva variable
	con el prefijo <lit>d_</lit>. Así <cmd>diff x y</cmd> genera las nuevas
	variables
      </para>
      <mono>
	d_x = x(t) - x(t-1)
	d_y = y(t) - y(t-1)
      </mono>
    </description>

    <gui-access>
      <menu-path>/Añadir/Primeras diferencias de las variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="difftest" section="Tests"
    label="Contrastes no paramétricos de diferencias" context="cli">

    <usage>
      <arguments>
        <argument>serie1</argument>
	      <argument>serie2</argument>
      </arguments>
      <options>
	<option>
	  <flag>--sign</flag>
	  <effect>Contraste de los signos, por defecto</effect>
	</option>
	<option>
	  <flag>--rank-sum</flag>
	  <effect>Contraste de la suma de rangos de Wilcoxon</effect>
	</option>
	<option>
	  <flag>--signed-rank</flag>
	  <effect>Contraste de los rangos con signo de Wilcoxon</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta resultados adicionales</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Suprime la presentación de resultados</effect>
	</option>
      </options>
	<examples>
	<demos>
	  <demo>ooballot.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Lleva a cabo un contraste no paramétrico sobre la diferencia entre
	dos poblaciones o grupos, en la que el contraste concreto depende
	de la opción seleccionada.
      </para>
      <para>
	Con la opción <opt>sign</opt>, se realiza el contraste de los signos.
	Este contraste se basa en el hecho de que, cuando se extraen dos
	muestras, <math>x</math> e <math>y</math>, de forma
	aleatoria de una misma distribución, la probabilidad de que
	<math>x</math><sub>i</sub> &gt; <math>y</math><sub>i</sub>,
	para cada observación <math>i</math>, deberá ser igual
	a 0.5. El estadístico de contraste es <math>w</math>, es decir,
	el número de observaciones para las que se cumple que
	<math>x</math><sub>i</sub> &gt; <math>y</math><sub>i</sub>.
	Bajo la hipótesis nula, este estadístico sigue una distribución
	de probabilidad Binomial con parámetros (<math>n</math>, 0.5),
	donde <math>n</math> indica el número de
	observaciones.
      </para>
      <para>
	Con la opción <opt>rank-sum</opt>, se realiza el contraste de la suma de rangos de
	Wilcoxon. Este contraste se desarrolla determinando el rango en jerarquía de las
	observaciones de ambas muestras juntas, desde la de menor valor hasta la de
	mayor, y luego calculando la suma de los rangos de las observaciones de una cualquiera
	de las dos muestras. No es necesario que las dos muestras tengan el mismo
	tamaño y, si son diferentes, se utiliza la muestra más pequeña para calcular
	la suma de los rangos. Bajo la hipótesis nula de que las muestras proceden de
	poblaciones con la misma mediana, la distribución de probabilidad de la suma de
	rangos puede calcularse para cualquier tamaño de muestra que se indique; y para
	muestras razonablemente largas, existe una estrecha aproximación Normal.
      </para>
      <para>
	Con la opción <opt>signed-rank</opt>, se realiza el contraste de los rangos con
	signo de Wilcoxon, que está ideada para pares de datos ligados
	como, por ejemplo, los pares de valores de una misma variable en una
	muestra de individuos, antes y después de algún tratamiento. El contraste
	se desarrolla calculando las diferencias entre las observaciones emparejadas
	<math>x</math><sub>i</sub> &minus; <math>y</math><sub>i</sub>,
	y determinando el rango de estas diferencias según su valor absoluto,
	además de asignándole a cada par, un rango con un signo que coincide
	con el signo de la diferencia. A continuación se calcula la suma de los rangos
	con signo positivo (<math>W</math><sub>+</sub>). De igual modo
	que en el contraste de la suma de rangos, bajo la hipótesis nula de que la
	diferencia de las medianas es cero, este estadístico sigue una distribución
	de probabilidad bien definida, que converge a la Normal para muestras
	de tamaño razonable.
      </para>
      <para>
	Para los contrastes de Wilcoxon, cuando indicas la opción <opt>verbose</opt>,
	entonces se presenta la ordenación. (Esta opción no tiene efecto cuando se
	selecciona el contraste de los signos.)
      </para>
      <para>
	Al completarse con éxito, vas a tener disponibles los accesores
	<fncref targ="$test"/> y <fncref targ="$pvalue"/>. Si únicamente
	quieres obtener estos valores, puedes añadir la opción <opt>quiet</opt>
	a la instrucción.
      </para>
    </description>

  </command>

  <command name="discrete" section="Transformations"
    label="Marcar variables como discretas" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--reverse</flag>
	  <effect>Marca las variables como continuas</effect>
	</option>
      </options>
	<examples>
	<demos>
	  <demo>ooballot.inp</demo>
	  <demo>oprobit.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Marca cada variable de <repl>listavariables</repl> como discreta pues, por
	defecto, todas las variables se tratan como continuas. Al hacer que
	una variable sea discreta, eso afecta al modo en el que se maneja
	esa variable en los gráficos de frecuencia, y también te permite escoger
	la variable para la instrucción <cmdref targ="dummify"/>.
      </para>
      <para>
	Cuando especificas la opción <opt>reverse</opt>, la operación se invierte;
	es decir, las variables contenidas en <repl>listavariables</repl> se marcan como
	continuas.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Editar atributos</menu-path>
    </gui-access>

  </command>

  <command name="dpanel" section="Estimation" label="Modelos de panel dinámicos">

    <usage>
      <arguments>
	      <argument>p</argument>
	     <argblock separated="true">
	      <argument>depvar</argument>
	      <argument>indepvars</argument>
	     </argblock>
	     <argblock optional="true" separated="true">
	      <argument>instrumentos</argument>
	     </argblock>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>No muestra el modelo estimado</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
        <option>
	  <flag>--two-step</flag>
	  <effect>Realiza la estimación MGM (GMM) en 2 etapas</effect>
        </option>
        <option>
	  <flag>--system</flag>
	  <effect>Añade ecuaciones en niveles</effect>
        </option>
        <option>
	  <flag>--collapse</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>Añade variables ficticias temporales</effect>
        </option>
        <option>
	  <flag>--dpdstyle</flag>
	  <effect>Imita el paquete DPD para Ox</effect>
        </option>
        <option>
	  <flag>--asymptotic</flag>
	  <effect>Desviaciones típicas asintóticas sin corregir</effect>
        </option>
        <option>
	  <flag>--keep-extra</flag>
	  <effect>Mira abajo</effect>
        </option>
      </options>
      <examples>
        <example>dpanel 2 ; y x1 x2</example>
	<example>dpanel 2 ; y x1 x2 --system</example>
        <example>dpanel {2 3} ; y x1 x2 ; x1</example>
	<example>dpanel 1 ; y x1 x2 ; x1 GMM(x2,2,3)</example>
	<demos>
	  <demo>bbond98.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Realiza la estimación de modelos dinámicos con datos de panel
	(es decir, modelos de panel que incluyen uno o más retardos de la variable
	dependiente) utilizando bien el método GMM-DIF o bien GMM-SYS.
      </para>
      <para context="cli">
	El parámetro <repl>p</repl> representa el orden de autorregresión
	para la variable dependiente. En el caso más sencillo, este parámetro es
	un valor escalar, pero también puedes indicar una matriz definida
	previamente para este argumento, para especificar con ello un
	conjunto de retardos (posiblemente no consecutivos) a utilizar.
      </para>
      <para>
	Debes indicar la variable dependiente y los regresores con sus
	valores en niveles, pues ya se van a diferenciar automáticamente
	(dado que este estimador utiliza la diferenciación para eliminar
	los efectos individuales).
      </para>
      <para context="cli">
	El último campo (opcional) de la instrucción es para especificar los
	instrumentos. Si no indicas ningún instrumento, se asume que
	todas las variables independientes son estrictamente exógenas. Si
	especificas cualquier instrumento, debes incluir en la lista
	cualquier variable independiente estrictamente exógena. Para los
	regresores predeterminados puedes utilizar la función <lit>GMM</lit>
	para incluir un rango específico de retardos con el estilo diagonal
	por bloques, como se ilustra en el tercer ejemplo de arriba. El
	primer argumento de <lit>GMM</lit> es el nombre de la variable en
	cuestión, el segundo es el retardo mínimo que se utiliza como
	instrumento, y el tercero es el retardo máximo. Puedes utilizar la
	misma sintaxis con la función <lit>GMMlevel</lit> para especificar
	instrumentos de tipo GMM para las ecuaciones en niveles.
      </para>
      <para context="cli">
	Puedes usar la opción <opt>collapse</opt> para limitar la proliferación
	de instrumentos de <quote>estilo GMM</quote>, lo que podría llegar a
	ser un problema con este estimador. Su efecto consiste en reducir ese
	tipo de instrumentos, de uno por cada retardo y por observación, a
	uno por cada retardo.
      </para>
      <para context="gui">
	En lo referente al manejo de los instrumentos, consulta la documentación para
	a versión de guion de esta instrucción. Actualmente no puedes especificar
	instrumentos explícitamente en la Interfaz Gráfica de Usuario (GUI), así
	todas las variables independientes se consideran estrictamente exógenas.
      </para>
      <para>
	Por defecto, se presentan los resultados de la estimación en 1 etapa
	(con las desviaciones típicas robustas) pero tienes la opción de escoger
	la estimación en 2 etapas. En ambos casos, se presentan los contrastes
	de autocorrelación de orden 1 y 2 , así como los contrastes de Sargan
	y/o de Hansen de sobreidentificación, y el estadístico del contraste de
	Wald para la significación conjunta de los regresores. Ten en cuenta
	que en este modelo en diferencias, la autocorrelación de primer orden
	no es una amenaza para la validez del modelo, pero la autocorrelación
	de segundo orden infringe los supuestos estadísticos vigentes.
      </para>
      <para context="cli">
	En el caso de la estimación en 2 etapas, las desviaciones típicas se calculan
	por defecto utilizando la corrección de muestra finita sugerida por
	<cite key="windmeijer05">Windmeijer (2005)</cite>. Generalmente
	se considera que las desviaciones típicas asintóticas estándar asociadas
	al estimador del método en 2 etapas, son una guía poco fiable para la
	inferencia, pero si por alguna razón quieres verlas, puedes utilizar
	la opción <opt>asymptotic</opt> para desactivar la corrección de
	Windmeijer.
      </para>
      <para context="cli">
	Si indicas la opción <opt>time-dummies</opt>, se añade un conjunto
	de variables ficticias temporales a los regresores especificados.
	El número de estas variables ficticias es una menos que el número
	máximo de períodos usados en la estimación, para evitar que haya
	multicolinealidad perfecta con la constante. Las variables ficticias
	se introducen en forma de diferencias excepto que se indique la opción
	<opt>dpdstyle</opt>, en cuyo caso se introducen en niveles.
      </para>
      <para context="cli">
	De igual modo que con otras instrucciones para hacer la estimación,
	dispones de un 'bundle' <fncref targ="$model"/> después de realizarla.
	En caso de <lit>dpanel</lit>, puedes usar la opción <opt>keep-extra</opt>
	para guardar información que quieras añadir a ese 'bundle', por ejemplo
	las matrices de ponderaciones y de instrumentos GMM.
      </para>
      <para>
	Para obtener otros detalles y ejemplos, consulta
	<guideref targ="chap:dpanel"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Panel/Modelo de panel dinámico</menu-path>
    </gui-access>

  </command>

  <command name="dummify" section="Transformations" context="gui"
    label="Generar conjuntos de variables ficticias">

    <description>
      <para>
	La operación <quote>dummify</quote> está disponible únicamente
	para series con valores discretos. Su efecto consiste en generar
	un conjunto de variables ficticias que codifican los distintos
	valores presentes en las series.
      </para>
      <para>
	Por ejemplo, supón que tienes una serie titulada <lit>raza</lit>, con valores
	de 1 para <quote>blanco</quote>, 2 para <quote>negro</quote>, 3 para
	<quote>hispano</quote> y 4 para <quote>otros</quote>. Crear variables
	ficticias a partir de esta serie significa generar 4 variables ficticias: la
	primera tiene el valor 1 para todas las observaciones en las que raza = 1 y cero
	en otro caso; la segunda tiene el valor 1 para todas las observaciones en las que
	raza = 2, cero en otro caso; etcétera.
      </para>
      <para>
	En la práctica, es posible que para una serie discreta con
	<math>k</math> categorías quieras generar únicamente
	<math>k</math> &minus; 1 variables ficticias, para evitar caer
	en la denominada <quote>trampa de las variables ficticias</quote>.
	De ahí que tengas la posibilidad de prescindir de la codificación, bien
	del valor más bajo o bien del valor más alto de los considerados.
      </para>
    </description>

  </command>

  <command name="dummify" section="Transformations"
    label="Generar conjuntos de variables ficticias" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--drop-first</flag>
	  <effect>Excluye de la codificación al valor más bajo</effect>
	</option>
	<option>
	  <flag>--drop-last</flag>
	  <effect>Excluye de la codificación al valor más alto</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Para cualquier variable adecuada de <repl>listavariables</repl>, genera un
	conjunto de variables ficticias que codifican los distintos valores
	de esa variable. Las variables adecuadas son aquellas que se marcan
	explícitamente como discretas o aquellas que tienen un número
	claramente pequeño de valores, de los que todos ellos estén
	<quote>claramente redondeadados</quote> (múltiplos de 0.25).
      </para>
      <para>
	Por defecto, se añade una variable ficticia por cada valor diferente de la
	variable en cuestión. Por ejemplo, si una variable discreta <lit>x</lit>
	tiene 5 valores diferentes, se añaden 5 variables ficticias al conjunto de
	datos, con los nombres <lit>Dx_1</lit>, <lit>Dx_2</lit>, etcétera. La primera
	variable ficticia va a tener el valor 1 en las observaciones donde <lit>x</lit>
	toma su valor más pequeño y 0 en otro caso; la siguiente variable
	ficticia va a tener el valor 1 en las observaciones donde <lit>x</lit> toma su
	segundo valor más pequeño, etcétera. Si añades uno de los indicadores de
	opción <opt>drop-first</opt> o <opt>drop-last</opt>, entonces se omite del
	proceso de codificación bien el valor más bajo o bien el valor más alto
	de cada variable, respectivamente (lo que puede serte útil para evitar la
	<quote>trampa de las variables ficticias</quote>).
      </para>
      <para>
	También hay una función que se corresponde con esta instrucción,
	consulta <fncref targ="dummify"/>. Esto posibilita integrar la llamada
	directamente en la especificación de una regresión. Por ejemplo, la
	siguiente linea especifica un modelo en el que <lit>y</lit> se regresa
	sobre el conjunto de variables ficticias que se codifican para
	<lit>x</lit>. (Sin embargo, los indicadores de opciones son únicamente
	para la variante de la instrucción, no para la variante de la función
	<cmd>dummify</cmd>.)
      </para>
      <code>
	ols y dummify(x)
      </code>
    </description>

    <gui-access>
      <other-access>Ventana principal: Menú emergente (selección única)</other-access>
    </gui-access>

  </command>

  <command name="duration" section="Estimation" label="Modelos de duración"
    context="cli">
    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
        <argument separated="true" optional="true">censuravar</argument>
      </arguments>
      <options>
        <option>
          <flag>--exponential</flag>
          <effect>Utiliza la distribución exponencial</effect>
        </option>
        <option>
          <flag>--loglogistic</flag>
          <effect>Utiliza la distribución log-logística</effect>
        </option>
        <option>
          <flag>--lognormal</flag>
          <effect>Utiliza la distribución log-normal</effect>
        </option>
        <option>
          <flag>--medians</flag>
          <effect>Los valores ajustados son las medianas</effect>
        </option>
        <option>
          <flag>--robust</flag>
          <effect>Desviaciones típicas robustas: CMV (QML)</effect>
        </option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustervar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para explicación</effect>
        </option>
        <option>
          <flag>--vcv</flag>
          <effect>Presenta la matriz de covarianzas</effect>
        </option>
        <option>
          <flag>--verbose</flag>
          <effect>Presenta los detalles de las iteraciones</effect>
        </option>
	      <option>
	        <flag>--quiet</flag>
	        <effect>No presenta nada</effect>
	      </option>
      </options>
      <examples>
        <example>duration y 0 x1 x2</example>
	<example>duration y 0 x1 x2 ; cens</example>
	<demos>
	  <demo>weibull.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Estima un modelo de duración en el que la variable dependiente (que debe
	ser positiva) representa la duración de algún estado de un asunto; por
	ejemplo, la duración del período de desempleo para una sección
	cruzada de encuestados. Por defecto, se utiliza la distribución de
	Weibull pero también están disponibles las distribuciones exponencial,
	log-logística y log-normal.
      </para>
      <para>
	Si algunas de las medidas de duración están censuradas por la derecha
	(&eg; el período del desempleo de un individuo aún no acabó dentro
	del período de observación), entonces debes indicar en el argumento
	posterior <repl>censuravar</repl>, una serie en la que los valores no
	nulos indiquen los casos censurados por la derecha.
      </para>
      <para>
	Por defecto, los valores ajustados que obtienes mediante el accesor
	<lit>$yhat</lit> son las medias condicionadas de las duraciones, pero
	cuando indicas la opción <opt>medians</opt> entonces <lit>$yhat</lit>
	te proporciona las medianas condicionadas en su lugar.
      </para>
      <para>
	Consulta <guideref targ="chap:probit"/> para obtener más detalles.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Variable dependiente limitada/Datos de duración</menu-path>
    </gui-access>

  </command>

  <command name="elif" section="Programming" label="Control de flujo" context="cli">
    <description>
      <para>Consulta <cmdref targ="if"/>.
      </para>
    </description>
  </command>

  <command name="else" section="Programming" label="Control de flujo" context="cli">
    <description>
      <para>Consulta <cmdref targ="if"/>. Ten en cuenta que la instrucción
	<cmd>else</cmd> necesita una línea para ella misma, antes de la siguiente
	instrucción condicional. Puedes añadirle un comentario, como en
      </para>
      <code>
	else # Correcto, hace algo distinto
      </code>
      <para>
	Pero no puedes añadirle una instrucción, como en
      </para>
      <code>
	else x = 5 # Incorrecto!
      </code>
    </description>
  </command>

  <command name="ema-filter" section="Transformations" context="gui"
    label="Media móvil exponencial">

    <description>
      <para>
	La fórmula que emplea GRETL para calcular la media móvil exponencial
	(MME o EMA) es la de <cite key="roberts59">Roberts (1959)</cite>,
	concretamente
      </para>
      <para>
	<math>s</math><sub>t</sub> =
	&agr;<math>y</math><sub>t</sub> +
        (1&minus;&agr;)<math>s</math><sub>t&minus;1</sub>
      </para>
      <para>
	donde <math>s</math> es la MME, <math>y</math> es la serie original, y
	&agr; es una constante entre 0 y 1. Los valores más grandes de &agr;
	cargan más ponderación en la observación vigente; y los valores más
	pequeños producen un mayor suavizado.
      </para>
      <para>
	Como <quote>primer valor de la MME</quote>, si no se especifica,
	se toma el último valor previo a la muestra, lo que significa que el cálculo
	del filtro comienza con la primera observación que hay en el rango de la muestra
	vigente.
      </para>
      <para>
	Para una línea de instrucción equivalente, consulta la función
	<fncref targ="movavg"/>.
      </para>
    </description>

  </command>

  <command name="end" section="Programming"
    label="Finalizar un bloque de instrucciones" context="cli">
    <description>
      <para>
	Termina un bloque de instrucciones de algún tipo. Por ejemplo, <cmd>end system</cmd>
	termina un sistema de ecuaciones (<cmdref targ="system"/>).
      </para>
    </description>
  </command>

  <command name="endif" section="Programming" label="Control de flujo" context="cli">
    <description><para>Consulta <cmdref targ="if"/>.</para>
    </description>
  </command>

  <command name="endloop" section="Programming"
    label="Finalizar un bucle de instrucciones" context="cli">
    <description>
      <para>
	Marca el final de un bucle de instrucciones. Consulta <cmdref targ="loop"/>.
      </para>
    </description>
  </command>

  <command name="eqnprint" section="Printing"
    label="Presentar un modelo como ecuación" context="cli">

    <usage>
      <options>
        <option>
	  <flag>--complete</flag>
	  <effect>Genera un documento completo</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el resultado al archivo especificado</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Debe ir después de la estimación de un modelo y presenta el modelo
	estimado en formato de una ecuación &latex;. Si especificas el nombre
	de un archivo utilizando la opción <opt>output</opt>, el resultado
	se dirige a ese archivo; en otro caso, se dirige a un archivo con un
	nombre con el estilo <filename>equation_N.tex</filename>, donde <lit>N</lit>
	es el número de modelos estimados hasta ese momento en la sesión vigente.
	Consulta también <cmdref targ="tabprint"/>.
      </para>
      <para>
	El archivo resultante va a escribirse en el directorio de trabajo
	(<cmdref targ="workdir"/>) establecido en ese momento, excepto que la cadena
	<repl>nombrearchivo</repl> contenga una especificación completa de la ruta.
      </para>
      <para>
	Cuando especificas la opción <opt>complete</opt>, el archivo &latex; es
	un documento completo (listo para procesar); en otro caso, debes
	incluirlo en un documento.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="equation" section="Estimation"
    label="Definir una ecuación dentro de un sistema" context="cli">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <examples>
        <example>equation y x1 x2 x3 const</example>
      </examples>
    </usage>

    <description>
      <para>
	Te permite especificar una de las ecuaciones de un sistema de ellas (consulta
	<cmdref targ="system"/>). La sintaxis para especificar una ecuación de un
	sistema SUR es la misma que para, &eg;, <cmdref targ="ols"/>. Pero para
	una de las ecuaciones de un sistema a estimar con Mínimos Cuadrados en 3 etapas,
	puedes: (a) indicar una especificación de una ecuación como se estima con
	MCO y proporcionar una lista normal de instrumentos utilizando la palabra
	clave <cmd>instr</cmd> (de nuevo, consulta <cmdref targ="system"/>), o
	(b) utilizar la misma sintaxis de ecuaciones que para <cmdref targ="tsls"/>.
      </para>
    </description>

  </command>

  <command name="estimate" section="Estimation"
    label="Estimar sistemas de ecuaciones" context="cli">

    <usage>
      <arguments>
        <argument optional="true">nombresistema</argument>
	      <argument optional="true">estimador</argument>
      </arguments>
      <options>
	<option>
	  <flag>--iterate</flag>
	  <effect>Itera hasta la convergencia</effect>
	</option>
	<option>
	  <flag>--no-df-corr</flag>
	  <effect>Sin corrección de los grados de libertad</effect>
	</option>
	<option>
	  <flag>--geomean</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
	</option>
      </options>
      <examples>
        <example>estimate "Klein Model 1" method=fiml</example>
	<example>estimate Sys1 method=sur</example>
	<example>estimate Sys1 method=sur --iterate</example>
      </examples>
    </usage>

    <description>
      <para>
	Solicita la estimación de un sistema de ecuaciones que debes
	definir previamente usando la instrucción <cmdref targ="system"/>.
	Debes indicar primero el nombre del sistema, puesto entre
	comillas si el nombre contiene espacios. El estimador debe ser uno
	de los siguientes: <cmd>ols</cmd>, <cmd>tsls</cmd>, <cmd>sur</cmd>,
	<cmd>3sls</cmd>, <cmd>fiml</cmd> o <cmd>liml</cmd>; y debes
	de ponerle antes la cadena de texto <lit>method=</lit>. Estos
	argumentos son opcionales si el sistema en cuestión ya se
	estimó, y ocupa el lugar del <quote>último modelo</quote>;
	en ese caso, el estimador que se toma por defecto será el utilizado
	previamente.
      </para>
      <para>
	Si el sistema en cuestión tuvo aplicadas un conjunto de restricciones
	(consulta la instrucción <cmdref targ="restrict"/>), la estimación
	estará sujeta a las restricciones especificadas.
      </para>
      <para>
	Si el método de estimación es <cmd>sur</cmd> o <cmd>3sls</cmd>, y
	especificas la opción <opt>iterate</opt>, se va a calcular el estimador
	iterativamente. En caso de SUR, si el procedimiento converge, los
	resultados son las estimaciones máximo verosímiles. La iteración de
	Mínimos Cuadrados en 3 Etapas (3sls), sin embargo, en general no converge a los
	resultados de la máxima verosimilitud con información completa (fiml).
	La opción <opt>iterate</opt> se ignora para otros métodos de
	estimación.
      </para>
      <para>
	Si eliges los estimadores de ecuación a ecuación <cmd>ols</cmd>
	o <cmd>tsls</cmd>, por defecto se aplica una corrección de los
	grados de libertad cuando se calculan las desviaciones típicas, pero
	puedes eliminar esto utilizando la opción <opt>no-df-corr</opt>. Esta
	opción no tiene efecto con los otros estimadores, y así no se aplica la
	corrección de los grados de libertad en ningún caso.
      </para>
      <para>
	Por defecto, la fórmula utilizada para calcular los elementos
	de la matriz de covarianzas de las ecuaciones cruzadas es
	<equation status="display"
	tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{T}\]"
	ascii="sigma(i,j) = u(i)' * u(j) / T"
	graphic="syssigma1"/>
	Cuando indicas la opción <opt>geomean</opt>, se aplica una
	corrección de los grados de libertad con lo que la fórmula en ese
	caso es
	<equation status="display"
	tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{\sqrt{(T-k_i)(T-k_j)}}\]"
	ascii="sigma(i,j) = u(i)' * u(j) / sqrt((T - ki) * (T - kj))"
	graphic="syssigma2"/>
	donde las <math>k</math>s denotan el número de parámetros
	independientes en cada ecuación.
      </para>
      <para>
	Cuando indicas la opción <opt>verbose</opt> y especificas un
	método iterativo, se presentan detalles de las iteraciones.
      </para>
    </description>

  </command>

  <command name="eval" section="Utilities" context="cli">
    <usage>
      <arguments>
        <argument>expresión</argument>
      </arguments>
      <examples>
        <example>eval x</example>
	<example>eval inv(X'X)</example>
	<example>eval sqrt($pi)</example>
      </examples>
    </usage>
    <description>
      <para>
	Esta instrucción hace que GRETL funcione como una sofisticada
	calculadora. El programa evalúa <repl>expresión</repl> y
	presenta su valor. El argumento puede ser el nombre de una
	variable, o algo más complicado. En cualquier caso, debe
	ser una expresión que puedas poner correctamente como
	el lado derecho de un enunciado de asignación (igualdad).
      </para>
      <para>
	En el uso interactivo (por ejemplo con la consola de GRETL), un signo
	igual funciona como una abreviatura de <lit>eval</lit>, como en
      </para>
      <code>
	=sqrt(x)
      </code>
      <para>
	(con o sin espacio después de <quote>=</quote>). Pero esta variante
	no se admite en el modo de edición de guiones puesto que podría
	esconder fácilmente fallos de codificación.
      </para>
      <para>
	En la mayoría de los contextos, puedes usar la instrucción <cmdref targ="print"/>
	en lugar de <lit>eval</lit> para obtener el mismo efecto. Consulta también
	<cmdref targ="printf"/> para aquellos casos en los que quieras combinar
	resultados de texto y numéricos.
      </para>
    </description>
  </command>

  <command name="expand" section="Dataset" context="gui"
    label="Expandir datos">

    <description>
      <para>
	Debes considerar la <quote>expansión</quote> desde una frecuencia
	menor a una mayor de un conjunto de datos o de una serie, como una
	opción para expertos, pues necesitas saber que estás haciendo. Cuando
	combinas series de diferentes frecuencias originales dentro de un conjunto
	de datos, probablemente deberías considerar como compactar los datos
	de frecuencia mayor, en lugar de expandir las series de frecuencia menor.
      </para>
      <para>
	Dicho esto, GRETL admite la expansión mediante la simple repetición
	de los valores de baja frecuencia. Por ejemplo, al expandir desde
	frecuencia trimestral a mensual, los valores trimestrales se repiten
	para cada mes del trimestre. Las series generadas de este modo no es
	probable que se puedan usar tal cual para el análisis econométrico, pero
	después de la expansión puedes usar la función <fncref targ="tdisagg"/>
	para producir una versión distribuida o interpolada de los datos
	(<quote>desagregación temporal</quote>).
      </para>
      <para>
	Puedes acceder a algunas de las prestaciones de la función
	<lit>tdisagg</lit> por medio de la interfaz gráfica, seleccionando
	una serie en la ventana principal de GRETL, y a continuación buscar
	<quote>Desagregar</quote> bajo el menú Variable.
      </para>
    </description>
  </command>

  <command name="export" section="Dataset" context="gui"
    label="Exportar datos">

    <description>
      <para>
	Puedes exportar datos en el formato Valores Separados por Comas (CSV)
	que pueden abrirse en hojas de cálculo y muchos otros programas.
	Si escoges esta opción, vas a tener algunas opciones adicionales con
	relación al formato específico del archivo CSV.
      </para>
      <para>
	También tienes la opción de exportar datos con el formato de un archivo
	de datos <quote>propio</quote> de GRETL, o de exportarlos a
	una base de datos de GRETL (si los datos son adecuados). Consulta
	<url>gretl.sourceforge.net/gretl_data.html</url> para ver una
	relación de las bases de datos de GRETL.
      </para>
      <para>
	Puedes también exportar datos en un formato de texto plano adecuado para
	usarlos con los siguientes programas:
      </para>
      <ilist>
	<li>
	  <para>
	    GNU R (<url>www.r-project.org</url>): Se escriben los datos con el formato
	    que utiliza espacios separados y que la función <lit>read.table</lit>
	    de R puede asimilar fácilmente. Sufijo, por defecto, del nombre de
	    archivo: <lit>.txt</lit>
	  </para>
	</li>
	<li>
	  <para>
	    GNU octave (<url>www.gnu.org/software/octave</url>): Los datos se
	    escriben como una matriz en el formato favorito de Octave. Sufijo,
	    por defecto, del nombre de archivo: <lit>.m</lit>
	  </para>
	</li>
	<li>
	  <para>
	    JMulTi (<url>www.jmulti.de</url>): Sufijo, por defecto, del nombre de
	    archivo: <lit>.dat</lit>
    </para>
	</li>
	<li>
	  <para>
	    PcGive (<url>www.pcgive.com</url>): Sufijo, por defecto, del nombre de
	    archivo: <lit>.dat</lit>
    </para>
	</li>
      </ilist>
      <para>
	Si quieres exportar los datos copiándolos al portapapeles mejor que
	escribiéndolos en un archivo del disco, selecciona en la ventana principal
	las series que quieres copiar, pulsa con el botón derecho del ratón en la
	selección y escoge <quote>Copiar al portapapeles</quote>.
	(Solo se admite el formato CSV en este contexto.)
      </para>
    </description>
  </command>

  <command name="factorized" section="Graphs" context="gui"
    label="Gráfico con factor de separación">

    <description>
      <para>
	Esta instrucción requiere que selecciones 3 variables y la última de
	ellas (la variable de factor) debe ser discreta. La variable Y se
	representa gráficamente frente a la variable X, con los puntos de datos
	con estilos diferentes dependiendo del valor de la tercera variable.
      </para>
      <para>
	Ejemplo: Supón que tienes datos sobre salarios y cualificaciones educativas
	para una muestra de personas, y también una variable ficticia con el valor 1
	para los hombres y 0 para las mujeres (como en <filename>data7-2</filename>
	de Ramanathan). Un <quote>gráfico con factor de separación</quote> de
	<lit>WAGE</lit> frente a <lit>EDUC</lit>, utilizando la variable ficticia
	<lit>GENDER</lit> como factor, mostrará los puntos de datos para los
	hombres en un color y aquellos para las mujeres en otro (con una leyenda para
	identificarlos).
      </para>
    </description>

  </command>

  <command name="fcast" section="Prediction"
    label="Generar predicciones">

    <usage>
      <altforms>
	<altform><lit>fcast [</lit><repl>obsinicio obsfin</repl><lit>] [</lit><repl>nombrev</repl><lit>]</lit></altform>
	<altform><lit>fcast [</lit><repl>obsinicio obsfin</repl><lit>]</lit> <repl>pasosadelante</repl> <lit>[</lit><repl>nombrev</repl><lit>] --recursive</lit></altform>
      </altforms>
      <options>
        <option>
	  <flag>--dynamic</flag>
	  <effect>Genera la predicción dinámica</effect>
        </option>
        <option>
	  <flag>--static</flag>
	  <effect>Genera la predicción estática</effect>
        </option>
        <option>
	  <flag>--out-of-sample</flag>
	  <effect>Genera la predicción postmuestral</effect>
        </option>
        <option>
	  <flag>--no-stats</flag>
	  <effect>No presenta las estadísticas de predicción</effect>
        </option>
        <option>
	  <flag>--stats-only</flag>
	  <effect>Presenta solo las estadísticas de predicción</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
        </option>
        <option>
	  <flag>--recursive</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--all-probs</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--plot</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
        </option>
      </options>
      <examples>
        <example>fcast 1997:1 2001:4 f1</example>
	<example>fcast fit2</example>
	<example>fcast 2004:1 2008:3 4 rfcast --recursive</example>
	<demos>
	  <demo>gdp_midas.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Debe ir después de una instrucción de estimación. Las predicciones se generan
	para el rango especificado de observaciones. Dependiendo de la naturaleza del
	modelo, también pueden generarse las desviaciones típicas (mira abajo).
      </para>

      <para context="cli">
	Debe ir después de una instrucción de estimación. Las predicciones se
	generan para cierto rango de observaciones que será, bien el definido
	cuando indicas <repl>obsinicio</repl> y <repl>obsfin</repl> (de ser
	posible), bien el definido por las observaciones que van a continuación
	del rango sobre el que se estimó el modelo cuando indicas la opción
	<opt>out-of-sample</opt>, o bien, en otro caso, el rango de la muestra
	definido en ese momento. Cuando solicitas una predicción 'out-of-sample'
	pero no hay disponibles observaciones relevantes, se muestra un fallo.
	Dependiendo de la naturaleza del modelo, también pueden generarse
	las desviaciones típicas (mira abajo). También mira abajo para indagar
	sobre el efecto especial de la opción <opt>recursive</opt>.
      </para>

      <para context="cli">
	Si el último modelo estimado tiene una única ecuación, entonces el
	argumento <repl>nombrev</repl> (opcional) tiene el siguiente efecto:
	no se presentan los valores de la predicción, sino que se guardan en
	el conjunto de datos con el nombre indicado. Si el último modelo es un
	sistema de ecuaciones, <repl>nombrev</repl> tiene un efecto distinto
	ya que, en concreto, escoge una variable endógena en particular para
	hacer la predicción (pues por defecto se generan las predicciones para
	todas las variables endógenas). En caso de un sistema o si no
	indicas <repl>nombrev</repl>, puedes recuperar los valores de
	predicción utilizando el accesor <fncref targ="$fcast"/> y, si están
	disponibles, las desviaciones típicas mediante <fncref targ="$fcse"/>.
      </para>

      <subhead>Predicciones estáticas y dinámicas</subhead>
      <para>
	La elección entre una predicción estática o dinámica se aplica
	únicamente en caso de modelos dinámicos, con una perturbación con un
	proceso autorregresivo y/o que incluyan uno o más valores retardados
	de la variable dependiente como regresores. Las predicciones estáticas son
	un paso adelantadas (basadas en los valores obtenidos en el período previo),
	mientras que las predicciones dinámicas emplean la regla de la cadena de
	predicción. Por ejemplo, si una predicción para <math>y</math> en
	2008 requiere como entrada un valor de <math>y</math> en 2007, una
	predicción estática es imposible sin datos actualizados para 2007,
	pero una predicción dinámica para 2008 es posible si puedes substituir
	una predicción previa para <math>y</math> en 2007.
      </para>
      <para>
	Por defecto se proporciona: (a) una predicción estática para alguna
	porción del rango de predicción que cae dentro del rango de la muestra sobre
	el que se estima el modelo, y (b) una predicción dinámica (si es relevante)
	fuera de la muestra. La opción <opt>dynamic</opt> solicita una predicción
	dinámica a partir de la fecha lo más temprana posible, y la opción
	<opt>static</opt> solicita una predicción estática incluso fuera de la
	muestra.
      </para>

      <subhead context="cli">Predicciones recursivas</subhead>
      <para context="cli">
	La opción <opt>recursive</opt> está actualmente disponible solo
	para modelos de una sola ecuación, estimados mediante MCO.
	Cuando indicas esta opción las predicciones son recursivas; es
	decir, cada predicción se genera a partir de una estimación del
	modelo indicado, utilizando los datos a partir de un punto de
	inicio fijado (en concreto, el inicio del rango de la muestra
	para la estimación original) hasta la fecha de predicción menos
	<math>k</math>, el número de pasos adelantados que debes
	indicar en el argumento <repl>pasosadelante</repl>. Las predicciones
	siempre son dinámicas si eso es pertinente. Ten en cuenta
	que debes indicar el argumento <repl>pasosadelante</repl>
	únicamente junto con la opción <opt>recursive</opt>.
      </para>

      <subhead>Modelos ordenados y modelo multinomial</subhead>
      <para>
	Cuando la estimación es mediante logit o probit ordenados, o logit
	multinomial, podrías estar interesado en las probabilidades estimadas
	de cada uno de los resultados discretos, mejor que únicamente en el
	resultado <quote>más probable</quote> para cada observación. Esto se
	consigue mediante la opción <opt>all-probs</opt>: el efecto de
	<lit>fcast</lit> es en ese caso una matriz con una columna por cada
	resultado posible. Puedes usar el argumento <repl>vname</repl> para
	nombrar esa matriz, en cuyo caso no se presenta nada. Si no indicas
	<repl>vname</repl>, entonces la matriz se puede recuperar mediante
	<fncref targ="$fcast"/>. La opción <opt>plot</opt> no es compatible
	con la opción <opt>all-probs</opt>.
      </para>

      <subhead context="cli">Gráficos de predicciones</subhead>
      <para context="cli">
	La opción <opt>plot</opt> solicita que se produzca un archivo gráfico,
	que contiene una representación gráfica de la predicción. En el caso de
	un sistema, esta opción solo está disponible cuando se usa el argumento
	<repl>nombrev</repl> para seleccionar una única variable para hacer
	la predición. El sufijo del argumento <repl>nombrearchivo</repl> de
	esta opción, controla el formato del gráfico: <lit>.eps</lit> para EPS,
	<lit>.pdf</lit> para PDF, <lit>.png</lit> para PNG, y <lit>.plt</lit>
	para un archivo de instrucciones de Gnuplot. Puedes utilizar el nombre
	ficticio <lit>display</lit> en substitución del nombre de archivo para
	forzar la representación del gráfico en una ventana. Por
	ejemplo,
      </para>
      <code context="cli">
	fcast --plot=fc.pdf
      </code>
      <para context="cli">
	va a generar un gráfico con formato PDF. Se respetan los nombres de
	rutas que no ofrezcan dudas; en otro caso, los archivos se escriben
	en el directorio de trabajo de GRETL.
      </para>

      <subhead>Desviaciones típicas</subhead>
      <para>
	La naturaleza de las desviaciones típicas de las predicciones (si están disponibles)
	depende de la naturaleza del modelo y de la predicción. En modelos lineales estáticos,
	las desviaciones típicas se calculan utilizando el método bosquejado por
	<cite key="davidson-mackinnon04">Davidson y MacKinnon (2004)</cite>;
	ellos incorporan tanto la incertidumbre debida al proceso de la perturbación como la
	incertidumbre en los parámetros (resumida en la matriz de covarianzas de los
	estimadores de los parámetros). En modelos dinámicos, las desviaciones
	típicas de las predicciones se calculan únicamente en caso de una predicción
	dinámica, y no incorporan la incertidumbre en los parámetros. Para modelos
	no lineales, las desviaciones típicas de las predicciones no están disponibles
	actualmente.
      </para>

    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Análisis/Predicciones</menu-path>
    </gui-access>

  </command>

  <command name="flush" section="Programming" context="cli">

    <description>
      <para>
	Esta sencilla instrucción (sin argumentos, sin opciones) está ideada para
	ser usada en guiones que llevan algo de tiempo, y que deben ejecutarse con la
	Interfaz Gráfica de Usuario (GUI) de GRETL (el programa de líneas de
	instrucción lo ignora), para darle al usuario un indicio visual de que
	las cosas se están moviendo y GRETL no está <quote>parado</quote>.
      </para>
      <para>
	Generalmente, si lanzas un guion en la Interfaz Gráfica de Usuario (GUI),
	no se muestra el resultado hasta que se complete su ejecución, pero
	el efecto de invocar <lit>flush</lit> es como se indica a continuación:
      </para>
      <ilist>
       <li>
	    <para>
	   En la primera llamada, GRETL abre una ventana, muestra los resultados
	   hasta el presente y añade el mensaje
	   <quote>Procesando...</quote>.
	    </para>
       </li>
       <li>
	    <para>
	   Tras invocaciones posteriores, se actualiza el texto que se muestra
	   en la ventana de resultados, y se añade un nuevo mensaje
	   <quote>Procesando</quote>.
	    </para>
       </li>
     </ilist>
      <para>
	Cuando se completa la ejecución del guion, cualquier resultado que
	quede pendiente se descarga automáticamente en la ventana de texto.
      </para>
      <para>
	Ten en cuenta que no tiene sentido que utilices <lit>flush</lit> en
	guiones que tarden menos de (digamos) 5 segundos en ejecutarse.
	También ten en cuenta que no deberías utilizar esta instrucción en un
	lugar del guion donde no hay resultados posteriores que presentar,
	ya que el mensaje <quote>Procesando</quote> será entonces engañoso
	para el usuario.
      </para>
      <para>
	El siguiente código ilustra el uso que se pretende con <lit>flush</lit>:
      </para>
     <code>
       set echo off
       scalar n = 10
       loop i=1..n
           # Hacer una operación que lleve algo de tiempo
           loop 100 --quiet
               a = mnormal(200,200)
               b = inv(a)
           endloop
           # Presentar algunos resultados
           printf "Iteración %2d hecha\n", i
           if i &lt; n
               flush
           endif
       endloop
     </code>
    </description>

  </command>

  <command name="foreign" section="Programming"
    label="Guion ajeno" context="cli">

    <usage>
      <syntax><lit>foreign language=</lit><repl>ling</repl></syntax>
      <options>
	<option>
	  <flag>--send-data</flag>
	  <optparm optional="true">lista</optparm>
	  <effect>Carga previamente los datos; mira abajo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Elimina los resultados del programa externo</effect>
	</option>
      </options>
    </usage>

    <description>
     <para>
	Esta instrucción abre un modo especial en el que se admiten
	instrucciones que van a ejecutarse con otro programa. Puedes
	salir de este modo con <lit>end foreign</lit> y, en ese punto,
	se ejecutan las instrucciones acumuladas.
      </para>
      <para>
	Actualmente los programas <quote>externos</quote> a los que se les
	da apoyo de este modo son GNU R (<lit>language=R</lit>), Python,
	Julia, GNU Octave (<lit>language=Octave</lit>), Ox de Jurgen
	Doornik y Stata. Los nombres de los lenguajes se reconocen en términos
	que no distinguen mayúsculas y minúsculas.
      </para>
      <para>
	Junto con R, Octave y Stata, la opción <opt>send-data</opt>
	tiene como efecto el hacer accesibles los datos del espacio de
	trabajo del GRETL dentro del programa señalado. Por defecto, se
	envía el conjunto completo de datos, pero puedes limitar los
	datos que se van a enviar indicando el nombre de una lista de series
	definida previamente. Por ejemplo:
      </para>
      <code>
	list Rlist = x1 x2 x3
	foreign language=R --send-data=Rlist
      </code>
      <para>
	Consulta <guideref targ="chap:gretlR"/> para obtener más detalles y ejemplos.
      </para>
    </description>

  </command>

  <command name="fractint" section="Statistics" label="Integración fraccional">

    <usage>
      <arguments>
        <argument>serie</argument>
	      <argument optional="true">orden</argument>
      </arguments>
      <options>
        <option>
	  <flag>--gph</flag>
	  <effect>Hace el contraste de Geweke y Porter-Hudak</effect>
        </option>
        <option>
	  <flag>--all</flag>
	  <effect>Hace ambos contrastes</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Comprueba la integración fraccional (<quote>memoria larga</quote>)
	de las series especificadas contrastando la hipótesis nula de que el orden de
	integración de la serie es cero. Por defecto, se utiliza el Estimador Local
	Whittle <cite key="robinson95" p="true">(Robinson, 1995)</cite>,
	pero cuando indicas la opción <opt>gph</opt>, se realiza el contraste GPH
	<cite key="GPH83" p="true">(Geweke y Porter-Hudak, 1983)</cite>
	en su lugar. Cuando decidas indicar la opción <opt>all</opt>,
	entonces se van a presentar los resultados de ambos
	contrastes.
      </para>
      <para>
	Para obtener más detalles sobre este tipo de contraste, consulta
	<cite key="phillips04">Phillips y Shimotsu (2004)</cite>.
      </para>
      <para>
	Cuando no indicas el argumento <repl>orden</repl> (opcional), el orden
	para el(los) contraste(s) se establece automáticamente como el número menor
	entre <math>T</math>/2 y <math>T</math><sup>0.6</sup>.
      </para>
      <para>
	Los órdenes estimados de integración fraccional y sus desviaciones
	típicas correspondientes están disponibles a través del accesor
	<fncref targ="$result"/>. Con la opción <opt>all</opt>, encontrarás
	la estimación Local Whittle en la primera fila y la estimación GPH
	en la segunda.
      </para>
      <para>
	Puedes recuperar los resultados del test utilizando los accesores
	<fncref targ="$test"/> y <fncref targ="$pvalue"/>. Estos valores se
	basan en el Estimador Local Whittle excepto cuando indicas la
	opción <opt>gph</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Contrastes de raíz unitaria/Integración fraccional</menu-path>
    </gui-access>

  </command>

  <command name="freq" section="Statistics" label="Distribución de frecuencias">

    <usage>
      <arguments>
        <argument>variable</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nbins</flag>
	  <optparm>n</optparm>
	  <effect>Especifica el número de intervalos</effect>
        </option>
        <option>
	  <flag>--min</flag>
	  <optparm>valormínimo</optparm>
	  <effect>Especifica el mínimo, mira abajo</effect>
        </option>
        <option>
	  <flag>--binwidth</flag>
	  <optparm>ancho</optparm>
	  <effect>Especifica el ancho del intervalo, mira abajo</effect>
        </option>
        <option>
	  <flag>--normal</flag>
	  <effect>Contrasta la distribución Normal</effect>
        </option>
        <option>
	  <flag>--gamma</flag>
	  <effect>Contrasta la distribución Gamma</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nombrematriz</optparm>
	  <effect>Utiliza una columna de la matriz indicada</effect>
        </option>
        <option>
	  <flag>--plot</flag>
	  <optparm>modo-o-nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
        </option>
      </options>
      <examples>
  <example>freq x</example>
	<example>freq x --normal</example>
	<example>freq x --nbins=5</example>
	<example>freq x --min=0 --binwidth=0.10</example>
      </examples>
    </usage>

    <description context="cli">
      <para>
	Si no indicas opciones, muestra la distribución de frecuencias de la
	serie <repl>variable</repl> (indicada por su nombre o número) en
	formato tabular, con el número de intervalos y sus tamaños elegidos
	automáticamente, con o sin un gráfico adjunto tal como se explica
	más abajo. Cuando se completa la instrucción con éxito, puedes
	recuperar la tabla de frecuencias como una matriz utilizando
	el accesor <fncref targ="$result"/>.
      </para>
      <para>
	Cuando indicas la opción <opt>matrix</opt>, entonces <repl>variable</repl>
	debe ser un número entero y se interpreta en este caso como un
	índice que escoge una columna de la matriz indicada. Si la matriz
	en cuestión es realmente un vector columna, puedes omitir este
	argumento <repl>variable</repl>.
      </para>
      <para>
	Por defecto, la distribución de frecuencias utiliza un número de
	intervalos calculado automáticamente si los datos son continuos, o no
	agrupa en intervalos si los datos son discretos. Para controlar este
	aspecto puedes: (a) usar la instrucción <cmdref targ="discrete"/> para
	establecer el estatus de la <repl>variable</repl>, o (b), si los datos son
	continuos, especificar <emphasis>o</emphasis> el número de intervalos,
	o el valor mínimo junto con el ancho de los intervalos, como se muestra
	en los dos últimos ejemplos de arriba. La opción <opt>min</opt> establece
	el límite inferior del intervalo situado más a la izquierda.
      </para>
      <para>
	Cuando indicas la opción <opt>normal</opt>, se calcula el estadístico
	chi-cuadrado de Doornik&ndash;Hansen para contrastar la Normalidad.
	Cuando indicas la opción <opt>gamma</opt>, el contraste de Normalidad
	se substituye por el contraste no paramétrico de Locke respecto a la hipótesis
	nula de que una variable sigue una distribución Gamma; consulta
	<cite key="locke76">Locke (1976)</cite>, y también
	<cite key="shapiro-chen01">Shapiro y Chen (2001)</cite>. Ten en
	cuenta que la forma en la que se indican en GRETL los parámetros de la
	distribución Gamma utilizada es (forma, escala).
      </para>
      <para>
	Por defecto, si GRETL no está en modo de procesamiento por
	lotes, se muestra un gráfico de la distribución, pero puedes ajustar
	esto mediante la opción <opt>plot</opt>. Los parámetros admisibles
	para esta opción son: <lit>none</lit> (para suprimir el gráfico),
	<lit>display</lit> (para mostrar un gráfico incluso cuando estés
	en modo de procesamiento por lotes), o un nombre de archivo. El
	efecto de indicar un nombre de archivo es como se describe para la
	opción <opt>output</opt> de la instrucción <cmdref targ="gnuplot"/>.
      </para>
      <para>
	La opción <opt>silent</opt> elimina el resultado de texto habitual.
	Puedes utilizar esto junto con una u otra de las opciones para contrastes
	de distribución; entonces se registran el estadístico de prueba más su
	probabilidad asociada, y puedes recuperarlos utilizando los accesores
	<fncref targ="$test"/> y <fncref targ="$pvalue"/>. También puedes usar
	esto junto con la opción <opt>plot</opt> si únicamente quieres un
	histograma y no te interesa mirar el texto que lo acompaña.
      </para>
      <para>
	Ten en cuenta que GRETL no tiene una función que se corresponda
	con esta instrucción, pero resulta posible utilizar la función
	<fncref targ="aggregate"/> para lograr el mismo objetivo.
	Además, puedes obtener la distribución de frecuencias que se
	genera con la instrucción <lit>freq</lit>, en forma de matriz, por
	medio del accesor <fncref targ="$result"/>.
      </para>
    </description>

    <description context="gui">
      <para>
	En la caja de diálogo de gráfico de frecuencia puedes controlar las
	características del gráfico de cualquiera de estos dos modos.
      </para>
      <para>
	Primero, puedes escoger el número de intervalos. En este caso,
	se calculan automáticamente el ancho y la situación de los intervalos.
      </para>
      <para>
	Como alternativa, puedes especificar el límite inferior del intervalo
	situado más a la izquierda, y el ancho de los intervalos. En este caso, el
	número de intervalos se calcula automáticamente.
      </para>
      <para>
	Si quieres alinear los intervalos en números redondeados, aquí tienes un
	modo de proceder: comienza especificando el número de intervalos que
	quieres y echa una ojeada al gráfico que se produce. Si no es de tu
	agrado, apunta la modificación que se requiere (por ejemplo, hacer que
	el intervalo situado más a la izquierda comience en 100 e impón un ancho
	de intervalo de 200). Entonces haz una segunda prueba, especificando el
	límite izquierdo y el ancho del intervalo.
      </para>
      <para>
	Este diálogo también permite elegir una distribución teórica para representar
	frente a los datos: la Normal o la Gamma. Cuando escoges la opción Normal,
	se calcula el estadístico del contraste de Normalidad de Doornik&ndash;Hansen.
	Cuando seleccionas la opción Gamma, GRETL calcula el estadístico del contraste no
	paramétrico de Locke respecto a la hipótesis nula que sostiene que la variable
	sigue una distribución Gamma. Ten en cuenta que la forma en la que se
	indican en GRETL los parámetros de la distribución Gamma es (forma, escala).
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Distribución de frecuencias</menu-path>
    </gui-access>

  </command>

  <command name="funcerr" section="Programming"
    label="Saír ao fallar" context="cli">

    <usage>
      <arguments>
        <argument optional="true">mensaje</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Solo es aplicable en el contexto de una función definida por el usuario
	(consulta <cmdref targ="function"/>). Provoca que la ejecución de la
	función actual, finalice con la señalización de una condición de fallo.
      </para>
      <para>
	El argumento <repl>mensaje</repl> (opcional) puede tener
	la forma de una cadena de texto literal, o del nombre de una variable
	de cadena; si está presente, se presenta como parte del mensaje
	de fallo que se le muestra a quien invoca la función.
      </para>
      <para>
	Consulta también la función estrechamente vinculada,
	<fncref targ="errorif"/>.
      </para>
    </description>

  </command>

  <command name="function" section="Programming"
    label="Definir una función" context="cli">

    <usage>
      <arguments>
        <argument>nombrefunción</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Abre un bloque de expresiones en las que se define una función. Este
	bloque debe estar terminado con <lit>end function</lit>. (Como excepción
	está el caso en el que desees eliminar una función definida por el
	usuario, pues lo puedes conseguir mediante la sencilla linea de instrucción
	<lit>function foo delete</lit> para a función chamada <quote>foo</quote>.)
	Consulta <guideref targ="chap:functions"/> para obtener más detalles.
      </para>
    </description>

  </command>

  <command name="garch" section="Estimation" label="Modelo GARCH">

    <usage>
      <arguments>
        <argument>p</argument>
	      <argument>q</argument>
	      <argument separated="true">depvar</argument>
	      <argument optional="true">indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
	      </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--nc</flag>
	  <effect>Sin constante</effect>
        </option>
        <option>
	  <flag>--stdresid</flag>
	  <effect>Tipifica los errores</effect>
        </option>
        <option>
	  <flag>--fcp</flag>
	  <effect>Utiliza el algoritmo de Fiorentini, Calzolari y Panattoni</effect>
        </option>
        <option>
	  <flag>--arma-init</flag>
	  <effect>Parámetros iniciales de la varianza partiendo de ARMA</effect>
        </option>
      </options>
      <examples>
        <example>garch 1 1 ; y</example>
	<example>garch 1 1 ; y 0 x1 x2 --robust</example>
	<demos>
	  <demo>garch.inp</demo>
	  <demo>sw_ch14.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Estima un modelo GARCH (GARCH, Heterocedasticidad Condicional
	Autorregresiva Generalizada), bien en un modelo univariante o
	bien incluyendo las variables exógenas indicadas si especificas
	<repl>indepvars</repl>. Los valores enteros <repl>p</repl> y
	<repl>q</repl> (que puedes indicar en formato numérico o con
	nombres de variables escalares ya existentes) representan los
	órdenes de retardo en la ecuación de varianza condicional:
	<equation status="display"
	  tex="\[h_t = \alpha_0 + \sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} +
	  \sum_{j=1}^p \beta_j h_{t-j}\]"
	  ascii="h(t) = a(0) + sum(i=1 to q) a(i)*u(t-i)^2 + sum(j=1 to p) b(j)*h(t-j)"
	  graphic="garch_h"/>
      </para>
      <para context="cli">
	Así, el parámetro <repl>p</repl> representa el orden Generalizado
	(o <quote>AR</quote>), mientras que <repl>q</repl> representa el orden
	normal ARCH (o <quote>MA</quote>). Cuando <repl>p</repl> es no nulo,
	<repl>q</repl> también debe ser no nulo; en otro caso, el modelo no está
	identificado. Con todo, puedes estimar un modelo ARCH normal estableciendo
	que <repl>q</repl> es un valor positivo, y que <repl>p</repl> es cero.
	La suma de <repl>p</repl> y <repl>q</repl> no debe ser mayor que
	5. Ten en cuenta que se incluye automáticamente una constante en la
	ecuación media, excepto cunado indiques la opción <opt>nc</opt>.
      </para>

      <para context="gui">
	Estima un modelo GARCH (GARCH, Heterocedasticidad Condicional
	Autorregresiva Generalizada), bien en un modelo univariante o bien
	incluyendo las variables exógenas indicadas (cuando se escogen
	variables independientes). La ecuación de la varianza condicionada
	se muestra abajo.
	<equation status="display" tex="\[h_t = \alpha_0 +
  \sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} + \sum_{j=1}^p
  \beta_i h_{t-j}\]" ascii="h(t) = a(0) + sum(i=1 to q) a(i)*u(t-i) +
  sum(j=1 to p) b(j)*h(t-j)" graphic="garch_h"/>
      </para>
      <para context="gui">
	Así, el parámetro <repl>p</repl> representa el orden Generalizado
	(o <quote>AR</quote>), mientras que <repl>q</repl> representa el orden
	normal ARCH (o <quote>MA</quote>). Cuando <repl>p</repl> es no nulo,
	<repl>q</repl> también debe ser no nulo; en otro caso, el modelo no está
	identificado. Con todo, puedes estimar un modelo ARCH normal estableciendo
	que <repl>q</repl> es un valor positivo, y que <repl>p</repl> es cero.
	La suma de <repl>p</repl> y <repl>q</repl> no debe ser mayor que
	5.
      </para>

      <para>
	Por defecto, se utiliza el propio código de GRETL para estimar los
	modelos GARCH, pero también tienes la opción de usar el algoritmo de
	<cite key="fiorentini96">Fiorentini, Calzolari y Panattoni (1996)</cite>.
	El primero utiliza el maximizador BFGS mientras que el último usa
	la matriz de información para maximizar la verosimilitud, con una
	puesta a punto mediante la matriz Hessiana.
      </para>

      <para context="cli">
	Con esta instrucción dispones de diversas variantes de la matriz
	estimada de las covarianzas de los estimadores. Por defecto, se usa
	la matriz Hessiana excepto que indiques la opción <opt>robust</opt>,
	en cuyo caso se va a usar la matriz de covarianzas CMV (QML de White).
	También se pueden especificar otras posibilidades (&eg; la matriz
	de información o el estimador de Bollerslev&ndash;Wooldridge)
	mediante la clave <lit>garch_vcv</lit> bajo la instrucción
	<cmdref targ="set"/>.
      </para>

      <para context="gui">
	Con esta instrucción dispones de diversas variantes de la matriz estimada
	de las covarianzas dos estimadores. Por defecto, se utiliza la
	matriz Hessiana excepto que marques el cuadradito
	<quote>Desviaciones típicas robustas</quote>, en cuyo caso se va a
	usar la matriz de covarianzas CMV (QML de White). También puedes
	especificar otras posibilidades (&eg; la matriz de información
	o el estimador de Bollerslev&ndash;Wooldridge) utilizando la
	instrucción <cmdref targ="set"/>.
      </para>

      <para context="gui">
	Puedes acceder a la varianza condicionada estimada, así como a los
	errores y a otros estadísticos del modelo, y añadirlos al
	conjunto de datos utilizando el menú <quote>Guardar</quote> de la
	ventana donde se presenta el modelo. Si marcas el cuadradito titulado
	<quote>Estandarizar los residuos</quote>, se dividen los errores por la
	raíz cuadrada de la varianza condicionada.
      </para>

      <para context="cli">
	Por defecto, las estimaciones de los parámetros de la varianza se inician
	usando la varianza de la perturbación no condicionada de una estimación
	inicial por MCO (para la constante) y valores positivos pequeños
	(para los coeficientes que acompañan a los valores pasados tanto de las
	perturbaciones cuadradas como de la varianza de la perturbación). La opción
	<opt>arma-init</opt> solicita que, para establecer los valores
	iniciales de estos parámetros, se utilice un modelo inicial ARMA,
	explotando la relación entre GARCH y ARMA expuesta en el capítulo 21
	del libro <book>Time Series Analysis</book> de Hamilton. En algunos
	casos, esto puede mejorar las posibilidades de convergencia.
      </para>

      <para context="cli">
	Puedes recuperar los errores GARCH y la varianza condicionada estimada
	con <lit>$uhat</lit> y <lit>$h</lit>, respectivamente. Por ejemplo,
	para obtener la varianza condicional:
      </para>
      <code context="cli">
	series ht = $h
      </code>
      <para context="cli">
	Cuando indicas la opción <opt>stdresid</opt>, se dividen los valores de
	<lit>$uhat</lit> por la raíz cuadrada de <math>h</math><sub>t</sub>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelo/Series temporales univariantes/GARCH</menu-path>
    </gui-access>

  </command>

  <command name="genr" section="Dataset"
    label="Generar una nueva variable">

    <usage>
      <arguments>
        <argument>nuevavariable</argument>
        <argument>= fórmula</argument>
      </arguments>
    </usage>

    <description>

      <para>
	NOTA: Esta instrucción experimentó numerosos cambios y mejoras
	desde que se escribió el siguiente texto de ayuda, por eso para
	comprender y actualizar la información sobre esta instrucción, deberás
	seguir la referencia de <guideref targ="chap:genr"/>. Por otro lado,
	esta ayuda no contiene nada actualmente incorrecto, por lo que interpreta
	lo que sigue como <quote>tienes esto, y más</quote>.
      </para>

      <para context="cli">
	Para esta instrucción y en el contexto apropiado, las expresiones
	<lit>series</lit>, <lit>scalar</lit>, <lit>matrix</lit>,
	<lit>string</lit>, <lit>bundle</lit> y <lit>array</lit> son
	sinónimos.
      </para>

      <para context="cli">
	Genera nuevas variables, habitualmente mediante transformaciones de las
	variables ya existentes. Consulta también <cmdref targ="diff"/>,
	<cmdref targ="logs"/>, <cmdref targ="lags"/>, <cmdref targ="ldiff"/>,
	<cmdref targ="sdiff"/> y <cmdref targ="square"/> como atajos.
	En el contexto de una fórmula <lit>genr</lit>, debes hacer referencia
	a las variables ya existentes mediante su nombre, no con su número ID.
	La fórmula debe ser una combinación bien hecha de nombres de
	variables, constantes, operadores y funciones (descrito más
	abajo). Ten en cuenta que puedes encontrar más detalles sobre
	algunos aspectos de esta instrucción en <guideref targ="chap:genr"/>.
      </para>

      <para context="gui">
	Utiliza esta caja para definir una nueva variable, con el patrón
	<repl>nuevavariable</repl> = <repl>fórmula</repl>. La fórmula debe
	ser una combinación bien hecha de nombres de variables, constantes,
	operadores y funciones (detalles más abajo). Para asegurarte
	de que obtienes el tipo de variable que quieres, puedes preceder la
	fórmula con un tipo de nombre (&eg; <lit>scalar</lit>, <lit>series</lit>
	o <lit>matrix</lit>). Por ejemplo, para generar una serie que
	tenga un valor constante igual a 10, puedes escribir
      </para>
      <code context="gui">
	series c = 10
      </code>
      <para context="gui">
	(en otro caso, <lit>c = 10</lit> generaría una variable escalar).
      </para>

      <para context="cli">
	Una instrucción <lit>genr</lit> puede producir un resultado escalar o
	una serie. Por ejemplo, la fórmula <lit>x2 = x * 2</lit> naturalmente
	produce una serie cuando la variable <lit>x</lit> es una serie, y un
	escalar cuando <lit>x</lit> es un escalar. Las fórmulas <lit>x = 0</lit> y
	<lit>mx = mean(x)</lit> naturalmente devuelven escalares. Bajo ciertas
	circunstancias, puedes querer tener un resultado escalar ampliado a una
	serie o vector; esto puedes hacerlo utilizando <lit>series</lit> como
	un <quote>alias</quote> para la instrucción <lit>genr</lit>. Por
	ejemplo, <lit>series x = 0</lit> produce una serie en la que todos
	sus valores se ponen a 0. También puedes utilizar <lit>scalar</lit> como
	alias de <lit>genr</lit>. No es posible forzar a un resultado en forma
	de vector que sea un escalar, pero la utilización de esta palabra clave
	indica que el resultado <emphasis>debiera de ser</emphasis> un escalar:
	si no lo es, aparece un fallo.
      </para>

      <para context="cli">
	Cuando una fórmula produce un resultado en forma de serie, el rango
	sobre el que se escribe ese resultado en la variable objetivo depende
	de la configuración vigente de la muestra. Por lo tanto, puedes definir una
	serie hecha a trozos utilizando la instrucción <lit>smpl</lit> junto con
	<lit>genr</lit>.
      </para>

      <para>
	Se admiten los <emphasis>operadores aritméticos</emphasis>,
	en orden de prioridad: <lit>^</lit> (elevar a la potencia);
	<lit>*</lit>, <lit>/</lit> y <lit>%</lit> (módulo o resto);
	<lit>+</lit> y <lit>-</lit>.
      </para>

      <para>
	Los <emphasis>operadores booleanos </emphasis> disponibles son
	(de nuevo, en orden de prioridad): <lit>!</lit> (negación),
	<lit>&amp;&amp;</lit> (Y lógico), <lit>||</lit> (O lógico),
	<lit>&gt;</lit>, <lit>&lt;</lit>, <lit>==</lit> (igual a),
	<lit>&gt;=</lit> (mayor o igual que), <lit>&lt;=</lit> (menor o igual que)
	y <lit>!=</lit> (no igual). También puedes utilizar los operadores
	booleanos en la construcción de variables ficticias: por ejemplo,
	<lit>(x &gt; 10)</lit> devuelve 1 en caso de que <lit>x</lit> &gt; 10,
	y 0 en otro caso.
      </para>

      <para>
	Las constantes integradas son <lit>pi</lit> y <lit>NA</lit>. La última
	es el código de valor ausente: puedes iniciar una variable con el valor
	ausente mediante <lit>scalar x = NA</lit>.
      </para>

      <para>
	La instrucción <lit>genr</lit> admite un amplio rango de funciones
	matemáticas y estadísticas, incluyendo todas las habituales más
	varias que son especiales de Econometría. Además, ofrece acceso
	a muchas variables internas que se definen durante la ejecución
	de las regresiones, la realización de contrastes de hipótesis, etcétera.
	<refnote xref="false">
	  Para obtener un listado de funciones y accesores, escribe
	  <quote>help functions</quote>.
	</refnote>
	<refnote xref="true">
	  Para ver un listado de funciones y accesores, consulta
	  <gfr targ="chap:funcref"/>.
	</refnote>
      </para>

      <para>
	Además de los operadores y de las funciones indicados arriba, hay
	algunos usos especiales de <cmd>genr</cmd>:
      </para>

      <ilist>
	<li>
	    <para>
	    <cmd>genr time</cmd> genera una variable de tendencia temporal
	    (1,2,3,&hellip;) llamada <cmd>time</cmd>. Y <cmd>genr index</cmd>
	    tiene el mismo efecto, salvo que la variable se llama <lit>index</lit>.
	    </para>
	</li>
	<li>
	    <para>
	    <cmd>genr dummy</cmd> genera tantas variables ficticias como
	    sea la periodicidad de los datos. En caso de tener datos
	    trimestrales (periodicidad 4), el programa genera <lit>dq1</lit> = 1
	    para el primer trimestre y 0 para los otros trimestres,
	    <lit>dq2</lit> = 1 para el segundo trimestre y 0 para los otros
	    trimestres, etcétera. Con datos mensuales, las variables ficticias
	    se nombran <lit>dm1</lit>, <lit>dm2</lit>, etcétera; con datos
	    diarios, se nombran <lit>dd1</lit>, <lit>dd2</lit>, etcétera;
	    y con otras frecuencias, los nombres son <lit>dummy_1</lit>,
	    <lit>dummy_2</lit>, etc.
	    </para>
	</li>
	<li>
	  <para>
	    <cmd>genr unitdum</cmd> y <cmd>genr timedum</cmd> generan conjuntos
	    de variables ficticias especiales para utilizar con datos de panel,
	    codificando las unidades de sección cruzada con la primera, y el período
	    de tiempo de las observaciones con la segunda.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Advertencia</emphasis>: Con el programa en líneas de instrucción,
	las instrucciones <cmd>genr</cmd> que recuperan datos relacionados con un
	modelo, siempre se refieren al modelo que se estimó más recientemente.
	Esto también es cierto en el programa de Interfaz Gráfica de Usuario (GUI),
	cuando utilizas <cmd>genr</cmd> en la <quote>consola de GRETL</quote>o si
	introduces una fórmula usando la opción <quote>Definir nueva variable</quote>
	bajo el menú Añadir en la ventana principal. Con la GUI, sin embargo, tienes la opción
	de recuperar datos de cualquiera de los modelos que se muestran en ese momento
	en una ventana (sea o no sea el modelo estimado más recientemente).
	Puedes hacer esto bajo el menú <quote>Guardar</quote> de la ventana del
	modelo correspondiente.
      </para>

      <para>
	La variable especial <lit>obs</lit> sirve como índice para las observaciones.
	Por ejemplo, <lit>series dum = (obs==15)</lit> genera una variable
	ficticia que tiene valor 1 para la observación 15, y el valor 0 en otro caso.
	También puedes usar esta variable para escoger observaciones concretas
	por fecha o nombre. Por ejemplo, <lit>series d = (obs&gt;1986:4)</lit>,
	<lit>series d = (obs&gt;"2008-04-01")</lit>, o
	<lit>series d = (obs=="CA")</lit>. Cuando utilizas fechas diarias o
	marcadores de observación en este contexto, debes ponerlas entre
	comillas, pero puedes usar las fechas trimestrales y mensuales (con dos
	puntos) sin comillas. Ten en cuenta que, en caso de datos de series
	temporales anuales, el año no se distingue sintácticamente de un sencillo
	número entero. Por lo tanto, si quieres comparar observaciones frente a
	<lit>obs</lit> por año, debes usar la función <lit>obsnum</lit> para
	convertir así el año en un valor índice en base 1, como se hace en
	<lit>series d = (obs&gt;obsnum(1986))</lit>.
      </para>

      <para>
	Puedes sacar los valores escalares de una serie en el contexto de una
	fórmula <lit>genr</lit>, utilizando la sintaxis
	<repl>varname</repl><lit>[</lit><repl>obs</repl><lit>]</lit> en la que
	puedes indicar el valor <repl>obs</repl> por número o fecha. Ejemplos:
	<lit>x[5]</lit>, <lit>CPI[1996:01]</lit>. Para datos diarios, debes
	usar la forma <repl>YYYY-MM-DD</repl>; &eg; <lit>ibm[1970-01-23]</lit>.
      </para>

      <para>
	Puedes modificar una observación individual de una serie mediante
	<lit>genr</lit>. Para hacer esto, debes añadir un número válido de
	observación o de fecha, entre corchetes, al nombre de la variable
	en el lado izquierdo de la fórmula. Por ejemplo, <lit>genr x[3] = 30</lit>
	o <lit>genr x[1950:04] = 303.7</lit>.
      </para>

      <table id="tab-genr" title="Ejemplos de uso de la instrucción genr"
  lhead="Fórmula" rhead="Comentario" lwidth="100pt" rwidth="300pt"
  style="rpara">
	<row>
	  <cell><lit>y = x1^3</lit></cell>
	  <cell><lit>x1</lit> al cubo</cell>
	</row>
	<row>
	  <cell><lit>y = ln((x1+x2)/x3)</lit></cell>
	  <cell/>
	</row>
	<row>
	  <cell><lit>z = x&gt;y</lit></cell>
	  <cell><lit>z(t)</lit> = 1 si <lit>x(t) &gt; y(t)</lit>,
	    en otro caso 0</cell>
	</row>
	<row>
	  <cell><lit>y = x(-2)</lit></cell>
	  <cell><lit>x</lit> retardada 2 períodos</cell>
	</row>
	<row>
	  <cell><lit>y = x(+2)</lit></cell>
	  <cell><lit>x</lit> adelantada 2 períodos</cell>
	</row>
	<row>
	  <cell><lit>y = diff(x)</lit></cell>
	  <cell><lit>y(t) = x(t) - x(t-1)</lit></cell>
	</row>
	<row>
	  <cell><lit>y = ldiff(x)</lit></cell>
	  <cell><lit>y(t) = log x(t) - log x(t-1)</lit>, la tasa
	    de crecimiento instantáneo de <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sort(x)</lit></cell>
	  <cell>Ordena <lit>x</lit> en orden ascendente y lo guarda en
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = dsort(x)</lit></cell>
	  <cell>Ordena <lit>x</lit> en orden descendente</cell>
	</row>
	<row>
	  <cell><lit>y = int(x)</lit></cell>
	  <cell>Trunca <lit>x</lit> y guarda su valor entero como
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = abs(x)</lit></cell>
	  <cell>Guarda los valores absolutos de <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sum(x)</lit></cell>
	  <cell>Suma los valores de <lit>x</lit> excluyendo las entradas
	  ausentes <lit>NA</lit></cell>
	</row>
	<row>
	  <cell><lit>y = cum(x)</lit></cell>
	  <cell>Acumulación:
		<equation status="inline"
		  tex="$y_t = \sum_{\tau=1}^t x_{\tau}$"
		  ascii="y(t) = suma desde s=1 hasta s=t de x(s)"
		  graphic="cumulate"/>
	  </cell>
	</row>
	<row>
	  <cell><lit>aa = $ess</lit></cell>
	  <cell>Establece <lit>aa</lit> igual a la Suma de Errores Cuadrados
	    de la última regresión</cell>
	</row>
	<row>
	  <cell><lit>x = $coeff(sqft)</lit></cell>
	  <cell>Recoge el coeficiente estimado de la variable
	    <lit>sqft</lit> de la última regresión</cell>
	</row>
	<row>
	  <cell><lit>rho4 = $rho(4)</lit></cell>
	  <cell>Recoge el coeficiente autorregresivo de orden 4 del
	    último modelo (asume un modelo <lit>ar</lit>)</cell>
	</row>
	<row>
	  <cell><lit>cvx1x2 = $vcv(x1, x2)</lit></cell>
	  <cell>Recoge la covarianza estimada de los coeficientes de las
	    variables <lit>x1</lit> y <lit>x2</lit> del último modelo</cell>
	</row>
	<row>
	  <cell><lit>foo = uniform()</lit></cell>
	  <cell>Variable pseudoaleatoria Uniforme en el rango
	    0&ndash;1</cell>
	</row>
	<row>
	  <cell><lit>bar = 3 * normal()</lit></cell>
	  <cell>Variable pseudoaleatoria Normal, &mu; = 0, &sigma; =
	    3</cell>
	</row>
	<row>
	  <cell><lit>samp = ok(x)</lit></cell>
	  <cell>= 1 para las observaciones donde <lit>x</lit> no está
	    ausente</cell>
	</row>
      </table>

    </description>

    <gui-access>
      <menu-path>/Añadir/Definir nueva variable</menu-path>
      <other-access>Ventana principal: Menú emergente</other-access>
    </gui-access>

  </command>

  <command name="genrand" section="Programming" context="gui"
    label="Generar variables aleatorias">

    <description>
      <para>
	En este diálogo debes indicar un nombre para la variable que se va a
	generar, más alguna información adicional dependiendo del tipo de
	distribución.
      </para>

      <ilist>
	<li>
	    <para>
	    Uniforme: Los límites inferior y superior de la distribución.
	    </para>
	</li>
	<li>
	    <para>
	    Normal: La media y la desviación típica (positiva).
	    </para>
	</li>
	<li>
	    <para>
	    Chi-cuadrado y t de Student: Los grados de libertad (que deben
	    ser positivos).
	    </para>
	</li>
	<li>
	    <para>
	    F: Los grados de libertad tanto del numerador como del denominador.
	    </para>
	</li>
	<li>
	    <para>
	    Gamma: Los parámetros de forma y de escala (ambos positivos).
	    </para>
	</li>
	<li>
	    <para>
	    Binomial: La probabilidad de <quote>éxito</quote> y un entero con
	    el número de intentos.
	  </para>
	</li>
	<li>
	  <para>
	    Poisson: La media positiva (que también es igual a la varianza).
	  </para>
	</li>
      </ilist>

      <para>
	Si quieres generar secuencias repetibles de números pseudoaleatorios,
	puedes establecer la semilla mediante el elemento
	<mnu targ="SetSeed">Semilla para los números aleatorios</mnu>,
	en el menú Herramientas.
      </para>

    </description>
  </command>

  <command name="genseed" section="Programming" context="gui"
    label="Establecer la semilla para números aleatorios">

    <description>
      <para>
	La 'semilla' controla el punto de inicio para la secuencia de números
	pseudoaleatorios generados en una sesión determinada de GRETL. Por defecto,
	la semilla se establece cuando se inicia el programa, utilizando el
	reloj del sistema. Esto te asegura que obtienes una secuencia distinta
	de números aleatorios cada vez que ejecutas el programa. Si quieres
	obtener secuencias repetibles, necesitas establecer la semilla de forma
	manual (y tomar nota del valor que utilizas).
      </para>
      <para>
	Ten en cuenta que siempre que pulsas un clic 'OK' en esta caja de
	diálogo, el generador se vuelve a reiniciar utilizando la semilla indicada.
	Así, por ejemplo, si (a) estableces la semilla en (digamos) 147;
	(b) generas una serie con distribución Normal estándar; (c) vuelves a
	visitar este diálogo y pulsas un clic 'OK' de nuevo con la semilla
	aún en 147; y (d) generas una segunda serie con distribución
	Normal estándar, las dos series generadas serán idénticas.
      </para>
    </description>
  </command>

  <command name="gmm" section="Estimation" label="Estimación MGM (GMM)">

    <usage>
      <options>
	<option>
	  <flag>--two-step</flag>
	  <effect>Estimación en 2 etapas</effect>
	</option>
	<option>
	  <flag>--iterate</flag>
	  <effect>GMM iterados</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
	</option>
	<option>
	  <flag>--lbfgs</flag>
	  <effect>Utiliza L-BFGS-B en lugar del BFGS normal</effect>
	</option>
      </options>
	<examples>
     <demos>
	  <demo>hall_cbapm.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Realiza la estimación con el Método Generalizado de los Momentos (MGM o GMM)
	utilizando el algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno).
	Debes especificar: (a) una o más instrucciones para actualizar las
	cantidades relevantes (típicamente errores GMM), (b) uno o más conjuntos
	de condiciones de ortogonalidad, (c) una matriz inicial de ponderaciones,
	y (d) un listado con los parámetros a estimar, todo puesto entre
	las etiquetas <lit>gmm</lit> y <lit>end gmm</lit>. Cualquier opción
	deberá añadirse a la línea <lit>end gmm</lit>.
      </para>
      <para>
	Consulta <guideref targ="chap:gmm"/> para obtener más detalles sobre
	esta instrucción. Aquí simplemente lo ilustramos con un ejemplo sencillo.
      </para>
      <code>
	gmm e = y - X*b
	  orthog e ; W
	  weights V
	  params b
	end gmm
      </code>
      <para>
	En el ejemplo de arriba, asumimos que tanto <lit>y</lit> como <lit>X</lit> son
	matrices de datos, <lit>b</lit> es un vector de valores de los parámetros
	con la dimensión adecuada, <lit>W</lit> es una matriz de instrumentos, y
	<lit>V</lit> es una matriz adecuada de ponderaciones. La expresión
      </para>
      <code>
	orthog e ; W
      </code>
      <para>
	indica que el vector de errores (<lit>e</lit>) es ortogonal, en principio,
	a cada uno de los instrumentos que constituyen las columnas de
	<lit>W</lit>.
      </para>
      <subhead>Nombres de los parámetros</subhead>
      <para>
	Al estimar un modelo no lineal, frecuentemente resulta conveniente
	que nombres los parámetros de modo conciso. Al presentar los resultados,
	sin embargo, puede que desees utilizar etiquetas más informativas. Puedes
	lograr esto mediante la palabra clave adicional <lit>param_names</lit>
	dentro del bloque de instrucción. Para un modelo con <math>k</math>
	parámetros, el argumento que sigue a esta palabra clave debe ser,
	una cadena de texto literal entre comillas que contenga <math>k</math>
	nombres separados por espacios, el nombre de una variable de cadena
	que contenga <math>k</math> de esos nombres, o el nombre de un array
	con <math>k</math> cadenas de texto.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Variables instrumentales/GMM</menu-path>
    </gui-access>

  </command>

  <command name="gnuplot" section="Graphs"
    label="Generar un gráfico Gnuplot" context="cli">

    <usage>
      <altforms>
        <altform><lit>gnuplot</lit> <repl>yvars</repl> <repl>xvar</repl></altform>
        <altform><lit>gnuplot</lit> <repl>yvars</repl> <lit>--time-series</lit></altform>
        <altform><lit>gnuplot</lit> <repl>yvars</repl> <repl>xvar</repl> <repl>factor</repl> <lit>--factorized</lit></altform>
        <altform><lit>gnuplot</lit> <repl>yvar</repl> <repl>xvar</repl> <repl>zvars</repl> <lit>--control</lit></altform>
      </altforms>
      <options>
        <option>
	  <flag>--with-lines</flag>
	  <optparm optional="true">varspec</optparm>
	  <effect>Utiliza líneas, no puntos</effect>
        </option>
        <option>
	  <flag>--with-lp</flag>
	  <optparm optional="true">varspec</optparm>
	  <effect>Utiliza líneas y puntos</effect>
        </option>
        <option>
	  <flag>--with-impulses</flag>
	  <optparm optional="true">varspec</optparm>
	  <effect>Utiliza barras finas verticales</effect>
        </option>
        <option>
	  <flag>--with-steps</flag>
	  <optparm optional="true">varspec</optparm>
	  <effect>Utiliza segmentos de líneas perpendiculares</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>Representa frente al tiempo</effect>
        </option>
        <option>
	  <flag>--single-yaxis</flag>
	  <effect>Fuerza el uso de un único eje de ordenadas</effect>
        </option>
        <option>
	  <flag>--y2axis</flag>
	  <optparm>yvar</optparm>
	  <effect>Coloca la variable especificada en un segundo eje y</effect>
        </option>
        <option>
	  <flag>--ylogscale</flag>
	  <optparm optional="true">base</optparm>
	  <effect>Utiliza la escala logarítmica para el eje vertical</effect>
        </option>
        <option>
	  <flag>--control</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--factorized</flag>
          <optparm optional="true">lista</optparm>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--fit</flag>
	  <optparm>espajuste</optparm>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--font</flag>
	  <optparm>espfuente</optparm>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--band</flag>
	  <optparm>espfranja</optparm>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nombrematriz</optparm>
	  <effect>Representa las columnas de la matriz indicada</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el resultado al archivo especificado</effect>
        </option>
        <option>
	  <flag>--outbuf</flag>
	  <optparm>nombrecadena</optparm>
	  <effect>Envía el resultado a la cadena de texto especificada</effect>
        </option>
        <option>
	  <flag>--input</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Coge la entrada de datos desde un archivo especificado</effect>
        </option>
        <option>
	  <flag>--inbuf</flag>
	  <optparm>nombrecadena</optparm>
	  <effect>Coge la entrada de datos desde la cadena de texto especificada</effect>
        </option>
      </options>
      <examples>
        <example>gnuplot y1 y2 x</example>
        <example>gnuplot x --time-series --with-lines</example>
	<example>gnuplot wages educ gender --factorized</example>
	<example>gnuplot y x --fit=quadratic</example>
	<example>gnuplot y1 y2 x --with-lines=y2</example>
      </examples>
    </usage>

    <description>
      <para>
	Las series de la lista <repl>yvars</repl> se dibujan frente a
	<repl>xvar</repl>. Para un gráfico de una serie temporal puedes
	bien proponer <lit>time</lit> en lugar de <repl>xvar</repl>, o bien
	utilizar el indicador de opción <opt>time-series</opt>. Consulta
	también las instrucciones<cmdref targ="plot"/> y <cmdref targ="panplot"/>.
      </para>
      <para>
	Por defecto, las posiciones de los datos se muestran con puntos,
	pero puedes anular esto indicando una de las siguientes opciones:
	<opt>with-lines</opt> (líneas y puntos), <opt>with-lp</opt>,
	<opt>with-impulses</opt> o <opt>with-steps</opt>. Cuando vas a
	representar más de una variable en el eje de la <math>y</math>, puedes
	limitar el efecto de estas opciones a un subconjunto de las variables
	usando el parámetro <repl>varspec</repl>. Este deberá tener el formato
	bien de un listado con los nombres o números (en ambos casos separados
	por comas) de las variables que se van a representar del modo indicado,
	o bien del nombre de una lista predefinida. Pongamos por caso, en el
	último ejemplo de arriba se muestra como representar <lit>y1</lit> e
	<lit>y2</lit> frente a <lit>x</lit>, de tal modo que <lit>y2</lit> se
	representa con una línea mientras <lit>y1</lit> con puntos.
      </para>
      <para>
	Cuando <repl>yvars</repl> contiene más de una variable, podría ser
	preferible utilizar dos ejes y (a la izquierda y a la derecha). Por defecto,
	esto se realiza automáticamente, mediante una técnica heurística basada
	en las escalas relativas de las variables; pero puedes utilizar dos
	opciones (mutuamente excluyentes) para anular lo predeterminado:
	<opt>single-yaxis</opt> evita el uso de un segundo eje, mientras que
	<opt>y2axis=</opt><repl>yvar</repl> especifica que se represente una
	cierta variable (únicamente) en relación al segundo eje.
      </para>
	      <subhead>Gráficas factorizadas</subhead>
      <para>
	La opción <opt>factorized</opt> apoya al gráfico X&ndash;Y en el que
	<repl>yvars</repl> se dibujan con distintos estilos (tipo de punto, color)
	dependiendo del valor de una variable factorial discreta en cada
	observación. El factor se debe especificar siguiendo la variable
	<math>x</math>.
      </para>
      <para>
	El caso más simple representa una única variable <math>y</math>
	con una variable ficticia de tipo 0/1 como factor, como en el tercer
	ejemplo de utilización indicado arriba que representa el salario (wage)
	frente a la educación, factorizado por el género (gender). Pero puedes
	tener más de una variable <math>y</math>, y el factor puede tener más
	de dos valores. Cuando se van a representar múltiples variables
	<math>y</math>, puedes restringir el tratamiento de factorización
	a un subconjunto añadiendo un parámetro al indicador de opciones:
	el nombre de una serie o de una lista de series. En el siguiente ejemplo
	<lit>y</lit> e <lit>yhat</lit> se representan frente a <lit>x</lit>,
	con factorización mediante <lit>id</lit> limitada a
	<lit>y</lit>.
      </para>
      <code>
	gnuplot y yhat x id --with-lines=yhat --factorized=y
      </code>
      <subhead>Gráfico con control</subhead>
      <para>
	Cuando se especifica la opción <opt>control</opt>, deben indicarse
	tres o más variables: una única variable <math>y</math>, una
	única variable <math>x</math>, y una o más variables de control,
	<repl>zvars</repl>. El  efecto de esto es que tanto <math>y</math> como
	<math>x</math> se van a regresar cada una sobre <repl>zvars</repl>,
	y los errores de <math>y</math> se representan contra los errores de
	<math>x</math>. Este gráfico muestra la relación entre <math>x</math>
	e <math>y</math> teniendo en cuenta el efecto que los controles tienen
	sobre las dos.
      </para>
      <subhead>Escala logarítmica</subhead>
      <para>
	Puedes especificar que la escala del eje <math>y</math> sea logarítmica
	en lugar de que sea lineal, utilizando la opción <opt>ylogscale</opt>,
	junto con un parámetro de base.
	Por ejemplo,
      </para>
      <code>
	gnuplot y x --ylogscale=2
      </code>
      <para>
	representa los datos de modo que el eje vertical se expresa con potencias
	de 2. Si no especificas la base, por defecto, se establece igual a 10.
      </para>
      <subhead>Cogiendo datos de una matriz</subhead>
      <para>
	En el caso básico se requieren los argumentos <repl>yvars</repl> y
	<repl>xvar</repl> que se refieren a series del conjunto vigente de datos
	(indicados por el nombre o por el número ID). Pero si mediante la
	opción <opt>matrix</opt>, indicas una matriz ya definida, estos
	argumentos se convierten en opcionales: si la matriz especificada
	tiene <math>k</math> columnas, por defecto se tratan las primeras
	<math>k</math> &minus; 1 columnas como las <repl>yvars</repl> y la
	última columna se trata como <repl>xvar</repl>. Sin embargo, cuando
	indicas la opción <opt>time-series</opt>, todas las <math>k</math>
	columnas se representan frente al tiempo. Si quieres representar columnas
	escogidas de la matriz, debes especificar <repl>yvars</repl>
	y <repl>xvar</repl> con el formato de números de columna enteros
	positivos. Por ejemplo, si quieres un gráfico de dispersión de la
	columna 2 de la matriz <lit>M</lit> frente a la columna 1, puedes hacer:
      </para>
      <code>
	gnuplot 2 1 --matrix=M
      </code>
      <subhead>Mostrar la línea del mejor ajuste</subhead>
      <para>
	La opción <opt>fit</opt> es solo aplicable en gráficos de dispersión de dos
	variables y en gráficos de series temporales individuales. Por defecto, el
	procedimiento en un gráfico de dispersión consiste en mostrar el ajuste MCO si
	el coeficiente de la pendiente es significativo a un nivel del 10 por ciento,
	mientras que el proceder para las series temporales es no mostrar ninguna
	línea de ajuste. Puedes solicitar un comportamiento diferente utilizando
	esta opción junto con alguno de los siguientes valores de los parámetros
	<repl>espajuste</repl>. Ten en cuenta que si el gráfico es para una serie
	temporal individual, el lugar de <math>x</math> lo ocupa 'time'.
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>linear</lit>: Muestra el ajuste MCO lineal independientemente
	    del nivel de significación estadística.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>none</lit>: No muestra ninguna línea de ajuste.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>inverse</lit> (inversa), <lit>quadratic</lit> (cuadrática),
	    <lit>cubic</lit> (cúbica), <lit>semilog</lit> o <lit>linlog</lit>:
	    Muestran una línea de ajuste basada en la regresión del tipo indicado.
	    Con <lit>semilog</lit> queremos decir una regresión del logaritmo de
	    <math>y</math> sobre <math>x</math>; entonces la línea ajustada
	    representa la esperanza condicionada de <math>y</math>, obtenida por
	    medio de la función exponencial. Con <lit>linlog</lit> se quiere decir
	    una regresión de <math>y</math> sobre el logaritmo de <math>x</math>.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>loess</lit>: Muestra el ajuste de una regresión robusta
	    localmente ponderada (que también se conoce a veces como
	    <quote>lowess</quote>).
	  </para>
	</li>
      </ilist>
      <subhead>Representando una franja</subhead>
      <para>
	Puedes utilizar la opción <opt>band</opt> para representar una
	<quote>franja</quote> de algún tipo (típicamente representa un intervalo
	de confianza) junto con otros datos. El modo recomendado de especificar
	esa franja es mediante un ‘bundle', cuyo nombre se indica como
	parámetro de esa opción. Un paquete <lit>band</lit> requiere dos
	elementos que son necesarios: una clave <lit>center</lit>, el nombre
	de una serie para el centro de la franja; y una clave <lit>width</lit>,
	el nombre de una serie que represente el ancho de la franja (ambos
	indicados como cadenas de texto entre comillas). Además, se admiten
	otros cuatro elementos opcionales, del modo que se indica a continuación.
      </para>
      <ilist>
	<li>
	  <para>En la clave <lit>factor</lit>: un escalar que indica el factor
	  por el que se debe multiplicar el ancho (siendo 1 el valor por
	  defecto).
	  </para>
	</li>
	<li>
	  <para>En la clave <lit>style</lit> : una cadena de texto para
	  especificar cómo se representa la franja; y que debe ser una de entre
	  <lit>line</lit> (línea, predeterminada), <lit>fill</lit> (relleno),
	  <lit>dash</lit> (raya), <lit>bars</lit> (barra) o <lit>step</lit> (escalón).
	  </para>
	</li>
	<li>
	  <para>En la clave <lit>color</lit>: un color para la franja, como una
	  cadena de texto que contenga el nombre de un color de Gnuplot, o
	  como una representación de RGB en hexadecimal, indicada como cadena
	  de texto o como escalar (mira más abajo para obtener más detalles).
	  Por defecto, el color se selecciona automáticamente.
	  </para>
	</li>
	<li>
	  <para>En la clave <lit>title</lit>: un título para la franja, para que
	  aparezca en la clave o leyenda del gráfico. Por defecto, las franjas
	  no tienen título.
	  </para>
	</li>
      </ilist>
      <para>
	Aquí tienes dos ejemplos de uso, en los que se emplea la sintaxis abreviada
	<lit>_()</lit> para definir un 'bundle'. El primero únicamente satisface
	los requerimientos mínimos, mientras que en el segundo se practican las
	tres opciones. Se está asumiendo que todas as series <lit>y</lit>,
	<lit>x</lit> y <lit>w</lit> están en el conjunto de datos vigente.
      </para>
      <code>
	bundle b1 = _(center="x", width="w")
	gnuplot y --time-series --with-lines --band=b1
	bundle b2 = _(center="x", width="w", factor=1.96, style="fill")
	b2.color=0xcccccc
	b2.title = "Intervalo del 95%"
	gnuplot y --time-series --with-lines --band=b2
      </code>
      <para>
	Si el gráfico va a contener dos o más de esas bandas, el indicador de
	opción se debe expresar en plural, y su parámetro debe ser el nombre
	de un <emphasis>array</emphasis> de paquetes (bundles), como
	(continuando el ejemplo anterior) en lo que sigue:
      </para>
      <code>
	bundles bb = defarray(b1, b2)
	gnuplot y --time-series --with-lines --bands=bb
      </code>
      <para>
	Cuando se representa gráficamente una matriz, en lugar de datos de
	series, la única diferencia es que los elementos <lit>centro</lit> (center)
	y <lit>ancho</lit> (width) del ‘bundle’ de la franja se sustituyen por un
	único elemento en la clave <lit>bandmat</lit>. Este tiene que indicar una
	matriz con dos columnas, con el centro de banda en la primera columna
	y el ancho en la segunda. Como alternativa, puedes indicar una cadena de
	texto bajo esta clave: el <i>nombre entre comillas</i> de una matriz
	adecuada. Esta variante puede ser preferible si la matriz en cuestión
	se va a reutilizar con distintos valores del factor, dado que evita tener
	que duplicar la matriz en la memoria.
      </para>
      <subhead>Barras de recesión</subhead>
      <para>
	También puedes utilizar la opción <quote>band</quote> para añadir
	<quote>barras de recesión</quote> a un gráfico. De este modo nos referimos
	a barras verticales que ocupan todo el rango de la dimensión <math>y</math>
	del gráfico, y que indican la presencia (con barra) o ausencia (sin barra)
	de alguna característica cualitativa, en un gráfico de series de tiempo.
	Estas barras habitualmente se utilizan para indicar períodos de recesión;
	pero también puedes usarlas para señalar períodos de guerra, o cualquier
	cosa que pueda codificarse con una variable ficticia 0/1.
      </para>
      <para>
	En este contexto, la opción <opt>band</opt> requiere un único parámetro:
	en la clave <lit>dummy</lit>, un nombre entre comillas de una serie 0/1
	(o el nombre entre comillas de un vector columna adecuado, en caso de una
	matriz de datos). Las barras verticales estarán <quote>activas</quote>
	para las observaciones en las que esa serie o vector tome el valor 1 e
	<quote>inactivas</quote> cuando sea 0. Las claves de <lit>centro</lit>
	(center), <lit>ancho</lit> (width), <lit>factor</lit> y <lit>estilo</lit>
	(style) no son pertinentes, pero se puede usar <lit>color</lit>. Observa
	que solo puede usarse una de esas especificaciones por cada gráfico.
	Aquí tienes un ejemplo:
      </para>
      <code>
	open AWM17 --quiet
	series dum = obs &gt;= 1990:1 &amp;&amp; obs &lt;= 1994:2
	bundle b = _(dummy="dum", color=0xcccccc)
	gnuplot YER URX --with-lines --time-series \
	  --band=b --output=display {set key top left;}
      </code>
      <subhead>Nombres de los colores</subhead>
      <para>
	Los colores se identifican mediante los números RGB, habitualmente
	expresados en formato hexadecimal con 6 dígitos: los dos primeros
	dígitos indican la cantidad de rojo (de 0 a 255), los dos del medio
	indican la cantidad de verde, y los dos últimos indican la cantidad de
	azul. Así, por ejemplo, <lit>0xff0080</lit> tiene el máximo de rojo, no
	tiene verde, y un poco de azul (es un morado rojizo). Con gnuplot 5.2
	en adelante, puedes utilizar cuatro pares de dígitos en lugar de tres:
	en ese caso, los dos primeros dígitos indican la transparencia, variando
	de 0 (opaco) a 255 (transparente). Por ejemplo, <lit>0xc0ff0080</lit>
	proporcionaría al color un valor de 192 (c0 en hexadecimal) para la
	transparencia. Puedes comprobar tu versión de gnuplot revisando
	el 'bundle' que devuelve la función <fncref targ="$sysinfo"/>.
      </para>
      <para>
	Los colores hexadecimales se pueden pasar como escalares, o bien como
	cadenas de texto. Una cadena para el color puede ser un número hexadecimal
	entre comillas (p.e. "0x191970"), pero gnuplot reconoce algunos
	colores <quote>abreviados</quote>. Por ejemplo, <quote>violet</quote>
	equivale a <quote>0xee82ee</quote> y <quote>brown</quote> equivale
	a <quote>0xa52a2a</quote>. Puedes acceder a la lista completa con
	los nombres de colores que reconoce gnuplot formulando la instrucción
	<quote><lit>show colornames</lit></quote> en el propio gnuplot, o
	ejecutando en la consola de Gretl
      </para>
      <code>
	eval readfile("@gretldir/data/gnuplot/gpcolors.txt")
      </code>
      <para>
	Para obtener un resultado estéticamente agradable, puede interesarte
	usar la función <fncref targ="rgbmix"/>.
      </para>
      <subhead>Controlando la salida de resultados</subhead>
      <para>
	En modo interactivo, el gráfico se muestra inmediatamente. En modo
	de procesamiento por lotes (como al ejecutar un guion), el procedimiento
	por defecto consiste en escribir un archivo de instrucciones Gnuplot
	en el directorio de trabajo del usuario, con un nombre con el patrón
	<filename>gpttmpN.plt</filename>, comenzando con N = <lit>01</lit>.
	Puedes generar los gráficos reales más tarde utilizando
	<program>gnuplot</program> (bajo MS Windows,
	<program>wgnuplot</program>). Y puedes modificar este proceder
	utilizando la opción <opt>output=</opt><repl>nombrearchivo</repl>. Esta
	opción controla el nombre de archivo utilizado, y al mismo tiempo te
	permite especificar un formato concreto para el resultado mediante
	la extensión del nombre del archivo, del siguiente modo:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>.eps</lit>: Encapsulated PostScript
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.pdf</lit>: PDF
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.png</lit>: PNG (Portable Network Graphics)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.emf</lit>: EMF (Microsoft's Enhanced MetaFile)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.html</lit>: 'canvas' de HTML
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.svg</lit>: SVG (Scalable Vector Graphics)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.fig</lit>: Xfig (*nix, programa de dibujo)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.tex</lit>: pict2e (para usar con &latex;)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.tikz</lit>: TiKZ (para usar con &latex;).
	  </para>
	</li>
      </ilist>
      <para>
	Cuando se proporciona el nombre ficticio <quote><lit>display</lit></quote>
	para el archivo, el gráfico se muestra en la pantalla en modo interactivo.
	Cuando se proporciona un nombre de ficheiro con cualquier otra extensión
	distinta a las antes mencionadas, se escribe un archivo de instruciones de gnuplot.
      </para>
      <para>
	Un medio alternativo para dirigir la salida de resultados es con la opción
	<opt>outbuf=</opt><repl>nombrecadena</repl>. Esto escribe las instrucciones
	de Gnuplot en la cadena de texto indicada o en el <quote>buffer</quote>.
	Ten en cuenta que las opciones <opt>output</opt> y <opt>outbuf</opt>
	son mutuamente incompatibles.
      </para>
      <subhead>Especificando una fuente</subhead>
      <para>
	Puedes utilizar la opción <opt>font</opt> para especificar una fuente
	concreta para el gráfico. El parámetro <repl>espfuente</repl> debe
	tener la forma del nombre de una fuente, seguida opcionalmente por un
	número que indique el tamaño en puntos, separado del nombre por una
	coma o espacio, todo ello puesto entre comillas, como en
      </para>
      <code>
	--font="serif,12"
      </code>
      <para>
	Ten en cuenta que las fuentes disponibles para Gnuplot varían dependiendo
	de la plataforma, y si estás escribiendo una instrucción de gráfico que
	pretendes que sea portable, es mejor restringir el nombre de la fuente
	a las genéricas <lit>sans</lit> o <lit>serif</lit>.
      </para>
      <subhead>Añadiendo instrucciones Gnuplot</subhead>
      <para>
	Dispones de una opción especial añadida de esta instrucción pues, a
	continuación de la especificación de las variables que se van a dibujar y
	del indicador de opción (si hay alguno), puedes añadir instrucciones
	literales de Gnuplot para controlar la apariencia del gráfico (por ejemplo,
	estableciendo el título del gráfico y/o rangos de los ejes). Estas
	instrucciones deben estar puestas entre llaves, y debes terminar cada
	instrucción Gnuplot con un punto y coma. Puedes utilizar una barra
	inversa para continuar un conjunto de instrucciones Gnuplot a lo largo
	de más de una línea. Aquí tienes un ejemplo de la sintaxis:
      </para>
      <code>
	{ set title 'Mi Título'; set yrange [0:1000]; }
      </code>
    </description>

    <gui-access>
      <menu-path>/Ver/Gráficos</menu-path>
      <other-access>Ventana principal: Menú emergente, botón de gráficos en la barra de herramientas</other-access>
    </gui-access>

  </command>

  <command name="graphing" section="Graphs" context="gui"
    label="Representar gráficos">

    <description>
      <para>
	GRETL solicita que un programa distinto, concretamente Gnuplot,
	genere gráficos. Gnuplot es un programa de representación gráfica muy
	completo con miles de opciones. Mediante una interfaz gráfica,
	GRETL te da acceso directo a un subconjunto de estas opciones y trata
	de elegir valores sensatos para ti; si quieres, también te permite
	que tengas un control completo sobre los detalles del gráfico.
      </para>
      <para>
	Con un gráfico ya representado, puedes hacer clic en la ventana del gráfico
	para obtener un menú emergente con varias opciones, incluidas estas:
      </para>
      <ilist>
	<li>
	  <para>
	    Guardar como PNG: Guarda en formato 'Portable Network Graphics'
	  </para>
	</li>
	<li>
	  <para>
	    Guardar como postscript (EPS): Guarda el gráfico en formato 'Encapsulated
	    postscript' (EPS)
	  </para>
	</li>
	<li>
	  <para>
	    Guardar en la sesión como icono: El gráfico aparecerá en forma de
	    icono cuando escojas <quote>Vista de Iconos</quote> en el menú
	    de la sesión
	  </para>
	</li>
	<li>
	  <para>
	    Zoom: Te permite seleccionar un área dentro del gráfico para
	    hacer una inspección más de cerca
	  </para>
	</li>
	<li>
	  <para>
	    Copiar al portapapeles: Te permite pegar el gráfico en aplicaciones
	    tales como procesadores de texto
	  </para>
	</li>
	<li>
	  <para>
	    Editar: Abre un controlador para el gráfico que te permite ajustar
	    varios aspectos de su aspecto
	  </para>
	</li>
	<li>
	  <para>
	    Cerrar: Cierra la ventana del gráfico
	  </para>
	</li>
      </ilist>

      <para>
	Si tienes algún conocimiento sobre Gnuplot y quieres obtener un control más
	fino sobre el aspecto de un gráfico que el que es accesible mediante el
	controlador gráfico (opción <quote>Editar</quote>), dispones de una opción
	adicional:
      </para>

      <ilist>
	<li>
	  <para>
	    Una vez que has guardado el gráfico como icono de sesión, pulsa el botón
	    derecho del ratón sobre ese icono para ver un menú emergente posterior.
	    Aquí, una de las opciones es <quote>Editar las órdenes de gráfico</quote>:
	    esto abre una ventana de edición con la presentación de las instrucciones
	    Gnuplot vigentes. Puedes editar estas instrucciones y, bien guardarlas para
	    ejecutarlas en el futuro, o bien enviarlas a Gnuplot (con el icono Ejecutar
	    de la barra de herramientas en la ventana de instrucciones del gráfico).
	  </para>
	</li>
      </ilist>

      <para>
	Para descubrir más sobre Gnuplot, consulta <url>www.gnuplot.info</url>.
      </para>

    </description>

  </command>

  <command name="graphpg" section="Graphs" label="Página de gráficos de GRETL">

    <usage>
      <altforms>
        <altform><lit>graphpg add</lit></altform>
	<altform><lit>graphpg fontscale </lit><repl>escala</repl></altform>
	<altform><lit>graphpg show</lit></altform>
	<altform><lit>graphpg free</lit></altform>
	<altform><lit>graphpg --output=</lit><repl>nombrearchivo</repl></altform>
      </altforms>
    </usage>

    <description>

      <para>
	La sesión <quote>Página de gráficos</quote> va a funcionar solo cuando
	tengas instalado el sistema de composición tipográfica &latex;, y además
	puedas generar y ver un resultado PDF o PostScript.
      </para>
      <para>
	En la ventana de iconos de la sesión, puedes arrastrar hasta 8 gráficos sobre el
	icono de página de gráficos. Cuando pulses un doble clic sobre la página
	de gráficos (o pulses el botón derecho y elijas <quote>Mostrar</quote>),
	se va a componer una página que contiene los gráficos seleccionados y se va a
	abrir con un visor adecuado. Desde ahí deberías poder imprimir la página.
      </para>
      <para>
	Para vaciar la página de gráficos, pulsa el botón derecho del ratón sobre
	su icono y selecciona <quote>Vaciar</quote>.
      </para>
      <para>
	Ten en cuenta que en sistemas diferentes a MS Windows, podrías tener
	que ajustar la configuración del programa utilizado para ver archivos
	PDF o PostScript. Encuéntralo bajo la pestaña <quote>Programas</quote>
	en la caja de diálogo de las Preferencias generales de GRETL (bajo el menú
	Herramientas de la ventana principal).
      </para>
      <para>
	También es posible trabajar en la página de gráficos mediante un guion, o
	utilizando la consola (en el programa de Interfaz Gráfica de Usuario,
	GUI). Se le da apoyo a las siguientes instrucciones y opciones:
      </para>
      <para>
	Para añadir un gráfico a la página de gráficos, puedes indicar la instrucción
	<lit>graphpg add</lit> luego de guardar un gráfico definido, como en
      </para>
      <code>
	grf1 &lt;- gnuplot Y X
	graphpg add
      </code>
       <para>
	Para mostrar la página de gráficos: <lit>graphpg show</lit>.
      </para>
      <para>
	Para vaciar la página de gráficos: <lit>graphpg free</lit>.
      </para>
      <para>
	Para ajustar la escala de la fuente utilizada en la página de gráficos,
	usa <lit>graphpg fontscale</lit> <repl>escala</repl>, donde
	<repl>escala</repl> es un múltiplo (por defecto igual a 1.0).
	De este modo, para hacer que el tamaño de la fuente sea un 50 por
	ciento mayor que el tamaño por defecto, puedes hacer
      </para>
      <code>
	graphpg fontscale 1.5
      </code>
      <para>
	Para solicitar la impresión de la página del gráfico en un archivo,
	usa la opción <opt>output=</opt> más un nombre de archivo; este
	nombre debería tener la extensión <quote><lit>.pdf</lit></quote>,
	<quote><lit>.ps</lit></quote> o <quote><lit>.eps</lit></quote>.
	Por ejemplo:
      </para>
      <code>
	graphpg --output="myfile.pdf"
      </code>
      <para>
	El archivo resultante va a escribirse en el directorio establecido en ese momento
	(<cmdref targ="workdir"/>), excepto que la cadena <repl>nombrearchivo</repl>
	contenga una especificación completa de la ruta.
      </para>
      <para>
	En este contexto, para el resultado se utilizan líneas de colores por
	defecto; para utilizar patrones punto/raya en vez de colores, puedes
	añadir la opción <opt>monochrome</opt>.
      </para>

    </description>

  </command>

  <command name="gretl_edit" section="Utilities" context="gui"
    label="gretl_edit">

    <description>
      <para>
	gretl_edit es una variante ligera, con un propósito especial, de la
	Interfaz Gráfica de Usuario (GUI) de GRETL. Incluye un editor tabulado
	de guiones, con los medios para ejecutar guiones y ver sus resultados.
	Carece de muchas de las funcionalidades de la GUI principal de GRETL,
	pero puede ser útil en base a que, a veces, <quote>menos es más</quote>.
      </para>
      <para>
	Este es el contexto para el que está diseñado gretl_edit.
	Estás trabajando en algún código relativamente complejo, y quieres
	efectuar el siguiente ciclo:
      </para>
      <code>
	    editar un código
	    ejecutar el código, revisar los resultados, buscar fallos
	    revisar el código
	    ejecutar otra vez...
      </code>
      <para>
	Si esto es algo que haces de vez en cuando, inténtalo con gretl_edit.
	Se no lo haces, entonces puedes ignorar este programa de forma segura.
      </para>
      <para>
	Ten en cuenta que gretl_edit <quote>no tiene estado</quote>.
	A diferencia de la GUI principal de GRETL, los modelos, las matrices, los
	"bundles" y todo lo demás, no están guardados. El único estado que se
	preserva es el del guion (o guiones) que se estén editando. En el contexto
	descrito antes, esto probablemente es lo que se quiere: que cada vez que
	se ejecute un guion, comience con una <quote>pizarra en blanco</quote>.
	Esto quiere decir que, si un guion utiliza un conjunto de datos, debe
	incluir una instrucción para abrir ese conjunto de datos.
      </para>
      <para>
	Obviamente, gretl_edit admite HANSL, el lenguaje propio de GRETL para
	hacer guiones. De modo menos obvio, también admite lenguajes que están
	cubiertos por el instrumental <quote>externo</quote> a GRETL: R, Octave,
	Julia, Ox, Stata. en estos casos externos, el editor de guiones no tiene
	una funcionalidad tan completa como para HANSL: ofrece la sintaxis con
	resalte, pero no el sangrado automático ni el autocompletado.
      </para>
    </description>
  </command>

  <command name="gridplot" section="Graphs" context="cli">
    <usage>
      <arguments>
        <argument>plotspecs</argument>
      </arguments>
      <options>
	<option>
	  <flag>--fontsize</flag>
	  <optparm>fs</optparm>
	  <effect>Tamaño de la fuente en puntos [10]</effect>
	</option>
	<option>
	  <flag>--width</flag>
	  <optparm>w</optparm>
	  <effect>Ancho del gráfico en pixels [800]</effect>
	</option>
	<option>
	  <flag>--height</flag>
	  <optparm>h</optparm>
	  <effect>Altura del gráfico en pixels [600]</effect>
	</option>
	<option>
	  <flag>--title</flag>
	  <optparm>cadena entre comillas</optparm>
	  <effect>Añadir un título general</effect>
	</option>
	<option>
	  <flag>--rows</flag>
	  <optparm>r</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--cols</flag>
	  <optparm>c</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--layout</flag>
	  <optparm>lmat</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--output</flag>
	  <optparm>destino</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--outbuf</flag>
	  <optparm>destino alternativo</optparm>
	  <effect>Mira abajo</effect>
	</option>
      </options>
      <examples>
        <example>gridplot myspecs --rows=3 --output=display</example>
        <example>gridplot myspecs --layout=lmat --output=compuesto.pdf</example>
      </examples>
    </usage>
    <description>
      <para>
	Esta instrucción coge dos o más especificaciones individuales para
	gráficos y las ordena en una parrilla para generar un gráfico combinado.
	El único argumento requerido, <repl>plotspecs</repl>, tiene el formato
	de un 'array' de cadenas de texto, cada una especificando un gráfico.
	Su instrucción asociada, <cmdref targ="gpbuild"/>, ofrece un modo
	fácil de crear ese tipo de 'array'.
      </para>
      <subhead>Especificando la parrilla</subhead>
      <para>
	La forma de la parrilla se puede establecer por cualquiera de las tres
	opciones (mutuamente incompatibles) <opt>rows</opt>, <opt>cols</opt> y
	<opt>layout</opt>. Si no se indica ninguna de esas opciones, el número
	de filas se establece como la raíz cuadrada del número de gráficos (el
	tamaño del 'array' de entrada), redondeado hacia el entero superior más
	próximo, de ser necesario. Entonces, el número de columnas se establece
	como el número de gráficos dividido por el número de filas, de nuevo
	redondeado hacia arriba, de ser necesario. Los gráficos se colocan en la
	parrilla por filas, en el mismo orden que en el 'array'. Si se indica la
	opción <opt>rows</opt>, ese valor ocupa la posición de selección automática,
	pero el número de columnas se establece automáticamente como se describió
	antes. En cambio, si se indica la opción <opt>cols</opt>, el número de
	filas se establece de forma automática.
      </para>
      <para>
	La opción <opt>layout</opt>, que necesita una matriz como parámetro,
	ofrece una alternativa más flexible. Esa matriz especifica la
	configuración de la parrilla de este modo: los elementos 0 piden celdas
	vacías en la parrilla, y los elementos enteros de 1 a <math>n</math>
	se refieren a los subgráficos en el orden que tengan en el 'array'.
	Así por ejemplo,
      </para>
      <code>
	matrix m = {1,0,0; 2,3,0; 4,5,6}
	gridplot ... --layout=m ...
      </code>
      <para>
	se refiere a una configuración triangular inferior de seis gráficos
	en una parrilla <by r="3" c="3"/>. Utilizando esta opción se pueden
	omitir algunos subgráficos, o incluso repetir alguno.
      </para>
      <subhead>Opciones de salida</subhead>
      <para>
	La opción <opt>output</opt> puede utilizarse para indicar <lit>display</lit>
	(presentar el gráfico inmediatamente) o el nombre de un archivo de salida.
	Como alternativa, se puede usar la opción <opt>outbuf</opt> para hacer
	una salida directa (con el formato de un búfer de instrucciones de GNUPLOT)
	a la cadena de texto mencionada. En ausencia de estas opciones, la salida
	es un archivo de instrucciones de GNUPLOT nombrado de forma automática.
	Consulta <cmdref targ="gnuplot"/> para obtener más detalles.
      </para>
    </description>
  </command>

  <command name="gpbuild" section="Graphs" context="cli">
    <usage>
      <arguments>
	<argument>plotspecs</argument>
      </arguments>
      <examples>
        <example>gpbuild MyPlots</example>
      </examples>
    </usage>
    <description>
      <para>
	Esta instrucción empieza un bloque en el que cualquier instrucción o
	llamada a una función que produce gráficos se trata de modo especial, con
	objeto de producir un 'array' de cadenas de texto de especificación de
	gráficos, para usarlas con la instrucción 	<cmdref targ="gridplot"/>: el
	argumento <repl>plotspecs</repl> proporciona el nombre para ese 'array'.
	El bloque se acaba con la instrucción <quote><lit>end gpbuild</lit></quote>.
      </para>
      <subhead>Dos restricciones</subhead>
      <para>
	Dentro de un bloque <lit>gpbuild</lit> solo tienen un tratamiento especial
	las instrucciones para representación gráfica; todas las otras instrucciones
	se ejecutan normalmente. Únicamente hay dos restricciones que advertir.
      </para>
      <ilist>
   <li>
      <para>
	Las instrucciones de representación <emphasis>no</emphasis> deben
	incluir una especificación de salida en este contexto, puesto que eso
	estaría en conflicto con la redirección automática de la salida, hacia
	el 'array' de <repl>plotspecs</repl>. Una excepción a esta regla se
	permite para <lit>--output=display</lit> (que es bastante habitual
	como opción predeterminada en los paquetes de funciones relacionadas
	con representaciones gráficas); esta directiva se ignora de modo
	silencioso en favor del tratamiento automático.
      </para>
    </li>
    <li>
      <para>
	Los gráficos que invoquen la directiva
	<quote><lit>multiplot</lit></quote> de GNUPLOT no son adecuados
	para ser incluidos en un bloque <lit>gpbuild</lit>. Esto es porque
	<lit>gridplot</lit> utiliza internamente <lit>multiplot</lit>,
	y esas construcciones no se pueden
	anidar.
      </para>
    </li>
      </ilist>
      <subhead>Alternativa manual</subhead>
      <para>
	Se puede preparar un 'array' de especificaciones de gráficos para utilizar
	con <lit>gridplot</lit> sin usar un bloque <lit>gpbuild</lit>, como en el
	siguiente ejemplo:
      </para>
      <code>
	open data4-10
	strings MyPlots = array(3)
	gnuplot ENROLL CATHOL --outbuf=MyPlots[1]
	gnuplot ENROLL INCOME --outbuf=MyPlots[2]
	gnuplot ENROLL COLLEGE --outbuf=MyPlots[3]
      </code>
      <para>
	En esencia, lo anterior es equivalente a
      </para>
      <code>
	open data4-10
	gpbuild MyPlots
	   gnuplot ENROLL CATHOL
	   gnuplot ENROLL INCOME
	   gnuplot ENROLL COLLEGE
	end gpbuild
      </code>
    </description>
  </command>

  <command name="3-D" section="Graphs" context="gui"
    label="Gráficos en 3 dimensiones">

    <description>
      <para>
	Si el botón <quote>Hacer el gráfico interactivo</quote> está
	disponible y marcado, puedes manejar el gráfico 3-D con el ratón
	(girarla, expandir o encoger los ejes).
      </para>
      <para>
	Al componer un gráfico 3-D, ten en cuenta que el eje Z se va a
	mostrar como eje vertical. Así, si tienes alguna variable dependiente
	que piensas que puede estar influida por dos variables independientes,
	debes colocar la variable dependiente en el eje Z, y las variables
	independientes en los ejes X e Y.
      </para>
      <para>
	Al contrario que en la mayoría de los gráficos de GRETL, uno interactivo 3-D
	se controla mediante Gnuplot y no con el propio GRETL; por eso el menú de
	GRETL para editar gráficos, no está disponible. Para ver el código de Gnuplot
	que genera el gráfico, quita la marca que permite hacerlo interactivo. Puedes
	usar entonces el propio menú del gráfico (pulsa en él con el botón derecho del
	ratón) para guardarlo <quote>como icono</quote>. En la ventana del Visor de iconos
	de la sesión, puedes ver las instrucciones pulsando con el botón derecho en el icono del gráfico.
      </para>
    </description>
  </command>

  <command name="gui-funcs" section="Programming"
     label="Funciones especiales" context="gui">
    <description>
      <para>
	Este diálogo te permite especificar las funciones (si existe alguna)
	dentro de un paquete que deben asignarse a ciertos roles especiales.
	Ten en cuenta que puedes asignar una determinada función como mucho
	a uno de los siguientes roles; y que una función tiene que satisfacer ciertos
	criterios para calificarla como candidata a uno de esos roles.
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>bundle-print</lit>: Presenta el resultado basado en el
	    contenido de un bundle producido por tu paquete. Criterios:
	    Esta función debe tener como primer parámetro un
	    puntero-bundle. Cuando se presenta un segundo
	    parámetro, debe tener el formato de un conmutador
	    entero que tenga un valor por defecto.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>bundle-plot</lit>: Genera uno o más gráficos utilizando
	    un bundle producido por tu paquete. Criterios: Igual que para
	    <lit>bundle-print</lit>.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>bundle-test</lit>: Realiza algún tipo de contraste estadístico
	    utilizando un bundle producido por tu paquete. Criterios:
	    Igual que para <lit>bundle-print</lit>.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>gui-main</lit>: La interfaz pública que debiera de presentarse por
	    defecto a los usuarios al utilizar la Interfaz Gráfica de Usuario (GUI).
	    Esto resulta útil solo cuando el paquete tiene más de una interfaz pública.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>gui-precheck</lit>: Función guardián que devuelve 0
	    si la funcionalidad de tu paquete es aplicable en el contexto
	    vigente, y en otro caso devuelve no cero. Esto está pensado
	    para utilizar con paquetes que afectan a un modelo de algún
	    modo, para diferenciar los tipos de modelos que no se
	    manejan con el paquete.
	  </para>
	</li>
      </ilist>
      <para>
	Además, ciertas funciones pueden indicarse con <quote>no-print</quote>. En
	general, cuando se llama a una función mediante el programa de Interfaz
	Gráfica de Usuario (GUI), GRETL abre una ventana para mostrar su
	resultado en texto. Al marcar este cuadradito estás indicándole a GRETL
	que no haga esto, de ahí que no debas esperar resultados en texto.
      </para>
      <para>
	Finalmente, puedes marcar la función <lit>gui-main</lit> (si existe)
	como <quote>menu-only</quote>. Esto le indica a GRETL que la función
	en cuestión está diseñada específicamente para que se invoque desde
	el menú de la Interfaz Gráfica de Usuario (GUI) a la que está unida, y no
	debe presentarse a los usuarios, a no ser en ese caso.
      </para>
    </description>
  </command>

  <command name="gui-htest" section="Tests" context="gui"
    label="Calculadora de estadísticos de contraste">

    <description>
      <para>
	La calculadora de contrastes de GRETL encuentra los valores de los estadísticos
	de contraste y de sus probabilidades asociadas (valores p) en varios
	contrastes habituales de hipótesis, relativas a una o dos poblaciones.
	Las entradas que se requieren consisten en estadísticos muestrales obtenidos
	de una o dos muestras, en función del contraste escogido; y puedes escribir
	estos estadísticos con valores numéricos. Alternativamente, si tienes
	abierto un archivo de datos, puedes lograr que GRETL calcule los
	estadísticos muestrales para una o varias variables escogidas
	(en caso de medias y varianzas, pero no en caso de proporciones).
      </para>
      <para>
	Si quieres basar tu contraste en una variable del conjunto de
	datos, primero activa esta opción marcando el cuadradito titulado
	<quote>Utilice una variable del conjunto de datos</quote>.
	Entonces, la lista desplegable con las variables se activará y podrás
	elegir una variable. Cuando escoges una variable de la lista, los
	estadísticos destacados se insertan automáticamente en las cajas
	de debajo.
      </para>
      <para>
	Ten en cuenta que en el caso de dos muestras, los contrastes son de
	tipo desemparejado. Si, por ejemplo, quieres realizar un contraste
	<emphasis>emparejado</emphasis> sobre si la diferencia entre las
	medias de dos variables es nula, debes crear simplemente una nueva
	serie con las diferencias entre las dos ya existentes, y realizar un
	sencillo contraste sobre la media de esa nueva serie.
	    </para>
      <para>
	Además de la simple selección de una variable, tienes la opción de
	especificar una restricción sobre la variable escogida (es
	decir, definiendo una submuestra). Por ejemplo, supón que tienes
	datos de salarios en una variable llamada <lit>salario</lit>,
	y también tienes una variable ficticia llamada <lit>género</lit>
	que es igual a 1 para hombres y a 0 para mujeres (o viceversa).
	Entonces, en el contraste de la diferencia entre las dos medias, puedes
	escoger <lit>salario</lit> en ambas cajas pero añade a la
	misma caja de arriba <lit>(genero==0)</lit> y a la de abajo
	<lit>(genero==1)</lit>. Así, esto te ofrece un contraste de la
	diferencia entre el ingreso medio masculino y el ingreso medio
	femenino. Ten en cuenta que cuando tecleas una restricción
	de este modo, entonces debes pulsar la tecla Intro para obtener
	los estadísticos muestrales calculados.
      </para>
      <para>
	Debes colocar la restricción de la submuestra entre paréntesis
	a continuación de la variable escogida, y en general esa restricción
	tiene la forma
      </para>
      <code>
	var2 op val
      </code>
      <para>
	donde <lit>var2</lit> es el nombre de una variable del conjunto
	vigente de datos, <lit>val</lit> es un valor numérico, y
	<lit>op</lit> es uno de los siguientes operadores de comparación:
      </para>
      <code>
	==  !=  &lt;  &gt;  &lt;=  &gt;=
      </code>
      <para>
	(indicando respectivamente: igualdad, desigualdad, menor
	que, mayor que, menor o igual que, y mayor o igual que).
	Los espacios alrededor del operador son opcionales.
      </para>
    </description>
  </command>

  <command name="gui-htest-np" section="Tests" context="gui"
    label="Contrastes no paramétricos">

    <description>
      <para>
	Tienes a tu disposición 3 tipos de contrastes no paramétricos mediante
	este diálogo: para la diferencia entre grupos, para la aleatoriedad,
	y para la correlación (por rangos).
      </para>

      <subhead>Contrastes de diferencias</subhead>
      <para>
	Bajo la pestaña <quote>Contraste de diferencias</quote> puedes efectuar
	un contraste no paramétrico de la diferencia entre dos poblaciones o
	grupos dependiendo, el contraste concreto, de la opción que selecciones.
      </para>
      <ilist>
	<li>
	  <para>
	    <emphasis>Contraste de signos</emphasis>: Este contraste
	    se basa en el hecho de que cuando se extraen dos muestras,
	    <math>x</math> e <math>y</math>, de forma aleatoria
	    de una misma distribución, la probabilidad de que
	    <math>x</math><sub>i</sub> &gt; <math>y</math><sub>i</sub>,
	    para cada observación <math>i</math>, deberá ser igual
	    a 0.5. El estadístico de contraste es <math>w</math>, es decir,
	    el número de observaciones para las que se cumple que
	    <math>x</math><sub>i</sub> &gt; <math>y</math><sub>i</sub>.
	    Bajo la hipótesis nula, este estadístico sigue una distribución
	    de probabilidad Binomial con parámetros (<math>n</math>, 0.5),
	    donde <math>n</math> indica el número de
	    observaciones.
	  </para>
	</li>
	<li>
	  <para>
	    <emphasis>Contraste de suma de rangos</emphasis>: Se realiza el contraste
	    de suma de rangos de Wilcoxon, que se desarrolla determinando
	    el rango en jerarquía de las observaciones de ambas muestras juntas,
	    desde la de menor valor hasta la de mayor, y luego calculando la suma
	    de los rangos de las observaciones de una cualquiera de las dos muestras.
	    No es necesario que las dos muestras tengan el mismo tamaño y, si
	    son diferentes, se utiliza la muestra más pequeña para calcular la
	    suma de los rangos. Bajo la hipótesis nula de que las muestras proceden
	    de poblaciones con la misma mediana, la distribución de probabilidad
	    de la suma de rangos puede calcularse para cualquier tamaño de muestra
	    que se indique; y para muestras razonablemente largas, existe una
	    estrecha aproximación Normal.
	  </para>
	</li>
	<li>
	  <para>
	    <emphasis>Contraste de los rangos con signo</emphasis>: Se realiza
	    el contraste de los rangos con signo de Wilcoxon, que está ideada
	    para pares de datos ligados como, por ejemplo, los pares
	    de valores de una misma variable en una muestra de individuos,
	    antes y después de algún tratamiento. El contraste se desenvuelve
	    calculando las diferencias entre las observaciones emparejadas
	    <math>x</math><sub>i</sub> &minus; <math>y</math><sub>i</sub>,
	    y determinando el rango de estas diferencias según su valor
	    absoluto, además de asignándole a cada par un rango con un signo
	    que coincide con el signo de la diferencia. A continuación se calcula la
	    suma de los rangos con signo positivo (<math>W</math><sub>+</sub>).
	    De igual modo que en el contraste de la suma de rangos, bajo la hipótesis
	    nula de que la diferencia de medianas es cero, este estadístico
	    sigue una distribución de probabilidad bien definida, que
	    converge a la Normal para muestras de tamaño razonable.
	  </para>
	</li>
      </ilist>

      <subhead>Aleatoriedad</subhead>
      <para>
	Bajo la pestaña <quote>Contraste de rachas</quote>, puedes llevar a cabo
	un contraste del carácter aleatorio de una determinada variable, basada en el
	número de rachas de valores consecutivos positivos o negativos.
	Si escoges la opción <quote>Utilizar la primera diferencia</quote>, se
	calcula la primera diferencia de la variable antes del análisis; y por eso
	las rachas se interpretan como rachas de valores crecientes o
	decrecientes de la variable original. El estadístico de contraste se basa
	en una aproximación Normal a la distribución del número de rachas
	bajo la hipótesis nula de que la variable tiene carácter aleatorio.
      </para>

      <subhead>Correlación</subhead>
      <para>
	Bajo la pestaña <quote>Correlación</quote>, dispones de los coeficientes
	de correlación por rangos rho de Spearman y tau de Kendall.
      </para>

    </description>
  </command>
  
  <command name="hccme" section="Estimation" context="gui"
    label="Desviaciones típicas robustas">

    <description>
      <para>
	Se te ofrecen diversas variantes de cálculo de las desviaciones típicas que
	son robustas en la presencia de heterocedasticidad (y de autocorrelación
	en el caso del estimador HAC).
      </para>
      <para>
	HC0 produce las <quote>Desviaciones típicas de White</quote> originales;
	HC1, HC2, HC3 y HC3a son variantes subsiguientes que generalmente
	se considera que producen resultados superiores (más fiables).
	La variante HC3a es la también denominada <quote>navaja</quote>
	(jackknife) de la que HC3 es una estrecha aproximación. Para obtener
	más detalles sobre los estimadores, consulta
	<guideref targ="chap:robust_vcv"/>
	o
	<cite key="davidson-mackinnon04">Davidson y MacKinnon, 2004)</cite>.
      </para>
      <para>
	Si utilizas el estimador HAC para MCO con datos de series temporales,
	puedes afinar la longitud del retardo y otros detalles utilizando
	la instrucción <cmdref targ="set"/>.
      </para>
      <para>
	Se ofrecen dos estimadores robustos de la matriz de covarianzas para
	modelos GARCH: QML es el estimador de Cuasi-Máxima Verosimilitud (CMV),
	y BW es el estimador de Bollerslev-Wooldridge.
      </para>
      <para>
	Cando se estiman modelos con datos de panel, el estimador robusto
	predeterminado de la matriz de covarianzas es el proporcionado por
	<cite key="arellano03">Arellano (2003)</cite>. Las alternativas son tanto
	las Desviaciones Típicas Corregidas de Panel (DTCP, PCSE) de
	<cite key="beck-katz95">Beck y Katz (1995)</cite> como el estimador
	Consistente de Correlación Espacial (CCE, SCC) de
	<cite key="driscoll_kraay98">Driscoll y Kraay (1998)</cite>.
	Consulta <guideref targ="chap:robust_vcv"/> para obtener más detalles.
      </para>
      <para>
	Por defecto, GRETL usa la distribución <math>t</math>-Student al calcular
	las probabilidades asociadas (valores p) basadas en desviaciones típicas
	robustas en el contexto de estimadores de mínimos cuadrados. La opción titulada
	<quote>Utilizar la distribución Normal para obtener valores p robustos</quote>
	puede usarse para modificar este comportamiento.
      </para>
    </description>

  </command>

  <command name="heckit" section="Estimation" context="cli"
    label="Modelo de selección de Heckman">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	      <argument separated="true">ecuaciondeseleccion</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
        <option>
	  <flag>--two-step</flag>
	  <effect>Realiza la estimación en 2 etapas</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
	<option>
	  <flag>--opg</flag>
	  <effect>Desviaciones típicas PEG (OPG)</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas CMV (QML)</effect>
        </option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para más explicaciones</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta resultados adicionales</effect>
        </option>
      </options>
      <examples>
        <example>heckit y 0 x1 x2 ; ys 0 x3 x4</example>
	<demos>
	  <demo>heckit.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Modelo de selección de tipo Heckman. Al especificar esta instrucción,
	la lista antes del punto y coma representa las variables de la ecuación
	resultante, y la segunda lista representa las variables de la ecuación de
	selección. La variable dependiente de la ecuación de selección (<lit>ys</lit>
	en el ejemplo de arriba) debe ser una variable binaria.
      </para>
      <para>
	Por defecto, los parámetros se estiman por el método de máxima
	verosimilitud. La matriz de covarianzas de los estimadores de los
	parámetros se calcula utilizando la inversa negativa de la matriz
	Hessiana. Si quieres hacer la estimación en 2 etapas, utiliza la
	opción <opt>two-step</opt>. En este caso, la matriz de covarianzas
	de los estimadores de los parámetros de la ecuación resultante se ajusta de
	modo adecuado según <cite key="heckman79">Heckman (1979)</cite>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Variable dependiente limitada/Heckit</menu-path>
    </gui-access>

  </command>

  <command name="help" section="Utilities"
    label="Ayuda sobre las instrucciones" context="cli">

    <usage>
      <altforms>
        <altform><lit>help</lit></altform>
	<altform><lit>help functions</lit></altform>
        <altform><lit>help</lit> <repl>instrucción</repl></altform>
        <altform><lit>help</lit> <repl>función</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--func</flag>
	  <effect>Escoge la ayuda sobre las funciones</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Si no indicas ningún argumento, presenta la lista de instrucciones disponibles.
	Si indicas el argumento simple <lit quote="true">functions</lit>, presenta la
	lista de funciones disponibles (consulta <cmdref targ="genr"/>).
      </para>
      <para>
	La expresión <lit>help</lit> <repl>instrucción</repl> describe cada
	instrucción indicada (&eg; <lit>help smpl</lit>). La expresión
	<lit>help</lit> <repl>función</repl> describe cada función indicada
	(&eg; <lit>help ldet</lit>). Algunas funciones tienen los mismos nombres
	que las instrucciones relacionadas (&eg; <lit>diff</lit>); en ese caso,
	por defecto se presenta la ayuda para la instrucción, pero puedes obtener
	ayuda para la función utilizando la opción <opt>func</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ayuda</menu-path>
    </gui-access>

  </command>

  <command name="hfplot" section="Graphs"
    label="Generar un gráfico MIDAS" context="cli">

    <usage>
      <arguments>
        <argument>listaaltafrec</argument>
	      <argument optional="true" separated="true">listabajafrec</argument>
      </arguments>
      <options>
	<option>
	  <flag>--with-lines</flag>
	  <effect>Gráfico con líneas</effect>
	</option>
	<option>
	  <flag>--time-series</flag>
	  <effect>Pon el tiempo en el eje de abscisas</effect>
	</option>
	<option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el resultado al archivo especificado</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Proporciona un medio de dibujar una serie de alta frecuencia,
	posiblemente junto a una o más series observadas con la frecuencia
	base del conjunto de datos. El primer argumento debe ser
	una <cmdref targ="MIDAS_list"/>; y los términos adicionales
	<repl>listabajafrec</repl> (opcionales) deberán ser series habituales
	(<quote>de baja frecuencia</quote>), después de un punto y coma.
      </para>
      <para>
	Para obtener más detalles sobre el efecto de la opción <opt>output</opt>,
	consulta la instrucción <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>

  <command name="hsk" section="Estimation"
    label="Estimaciones con la heterocedasticidad corregida">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--no-squares</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Esta instrucción es aplicable cuando existe heterocedasticidad en forma
	de una función desconocida de los regresores, que puede aproximarse por
	medio de una relación cuadrática. En ese contexto, ofrece la posibilidad
	de obtener desviaciones típicas consistentes y estimaciones más eficientes
	de los parámetros, en comparación con MCO.
      </para>
      <para>
	El procedimiento implica (a) la estimación MCO del modelo de interés,
	seguido de (b) una regresión auxiliar para generar una estimación de la
	varianza de la perturbación, y finalmente (c) mínimos cuadrados ponderados,
	utilizando como ponderación la inversa de la varianza estimada.
      </para>
      <para context="cli">
	En la regresión auxiliar de (b), se regresa el logaritmo de los errores
	cuadrados de la primera estimación MCO, sobre los regresores
	originales y sus cuadrados (por defecto), o solo sobre los
	regresores originales (si indicas la opción <opt>no-squares</opt>).
	La transformación logarítmica se realiza para asegurar que
	las varianzas estimadas son todas no negativas. Denominando
	<math>u</math><sup>*</sup> a los valores ajustados por esta
	regresión, la serie con las ponderaciones para la estimación MCP (WLS)
	final se forma entonces como 1/exp(<math>u</math><sup>*</sup>).
      </para>
      <para context="gui">
	En la regresión auxiliar de (b), se regresa el logaritmo de los errores cuadrados
	de la primera estimación MCO, sobre los regresores originales y sus cuadrados
	(por defecto), o solo sobre los regresores originales (si no marcas el
	cuadradito <quote>La ecuación de varianza incluye términos al cuadrado</quote>).
	La transformación logarítmica se realiza para asegurar que las varianzas
	estimadas son todas no negativas. Denominando <math>u</math><sup>*</sup>
	a los valores ajustados por esta regresión, la serie con las ponderaciones
	para la estimación MCP (WLS) final se forma entonces como
	1/exp(<math>u</math><sup>*</sup>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Otros modelos lineales/con corrección de Heterocedasticidad</menu-path>
    </gui-access>

  </command>

  <command name="hurst" section="Statistics"
    label="Exponente de Hurst">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--plot</flag>
	  <optparm>modo-o-nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcula el exponente de Hurst (una medida de persistencia o memoria
	larga) para una variable de tipo serie temporal que tenga por lo menos
	128 observaciones. Puedes obtener el resultado (junto con su desviación
	típica) mediante el accesor <fncref targ="$result"/>.
      </para>
      <para>
	<cite key="mandelbrot83">Mandelbrot (1983)</cite> discute
	sobre el exponente de Hurst. En términos teóricos, este es el
	exponente (<math>H</math>) de la relación
	<equation status="display"
	    tex="\[\mathrm{RS}(x) = an^H\]"
	    ascii="RS(x) = an^H" graphic="hurst"/> donde RS expresa el
	<quote>rango que se vuelve a escalar</quote> de la variable <math>x</math>
	en muestras de tamaño <math>n</math> y <math>a</math> es una
	constante. El rango reescalado es el rango (valor máximo menos
	mínimo) del valor acumulado o suma parcial de <math>x</math>
	(luego de la substracción de su media muestral) en el período de la
	muestra, dividida por la desviación típica muestral.
      </para>
      <para>
	Como punto de referencia, si <math>x</math> es una variable ruido
	blanco (con media y persistencia nulas) entonces el rango de su
	<quote>paseo</quote> (forma un paseo aleatorio) acumulado y
	escalado por su desviación típica, tiene un crecimiento igual a la
	raíz cuadrada del tamaño de la muestra, proporcionando un exponente
	de Hurst esperado de 0.5. Los valores del exponente que estén
	significativamente por encima de 0.5 indican persistencia, y los
	menores que 0.5 indican <quote>antipersistencia</quote> (autocorrelación
	negativa). En principio, el exponente está acotado entre 0 y 1, aunque
	en muestras finitas es posible obtener un exponente estimado mayor que 1.
      </para>
      <para>
	En GRETL, el exponente se estima utilizando submuestreo binario:
	se empieza con el rango completo de datos, después con las dos mitades
	del rango, después con los 4 cuartos, etcétera. Para tamaños de la muestra
	menores que el rango de datos, el valor RS es la media entre las
	muestras disponibles. El exponente se estima así como el coeficiente
	de la pendiente, en una regresión del logaritmo de RS sobre el logaritmo
	del tamaño de la muestra.
      </para>
      <para>
	Por defecto, si GRETL no está en modo de procesamiento por
	lotes, se muestra un gráfico del rango reescalado pero puedes ajustar
	esto mediante la opción <opt>plot</opt>. Los parámetros que se admiten
	para esta opción son <lit>none</lit> (para suprimir el gráfico);
	<lit>display</lit> (para presentar un gráfico incluso en caso de
	procesar por lotes); o un nombre de archivo. El efecto de indicar un
	nombre de archivo es como el descrito para la opción <opt>output</opt>
	de la instrucción <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Exponente de Hurst</menu-path>
    </gui-access>

  </command>

  <command name="if" section="Programming" label="Control de flujo" context="cli">

    <description>
      <para>Control de flujo para la ejecución de instrucciones. Se admiten
	3 tipos de construcción, como las indicadas a continuación.
      </para>
      <code>
	# Forma simple
	if (poner la condición)
	    instrucciones
	endif

	# Dos ramas
	if (poner la condición)
	    instrucciones 1
	else
	    instrucciones 2
	endif

	# Tres o más ramas
	if (poner la condición 1)
	    instrucciones 1
	elif (poner la condición 2)
	    instrucciones 2
	else
	    instrucciones 3
	endif
      </code>

      <para>
	La condición (<repl quote="true">condition</repl>) debe ser una
	expresión booleana; para su sintaxis consulta <cmdref targ="genr"/>.
	Puedes incluir más de un bloque <cmd>elif</cmd>. Además, puedes
	anidar los bloques <lit>if</lit> &hellip; <lit>endif</lit>.
      </para>
    </description>

  </command>

  <command name="include" section="Programming"
    label="Incluir definiciones de funciones" context="cli">

    <usage>
      <arguments>
        <argument>nombrearchivo</argument>
      </arguments>
      <options>
        <option>
	  <flag>--force</flag>
	  <effect>Fuerza a volver a leer desde el archivo</effect>
        </option>
      </options>
      <examples>
        <example>include myfile.inp</example>
        <example>include sols.gfn</example>
      </examples>
    </usage>

    <description>
      <para>
	Ideado para utilizar en un guion de instrucciones, principalmente
	para incluir definiciones de funciones. El nombre del archivo
	(<repl>nombrearchivo</repl>) debería tener la extensión <lit>inp</lit>
	(un guion de texto plano) o <lit>gfn</lit> (un paquete de funciones
	de GRETL). Las instrucciones de <repl>nombrearchivo</repl> se ejecutan
	y luego el control se devuelve al guion principal.
      </para>
      <para>
	La opción <opt>force</opt> es específica de los archivos <lit>gfn</lit> y
	su efecto consiste en forzar a GRETL a que vuelva a leer el paquete de
	funciones desde el archivo, incluso aunque ya esté cargado en la memoria.
	(Los archivos de texto plano <lit>inp</lit> siempre se leen y se procesan
	en respuesta a esta instrucción.)
      </para>
      <para>
	Consulta también <cmdref targ="run"/>.
      </para>
    </description>

  </command>

  <command name="info" section="Dataset"
    label="Información sobre el conjunto de datos" context="cli">
    <usage>
      <altforms>
	<altform><lit>info</lit></altform>
	<altform><lit>info --to-file=</lit><repl>nombrearchivo</repl></altform>
	<altform><lit>info --from-file=</lit><repl>nombrearchivo</repl></altform>
      </altforms>
    </usage>
    <description>
      <para>
	En su forma básica, presenta cualquier información adicional (metadatos)
	guardada con el archivo de datos vigente. Alternativamente, escribe esta
	información en un archivo (mediante la opción <opt>to-file</opt>), o
	lee los metadatos de un archivo especificado y los incorpora al conjunto
	de datos vigente (mediante <opt>from-file</opt>; en cuyo caso el texto
	debe tener un formato UTF-8 correcto).
      </para>
    </description>
    <gui-access>
      <menu-path>/Datos/Información del conjunto de datos</menu-path>
    </gui-access>
  </command>

  <command name="intreg" section="Estimation" label="Modelo de regresión por intervalos">

    <usage>
      <arguments>
        <argument>minvar</argument>
        <argument>maxvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
        <option>
	  <flag>--opg</flag>
	  <effect>Mira más abajo</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para más explicaciones</effect>
        </option>
      </options>
      <examples>
	<example>intreg lo hi const x1 x2</example>
	<demos>
	  <demo>wtp.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Estima un modelo de regresión por intervalos. Este modelo surge
	cuando la variable dependiente está imperfectamente observada para
	algunas observaciones (posiblemente todas). En otras palabras,
	se asume que el proceso generador de datos es
	<equation status="display" tex="\[y^*_t = x_t \beta+\epsilon_t\]" ascii="y* = x b + u"/>
	pero solo observamos
	<equation status="inline" tex="\[m_t \le y_t \le M_t\]" ascii="m &lt;= y* &lt;= M"/>
	(el intervalo puede no tener límite por la izquierda o por la derecha).
	Ten en cuenta que para algunas observaciones <math>m</math>
	puede ser igual a <math>M</math>. Las variables <repl>minvar</repl>
	y <repl>maxvar</repl> deben contener <lit>NA</lit>s para las
	observaciones sin límite por la izquierda o por la derecha,
	respectivamente.
      </para>

      <para context="gui">
	En la caja de diálogo de especificación del modelo, se identifican
	<repl>minvar</repl> y <repl>maxvar</repl> como la variable del
	límite Inferior y la variable del límite Superior, respectivamente.
      </para>

      <para>
	El modelo se estima mediante Máxima Verosimilitud, asumiendo la
	distribución Normal del término de perturbación aleatoria.
      </para>

      <para context="cli">
	Por defecto, las desviaciones típicas se calculan utilizando la inversa
	negativa de la matriz Hessiana. Cuando especificas la opción
	<opt>robust</opt>, entonces se calculan en su lugar las desviaciones
	típicas CMV (QML) o de Huber&ndash;White. En este caso, la matriz de
	covarianzas estimada es un <quote>emparedado</quote> entre la inversa
	de la matriz Hessiana estimada y el producto externo del vector gradiente. Como
	alternativa puedes indicar la opción<opt>opg</opt>, en cuyo caso las desviaciones
	típicas se basan únicamente en el producto externo del vector gradiente.
      </para>
      <para context="gui">
	Por defecto, las desviaciones típicas se calculan utilizando la inversa
	negativa de la matriz Hessiana. Si marcas el cuadradito de 'Desviaciones
	típicas robustas', entonces se calculan en su lugar las desviaciones típicas
	CMV (QML) o Huber&ndash;White. En este caso, la matriz de covarianzas
	estimada es un <quote>emparedado</quote> entre la inversa de la matriz
	Hessiana estimada y el producto externo del vector gradiente.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelo/Variable dependiente limitada/Regresión de intervalos</menu-path>
    </gui-access>

  </command>

  <command name="irfboot" section="Graphs" context="gui"
    label="Gráficos de respuesta al impulso">

    <description>
      <para>
	Si escoges la opción 'bootstrap' cuando representas respuestas al
	impulso, GRETL calcula un intervalo de confianza para las respuestas
	utilizando el método bootstrap. Se vuelve a hacer el muestreo con los
	errores del VAR (o VECM) original, con substitución; se construye
	un conjunto de datos artificial basado en las estimaciones originales
	de los parámetros y en los errores de ese nuevo muestreo; el sistema
	se vuelve a estimar y las respuestas al impulso se vuelven a evaluar.
	Por defecto, esto se repite 1999 veces, se hallan los cuantiles
	&alpha;/2 y 1 &minus; &alpha;/2 para las respuestas, y se dibujan
	junto con las estimaciones por punto. Esta opción no está disponible
	actualmente para VECMs restringidos.
      </para>
      <para>
	Este diálogo también admite la reordenación de las variables para hacer la
	descomposición de Cholesky de la matriz de covarianzas de las ecuaciones
	cruzadas. El proceder por defecto viene indicado por el orden en el que se
	introducen las variables en la especificación del modelo, pero puedes usar las
	flechas de arriba y abajo para adelantar o retrasar la variable escogida.
      </para>
      <para>
	Respecto a la escala de las respuestas al impulso, la dimensión del
	<quote>impacto</quote> se establece en una desviación típica de las
	innovaciones estimadas en la variable de origen, y las respuestas se
	proporcionan en cualquiera que sea la unidad <quote>natural</quote>
	de la variable objetivo.
      </para>
	  <para>
	  (Consulta el complemento SVAR para otras propuestas de identificación
	  de 'shocks' y para más opciones de bootstrap.)
	  </para>
    </description>

  </command>

  <command name="johansen" section="Tests" label="Contraste de cointegración de Johansen">

    <usage>
      <arguments>
        <argument>orden</argument>
        <argument>ylista</argument>
	     <argblock optional="true" separated="true">
	      <argument>xlista</argument>
	     </argblock>
	     <argblock optional="true" separated="true">
	      <argument>rxlista</argument>
	     </argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>Sin constante</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>Constante restringida</effect>
        </option>
        <option>
	  <flag>--uc</flag>
	  <effect>Constante no restringida</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>Constante y tendencia restringida</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>Constante y tendencia no restringida</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>Incluye variables ficticias estacionales centradas</effect>
        </option>
        <option>
	  <flag>--asy</flag>
	  <effect>Guarda los valores p asintóticos</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Presenta solo los contrastes</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Presenta detalles de las regresiones auxiliares</effect>
        </option>
      </options>
      <examples>
        <example>johansen 2 y x</example>
	<example>johansen 4 y x1 x2 --verbose</example>
	<example>johansen 3 y x1 x2 --rc</example>
	<demos>
	  <demo>hamilton.inp</demo>
	  <demo>denmark.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Lleva a cabo el contraste de cointegración de Johansen entre las variables
	de <repl>ylista</repl> para el orden de retardos seleccionado. Para obtener
	más detalles sobre este contraste, consulta <guideref targ="chap:vecm"/>
	o el capítulo 20 de <cite key="hamilton94">Hamilton (1994)</cite>. Las
	probabilidades asociadas (valores p) se calculan mediante la aproximación
	Gamma de Doornik <cite key="doornik98" p="true">(Doornik, 1998)</cite>.
	Se muestran dos conjuntos de valores p para el contraste de la traza: valores
	asintóticos directos y valores ajustados por el tamaño de la muestra. Por
	defecto, el accesor <fncref targ="$pvalue"/> genera la variante ajustada,
	pero puedes utilizar la opción <opt>asy</opt> para obtener en su lugar
	los valores asintóticos.
      </para>

      <para context="gui">
	Lleva a cabo el contraste de cointegración de Johansen entre las variables
	indicadas para el orden de retardos seleccionado. Para obtener más detalles
	sobre este contraste consulta, por ejemplo, el capítulo 20 del libro
	<book>Time Series Analysis</book> (1994) de Hamilton. Las probabilidades
	asociadas (valores p) se calculan mediante la aproximación Gamma de Doornik
	(1998). Se muestran dos conjuntos de valores p para el contraste de la traza:
	valores asintóticos directos y valores ajustados por el tamaño de la muestra.
      </para>

      <para context="cli">
	La inclusión de términos determinísticos en el modelo se controla mediante
	los indicadores de opción. Por defecto, si no especificas ninguna
	opción, se incluye una <quote>constante no restringida</quote>, que
	permite la presencia de una ordenada en el origen no nula en las relaciones
	de cointegración, así como una tendencia en los niveles de las variables
	endógenas. En la literatura generada a partir del trabajo de Johansen
	(por ejemplo, consulta su libro de 1995) se refiere esta situación
	como el <quote>caso 3</quote>. Las 4 primeras opciones indicadas arriba,
	que son mutuamente excluyentes, producen respectivamente los casos 1,
	2, 4 y 5. Tanto el significado de estos casos como el criterio para
	seleccionar un caso se explican en <guideref targ="chap:vecm"/>.
      </para>

      <para context="gui">
	La inclusión de términos determinísticos en el modelo se controla por medio
	de una lista desplegable de opciones. Por defecto, se incluye una
	<quote>constante no restringida</quote>, que permite la presencia
	de una ordenada en el origen no nula en las relaciones de cointegración, así
	como una tendencia en los niveles de las variables endógenas. En la literatura
	generada a partir del trabajo de Johansen (por ejemplo, consulta su
	libro de 1995) se refiere esta situación como el <quote>caso 3</quote>.
	Las 4 primeras opciones indicadas arriba producen respectivamente los
	casos 1, 2, 4 y 5. Tanto el significado de estos casos como el criterio
	para seleccionar un caso se explican en <guideref targ="chap:vecm"/>.
      </para>

      <para context="cli">
	Las listas <repl>xlista</repl> y <repl>rxlista</repl> (opcionales) te permiten
	controlar las variables exógenas especificadas, y así estas entran
	en el sistema bien sin restricciones (<repl>xlista</repl>) o bien restringidas
	al espacio de cointegración (<repl>rxlista</repl>). Estas listas
	se separan de <repl>ylista</repl> y unas de las otras mediante un
	punto y coma.
      </para>

      <para context="gui">
	Puedes controlar las variables exógenas añadiéndolas a la caja de la lista
	inferior. Por defecto, estas entran a formar parte del modelo de forma
	no restringida (indicada por una <lit>U</lit> al lado del nombre de la
	variable). Si quieres que una determinada variable exógena esté
	restringida al espacio de cointegración, pulsa con el botón derecho del
	ratón sobre ella y escoge <quote>Restringido</quote> en el menú emergente;
	y el símbolo al lado de la variable se va a cambiar a R.
      </para>

      <para context="cli">
	La opción <opt>seasonals</opt>, que puedes combinar con cualquiera de las
	otras opciones, especifica la inclusión de un conjunto de variables
	ficticias estacionales centradas. Esta opción está disponible solo
	para datos trimestrales o mensuales.
      </para>

      <para context="gui">
	Si los datos son trimestrales o mensuales, se te muestra un cuadradito de verificación que
	te permite incluir un conjunto de variables ficticias estacionales centradas. En
	todos los casos, un cuadradito de verificación adicional (<quote>Mostrar los detalles</quote>)
	permite la presentación de las regresiones auxiliares que forman el punto de comienzo
	del procedimiento de estimación máximo verosímil de Johansen.
      </para>

      <para context="notex">
	La siguiente tabla se ofrece como guía para la interpretación
	de los resultados del contraste que se muestran, para el caso con
	3 variables. <lit>H0</lit> denota la hipótesis nula, <lit>H1</lit>
	la hipótesis alternativa, y <lit>c</lit> el número de relaciones
	de cointegración.
      </para>
      <mono context="notex">
         Rango   Contraste traza      Contraste Lmáx
                  H0     H1          H0     H1
         ---------------------------------------
          0      c = 0  c = 3       c = 0  c = 1
          1      c = 1  c = 3       c = 1  c = 2
          2      c = 2  c = 3       c = 2  c = 3
         ---------------------------------------
      </mono>
      <para context="tex">
	La siguiente tabla se ofrece como guía para la interpretación
	de los resultados del contraste que se muestran, para el caso con
	3 variables. $H_0$ denota la hipótesis nula, $H_1$ la
	hipótesis alternativa, y $c$ el número de relaciones de
	cointegración.

	\begin{center}
	\begin{tabular}{cllll}
	&amp; \multicolumn{2}{c}{Contraste traza} &amp;
	   \multicolumn{2}{c}{Contraste $\lambda$-máx} \\
	Rango &amp;  \multicolumn{1}{c}{$H_0$} &amp;
	       \multicolumn{1}{c}{$H_1$} &amp;
	       \multicolumn{1}{c}{$H_0$} &amp;
	       \multicolumn{1}{c}{$H_1$} \\ [4pt]
 	0 &amp; $c$ = 0 &amp; $c$ = 3 &amp; $c$ = 0 &amp; $c$ = 1 \\
	1 &amp; $c$ = 1 &amp; $c$ = 3 &amp; $c$ = 1 &amp; $c$ = 2 \\
	2 &amp; $c$ = 2 &amp; $c$ = 3 &amp; $c$ = 2 &amp; $c$ = 3
	\end{tabular}
	\end{center}
      </para>

      <para>
	Consulta también la instrucción <cmdref targ="vecm"/>; y la instrucción
	<cmdref targ="coint"/> si quieres obtener el contraste de cointegración
	de Engle&ndash;Granger.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelo/Series temporales multivariantes</menu-path>
    </gui-access>

  </command>

  <command name="join" section="Dataset" label="Manejar fuentes de datos"
     context="cli">

    <usage>
      <arguments>
        <argument>nombrearchivo</argument>
	      <argument>nombrevar</argument>
      </arguments>
      <options>
	<option>
	  <flag>--data</flag>
	  <optparm>nombrecolumna</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--filter</flag>
	  <optparm>expresión</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--ikey</flag>
	  <optparm>claveinterna</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--okey</flag>
	  <optparm>claveexterna</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--aggr</flag>
	  <optparm>método</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--tkey</flag>
	  <optparm>nombrecoluma,cadenaformato</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Informe en marcha</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Esta instrucción incorpora una o más series desde el origen
	<repl>nombrearchivo</repl> (que debe ser bien un archivo de datos con
	el texto delimitado, o bien un archivo de datos <quote>propio</quote>
	de GRETL), con el nombre <repl>nombrevar</repl>. Para obtener más
	detalles, consulta <guideref targ="chap:join"/> pues aquí damos solo
	un breve resumen de las opciones disponibles. Consulta también
	<cmdref targ="append"/> para operaciones de anexión más simples.
      </para>
      <para>
	Puedes utilizar la opción <opt>data</opt> para especificar el
	encabezamiento de los datos del archivo de origen, si difiere del
	nombre por el que los datos debieran de conocerse en GRETL.
      </para>
      <para>
	Puedes usar la opción <opt>filter</opt> para especificar un
	criterio para filtrar los datos de origen (es decir, para escoger
	un subconjunto de las observaciones).
      </para>
      <para>
	Puedes utilizar las opciones <opt>ikey</opt> y <opt>okey</opt> para
	especificar una equivalencia entre las observaciones del conjunto
	vigente de datos y las observaciones de la fuente de datos (por ejemplo,
	los individuos pueden hacerse corresponder con el hogar al que pertenecen).
      </para>
      <para>
	La opción <opt>aggr</opt> se utiliza cuando la equivalencia entre
	las observaciones del conjunto vigente de datos y las del origen no
	es de una a una.
      </para>
      <para>
	La opción <opt>tkey</opt> se aplica solo cuando el conjunto vigente
	de datos tiene una estructura de serie temporal. Puedes usarla para
	especificar, bien el nombre de una columna que contenga fechas que van
	a ser emparejadas con el conjunto de datos, y/o bien el formato en el que
	las fechas se representan en esa columna.
      </para>
      <subhead>Incorporación de más de una serie al mismo tiempo</subhead>
      <para>
	Con la instrucción <cmd>join</cmd> puedes manejar la incorporación
	de varias series al mismo tiempo. Esto sucede si el argumento
	<repl>nombrevar</repl>: (a) consiste en una lista de nombres separados
	por espacios, en lugar de un único nombre; o (b) apunta a un 'array'
	de cadenas de texto, cuyos elementos deben ser los nombres de las
	series que se pretende incorporar.
      </para>
      <para>
	Sin embargo, este método tiene alguna limitación como el hecho de que la
	opción <opt>data</opt> en este caso no está disponible. Y cuando incorporas
	múltiples series, estás obligado a aceptar los nombres <quote>externos</quote>
	que ya tienen. Las demás opciones se aplican de modo uniforme a todas
	las series que se incorporan mediante una instrucción concreta.
      </para>
    </description>

  </command>

  <command name="join" section="Dataset" label="Añadir datos con controles"
     context="gui">
    <description>
    <para>
	    Este diálogo te da acceso a cierta funcionalidad (pero no toda)
	    de la instrucción <lit>join</lit>. Para obtener detalles más completos,
	    consulta <guideref targ="chap:join"/>.
    </para>
    <para>
	    En la izquierda deberías de ver un listado de las series del conjunto de datos
	    vigente. Aquí puedes escoger una serie, y utilizar los botones con las flechas
	    para especificarla como una u otra de las <quote>claves internas</quote>
	    (opcionales). Las claves funcionan para emparejar filas entre el conjunto
	    vigente de datos y el archivo del que estés importando datos.
    </para>
    <para>
	    En la derecha deberían listarse las series del archivo de datos que
	    escogiste. Puedes usar los botones con las flechas para elegir el nombre
	    de las series a importar de esa lista, y (de ser necesario) los nombres
	    de las series que se corresponden con las claves <quote>internas</quote>.
	    (Por defecto, se supone que las claves internas y externas tienen el mismo
	    nombre.) En esta lista también puedes ver una entrada <quote>ficticia</quote>
	    titulada <lit>$obsmajor</lit> que, aún no pudiendo importarse,
	    puede ser usada como clave; consulta <fncref targ="$obsmajor"/>.
    </para>
    <para>
	    En medio del cuadro de diálogo puedes especificar parámetros
	    adicionales para la operación <quote>join</quote>:
    </para>
    <ilist>
      <li>
	<para>
	  Un nombre con el que se deberá reconocer a la serie importada. (Por
	  defecto, este es el mismo que el nombre a <quote>importar</quote>).
	</para>
      </li>
      <li>
	<para>
	  Una expresión como filtro. Esta se va a evaluar para cada fila del
	  conjunto de datos externo, y solo se van a importar las filas en las que
	  la expresión proporcione un valor no nulo.
	</para>
      </li>
      <li>
	<para>
	  Un método de agregación. Este se requiere solo cuando el emparejamiento
	  mediante las claves selecciona más de un valor externo para cada
	  observación interna.
	</para>
      </li>
    </ilist>
    <subhead>Datos de series temporales</subhead>
    <para>
      Cuando la base de datos vigente consiste en series temporales, es
      muy probable que los datos que vayas a añadir sean también series de
      tiempo. En ese caso, es posible que GRETL averigüe la unión sin ayuda
      de las claves específicas de usuario. Esto se indica mediante la cadena
      de texto <quote>detectar automáticamente</quote>, del marcador de
      posición en las cajas de entrada de claves internas. Puesto que no hay
      garantía de que esto haga exactamente lo que deseas, probablemente
      valga la pena que pruebes antes a recurrir a un enfoque más complejo.
    </para>
    </description>
  </command>

  <command name="kalman" section="Utilities"
	   label="Modelado del espacio de estados" context="gui">
    <description>
      <para>
	Esta interfaz gráfica ofrece una pequeña muestra de la funcionalidad
	que está disponible mediante la creación de secuencias de comando en
	el mecanismo sobre estado de espacios de GRETL.
      </para>
      <para>
	Si te interesa lo que estás leyendo aquí, por favor, echa un vistazo a
	<guideref targ="chap:kalman"/> (titulado <quote>State Space Modeling</quote>).
	Ahí encontrarás detalles sobre cómo manejar matrices que varían con el
	tiempo, perturbaciones que están correlacionadas a través de observaciones
	y ecuaciones de transición entre estados, y mucho más. También vas a
	encontrar varios guiones de ejemplo que se pueden descargar. Estos
	ejemplos ilustran, entre otras cosas, como conectar el filtro de Kalman
	de GRETL con su maximizador de la verosimilitud.
      </para>
    </description>
  </command>

  <command name="kdplot" section="Graphs" label="Gráfico de la densidad del Kernel">
    <usage>
      <arguments>
	<argument>y</argument>
      </arguments>
      <options>
	<option>
	  <flag>--alt</flag>
	  <effect>Utiliza el kernel de Epanechnikov</effect>
        </option>
        <option>
	  <flag>--scale</flag>
	  <optparm>s</optparm>
	  <effect>Factor de ajuste del ancho de banda</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el gráfico al archivo indicado</effect>
        </option>
      </options>
    </usage>
    <description>
      <para>
	Representa un gráfico con la estimación de la densidad del kernel para
	la serie <argname>y</argname>. Por defecto, el kernel es Gaussiano pero
	si indicas la opción <opt>alt</opt>, se utiliza el kernel de
	Epanechnikov. Puedes ajustar el grado de suavizado mediante la opción
	<opt>scale</opt>, que tiene un valor predeterminado de 1.0
	(los valores más grandes de <repl>s</repl> producen un resultado
	más suavizado).
      </para>
      <para context="cli">
	La opción <opt>output</opt> tiene como efecto el envío del resultado al
	archivo que se indique en ella; utiliza la palabra <quote>display</quote>
	para forzar que el resultado aparezca en la pantalla. Consulta la instrucción
	<cmdref targ="gnuplot"/> para obtener más detalles sobre esta opción.
      </para>
      <para>
	Para obtener medios más flexibles para generar estimaciones de la
	densidad del kernel, con la posibilidad de recuperar el resultado en
	forma de matriz, consulta la función <fncref targ="kdensity"/>.
      </para>
    </description>
    <gui-access>
      <menu-path>/Variable/Gráfico de la densidad estimada</menu-path>
    </gui-access>
  </command>

  <command name="kpss" section="Tests" label="Contraste de estacionariedad KPSS">

    <usage>
      <arguments>
        <argument>orden</argument>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--trend</flag>
	  <effect>Incluye una tendencia</effect>
	</option>
	<option>
	  <flag>--seasonals</flag>
	  <effect>Incluye variables ficticias estacionales</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los resultados de la regresión</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>Utiliza la primera diferencia de la variable</effect>
	</option>
      </options>
      <examples>
	<example>kpss 8 y</example>
        <example>kpss 4 x1 --trend</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Calcula el contraste de estacionariedad KPSS (Kwiatkowski, Phillips, Schmidt
	y Shin, Journal of Econometrics, 1992) de la variable indicada (o de su
	primera diferencia, si escoges la opción de usar las primeras diferencias).
	La hipótesis nula es que la variable en cuestión es estacionaria, bien alrededor
	de un nivel o, si marcas el cuadradito de <quote>Incluir una tendencia</quote>,
	alrededor de una tendencia lineal determinística.
      </para>

      <para context="cli">
	Para utilizar esta instrucción con datos de panel, consulta la sección
	final de estas anotaciones.
      </para>

      <para context="cli">
	Calcula el contraste de estacionariedad KPSS
	<cite key="KPSS92" p="true">(Kwiatkowski et al, Journal of Econometrics, 1992)</cite>
	para cada una de las variables indicadas (o para sus primeras
	diferencias, si escoges la opción <opt>difference</opt>). La hipótesis
	nula es que la variable en cuestión es estacionaria, bien alrededor de un
	nivel o, si marcas la opción <opt>trend</opt>, alrededor de una tendencia
	lineal determinística.
      </para>

      <para context="gui">
	El orden de retardos seleccionado determina el tamaño de la ventana
	utilizada para el suavizado de Bartlett. Si marcas el cuadradito de
	<quote>Mostrar los resultados de la regresión</quote>, se presentan
	los resultados de la regresión auxiliar, junto con la varianza estimada
	de la componente de paseo aleatorio de la variable.
      </para>

      <para context="cli">
	El argumento <repl>orden</repl> determina el tamaño de la ventana
	utilizada para el suavizado de Bartlett. Cuando indicas un valor
	negativo, eso se toma como señal para que se utilice una ventana
	automática de tamaño 4(<math>T</math>/100)<sup>0.25</sup>, donde
	<math>T</math> es el tamaño de la muestra.
      </para>

      <para context="cli">
	Si escoges la opción <opt>verbose</opt>, se presentan los resultados
	de la regresión auxiliar junto con la varianza estimada de la componente de
	paseo aleatorio de la variable.
      </para>

      <para>
	Los puntos críticos mostrados para el estadístico de contraste se basan
	en superficies de respuesta estimadas del modo establecido por
	<cite key="sephton95">Sephton (Economics Letters, 1995)</cite>,
	que son más fiables para muestras pequeñas que los valores indicados
	en el artículo original de KPSS. Cuando el estadístico de contraste cae entre
	los puntos críticos del 1 y del 10 por ciento, se muestra una probabilidad
	asociada (valor p) que se obtiene mediante interpolación lineal y
	no debe tomarse demasiado literalmente. Consulta la función
	<fncref targ="kpsscrit"/> para ver un medio de obtener esos puntos
	críticos con la ayuda del programa.
      </para>

      <subhead context="cli">Datos de panel</subhead>

      <para context="cli">
	Cuando se utiliza la instrucción <lit>kpss</lit> con datos de panel, para
	realizar un contraste de raíz unitaria de panel, las opciones aplicables
	y los resultados mostrados son algo diferentes. Mientras que en el caso
	habitual de series temporales, puedes indicar una lista de variables
	para contrastar, con datos de panel solo puedes contrastar una variable
	por cada instrucción. Y la opción <opt>verbose</opt> tiene un significado
	diferente, pues genera una breve presentación del contraste para cada serie
	temporal individual (ya que, por defecto, solo se muestra el resultado global).
      </para>
      <para context="cli">
	Cuando es posible, se calcula el contraste global (Hipótesis nula:
	La serie en cuestión es estacionaria para todas las unidades del
	panel) utilizando para ello el método de
	<cite key="choi01">Choi (Journal of International Money and Finance, 2001)</cite>.
	Esto no siempre es sencillo pues la dificultad está en que, mientras
	que el contraste de Choi se basa en las probabilidades asociadas de los
	contrastes con las series individuales, no tenemos actualmente un
	modo de calcular las probabilidades asociadas para el estadístico
	de contraste KPSS; debemos apoyarnos en unos pocos puntos críticos.
      </para>
      <para context="cli">
	Si el estadístico de contraste con una determinada serie, cae entre los puntos críticos
	del 1 y del 10 por ciento, podemos interpolar una probabilidad asociada.
	Pero si el valor del estadístico del contraste cae por debajo del correspondiente
	al 10 por ciento o si excede al del 1 por ciento, no se puede interpolar y como
	mucho se puede establecer un límite sobre el contraste de Choi global. Si el valor
	del estadístico de contraste individual cae por debajo del correspondiente al 10
	por ciento para unas unidades y excede al del 1 por ciento para otras, ni
	siquiera se puede calcular un límite para el contraste global.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Contrastes de raíz unitaria/Contraste KPSS</menu-path>
    </gui-access>

  </command>

  <command name="labels" section="Dataset"
    label="Etiquetas de variables" context="cli">

    <usage>
      <altforms>
	<altform><lit>labels [</lit> <repl>listavariables</repl> <lit>]</lit></altform>
	<altform><lit>labels --to-file=</lit><repl>nombrearchivo</repl></altform>
	<altform><lit>labels --from-file=</lit><repl>nombrearchivo</repl></altform>
	<altform><lit>labels --delete</lit></altform>
      </altforms>
	<examples>
	<demos>
	  <demo>oprobit.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Con la primera forma, se presentan las etiquetas informativas
	(si existen) de las series de <repl>listavariables</repl>,
	o de todas las series del conjunto de datos cuando no especificas
	<repl>listavariables</repl>.
      </para>
      <para>
	Con la opción <opt>to-file</opt> se escriben en el archivo indicado, las
	etiquetas de todas las series del conjunto de datos, una etiqueta por
	cada línea. Si no hay ninguna etiqueta, se muestra un fallo; y si algunas
	series tienen etiqueta y otras no, se presenta una línea en blanco para
	las series sin etiqueta. El archivo resultante se va a escribir en el directorio
	<cmdref targ="workdir"/> vigente en ese momento, excepto que la cadena
	<repl>nombrearchivo</repl> contenga una especificación completa de la ruta.
      </para>
      <para>
	Con la opción <opt>from-file</opt>, se lee el archivo especificado
	(que debe ser de texto plano) y se asignan etiquetas a las series
	del conjunto de datos, leyéndose una etiqueta por línea y usando
	líneas en blanco para indicar etiquetas en blanco.
      </para>
      <para>
	La opción <opt>delete</opt> hace lo que cabría esperar pues elimina
	todas las etiquetas de las series del conjunto de datos.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos/Etiquetas de variables</menu-path>
    </gui-access>

  </command>

  <command name="lad" section="Estimation"
    label="Estimación de la Mínima Desviación Absoluta">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--no-vcv</flag>
	  <effect>No calcula la matriz de covarianzas</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
	      </option>
      </options>
    </usage>

    <description>
      <para>
	Calcula una regresión que minimiza la suma de las desviaciones absolutas
	de los valores ajustados respecto a los valores observados de la variable
	dependiente. Las estimaciones de los coeficientes se derivan utilizando el
	algoritmo del simplex de Barrodale&ndash;Roberts; y se presenta una
	advertencia si la solución no es única.
      </para>
      <para>
	Las desviaciones típicas se deducen utilizando el procedimiento 'bootstrap'
	con 500 extracciones. La matriz de covarianzas de los estimadores de los
	parámetros, que se presenta cuando indicas <opt>vcv</opt>, se basa en
	el mismo 'bootstrap'. Puesto que esta es una operación bastante costosa,
	la opción <opt>no-vcv</opt> se proporciona para aquellos casos en los que
	no se necesita la matriz de covarianzas; cuando indicas esta opción, las
	desviaciones típicas no van a estar disponibles.
      </para>
      <para>
	Ten en cuenta que este método puede resultar lento cuando la muestra
	es muy larga o cuando hay muchos regresores. Por eso, en esos casos,
	puede ser mejor utilizar la instrucción <cmdref targ="quantreg"/>.
	Dadas una variable dependiente <lit>y</lit> junto con una lista <lit>X</lit>
	de regresores, las siguientes instrucciones son básicamente equivalentes,
	con la excepción de que el método "quantreg" utiliza el algoritmo más
	rápido de Frisch&ndash;Newton, y que proporciona las desviaciones
	típicas analíticas en lugar de las de "bootstrapping".
      </para>
      <code>
	lad y const X
	quantreg 0.5 y const X
      </code>
    </description>

    <gui-access>
      <menu-path>/Modelo/Estimación robusta/Mínima desviación absoluta</menu-path>
    </gui-access>

  </command>

  <command name="lags" section="Transformations" label="Generar retardos"
     context="cli">

    <usage>
      <arguments>
        <argument optional="true" separated="true">orden</argument>
	      <argument>listaretardos</argument>
      </arguments>
      <options>
	<option>
	  <flag>--bylag</flag>
	  <effect>Ordena los términos por retardo</effect>
	</option>
      </options>
      <examples>
	<example>lags x y</example>
	<example>lags 12 ; x y</example>
	<example>lags 4 ; x1 x2 x3 --bylag</example>
	<demos>
	  <demo>sw_ch12.inp</demo>
	  <demo>sw_ch14.inp</demo>
	</demos>
	    </examples>
    </usage>

    <description>
      <para>
	Genera nuevas series que contienen los valores retardados de cada
	una de las series de <repl>listavariables</repl>. Por defecto, el
	número de retardos que se crean es igual a la periodicidad
	de los datos. Por ejemplo, si la periodicidad es 4 (trimestral),
	la instrucción <cmd>lags x</cmd> genera
      </para>
      <mono>
	x_1 = x(t-1)
	x_2 = x(t-2)
	x_3 = x(t-3)
	x_4 = x(t-4)
      </mono>
      <para>
	Puedes controlar el número de retardos generados mediante el
	primer parámetro opcional (que, si existe, debe estar
	seguido de un punto y coma).
      </para>
      <para>
	La opción <opt>bylag</opt> tiene sentido solo cuando <repl>listavariables</repl>
	contiene más de una serie y el orden máximo de retardos es mayor que 1.
	Por defecto, se añaden los términos retardados al conjunto de datos,
	por variable: primero todos los retardos de la primera serie de la lista,
	después todos los retardos de la segunda serie, etcétera. Pero cuando
	indicas <opt>bylag</opt>, la ordenación se hace por retardos: primero
	el retardo 1 de todas las series de la lista, después el retardo 2 de todas
	as series de la lista, etcétera.
      </para>
      <para>
  Esta prestación también está disponible como función: consulta
  <fncref targ="lags"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Añadir/Retardos de las variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="lags-dialog" section="Estimation" context="gui"
    label="Cuadro de selección de retardos">

    <description>
      <para>
	En este diálogo puedes elegir el orden de retardos para las variables independientes
	del modelo de series temporales y, en algunos casos, también para la variable dependiente.
	(Pero ten en cuenta que el orden de retardos habitual para modelos de vectores
	como VARs y VECMs se maneja por separado, mediante un botón con flechas
	arriba/abajo de selección, en la caja de diálogo principal del modelo.)
      </para>
      <para>
	Los botones con flechas arriba/abajo de la izquierda te permiten escoger un
	rango de retardos consecutivos para cualquier variable dada. Para indicar
	retardos no consecutivos, pulsa un clic en el cuadradito al lado del campo con el
	título <quote>Retardos específicos</quote>. Esto activa la caja de anotación,
	en la que puedes teclear una lista de retardos separados por espacios.
      </para>
      <para>
	La fila titulada <quote>Por defecto</quote> te ofrece un modo rápido de
	establecer una especificación de retardos común para todas las variables
	independientes, pues los valores colocados en esa fila se copian a todas las
	otras (excepto de la variable dependiente, si está presente).
      </para>
      <para>
	La variable dependiente se trata de modo especial: el retardo mínimo
	debe ser cero, lo que sitúa al valor actual de la variable en el lado
	izquierdo del modelo. Cualquier retardo mayor aparece con las variables
	independientes en el lado derecho del modelo.
      </para>
      <para>
	Los valores seleccionados en este diálogo se recuerdan a lo largo de la duración
	de tu sesión con un conjunto determinado de datos.
      </para>

    </description>

  </command>

  <command name="ldiff" section="Transformations"
    label="Diferencias logarítmicas" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Se obtiene la primera diferencia del logaritmo natural de cada una
	de las series de <repl>listavariables</repl>, y el resultado se guarda en una
	nueva serie con el prefijo <lit>ld_</lit>. Así <cmd>ldiff x y</cmd>
	genera las nuevas variables
      </para>
      <mono>
	ld_x = log(x) - log(x(-1))
	ld_y = log(y) - log(y(-1))
      </mono>
    </description>

    <gui-access>
      <menu-path>/Añadir/Diferencias de logaritmos de las variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="leverage" section="Tests" label="Observaciones influyentes">

    <usage>
      <options>
	<option>
	  <flag>--save</flag>
	  <effect>Guarda las series resultantes</effect>
	</option>
	<option>
	  <flag>--overwrite</flag>
	  <effect>Conformidad para sobrescribir series ya existentes</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
	<option>
	  <flag>--plot</flag>
	  <optparm>Modo-o-nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
	</option>
      </options>
	<examples>
	<demos>
	  <demo>leverage.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Debe ir después de una instrucción de MCO (<cmd>ols</cmd>). Calcula
	el apalancamiento (<math>h</math>, que debe caer en el rango entre 0 y 1)
	para cada punto de datos de la muestra sobre la que se estimó el modelo
	previo. Muestra el error (<math>u</math>) para cada observación junto
	con su apalancamiento y una medida de su influencia en las estimaciones,
	<math>uh</math>/(1 &minus; <math>h</math>).
	Los <quote>puntos de Leverage</quote> para los que el valor de
	<math>h</math> supera 2<math>k</math>/<math>n</math> (donde
	<math>k</math> es el número de parámetros que se estiman y
	<math>n</math> es el tamaño de la muestra) se destacan mediante
	un asterisco. Para obtener más detalles sobre los conceptos
	de apalancamiento e influencia, consulta el capítulo 2 del libro de
	<cite key="davidson-mackinnon93">Davidson y MacKinnon (1993)</cite>.
      </para>
      <para context="tex">
	También se calculan los valores DFFITS: estos son iguales a los Errores
	tipificados (errores divididos por sus desviaciones típicas) multiplicados
	por $\sqrt{h/(1 - h)}$. Proporcionan una medida de la diferencia en el
	ajuste de la observación <math>i</math> dependiendo de si esa observación
	está incluida o no en la muestra de la estimación. Para más información
	sobre este apartado, consulta el capítulo 12 del libro de Maddala
	<cite key="maddala92">Introduction to Econometrics</cite>
	o <cite key="belsley-etal80">Belsley, Kuh y Welsch (1980)</cite>.
	Para más detalles sobre los Errores tipificados consulta más abajo,
	la sección titulada <emphasis>Matriz mediante accesor</emphasis>.
      </para>
      <para context="notex">
	También se calculan los valores DFFITS: estos son iguales a los Errores
	tipificados (errores divididos por sus desviaciones típicas) multiplicados
	por la raíz cuadrada de <math>h</math>(1 &minus; <math>h</math>).
	Proporcionan una medida de la diferencia en el ajuste de la observación
	<math>i</math> dependiendo de si esa observación está incluida o no
	en la muestra de la estimación. Para más información sobre este
	apartado, consulta el capítulo 12 del libro de Maddala
	<cite key="maddala92">Introduction to Econometrics</cite>
	o <cite key="belsley-etal80">Belsley, Kuh y Welsch (1980)</cite>.
	Para más detalles sobre los Errores tipificados consulta más abajo,
	la sección titulada <emphasis>Matriz mediante accesor</emphasis>.
      </para>
      <para context="cli">
	Cuando especificas la opción <opt>save</opt> con esta instrucción,
	los valores de apalancamiento, influencia y DFFITS se añaden al
	conjunto vigente de datos; en este contexto, puedes utilizar la opción
	<opt>quiet</opt> para eliminar la presentación de los resultados. Los
	nombres por defecto de las series guardadas son <lit>lever</lit>,
	<lit>influ</lit> y <lit>dffits</lit>, respectivamente. Si ya
	existen series con esos nombres, lo que suceda dependerá de si
	indicas la opción <opt>overwrite</opt>, pues en ese caso se van
	a sobrescribir las series ya existentes. En caso contrario, los
	nombres se van a ajustar para poder garantizar la unicidad, y las
	nuevas series generadas serán las 3 series con números ID más
	grandes del conjunto de datos.
      </para>
      <para context="gui">
	Con el icono '+' de la parte de arriba de la ventana del contraste de apalancamiento,
	puedes presentar en la pantalla una caja de diálogo que te permite guardar
	en el conjunto vigente de datos, una o más de las variables de ese contraste.
      </para>
      <para context="tex">
	Después de la ejecución, el accesor <fncref targ="$test"/> devuelve el criterio
	de validación cruzada, que se define como
        \[
	\sum_{i=1}^n (y_i - \hat{y}_{-i})^2
        \]
	donde $\hat{y}_{-i}$ es el error de predicción para la observación
	$i$-ésima, después de que esta sea excluida de la muestra. Por eso, el
	criterio es igual a la suma de los errores cuadrados de predicción cuando se
	utilizan todas las $n$ observaciones excepto la $i$-ésima para predecir
	(el denominado estimador <emphasis>dejar-uno-fuera</emphasis>).
	Para una discusión más amplia sobre el criterio de validación
	cruzada, consulta el libro de Davidson y MacKinnon
	<book>Econometric Theory and Methods</book>, páginas 685--686,
	y las referencias que contiene.
      </para>
      <para context="notex">
	Después de la ejecución, el accesor <fncref targ="$test"/> devuelve el criterio
	de validación cruzada, que se define como la suma de las desviaciones cuadradas
	de la variable dependiente con relación a sus valores de predicción,
	estando la predicción para cada observación basada en una muestra de la
	que se excluye esa observación. (Este es el conocido como estimador
	<emphasis>dejar-uno-fuera</emphasis>). Para una discusión más amplia sobre
	el criterio de validación cruzada, consulta el libro de Davidson y MacKinnon
	<book>Econometric Theory and Methods</book>, páginas 685&ndash;686, y
	las referencias que contiene.
      </para>
      <para context="cli">
	Por defecto, si haces una llamada interactiva a esta instrucción, se
	muestra un gráfico con los valores de apanlancamiento e influencia.
	Puedes axustar esto mediante la opción <opt>plot</opt>. Los parámetros
	que se admiten para esta opción son <lit>none</lit> (para suprimir el
	gráfico), <lit>display</lit> (para mostrar un gráfico incluso al estar en modo
	de guiones), o un nombre de archivo. El efecto de indicar un nombre
	de archivo es como el descrito para la opción <opt>output</opt> de la
	instrucción <cmdref targ="gnuplot"/>.
      </para>
      <subhead context="cli">Matriz mediante accesor</subhead>
      <para context="cli">
	Además de la opción <opt>save</opt> señalada  antes, puedes recuperar
	los resultados de esta instrucción en formato de una matriz de tres
	columnas por medio del accesor <fncref targ="$result"/>. Las dos
	primeras columnas de la mencionada matriz contienen los valores de
	apalancamiento y de influencia (como con <opt>save</opt>), pero la
	tercera columna contiene los Errores tipificados, en lugar de los valores
	DFFITS. Estos son errores <quote>Tipificados externamente</quote>
	o <quote>navajeados (jackknifed)</quote> &mdash;es decir, la desviación
	típica que está en el divisor para la observación <math>i</math> utiliza
	la media de los cuadrados de los errores, omitiendo esa observación.
	Ese tipo de error puede interpretarse como un estadístico de prueba
	<math>t</math> para la hipótesis de que una variable ficticia 0/1 que
	codifica de forma especial la observación <math>i</math>, tendría un
	coeficiente real nulo. Para obtener más detalles sobre la discusión
	adicional en torno a los Errores tipificados, consulta
	<cite key="chatterjee-hadi86">Chatterjee e Hadi (1986)</cite>.
      </para>
      <para>
	Los valores DFFITS también pueden obtenerse a partir de la matriz de
	<lit>$result</lit> del siguiente modo:
      </para>
      <code>
	R = $result
	dffits = R[,3] .* sqrt(R[,1] ./ (1-R[,1]))
      </code>
      <para>
	O utilizando series:
      </para>
      <code>
	series h = $result[,1]  # Apalancamiento
	series sr = $result[,3] # Error tipificado
	series dffits = sr * sqrt(h/(1-h))
      </code>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Análisis/Observaciones influyentes</menu-path>
    </gui-access>

  </command>

  <command name="levinlin" section="Tests" label="Contraste de Levin-Lin-Chu">

    <usage>
      <arguments>
        <argument>orden</argument>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>Sin constante</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>Con constante y tendencia</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los resultados por unidad</effect>
	</option>
      </options>
      <examples>
	<example>levinlin 0 y</example>
        <example>levinlin 2 y --ct</example>
        <example>levinlin {2,2,3,3,4,4} y</example>
      </examples>
    </usage>

    <description>
      <para>
	Realiza el contraste de raíz unitaria para panel descrita por
	<cite key="LLC2002">Levin, Lin y Chu (2002)</cite>. La hipótesis
	nula es que todas las series temporales individuales presentan una
	raíz unitaria, y la alternativa es que ninguna de las series tiene una
	raíz unitaria. (Es decir, se asume un mismo coeficiente común de
	AR(1), aunque en otros aspectos se permite que las propiedades
	estadísticas de las series varíen de unos individuos a otros.)
      </para>
	    <para context="cli">
	Por defecto, las regresiones del contraste ADF incluyen una constante.
	Para eliminar la constante utiliza la opción <opt>nc</opt> y para
	incluirla junto con una tendencia lineal utiliza la opción <opt>ct</opt>.
	(Consulta la instrucción <cmdref targ="adf"/> para una explicación
	de las regresiones del ADF.)
      </para>
      <para context="cli">
	Puedes indicar el orden de retardo con <repl>orden</repl> (no negativo)
	para hacer el contraste (controlando así el número de retardos de la variable
	dependiente a incluir en las regresiones del ADF) de una de estas dos formas.
	Cuando indicas un valor escalar, esto se aplica a todos los individuos
	del panel. La alternativa es proporcionar una matriz que contenga un
	orden específico de retardos para cada individuo; esta debe ser
	un vector con tantos elementos como individuos haya en el rango de la
	muestra vigente. Puedes especificar esa matriz con el nombre o construirla
	utilizando llaves, como se ilustró en el último ejemplo de
	arriba.
      </para>
      <para context="cli">
	Cuando indicas la opción <opt>verbose</opt>, se presentan los
	siguientes resultados para cada unidad del panel:
	<lit>delta</lit>, el coeficiente del nivel retardado en cada
	regresión ADF; <lit>s2e</lit>, la varianza estimada de las
	innovaciones; y <lit>s2y</lit>, la varianza estimada a largo
	plazo de la serie diferenciada.
      </para>
      <para>
	Observa que los contrastes de raíz unitaria en un panel también puedes hacerlos
	utilizando las instrucciones <cmdref targ="adf"/> y <cmdref targ="kpss"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Contrastes de raíz unitaria/Contraste Levin-Lin-Chu</menu-path>
    </gui-access>

  </command>

  <command name="loess" section="Estimation" label="Loess" context="gui">
    <description>
      <para>
	Realiza la regresión local (polinómica ponderada localmente) y
	genera una serie que contiene los valores predichos de la variable
	dependiente para cada valor no ausente de la variable independiente.
	El método es como se describe por
	<cite key="cleveland79">William Cleveland (1979)</cite>.
      </para>
      <para>
	Los controles te permiten que especifiques el orden del polinomio
	de la variable independiente y la proporción de puntos de datos que
	se utilizan en cada regresión local (el ancho de banda). Los
	valores más grandes del ancho de banda producen un resultado
	más suave.
      </para>
      <para>
	Si marcas el cuadradito de ponderaciones robustas, el procedimiento
	de regresión local se reitera dos veces, con la modificación de las
	ponderaciones en base a los errores de la iteración previa, de modo que
	se le dé menos influencia a los valores atípicos.
      </para>
     </description>
  </command>

  <command name="logistic" section="Estimation" label="Regresión logística">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--ymax</flag>
	  <optparm>máximo</optparm>
	  <effect>Especifica el máximo de la variable dependiente</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para una explicación</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--fixed-effects</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
	</option>
      </options>
      <examples>
        <example>logistic y const x</example>
        <example>logistic y const x --ymax=50</example>
      </examples>
    </usage>

    <description>
      <para>
	Regresión logística: Lleva a cabo una regresión MCO utilizando
	la transformación logística de la variable dependiente,
	<equation status="display"
	  tex="\[\log\left(\frac{y}{y^*-y}\right)\]"
	  ascii="log(y/(y* - y))"
	  graphic="logistic1"/>
	En caso de usar datos de panel, la especificación puede incluír los
	efectos fijos individuales.
      </para>
      <para>
	La variable dependiente debe ser estrictamente positiva. Si
	todos sus valores están entre 0 y 1, por defecto se utiliza
	un valor de <math>y</math><sup>*</sup> (el máximo asintótico de la
	variable dependiente) igual a 1; si sus valores están entre
	0 y 100, entonces <math>y</math><sup>*</sup> es 100 por defecto.
      </para>
      <para context="cli">
	Si quieres establecer un máximo diferente, utiliza la opción
	<opt>ymax</opt>. Ten en cuenta que el valor que indiques debe
	ser mayor que todos los valores observados de la variable
	dependiente.
      </para>
      <para context="gui">
	Puedes especificar un valor máximo diferente para <math>y</math>.
	Ten en cuenta que el valor que indiques debe ser mayor que
	todos los valores observados de la variable dependiente.
      </para>
      <para>
	Los valores ajustados y los errores de la regresión se transforman
	automáticamente utilizando la inversa de la transformación
	logística:
	<equation status="display"
	  tex="\[y \approx E\left(\frac{y^*}{1+e^{-x}}\right)\]"
	  ascii="y =~ E(y* / (1 + exp(-x)))"
	  graphic="logistic2"/>
	donde <math>x</math> representa un valor ajustado o un error,
	obtenidos de la regresión MCO que utiliza la variable dependiente
	logística. De este modo puedes comparar los valores que se
	presentan con los de la variable dependiente original. La aproximación
	es necesaria pues la transformación inversa no es lineal, y por lo tanto
	la esperanza no se corresponde exactamente.
      </para>
      <para>
	La opción <opt>fixed-effects</opt> solo es aplicable cuando el conjunto
	de datos tiene forma de panel. En ese caso, se le restan las medias de
	grupo de la transformación logística de la variable dependiente, y la
	estimación continúa como se hace habitualmente con efectos fijos.
      </para>
      <para>
	Ten en cuenta que si la variable dependiente es binaria, debes
	utilizar en su lugar la instrucción <cmdref targ="logit"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Variable dependiente limitada/Logística</menu-path>
      <menu-path>/Modelo/Panel/Logística FE</menu-path>
    </gui-access>

  </command>

  <command name="logit" section="Estimation"
    label="Regresión Logit">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Desviaciones típicas agrupadas</effect>
        </option>
	<option>
	  <flag>--multinomial</flag>
	  <effect>Estima un logit multinomial</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>Muestra los valores p en vez de las pendientes</effect>
	</option>
	<option>
	  <flag>--estrella</flag>
	  <effect>Elige la variante pseudo-R-cuadrado</effect>
	</option>
      </options>
	<examples>
	<demos>
	  <demo>keane.inp</demo>
	  <demo>oprobit.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Si la variable dependiente es una variable binaria (todos sus
	valores son 0 o 1), se obtienen estimaciones máximo verosímiles
	de los coeficientes de las variables de <repl>indepvars</repl>
	mediante el método de Newton&ndash;Raphson. Como el modelo es no
	lineal, las pendientes están condicionadas por los valores de las
	variables independientes. Por defecto, se calculan las pendientes
	con respecto a cada una de las variables independientes (en las
	medias de esas variables), y estas pendientes substituyen los valores
	p habituales en el resultado de la regresión. Puedes prescindir de
	este proceder indicando la opción <opt>p-values</opt>. El estadístico
	chi-cuadrado contrasta la hipótesis nula de que todos los coeficientes
	son cero, excepto el de la constante.
      </para>
      <para context="cli">
	Por defecto, las desviaciones típicas se calculan utilizando la inversa
	negativa de la matriz Hessiana. Si indicas la opción <opt>robust</opt>,
	entonces se calculan en su lugar las desviaciones típicas CMV (QML) o de
	Huber&ndash;White. En este caso, la matriz de covarianzas estimadas es un
	<quote>emparedado</quote> entre la inversa de la matriz Hessiana estimada
	y el producto externo del vector gradiente; consulta el capítulo 10 del libro de
	<cite key="davidson-mackinnon04">Davidson y MacKinnon (2004)</cite>.
	Pero cuando indicas la opción <opt>cluster</opt>, entonces se generan las
	desviaciones típicas <quote>robustas por agrupación</quote>;
	consulta <guideref targ="chap:robust_vcv"/> para obtener más
	detalles.
      </para>
      <para context="cli">
	Por defecto, se va a presentar el estadístico pseudo-R-cuadrado que
	fue sugerido por <cite key="mcfadden74">McFadden (1974)</cite>;
	pero en el caso binario, si indicas la opción <opt>estrella</opt>
	se va a presentar en su lugar la variante recomendada por
	<cite key="estrella98">Estrella (1998)</cite>. Esta variante
	presumiblemente imita de forma más parecida las propiedades del
	<math>R</math><sup>2</sup> habitual en el contexto de la estimación
	de mínimos cuadrados.
      </para>
      <para context="cli">
	Si la variable dependiente es binaria, los coeficientes de logit van a
	representar los logaritmos de los ratios de probabilidades (cocientes entre
	la probabilidad de que <math>y</math> = 1 y la de que <math>y</math> = 0).
	En ese caso, el bundle de <lit>$model</lit> disponible después de la
	estimación incluye un elemento adicional denominado <lit>oddsratios</lit>,
	una matriz con cuatro columnas que contienen el coeficiente (ratio de
	de probabilidades) exponenciado, más el error típico calculado mediante
	el método delta, y el intervalo con el 95 por ciento de confianza, para
	cada regresor. Ten en cuenta, sin embargo, que el intervalo de confianza
	se calcula como el exponente del intervalo para el coeficiente
	original.
      </para>
      <para context="gui">
	Por defecto, las desviaciones típicas se calculan utilizando la inversa
	negativa de la matriz Hessiana. Si marcas el cuadradito de
	<quote>Desviaciones típicas robustas</quote>, entonces se calculan en su
	lugar las desviaciones típicas CMV (QML) o de Huber&ndash;White. En este
	caso, la matriz de covarianzas estimadas es un <quote>emparedado</quote>
	entre la inversa de la matriz Hessiana estimada y el producto externo del
	vector gradiente. Consulta el capítulo 10 del libro de Davidson y MacKinnon
	para obtener más detalles.
      </para>
      <para>
	Si la variable dependiente no es binaria sino discreta, entonces por defecto
	se interpreta como una respuesta ordinal y se obtienen las estimaciones con un
	Logit Ordenado. Sin embargo, cuando indicas la opción <opt>multinomial</opt>,
	la variable dependiente se interpreta como una respuesta sin ordenar y
	se generan las estimaciones con un Logit Multinomial. (En otro caso, si
	la variable escogida como dependiente no es de tipo discreto, se muestra
	un fallo.) El accesor <lit>$allprobs</lit> está disponible después de la
	estimación, para conseguir una matriz que contenga las probabilidades
	estimadas de los posibles valores de la variable dependiente para cada
	observación (con las observaciones por filas y los posibles valores por
	columnas).
      </para>
      <para>
	Si quieres utilizar un Logit para el análisis de proporciones donde, para
	cada observación, la variable dependiente es la proporción de casos
	que tienen una determinada característica (en vez de una variable
	con 1 o 0 para indicar si está presente o no la característica),
	no debes utilizar la instrucción <cmd>logit</cmd>, sino más
	bien construir la variable logit, como en
      </para>
      <code>
	series lgt_p = log(p/(1 - p))
      </code>
      <para>
	y utilizar esta como la variable dependiente de una regresión MCO. Consulta el capítulo 12 de <cite key="ramanathan02">Ramanathan (2002)</cite>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Variable dependiente limitada/Logit</menu-path>
    </gui-access>

  </command>

  <command name="logs" section="Transformations"
    label="Generar logaritmos" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Permite obtener el logaritmo natural de cada una de las series de
	<repl>listavariables</repl> y el resultado se guarda en una nueva serie con el
	prefijo <lit>l_</lit> (<quote>ele</quote> y guion bajo). Por
	ejemplo, <cmd>logs x y</cmd> genera las nuevas variables
	<lit>l_x</lit> = ln(<lit>x</lit>) y <lit>l_y</lit> = ln(<lit>y</lit>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Añadir/Logaritmos de las variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="loop" section="Programming"
    label="Comenzar un bucle de instrucciones" context="cli">

    <usage>
      <arguments>
        <argument>control</argument>
      </arguments>
      <options>
	<option>
	  <flag>--progressive</flag>
	  <effect>Permite formas especiales de ciertas instrucciones</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Refleja las instrucciones y muestra mensajes confirmatorios</effect>
	</option>
	<option>
	  <flag>--decr</flag>
	  <effect>Mira abajo</effect>
	</option>
      </options>
      <examples>
        <example>loop 1000</example>
        <example>loop i=1..10</example>
        <example>loop while essdiff &gt; .00001</example>
        <example>loop for (r=-.99; r&lt;=.99; r+=.01)</example>
	<example>loop foreach i listaX</example>
	<demos>
	  <demo>armaloop.inp</demo>
	  <demo>keane.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Esta instrucción abre un modo especial en el que el programa admite que
	las instrucciones se ejecuten repetidas veces. Terminas el proceso de
	ir introduciendo las instrucciones del bucle con <cmd>endloop</cmd> y
	en este punto se ejecutan las instrucciones acumuladas.
      </para>
      <para>
	El parámetro <repl quote="true">control</repl> puede tener cualquiera
	de las 5 formas siguientes, tal como se muestra en los ejemplos:
	(a) un número entero que indica las veces a repetir las instrucciones
	de un bucle; (b) un rango de valores enteros para una variable índice;
	(c) la palabra <quote><lit>while</lit></quote> más una condición booleana;
	(d) la palabra <quote><lit>for</lit></quote> más 3 expresiones dentro
	de un paréntesis, separadas con punto y comas (que imita la orden
	<lit>for</lit> en el lenguaje de programación C); o (e) la palabra
	<quote><lit>foreach</lit></quote> más una variable índice y una
	lista.
      </para>
      <para>
	La opción <opt>decr</opt> es específica solo para la forma de bucle
	del tipo <quote>rango de valores enteros</quote>. Por defecto, el índice
	se incrementa en 1 en cada iteración; y si el valor de inicio es menor
	que el valor final, el bucle no va a funcionar. Pero cuando se
	proporcione un valor para <opt>decr</opt>, el índice se minora en 1
	en cada iteración.
      </para>
      <para>
	Consulta <guideref targ="chap:looping"/> para obtener todos los detalles
	y ejemplos. Ahí se explica el efecto de la opción <opt>progressive</opt>
	(que está diseñada para ser utilizada con simulaciones de tipo Monte
	Carlo). No puedes utilizar todas las instrucciones de GRETL dentro de un
	bucle; por eso las instrucciones disponibles en este contexto también se
	exponen ahí.
      </para>
      <para>
	Por defecto, la ejecución de instrucciones se hace de modo más silencioso
	dentro de bucles que en otros contextos. Si quieres más retroalimentación
	con lo que esté sucediendo en un bucle, indica la opción <opt>verbose</opt>.
      </para>
    </description>

  </command>

  <command name="mahal" section="Statistics" label="Distancias de Mahalanobis">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
        </option>
	<option>
	  <flag>--save</flag>
	  <effect>Añade las distancias al conjunto de datos</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Calcula las distancias de Mahalanobis desde cada observación hasta el
	centroide, usando las series indicadas en <repl>listavariables</repl>.
	La distancia de Mahalanobis es la distancia entre dos puntos en
	un espacio de dimensión <math>k</math>, escalada por la variación
	estadística en cada dimensión del espacio. Por ejemplo, si
	<math>p</math> y <math>q</math> son dos observaciones de un conjunto
	de <math>k</math> variables con matriz de covarianzas <math>C</math>,
	entonces la distancia de Mahalanobis entre las observaciones viene
	dada por
	<equation status="display"
        tex="\[\sqrt{(p-q)^{\prime}C^{-1}(p-q)}\]"
        ascii="sqrt((p - q)' * C-inverse * (p - q))"
          graphic="mahal"/>
	donde (<math>p</math> &minus; <math>q</math>) es un vector
	de dimensión <math>k</math>. Esto se reduce a la distancia
	euclidiana en caso de que la matriz de covarianzas sea una
	matriz identidad.
      </para>
      <para>
	El espacio para el que se calculan las distancias está definido por las
	variables seleccionadas. Para cada observación del rango
	vigente de la muestra, la distancia se calcula entre la observación
	y el centroide de las variables escogidas. Esta distancia es la
	contrapartida multidimensional de una puntuación <math>z</math>
	estándar, y puedes utilizarla para juzgar si una observación
	dada <quote>pertenece</quote> a un grupo de otras
	observaciones.
      </para>
      <para context="cli">
	Cuando indicas la opción <opt>vcv</opt>, se presentan tanto la
	matriz de covarianzas como su inversa. Cuando indicas la
	opción <opt>save</opt>, las distancias se guardan en el conjunto
	de datos con el nombre <lit>mdist</lit> (o <lit>mdist1</lit>,
	<lit>mdist2</lit> y así sucesivamente, si ya existe una
	variable con ese nombre).
      </para>
      <para context="gui">
	Cuando el número de variables seleccionadas es de 4 o menos,
	se presentan tanto la matriz de covarianzas como su inversa.
	Al pulsar con el ratón en el botón '+' en lo alto de la ventana que muestra las
	distancias, te permite la posibilidad de añadir las distancias
	al conjunto de datos como una nueva variable.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Distancias de Mahalanobis</menu-path>
    </gui-access>

  </command>

  <command name="mailer" section="Utilities" context="gui"
    label="Enviar un archivo por correo">

    <description>
      <para>
	Puedes enviar una base de datos (o un guion de instrucciones) como añadido
	de correo desde dentro de GRETL, usando el SMTP (Simple Mail Transfer
	Protocol). A continuación, se explica cómo interpretar las dos tablas
	(<quote>Configuración de correo</quote> y <quote>Mensaje</quote>) de la caja
	de diálogo del correo. También se comentan los requerimientos de contraseña.
      </para>
      <subhead>Pestaña de configuración de correo</subhead>
      <ilist>
	<li>
	  <para>
	    Servidor SMTP: es el servidor con el que debiera de enviarse
	    tu correo. Si eres usuario de gmail es de esperar que te
	    encuentres con que te funciona la configuración por defecto,
	    <lit>smtps://smtp.gmail.com:465</lit>; de lo contrario, vas a tener
	    que introducir la información por tu cuenta. Fíjate en que la cadena
	    de texto del servidor debe comenzar o bien con <lit>smtp://</lit>,
	    o bien con <lit>smtps://</lit>. Después del nombre del servidor es
	    necesario añadir dos puntos, seguidos por el número de un puerto,
	    como en el <quote><lit>:465</lit></quote> indicado antes. Otros
	    valores posibles para el número del puerto SMTP son 25 y 587.
	  </para>
	</li>
	<li>
	  <para>
	    Nombre de usuario de correo: es el nombre de usuario con el que
	    te identifica tu servidor de correo. Probablemente es el mismo
	    nombre que tiene tu dirección de correo.
	  </para>
	</li>
	<li>
	  <para>
	    Contraseña de correo: lo más probable es que tu servidor SMTP
	    desee comprobar una contraseña, pero si no, puedes pulsar en
	    <quote>No es necesaria contraseña</quote>.
	  </para>
	</li>
      </ilist>
      <para>
	Tu información de servidor y de usuario se recuerda de una sesión de
	GRETL hasta la siguiente, de forma que solo tienes que introducirla una
	vez. De igual modo que con la contraseña, es elección tuya el guardarla
	o no; consulta la sección <emphasis>Contraseña de correo</emphasis>
	de más abajo para obtener más detalles.
      </para>
      <para>
	Pulsando <lit>OK</lit> en la ficha de configuración de correo, te moverás
	a la ficha de mensaje (excepto que se perdiese la información requerida).
      </para>
      <subhead>Pestaña de mensaje</subhead>
      <ilist>
       <li>
	 <para>
	   A: es la dirección de correo del destinatario. La primera vez
	   tendrás que introducirla por tu cuenta, pues GRETL no tiene acceso
	   a tu agenda de direcciones. Ahora bien, una vez introducida una
	   dirección, esta se recuerda y puedes seleccionarla más adelante
	   mediante una lista desplegable. Puedes guardar hasta diez
	   direcciones de esta forma.
	 </para>
       </li>
       <li>
	 <para>
	   De: es tu propia dirección de correo. Esta se recuerda de una
	   sesión de GRETL hasta la siguiente.
	 </para>
       </li>
       <li>
	 <para>
	   Tema: esto se rellena automáticamente, pero si lo deseas puedes
	   editarlo.
	 </para>
       </li>
       <li>
	 <para>
	   Nota: también se rellena automáticamente, pero puedes editarla.
	 </para>
       </li>
      </ilist>
      <para>
	Pulsando <lit>OK</lit> en la ficha de mensaje, enviarás el mensaje
	(excepto que se perdiese alguna información requerida).
      </para>
      <subhead>Contraseña de correo</subhead>
      <para>
	Si se necesita una contraseña para enviar el correo, puedes elegir
	que GRETL tenga guardada esta contraseña. En ese caso, se guarda en
	formato enrevesado en un directorio que está reservado para ti, en tu
	ordenador (en ningún servidor de internet). Sin embrago, no podemos
	garantizar su seguridad.
      </para>
      <para>
	Si eres usuario de gmail y utilizas la autentificación en 2-pasos,
	ten en cuenta que tu contraseña habitual de gmail no va a funcionar
	en este contexto. Vas a necesitar una
	<quote>App de contraseña</quote> para utilizarla con GRETL; consulta
	<url>https://support.google.com/accounts/answer/185833</url>.
      </para>
    </description>

  </command>

  <command name="makepkg" section="Programming" context="cli"
    label="Hacer un paquete de funciones">

    <usage>
      <arguments>
        <argument>nombrearchivo</argument>
      </arguments>
      <options>
        <option>
	  <flag>--index</flag>
	  <effect>Escribe el archivo índice, auxiliar</effect>
        </option>
        <option>
	  <flag>--translations</flag>
	  <effect>Escribe el archivo de cadenas de texto, auxiliar</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Funciona sigilosamente</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Da soporte a la creación de un paquete de funciones de GRETL mediante la línea
	de instrucciones. El modo de funcionamiento de esta instrucción depende de la
	extensión del <repl>nombrearchivo</repl>, que debe ser
	<lit>.gfn</lit> o <lit>.zip</lit>.
      </para>
      <subhead>Modo gfn</subhead>
      <para>
	Escribe un archivo gfn. Se asume que puede accederse a un archivo
	de especificación de un paquete, que tiene el mismo nombre base que
	<repl>nombrearchivo</repl> pero con la extensión <lit>.spec</lit>, junto
	con cualquier archivo auxiliar al que haga referencia. También se asume
	que todas las funciones a empaquetar se leyeron en la memoria.
      </para>
      <subhead>Modo zip</subhead>
      <para>
	Escribe un archivo comprimido zip de un paquete (un gfn más otros
	elementos). En caso de encontrarse un archivo gfn con el mismo nombre base
	que <repl>nombrearchivo</repl>, GRETL comprueba los archivos correspondientes
	<lit>inp</lit> y <lit>spec</lit>, y si los encuentra a ambos, siendo por lo
	menos uno de ellos más nuevo que el archivo gfn, entonces se vuelve a generar
	el gfn; en otro caso, se utiliza el gfn existente. Cuando no se encuentra
	ese archivo, GRETL intenta primero generar el gfn.
      </para>
      <subhead>Opciones de gfn</subhead>
      <para>
	Los indicadores de opciones admiten la escritura de archivos auxiliares,
	pensados para utilizar con los <quote>añadidos</quote> de GRETL. El
	archivo índice es un corto documento XML que contiene información
	básica sobre el paquete, y que tiene su mismo nombre como base
	además de la extensión <lit>.xml</lit>. El archivo de traducciones contiene
	las cadenas de texto del paquete (en formato C) que podrían ser
	apropiadas para la traducción; para un paquete <lit>foo</lit>
	este archivo se llama <lit>foo-i18n.c</lit>. Estos archivos
	no se generan si la instrucción opera en modo zip, y se utiliza
	un archivo gfn que ya existía.
      </para>
      <para>
	Para obtener más detalles sobre todo esto, consulta la
	<mnu targ="Pkgbook">Guía para paquetes de funciones</mnu> de GRETL.
      </para>
    </description>

    <gui-access>
      <menu-path>/Archivo/Paquetes de funciones/Paquete nuevo</menu-path>
    </gui-access>

  </command>

  <command name="maps" section="Utilities" label="Dibujar mapas" context="gui">
    <description>
      <para>
	Esta instrucción te permite crear un mapa, basado en datos geográficos
	descargados previamente (en formato de un archivo GeoJSON o de un
	archivo ESRI de forma). Las opciones son las siguientes.
      </para>
      <ilist>
	<li>
	  <para>
	    series to plot: En caso de existir, representa la serie a partir
	    de la que se deberán colorear las regiones del mapa; también
	    se conoce como la <quote>carga</quote>. Si falta esa carga
	    solo se mostrarán los trazos del mapa. Si el conjunto de datos
	    vigente contiene una o más series que parecen posibles candidatas
	    (en base a una sencilla heurística), estas se van a mostrar en
	    un selector desplegable.
	  </para>
	</li>
	<li>
	  <para>
	    palette: La paleta que permite la selección del conjunto de colores
	    que se utilizan para representar la carga, y que consecuentemente
	    solo es relevante cuando se selecciona una carga.
	  </para>
	</li>
	<li>
	  <para>
	    log scale: En caso de seleccionar una carga, se debería
	    representar esta en escala logarítmica? Por defecto, no.
	  </para>
	</li>
	<li>
	  <para>
	    border: Se debería dibujar un borde rectangular alrededor del mapa?
	    Por defecto, si; pero puedes eliminar esto.
	  </para>
	</li>
	<li>
	  <para>
	    feature border width: Te proporciona el control sobre la anchura
	    del borde o del contorno que se dibuja alrededor de las distintas
	    <quote>características</quote> del mapa (por ejemplo: países,
	    estados, regiones, provincias,...). Si tu gráfico ya incluye una
	    carga, puedes reducir la anchura hasta cero para eliminar esos
	    bordes.
	  </para>
	</li>
	<li>
	  <para>
	    height: Esto indica altura, y permite controlar el tamaño de la
	    imagen del mapa. Dada la altura, el ancho se calcula en base
	    al rango de longitud del mapa.
	  </para>
	</li>
      </ilist>
      <para>
	Ten en cuenta que puedes ganar un control <i>mucho</i> mayor
	sobre los detalles del mapa, mediante la invocación a la función
	<fncref targ="geoplot"/>.
      </para>
    </description>
  </command>

  <command name="markers" section="Dataset" label="Etiquetas de observación" context="cli">

    <usage>
      <altforms>
	<altform><lit>markers --to-file=</lit><repl>nombrearchivo</repl></altform>
	<altform><lit>markers --from-file=</lit><repl>nombrearchivo</repl></altform>
	<altform><lit>markers --to-array=</lit><repl>nombre</repl></altform>
	<altform><lit>markers --from-array=</lit><repl>nombre</repl></altform>
	<altform><lit>markers --from-series=</lit><repl>nombre</repl></altform>
	<altform><lit>markers --delete</lit></altform>
      </altforms>
    </usage>

    <description>
      <para>
	Las opciones <opt>to-file</opt> y <opt>to-array</opt> proporcionan formas
	de guardar las cadenas de texto que son marcadores de observaciones del
	conjunto vigente de datos, en el archivo o 'array' que indiques. Si no hay
	ninguna de esas cadenas, se muestra un fallo. En el caso del archivo, las
	cadenas se escriben una por línea en ese archivo, y este se guarda en el
	directorio (<cmdref targ="workdir"/>) establecido en ese momento, excepto
	que la cadena <repl>nombrearchivo</repl> contenga una especificación
	completa de la ruta. En el caso del 'array', si <repl>nombre</repl>
	es el identificador de un 'array' de cadenas de texto ya existente, ese
	'array' se va a sobrescribir; en caso contrario, se crea uno nuevo.
      </para>
      <para>
	Con la opción <opt>from-file</opt>, se lee el archivo especificado (que
	debe ser de texto UTF-8) y se asignan las etiquetas de observación
	contenidas en este, uno por cada línea, a las filas del conjunto de datos. En
	general, debería haber como mínimo tantas etiquetas en el archivo
	como observaciones en el conjunto de datos; pero si el conjunto de datos
	es de tipo panel, también se acepta que el número de etiquetas en el
	archivo coincida con el número de unidades de sección cruzada (en cuyo
	caso las etiquetas se repiten para cada período de tiempo.) La opción
	<opt>from-array</opt> funciona de modo similar, realizando la lectura a
	partir de un 'array' de cadenas de texto determinado.
      </para>
      <para>
	La opción <opt>from-series</opt> ofrece un modo adecuado de crear
	etiquetas de observación, copiándolas de una serie con valores en
	forma de cadenas de texto. Se presenta un fallo cuando la serie indicada
	no tiene valores de cadena de texto.
      </para>
      <para>
	La opción <opt>delete</opt> hace lo que ya esperarías, es decir, eliminar
	las cadenas de texto que etiquetan cada observación del conjunto de datos.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos/Etiquetas de las observaciones</menu-path>
    </gui-access>

  </command>

  <command name="meantest" section="Tests" label="Diferencia de medias">

    <usage>
      <altforms>
        <altform><lit>meantest</lit> <repl>x</repl> <repl>y</repl> </altform>
        <altform><lit>meantest</lit> <repl>x</repl> <lit>--split-by=</lit><repl>ficticia</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--unequal-vars</flag>
	  <effect>Asume que las varianzas no son iguales</effect>
        </option>
        <option>
	  <flag>--paired</flag>
	  <effect>Realiza un contraste de emparejados</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Elimina la presentación del resultado</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Solo para series temporales</effect>
        </option>
      </options>
      <examples>
        <example>meantest x y</example>
        <example>meantest x y --unequal-vars</example>
        <example>meantest x y --paired</example>
        <example>meantest x --split-by=d</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	En su uso básico, calcula el estadístico <math>t</math> para contrastar
	la hipótesis nula de que las medias en la población son iguales para las
	series <repl>x</repl> e <repl>y</repl>, mostrando además un resultado
	que incluye su probabilidad asociada (valor p). Los resultados se
	pueden recuperar utilizando los accesores <fncref targ="$test"/> y
	<fncref targ="$pvalue"/>, en cuyo caso se puede utilizar la opción
	<opt>quiet</opt> para omitir la impresión.
      </para>
      <para context="cli">
	En su forma alternativa, con la opción <opt>split-by</opt>, las muestras
	para las que se contrasta la igualdad de sus medias son dos subconjuntos
	de la serie <repl>x</repl>, para las que la serie <repl>ficticia</repl>
	toma los valores 0 y 1, respectivamente.
      </para>
      <para context="cli">
	Por defecto, el estadístico de contraste se calcula bajo el supuesto
	de que las varianzas son iguales para las dos variables. Con la
	opción <opt>unequal-vars</opt> se asume que las varianzas
	son diferentes; y en este caso, los grados de libertad del
	estadístico de contraste se aproximan conforme a
	<cite key="satter46">Satterthwaite (1946)</cite>.
      </para>
      <subhead context="cli">Contraste de emparejados</subhead>
      <para context="cli">
	En el caso básico (únicamente) se puede indicar la opción
	<opt>paired</opt> para contrastar la hipótesis nula de que la
	diferencia media entre los valores emparejados de las dos series de
	los argumentos, es nula. En caso contrario, no se asume el emparejamiento.
      </para>
      <subhead context="cli">Contraste robusto</subhead>
      <para context="cli">
	Con datos de series temporales, en el caso básico (únicamente) se
	puede indicar la opción <opt>robust</opt> para realizar un contraste
	de igualdad de medias entre <repl>x</repl> e <repl>y</repl> que es
	robusta respecto a la autocorrelación.
      </para>
      <para context="gui">
	Calcula el estadístico t para contrastar la hipótesis nula de que las medias
	en la población son iguales para dos series seleccionadas, y muestra
	su probabilidad asociada (valor p). Puedes invocar esta instrucción
	asumiendo o no que las varianzas son iguales para las dos variables.
	En el último caso, los grados de libertad del estadístico para el contraste
	se aproximan conforme a
	<cite key="satter46">Satterthwaite (1946)</cite>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Herramientas/Calculadora de estadísticos de contraste</menu-path>
    </gui-access>

  </command>

  <command name="MIDAS_list" section="Dataset" label="Lista MIDAS"
     context="gui">
    <description>
      <para>
	Una lista MIDAS (MIDAS = Mixed Data Sampling) es una lista definida
	(de series) cuyos elementos representan conjuntamente una variable
	de tipo serie temporal que se observa en una frecuencia mayor que la
	del conjunto de datos del contexto (<quote>host</quote>). Por ejemplo,
	una lista de este tipo podría representar una serie mensual en el
	contexto de un conjunto de datos trimestrales o anuales, o una serie
	diaria en el contexto de un conjunto de datos mensual.
      </para>
      <para>
	Una lista de este tipo debe tener <math>m</math> elementos,
	donde <math>m</math> es el número de períodos de alta frecuencia
	por período del conjunto de datos, y cada serie contiene los valores
	para un determinado subperíodo. En el caso mensual/trimestral, esto
	quiere decir que una lista tiene 3 elementos: un elemento contiene los
	valores para el tercer mes del trimestre, otro contiene los valores
	para el segundo mes, y el otro los valores para el primer mes.
      </para>
      <para>
	Además, estos miembros de la lista deben estar colocados en el orden
	particular <emphasis>primero los más recientes</emphasis>, en
	concreto. Continuando con el ejemplo mensual/trimestral, el orden debe
	ser: mes 3, mes 2, mes 1. Aunque esto podría parecer
	<quote>al revés</quote> es el orden que se requiere para poder
	generar las listas de retardos, que es la característica distintiva
	de la modelización MIDAS.
      </para>
      <para>
	Para tener una guía de cómo generar un conjunto de datos que
	admita listas MIDAS, consulta
      </para>
      <para>
	<url>http://gretl.sourceforge.net/midas/midas_gretl.pdf</url>
      </para>
    </description>
  </command>
  
  <command name="MIDAS_parm" section="Estimation"
     label="Hiperparámetros del MIDAS" context="gui">
    <description>
      <para>
	En este diálogo se te pide que escojas el tipo de disposición de
	parámetros para un conjunto de términos de alta frecuencia, así
	como el rango de retardos de estos términos. Los tipos admitidos de
	disposición de parámetros son:
      </para>
      <ilist>
	<li>
	  <para>
	    U-MIDAS o <quote>MIDAS no restringido</quote>: cada
	    retardo tiene su propio coeficiente.
	  </para>
	</li>
	<li>
	  <para>
	    Almon exponencial normalizada: requiere por lo menos un
	    parámetro y habitualmente utiliza dos.
	  </para>
	</li>
	<li>
	  <para>
	    Beta normalizada con un último retardo nulo: requiere
	    exactamente dos parámetros.
	  </para>
	</li>
	<li>
	  <para>
	    Beta normalizada con un último retardo no nulo:
	    requiere exactamente tres parámetros.
	  </para>
	</li>
	<li>
	  <para>
	    Polinomio de Almon: requiere por lo menos un parámetro.
	  </para>
	</li>
	<li>
	  <para>
	    Beta normalizada, 1 parámetro: esta es una variante
	    del Beta normalizada con un último retardo nulo, en el que
	    el valor del primer parámetro se fija en 1.0. El segundo
	    parámetro se estima sujeto a la restricción de que este es
	    cuando menos 1.0.
	  </para>
	</li>
      </ilist>
    </description>
  </command>

  <command name="midasreg" section="Estimation" label="Regresión MIDAS">
    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	      <argument separated="true">términosMIDAS</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
        </option>
        <option>
	  <flag>--levenberg</flag>
	  <effect>Mira abajo</effect>
        </option>
      </options>
      <examples>
        <example>midasreg y 0 y(-1) ; mds(X, 1, 9, 1, theta)</example>
	<example>midasreg y 0 y(-1) ; mds(X, 1, 9, 0)</example>
	<example>midasreg y 0 y(-1) ; mdsl(XL, 2, theta)</example>
	<demos>
	  <demo>gdp_midas.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Lleva a cabo la estimación por mínimos cuadrados (bien MCNL o bien
	MCO, dependiendo de la especificación) de un modelo MIDAS (Mixed Data
	Sampling). Este tipo de modelos incluye una o más variables
	independientes que se observan con una frecuencia mayor que a
	variable dependiente; para una buena y breve introducción consulta
	<cite key="armesto10">Armesto, Engemann y Owyang (2010)</cite>.
      </para>
      <para context="cli">
	Las variables de <repl>indepvars</repl> deben tener la misma
	frecuencia que la variable dependiente. Esta lista normalmente
	debe incluir <lit>const</lit> o <lit>0</lit> (ordenada en el origen),
	y habitualmente incluye uno o más retardos de la variable dependiente.
	Los términos de alta frecuencia se indican después de un punto y coma;
	cada uno tiene el formato de unos cuantos argumentos entre paréntesis,
	separados por comas, precedidos por <lit>mds</lit> o
	por <lit>mdsl</lit>.
      </para>
      <para context="gui">
	Las variables bajo <repl>Regresores</repl> tienen la misma frecuencia que
	la variable dependiente, y se escogen de la lista superior del lado izquierdo.
	Los modelos MIDAS habitualmente incluyen uno o más retardos de la variable
	dependiente; esto se controla mediante el botón con flechas arriba/abajo
	de <quote>Orden AR</quote>, que por defecto marca 1 retardo. Para añadir
	términos MIDAS (alta frecuencia), elige variables en la lista del lado inferior
	izquierdo y usa la flecha verde inferior (o pulsa el botón derecho del ratón).
      </para>
      <para context="gui">
	Al añadir un término MIDAS, emerge un diálogo para permitirte
	escoger: el rango de retardos, el tipo de disposición de parámetros
	y el número de hiperparámetros (para aquellos tipos que no tienen
	un número fijo de parámetros). Puedes hacer emerger otra vez este
	diálogo para revisar una especificación, pulsando el botón derecho
	del ratón en un término MIDAS de la derecha.
      </para>
      <para context="cli">
	<lit>mds</lit>: Esta variante generalmente requiere 5 argumentos, del
	modo siguiente: el nombre de una <cmdref targ="MIDAS_list"/>, dos
	enteros que indican los retardos mínimo y máximo de alta frecuencia,
	un entero entre 0 y 4 (o una cadena de texto, mira abajo) que
	especifica el tipo de disposición de los parámetros que se va a usar, y el
	nombre de un vector que contiene los valores iniciales de los parámetros. El
	ejemplo de abajo solicita los retardos del 3 al 11 de las series de alta
	frecuencia representadas en la lista <lit>X</lit>, utilizando para ello
	una disposición de los parámetros de tipo 1 (Almon exponencial, mira
	abajo) con el vector de inicio <lit>theta</lit>.
      </para>
      <code context="cli">
	mds(X, 3, 11, 1, theta)
      </code>
      <para context="cli">
	<lit>mdsl</lit>: Generalmente requiere 3 argumentos: el nombre de una lista de
	retardos MIDAS, un número entero (o una cadena de texto, mira abajo)
	para especificar el tipo de disposición de los parámetros y el nombre de un vector
	de inicio. En este caso, los retardos máximo y mínimo están implícitos en el
	argumento inicial de la lista. En el ejemplo de abajo <lit>Xlags</lit> debe
	ser una lista que ya contenga todos los retardos que se necesiten;
	puedes construir una lista de ese tipo utilizando la función
	<fncref targ="hflags"/>.
      </para>
      <code context="cli">
	mdsl(XLags, 1, theta)
      </code>
      <para context="cli">
	Los tipos de disposición de parámetros que se admiten, se muestran
	abajo. En el contexto de las especificaciones <lit>mds</lit> y <lit>mdsl</lit>,
	puedes indicarlos en forma de los códigos numéricos, o de las cadenas de texto
	entre comillas que se muestran después de los números:
      </para>
      <para context="cli">
	0 o <lit>"umidas"</lit>: MIDAS sin restricciones o U-MIDAS, en el que
	cada retardo tiene su propio coeficiente.
      </para>
      <para context="cli">
	1 o <lit>"nealmon"</lit>: Almon exponencial normalizada, que
	requiere por lo menos un parámetro y habitualmente utiliza dos.
      </para>
      <para context="cli">
	2 o <lit>"beta0"</lit>: Beta normalizada con un último retardo
	nulo, que requiere exactamente dos parámetros.
      </para>
      <para context="cli">
	3 o <lit>"betan"</lit>: Beta normalizada con un último retardo
	no nulo, que requiere exactamente tres parámetros.
      </para>
      <para context="cli">
	4 o <lit>"almonp"</lit>: Polinomio de Almon (no normalizada),
	que requiere por lo menos un parámetro.
      </para>
      <para context="cli">
	5 or <lit>"beta1"</lit>: Similar a <lit>beta0</lit>, pero con el primer
	parámetro fijado en 1 (dejando un único parámetro libre).
      </para>
      <para context="cli">
	Cuando la disposición de parámetros es U-MIDAS, no es necesario el
	vector de inicio del último argumento. En otros casos, puedes solicitar
	un inicio automático substituyendo el nombre del vector de
	parámetros inicial por alguna de estas dos formas:
      </para>
      <ilist context="cli">
	<li>
	  <para>
	    La palabra clave <lit>null</lit>: esto solo es admisible cuando la
	    disposición de los parámetros tiene un número fijo de términos (los
	    casos Beta, con 2 o 3 parámetros). También se acepta en el caso
	    del Almon exponencial, lo que implica que ese es el valor por
	    defecto de los dos parámetros.
	  </para>
	</li>
	<li>
	  <para>
	    Un valor entero que indica el número requerido de parámetros.
	  </para>
	</li>
      </ilist>
      <para context="cli">
	El método de estimación que utiliza esta instrucción depende de la
	especificación de los elementos de alta frecuencia. En el caso de U-MIDAS,
	el método es MCO (OLS); de lo contario, es mínimos cuadrados no lineales
	(MCNL o NLS). Cuando especificas las disposiciones de parámetros
	Almon exponencial normalizada o Beta normalizada, el método MCNL
	por defecto es una combinación de BFGS restringido y MCO, pero
	puedes indicar la opción <opt>levenberg</opt> para forzar que se
	utilice el algoritmo de Levenberg&ndash;Marquardt.
      </para>
      <para context="gui">
	El método de estimación que utiliza esta instrucción depende de la
	especificación de los elementos de alta frecuencia. En el caso de U-MIDAS,
	el método es MCO (OLS); de lo contario, es mínimos cuadrados no lineales
	(MCNL o NLS). Cuando especificas las disposiciones de parámetros
	Almon exponencial normalizada o Beta normalizada, el método MCNL
	por defecto es una combinación de BFGS restringido y MCO, excepto
	que marques la cajita titulada
	<quote>Prefiere NLS via Levenberg-Marquardt</quote>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Series temporales univariantes/MIDAS</menu-path>
    </gui-access>
  </command>

  <command name="missing" section="Dataset" context="gui"
    label="Valores para datos ausentes">

    <description>
      <para>
	Establece un valor numérico que se interpreta como <quote>ausente</quote>
	o <quote>no disponible</quote>, bien para una serie de datos particular
	(bajo el menú Variable) o bien globalmente para todo el conjunto de
	datos (bajo el menú Datos).
      </para>
      <para>
	GRETL tiene su propia codificación interna para los valores ausentes,
	pero a veces los datos que se importan pueden emplear otro código
	distinto. Por ejemplo, si una serie concreta está codificada de modo
	que el valor '-1' indica <quote>no aplicable</quote>, puedes escoger
	<quote>Establecer código de valor ausente</quote> bajo el menú
	Variable y teclear el valor <quote>-1</quote> (sin las comillas). Entonces
	GRETL va a leer esos (-1) como observaciones ausentes.
      </para>
    </description>
  </command>

  <command name="mdhelp" section="Programming" label="Ayuda para marcado Markdown"
    context="gui">

    <description>
      <para>
	En esta ventana del editor puedes insertar elementos para marcado ligero como
	se indica después; pero observa que la expresión <quote>inmediatamente</quote>
	de más abajo, quiere decir que no tenga ningún espacio intermedio.
      </para>
      <ilist>
	<li>
	  <para>
	    Negrita: Coloca dos asteriscos (<lit>**</lit>),
	    inmediatamente antes y después de un trozo de texto.
	  </para>
	</li>
	<li>
	  <para>
	    Cursiva: Coloca un único asterisco o guion bajo,
	    inmediatamente antes y después de un trozo de texto.
	  </para>
	</li>
	<li>
	  <para>
	    Monoespaciada: Coloca una comilla simple izquierda (<lit>`</lit>),
	    inmediatamente antes y después de un trozo de texto.
	  </para>
	</li>
	<li>
	  <para>
	    Cabecera de nivel 1: Coloca una única almohadilla (<lit>#</lit>)
	    antes de la cabecera, y deja una linea en blanco después de
	    la misma.
	  </para>
	</li>
	<li>
	  <para>
	    Cabecera de nivel 2: Coloca dos almohadillas sucesivas antes de
	    la cabecera, y deja una linea en blanco a continuación.
	  </para>
	</li>
	<li>
	  <para>
	    Bloque de código: Deja una linea en blanco y a continuación
	    coloca tres comillas simples izquierdas sucesivas (<lit>```</lit>)
	    en la linea justo anterior al código, y otras tres en la linea
	    justo después del mismo.
	  </para>
	</li>
	<li>
	  <para>
	    Lista no numerada: Deja una linea en blanco antes de la lista, e
	    inserta un guion con un espacio (<quote><lit>- </lit></quote>) antes
	    de cada elemento, usando una nueva linea para cada uno de ellos.
	  </para>
	</li>
	<li>
	  <para>
	    Lista numerada: Deja una linea en blanco antes de la lista, e
	    inserta el número, un punto y un espacio (por ejemplo,
	    <quote><lit>1. </lit></quote>) antes de cada elemento, usando
	    una nueva linea para cada uno de ellos.
	  </para>
	</li>
      </ilist>
      <para>
	El icono de un ojo de esta ventana te permite tener una visión previa
	del texto de ayuda con marcado ligero (markdown). Ten en cuenta que
	si realmente el texto no contiene anotaciones de marcado ligero, la
	<quote>visión previa</quote> podría no tener una buena apariencia.
      </para>
    </description>
  </command>

  <command name="menu-attach" section="Programming"
     label="Anexo al menú" context="gui">
    <description>
      <para>
	Este diálogo te permite especificar un anexo al menú para un paquete
	de funciones. Para eso debes completar los siguientes tres campos en la
	caja de diálogo.
      </para>
      <subhead>1. Etiqueta</subhead>
      <para>
	Esto requiere una corta cadena de texto como etiqueta, que aparecerá como
	acceso al paquete, en el menú.
      </para>
      <subhead>2. Ventana</subhead>
      <para>
	Selecciona <quote>Ventana de modelo</quote> para un paquete de
	funciones que hace algo con un modelo de GRETL, y deba aparecer
	en la barra de menús de una ventana de modelos de GRETL. En otro caso,
	selecciona <quote>Ventana principal</quote>.
      </para>
      <subhead>3. Árbol del menú</subhead>
      <para>
	Escoge la posición dentro del árbol del menú (bien de la ventana
	principal o bien de la ventana de modelos, como has elegido de acuerdo
	con lo indicado arriba), donde debe aparecer el acceso al paquete.
      </para>
      <subhead>Elementos opcionales</subhead>
      <para>
	Además, puedes utilizar el botón <quote>Texto de ayuda</quote> de la GUI
	para añadir o editar texto de ayuda específico de Interfaz Gráfica
	de Usuario (GUI) para que se muestre cuando se invoque el paquete desde
	un menú. Y si el paquete está pensado para invocarlo desde la ventana de un
	modelo, puedes especificar un cierto tipo de modelo (identificado por su
	palabra clave como instrucción de GRETL) como requisito.
      </para>
    </description>
  </command>

  <command name="mle" section="Estimation"
    label="Estimación Máximo Verosímil">

    <usage>
      <arguments>
        <argument>función logaritmo-verosimilitud</argument>
	      <argument optional="true">derivadas</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>No muestra el modelo estimado</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--hessian</flag>
	  <effect>Basa la matriz de covarianzas en la Hessiana</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <optparm optional="true">hac</optparm>
	  <effect>Matriz de covarianzas CMV (QML) o HAC</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Matriz de covarianzas robusta por agrupación</effect>
  </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
	</option>
	<option>
	  <flag>--no-gradient-check</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--auxiliary</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--lbfgs</flag>
	  <effect>Utiliza L-BFGS-B en vez del BFGS habitual</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>weibull.inp</demo>
	  <demo>biprobit_via_ghk.inp</demo>
	  <demo>frontier.inp</demo>
	  <demo>keane.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Realiza la estimación de Máxima Verosimilitud (MV o ML) usando
	el algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno) o el método
	de Newton. Debes especificar la función logaritmo de verosimilitud;
	y se te recomienda que también proporciones las expresiones de las
	derivadas de esta función con respecto a cada uno de los parámetros,
	si es posible.
      </para>
      <para>
	Este texto de ayuda asume que se utiliza el maximizador por defecto
	BFGS. Para obtener información relativa al uso del método de Newton,
	consulta <guideref targ="chap:mle"/>.
      </para>
      <para>
	Ejemplo sencillo: Supón que tenemos una serie <lit>X</lit> con
	valores 0 o 1, y queremos obtener la estimación máximo verosímil de la
	probabilidad (<lit>p</lit>) de que <lit>X</lit> = 1. (En este caso
	sencillo, se puede adelantar que la estimación MV de <lit>p</lit> será
	simplemente equivalente a la proporción de Xs iguales a 1, en la muestra.)
      </para>
      <para>
	Debes primero añadir el parámetro <lit>p</lit> al conjunto de datos e
	indicar su valor inicial. Puedes hacer esto usando la instrucción 'genr'
	o mediante elecciones de menú. Puedes teclear las líneas <quote>genr</quote>
	adecuadas en la ventana de especificación de la EMV, antes de especificar la
	función logaritmo de verosimilitud.
      </para>
      <para>
	En la ventana EMV, tecleamos las siguientes líneas:
      </para>
      <code>
	loglik = X*log(p) + (1-X)*log(1-p)
	deriv p = X/p - (1-X)/(1-p)
      </code>
      <para>
	La primera línea especifica la función logaritmo de verosimilitud,
	y la siguiente línea proporciona la derivada de esa función con
	respecto al parámetro 'p'. Si no indicas líneas 'deriv',
	se calcula una aproximación numérica a las derivadas.
      </para>
      <para>
	Cuando no se expresa previamente el parámetro 'p', podemos
	poner antes de las líneas de arriba algo como lo siguiente:
      </para>
      <code>
	scalar p = 0.5
      </code>
      <para>
	Las desviaciones típicas se basan en el Producto Externo del vector Gradiente, por
	defecto. Si marcas el cuadradito <quote>Desviaciones típicas robustas</quote>,
	se utiliza un estimador CMV (QML, un <quote>emparedado</quote> entre la
	inversa negativa de la matriz Hessiana y la matriz de covarianzas del vector
	gradiente, en concreto). La matriz Hessiana se aproxima numéricamente.
      </para>
      <para>
	Para una descripción mucho más en profundidad de la estimación
	<cmd>mle</cmd>, consulta <guideref targ="chap:mle"/>.
      </para>
    </description>

    <description context="cli">
      <para>
	Realiza la estimación de Máxima Verosimilitud (MV o ML)
	utilizando bien el algoritmo BFGS (Broyden, Fletcher, Goldfarb,
	Shanno) o bien el método de Newton. Debes especificar la
	función logaritmo de verosimilitud. Y debes expresar los
	parámetros de esta función, y asignarles valores iniciales antes
	de la estimación. Opcionalmente, el usuario puede especificar las
	derivadas de la función logaritmo de verosimilitud con respecto a
	cada uno de los parámetros; si no indicas las derivadas analíticas,
	se calcula una aproximación numérica.
      </para>
      <para>
	Este texto de ayuda asume que se utiliza, por defecto, el maximizador
	BFGS. Para obtener más información sobre el uso del método de Newton,
	por favor consulta <guideref targ="chap:mle"/>.
      </para>
      <para>
	Ejemplo sencillo: Supón que tenemos una serie <lit>X</lit>
	con valores 0 o 1, y queremos obtener la estimación máximo
	verosímil de la probabilidad (<lit>p</lit>) de que <lit>X</lit> = 1.
	(En este caso sencillo, se puede adelantar que la estimación MV
	de <lit>p</lit> será simplemente equivalente a la proporción
	de Xs iguales a 1, en la muestra.)
      </para>
      <para>
	Primero se debe añadir el parámetro <lit>p</lit> al conjunto de datos, e
	indicar su valor inicial. Por ejemplo,
        <lit>scalar p = 0.5</lit>.
      </para>
      <para>
	A continuación, se configura el bloque de instrucciones de estimación EMV:
      </para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  deriv p = X/p - (1-X)/(1-p)
	end mle
      </code>
      <para>
	La primera línea de arriba especifica la función logaritmo de
	verosimilitud. Comienza con la palabra clave <lit>mle</lit>, después
	se especifica la variable dependiente y se indica una expresión
	para el logaritmo de la verosimilitud (usando la misma sintaxis que
	en la instrucción <cmd>genr</cmd>). La siguiente línea (que es opcional)
	comienza con la palabra clave <lit>deriv</lit> y proporciona la
	derivada de la función logaritmo de verosimilitud con respecto
	al parámetro <lit>p</lit>. Si no indicas las derivadas, debes
	incluir una orden utilizando la palabra clave <lit>params</lit>
	que identifique los parámetros libres: estos se enumeran en una
	línea, separados por espacios y pueden ser bien escalares, bien
	vectores, o bien cualquier combinación de los dos. Por ejemplo,
	puedes cambiar lo de arriba por:
      </para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  params p
	end mle
      </code>
      <para>
	en cuyo caso se utilizarían derivadas numéricas.
      </para>
      <para>
	Ten en cuenta que cualquier indicador de opción debe añadirse a la
	línea final del bloque EMV (MLE). Por ejemplo:
      </para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  params p
	end mle --quiet
      </code>
      <subhead>Matriz de covarianzas y desviaciones típicas</subhead>
      <para>
	Cuando la función del logaritmo de la verosimilitud devuelve una serie o
	un vector que proporciona valores por observación, entonces las desviaciones
	típicas estimadas se basan por defecto en el Producto Externo del vector
	Gradiente (PEG); mientras que si indicas la opción <opt>hessian</opt>,
	por el contario se basan en la inversa negativa de la matriz Hessiana, que se
	aproxima numéricamente. Cuando indicas la opción <opt>robust</opt>,
	se utiliza un estimador CMV (QML, un <quote>emparedado</quote> entre
	la inversa negativa de la matriz Hessiana y el PEG). Si además añades
	el parámetro <lit>hac</lit> a esta opción, el PEG se incrementa del
	modo de <cite key="newey-west87">Newey y West</cite> para permitir
	autocorrelación del gradiente. (Esto únicamente tiene sentido con
	datos de series de tiempo.) Ahora bien, cuando la función del logaritmo
	de la verosimilitud únicamente devuelve un valor escalar, el PEG no
	está disponible (por lo tanto tampoco el estimador CMV), y las
	desviaciones típicas tienen que calcularse necesariamente utilizando
	la matriz Hessiana numérica.
      </para>
      <para>
	En caso de que únicamente quieras las estimaciones del parámetro
	primario, puedes indicar la opción <opt>auxiliary</opt>, que elimina
	el cálculo de la matriz de covarianzas y de las desviaciones típicas. Esto
	va a ahorrar algunos ciclos de CPU y uso de memoria.
      </para>
      <subhead>Comprobando las derivadas analíticas</subhead>
      <para>
	Si proporcionas las derivadas analíticas, por defecto GRETL ejecuta
	una verificación numérica de su credibilidad. Algunas veces esto
	puede producir falsos positivos, por situaciones en las que las derivadas
	correctas parecen ser incorrectas y la estimación se rechaza. Para
	tener esto en cuenta o para conseguir un poco de velocidad adicional,
	puedes indicar la opción <opt>no-gradient-check</opt>. Obviamente,
	debes hacer esto solo cuando tengas certeza de que el vector gradiente
	que has especificado es correcto.
      </para>
      <subhead>Nombres de parámetros</subhead>
      <para>
	Al estimar un modelo no lineal, con frecuencia es conveniente nombrar
	los parámetros de forma sucinta. Ahora bien, al presentar los resultados,
	puede que desees utilizar etiquetas más informativas. Esto lo puedes
	conseguir mediante la palabra clave adicional <lit>param_names</lit>
	dentro del bloque de instrucciones. Para un modelo con <math>k</math>
	parámetros, el argumento que sigue a esta palabra clave debe ser
	una cadena de texto literal entre comillas que contenga <math>k</math>
	nombres separados por espacios, el nombre de una variable de cadena
	que contenga <math>k</math> de esos nombres, o el nombre de un array
	con <math>k</math> cadenas de texto.
      </para>
      <para>
	Para una descripción más en profundidad de la estimación
	<cmd>mle</cmd> consulta <guideref targ="chap:mle"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Máxima Verosimilitud</menu-path>
    </gui-access>

  </command>

  <command name="modeltab" section="Utilities" label="La tabla de modelos">

    <usage>
      <altforms>
	<altform><lit>modeltab add</lit></altform>
	<altform><lit>modeltab show</lit></altform>
	<altform><lit>modeltab free</lit></altform>
	<altform><lit>modeltab --output=</lit><repl>nombrearchivo</repl></altform>
	<altform><lit>modeltab --options=</lit><repl>bundle</repl></altform>
      </altforms>
    </usage>

    <description context="gui">
      <para>
	En la investigación econométrica es habitual estimar varios modelos
	con una misma variable dependiente, diferenciándose esos modelos
	en las variables independientes que están incluidas en cada uno o,
	quizás, en el tipo de estimador utilizado. En esta situación, resulta
	conveniente presentar los resultados de la regresión en forma de una
	tabla, en la que cada columna contenga los resultados (las estimaciones
	de los coeficientes y de las desviaciones típicas) para un modelo dado,
	y en la que cada fila contenga las estimaciones para una determinada
	variable en los diferentes modelos.
      </para>
      <para>
	GRETL proporciona un medio para elaborar una tabla de este tipo
	(y de copiarla en texto plano, &latex; o Rich Text Format).
	Aquí tienes como hacerlo:
      </para>
      <nlist>
	<li>
	  <para>
	    Estima un modelo que quieras incluir en la tabla y,
	    bajo el menú Archivo de la ventana de modelos, selecciona
	    <quote>Guardar en la sesión como icono</quote> o
	    <quote>Guardar como icono y cerrar</quote>.
    </para>
	</li>
	<li>
	  <para>
	    Repite el paso 1 para los otros modelos que se van a
	    incluir en la tabla (hasta un total de 6 modelos).
    </para>
	</li>
	<li>
	  <para>
	    Cuando ya tengas hecha la estimación de los modelos, abre el visor de
	    iconos de tu sesión de GRETL (escogiendo <quote>Vista de iconos</quote>
	    bajo el menú de Ver en la ventana principal de GRETL, o pulsando en el
	    icono titulado <quote>Vista de iconos de sesión</quote> en la barra de
	    herramientas de GRETL).
    </para>
	</li>
	<li>
	  <para>
	    En la vista de iconos de sesión, hay un icono titulado
	    <quote>Tabla de modelos</quote>. Decide el modelo que quieres
	    que aparezca en la columna más a la izquierda de la Tabla de modelos y
	    añádelo a la tabla, bien arrastrando su icono sobre el icono de la
	    Tabla de modelos, o bien pulsando el botón derecho del ratón sobre el icono
	    del modelo, y escogiendo <quote>Añadir a la tabla de modelos</quote>
	    del menú emergente.
    </para>
	</li>
	<li>
	  <para>
	    Repite el paso 4 para los demás modelos que quieras incluir en la
	    tabla; así el segundo modelo que selecciones va a aparecer
	    en la segunda columna, empezando por la izquierda; etcétera.
    </para>
	</li>
	<li>
	  <para>
	    Cuando acabes de componer la tabla de modelos, muéstrala
	    pulsando un doble clic sobre su icono. Bajo el menú
	    'Copiar' de la ventana que aparece, tienes la posibilidad de
	    copiar la tabla al portapapeles en varios tipos de formato.
    </para>
	</li>
	<li>
	  <para>
	    Si el orden de los modelos en la tabla no es el que querías,
	    pulsa el botón derecho del ratón sobre el icono de la tabla de
	    modelos, y escoge <quote>Vaciar</quote>. Entonces vuelve al
	    paso 4 de arriba e inténtalo de nuevo.
    </para>
	</li>
      </nlist>
    </description>

    <description context="cli">
      <para>
	Permite manejar la <quote>Tabla de modelos</quote> de GRETL;
	consulta <guideref targ="chap:modes"/> para obtener más
	detalles. Las instrucciones subordinadas tienen los siguientes efectos:
	<cmd>add</cmd> añade el último modelo estimado a la tabla
	de modelos, cuando sea posible; <cmd>show</cmd> muestra la tabla
	de modelos en una ventana; y <cmd>free</cmd> vacía la tabla.
      </para>
      <para>
	Para solicitar que se guarde la tabla de modelos, usa la opción
	<opt>output=</opt> más un nombre de archivo. Cuando el nombre
	del archivo tenga el sufijo <quote><lit>.tex</lit></quote>, el
	resultado va a estar en formato &tex;; cuando el sufijo sea
	<quote><lit>.rtf</lit></quote>, el resultado tendrá formato RTF; y
	en otro caso, va a estar en texto plano. En caso de un resultado
	&tex;, por defecto se genera un <quote>trozo</quote> adecuado
	para incluir en un documento; en cambio, si quieres un documento
	independiente, usa la opción <opt>complete</opt>, como por ejemplo
      </para>
      <code>
	modeltab --output="myfile.tex" --complete
      </code>
      <para>
	Puedes utilizar el indicador <opt>options=</opt> (lo que requiere
	indicar el nombre de un 'bundle' de GRETL) para controlar algunos
	aspectos de formato en la tabla del modelo. Se admiten las siguientes
	claves:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>colheads</lit>: Entero de 1 a 4, que permite escoger entre
	    los cuatro estilos admitidos para el encabezamiento de columnas:
	    numeración Arábiga, numeración Romana, alfabética, o la utilización
	    de los nombres bajo los que se guardaron los modelos.
	    El predeterminado es 1 (numeración Arábiga).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>tstats</lit>: Booleano, que permite sustituir las desviaciones
	    típicas con los estadísticos t, o no (el predeterminado, 0).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>pvalues</lit>: Booleano, que permite incluir los valores
	    <math>P</math>, o no (el predeterminado, 0).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>asterisks</lit>: Booleano, que permite mostrar asteriscos
	    relativos al nivel de significación, o no (el predeterminado, 0).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>digits</lit>: Entero de 2 a 6, que permite elegir el número
	    de dígitos significativos que se muestran (el predeterminado, 4).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>decplaces</lit>: Entero de 2 a 6, que permite elegir el número
	    de posiciones decimales que se muestran.
	  </para>
	</li>
      </ilist>
      <para>
	Ten en cuenta que las dos últimas claves son mutuamente excluyentes.
	Ofrecen modos alternativos de especificar la precisión con la que se muestran
	los valores numéricos: o en términos de dígitos significativos, o en
	términos de posiciones decimales. Por defecto, son 4 dígitos significativos.
      </para>
      <para>
	Puedes indicar un 'bundle' de opciones mediante una instrucción
	independiente (como en el último de los ejemplos de más abajo),
	o se puede combinar con el proceso <lit>show</lit>, o con la opción
	<opt>output</opt>. Por ejemplo, el siguiente guion elabora una simple
	tabla de un modelo y la presenta, mostrando los valores <math>P</math>
	en lugar de los asteriscos relativos al nivel de significación:
      </para>
      <code>
	open data9-7
	ols 1 0 2 3 4
	modeltab add
	ols 1 0 2 3
	modeltab add
	bundle myopts = _(pvalues=1, asterisks=0)
	modeltab show --options=myopts
      </code>
    </description>

    <gui-access>
      <menu-path>Ventana de iconos de sesión: icono de Tabla de modelos</menu-path>
    </gui-access>

  </command>

  <command name="modprint" section="Printing"
    label="Presentar un modelo definido por el usuario" context="cli">

    <usage>
      <arguments>
        <argument>matrizcoef</argument>
        <argument>nombres</argument>
	      <argument optional="true">estadicionales</argument>
      </arguments>
      <options>
	<option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el resultado al archivo especificado</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Presenta la tabla de coeficientes y estadísticos adicionales opcionales
	para un modelo estimado <quote>a mano</quote>; es útil sobre todo para
	funciones escritas por el usuario.
      </para>
      <para>
	El argumento <repl>matrizcoef</repl> debe ser una matriz de
	dimensión <math>k</math> por 2, que contiene <math>k</math>
	coeficientes y <math>k</math> desviaciones típicas asociadas.
	El argumento <repl>nombres</repl> debe proporcionar por lo
	menos <math>k</math> nombres para etiquetar los coeficientes.
	Puedes indicarlo con el formato: (a) de una cadena de texto literal
	(puesta entre comillas) o de una variable de cadena, que
	contenga los nombres separados por comas o espacios, o (b) un
	array ya definido de cadenas de texto.
      </para>
      <para>
	El argumento <repl>estadicionales</repl> (opcional) es un vector que
	contiene <math>p</math> estadísticos adicionales que se muestran
	debajo de la tabla de coeficientes. Si indicas este argumento,
	entonces <repl>nombres</repl> debe contener <math>k + p</math>
	nombres, de forma que los <math>p</math> nombres agregados
	se asocien a los estadísticos adicionales.
      </para>
      <para>
	Si no indicas el argumento <repl>estadicionales</repl> y la matriz
	<repl>matrizcoef</repl> tiene adjuntos los nombres de las filas,
	entonces puedes omitir el argumento <repl>nombres</repl>.
      </para>
      <para>
	Para colocar el resultado en un archivo, utiliza la opción
	<opt>output=</opt> más un nombre de archivo. Cuando el nombre
	de archivo tenga el sufijo <quote><lit>.tex</lit></quote>, el
	resultado va a estar en formato &tex;; cuando el sufijo sea
	<quote><lit>.rtf</lit></quote>, el resultado tendrá formato RTF;
	y en otro caso, va a estar en texto plano. En caso de un resultado
	&tex;, por defecto se genera un <quote>trozo</quote> adecuado
	para incluir en un documento; en cambio, si quieres un documento
	independiente, usa la opción <opt>complete</opt>.
      </para>
      <para>
	El archivo resultante se escribe en el directorio (<cmdref targ="workdir"/>)
	establecido en ese momento, excepto que la cadena <repl>nombrearchivo</repl>
	contenga una especificación completa de la ruta.
      </para>
    </description>

  </command>

  <command name="modtest" section="Tests" label="Contrastes del modelo"
    context="cli">

    <usage>
      <arguments>
        <argument optional="true">orden</argument>
      </arguments>
      <options>
        <option>
	  <flag>--normality</flag>
	  <effect>Normalidad de las perturbaciones</effect>
        </option>
        <option>
	  <flag>--logs</flag>
	  <effect>No linealidad: logaritmos</effect>
        </option>
        <option>
	  <flag>--squares</flag>
	  <effect>No linealidad: cuadrados</effect>
        </option>
        <option>
	  <flag>--autocorr</flag>
	  <effect>Autocorrelación</effect>
        </option>
        <option>
	  <flag>--arch</flag>
	  <effect>ARCH</effect>
        </option>
        <option>
	  <flag>--white</flag>
	  <effect>Heterocedasticidad: contraste de White</effect>
        </option>
        <option>
	  <flag>--white-nocross</flag>
	  <effect>Contraste de White: solo cuadrados</effect>
        </option>
        <option>
	  <flag>--breusch-pagan</flag>
	  <effect>Heterocedasticidad: contraste de Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Estimación con varianzas robustas para Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--panel</flag>
	  <effect>Heterocedasticidad: por grupos</effect>
        </option>
        <option>
	  <flag>--comfac</flag>
	  <effect>Restricción de factor común: solo modelos AR1</effect>
        </option>
        <option>
	  <flag>--xdepend</flag>
	  <effect>Dependencia de sección cruzada: solo con datos de panel</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los detalles</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
        </option>
      </options>
	  <examples>
	<demos>
	  <demo>credscore.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Debe seguir inmediatamente a una instrucción de estimación.
	La discusión de abajo se aplica a la utilización de esta instrucción a
	continuación de la estimación de un modelo de una única ecuación;
	consulta <guideref targ="chap:var"/> para una exposición de
	como opera <cmd>modtest</cmd> después de la estimación de un VAR.
      </para>
      <para>
	Dependiendo de la opción que indiques, esta instrucción efectúa una de estas
	acciones: el contraste de Normalidad de la perturbación de Doornik&ndash;Hansen;
	un contraste de No Linealidad (logaritmos o cuadrados) con Multiplicadores
	de Lagrange; el contraste de Heterocedasticidad de White (con o sin
	productos cruzados) o el de Breusch&ndash;Pagan
	(<cite key="breusch-pagan79">Breusch y Pagan, 1979</cite>); el contraste LMF
	de Autocorrelación <cite key="kiviet86" p="true">(Kiviet, 1986)</cite>;
	un contraste de ARCH (Heterocedasticidad Condicional Autorregresiva;
	consulta también la instrucción <cmd>arch</cmd>); un contraste de la restricción
	de Factor Común implícita en la estimación AR(1); o un contraste de
	Dependencia de sección cruzada en modelos con datos de panel. Con la
	excepción de los contrastes de Normalidad, de Factor Común y de Dependencia
	de sección cruzada, la mayor parte de las opciones de estos contrastes solo
	están disponibles para modelos estimados mediante MCO, pero mira más
	abajo para obtener más detalles en relación con Mínimos Cuadrados en 2
	Etapas.
      </para>
      <para>
	El argumento <lit>orden</lit> (opcional) es importante solo en caso de
	que escojas las opciones <opt>autocorr</opt> o <opt>arch</opt>.
	Por defecto, estos contrastes se ejecutan utilizando un orden de retardos
	igual a la periodicidad de los datos, pero puedes ajustar esto indicando
	un orden de retardos específico.
      </para>
      <para>
	La opción <opt>robust</opt> se aplica únicamente cuando seleccionas
	el contraste de Breusch&ndash;Pagan; su efecto consiste en que se
	utiliza el estimador robusto de la varianza propuesto por
	<cite key="koenker81">Koenker (1981)</cite>, haciendo el contraste
	menos sensible al supuesto de Normalidad.
      </para>
      <para>
	La opción <opt>panel</opt> está disponible solo cuando el modelo se
	estima con datos de panel; y en este caso, se realiza un contraste de
	heterocedasticidad por grupos (es decir, de varianzas de las perturbaciones
	diferentes entre las unidades de sección cruzada).
      </para>
      <para>
	La opción <opt>comfac</opt> está disponible solo cuando el modelo se
	estima mediante un método AR(1) tal como el de Hildreth&ndash;Lu.
	La regresión auxiliar toma la forma de un modelo dinámico relativamente
	no restringido, que se utiliza para contrastar la restricción de factor
	común implícita en la especificación AR(1).
      </para>
      <para>
	La opción <opt>xdepend</opt> está disponible solo para modelos
	estimados con datos de panel. El estadístico de contraste es el
	desarrollado por <cite key="pesaran04">Pesaran (2004)</cite>.
	La hipótesis nula es que la perturbación se distribuye independientemente
	entre las unidades atemporales o los individuos.
      </para>
      <para>
	Por defecto, el programa presenta la regresión auxiliar en la que se
	basa el estadístico de contraste, si es aplicable. Puedes eliminar esto
	utilizando la opción <opt>quiet</opt> (presentación mínima de
	resultados) o la opción <opt>silent</opt> (no presenta ningún
	resultado). Puedes recuperar el estadístico de contraste y su
	probabilidad asociada (valor p) utilizando los accesores
	<fncref targ="$test"/> y <fncref targ="$pvalue"/>, respectivamente.
      </para>
      <para>
	Cuando un modelo se estima por Mínimos Cuadrados en 2 Etapas (consulta
	<cmdref targ="tsls"/>), se rompe el principio de Máxima Verosimilitud y
	GRETL ofrece algunos equivalentes: la opción <flag>--autocorr</flag>
	calcula el estadístico de Godfrey para contrastar autocorrelación
	<cite key="godfrey94" p="true">(Godfrey, 1994)</cite> mientras que la opción
	<flag>--white</flag> produce el estadístico del contraste HET1 de heterocedasticidad
	<cite key="pesaran99" p="true">(Pesaran y Taylor, 1999)</cite>.
      </para>
      <para>
	Para contrastes adicionales de diagnóstico sobre los modelos,
	consulta <cmdref targ="chow"/>, <cmdref targ="cusum"/>,
	<cmdref targ="reset"/> y <cmdref targ="qlrtest"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contrastes</menu-path>
    </gui-access>

  </command>

  <command name="mpi" section="Programming"
	   label="Interfaz de Paso de Mensajes">
    <usage>
      <arguments>
	<argument>Mira abajo</argument>
      </arguments>
    </usage>
    <description>
      <para>
	La instrucción <lit>mpi</lit> comienza un bloque de expresiones (que se
	deben finalizar con <lit>end mpi</lit>) para ser ejecutadas usando el
	cómputo en paralelo de MPI (Interfaz de Paso de Mensajes). Consulta
	<doc>gretl-mpi.pdf</doc> para obtener un informe completo de esta prestación.
      </para>
    </description>
  </command>

  <command name="mpols" section="Estimation" label="MCO de alta precisión">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
	<option>
	  <flag>--simple-print</flag>
	  <effect>No presenta los estadísticos auxiliares</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcula las estimaciones de MCO para el modelo especificado, utilizando
	aritmética de punto flotante con precisión múltiple, con la ayuda de la
	biblioteca Gnu Multiple Precision (GMP). Por defecto, se utilizan 256
	bits de precisión en los cálculos, pero puedes aumentar esto mediante la
	variable de entorno <lit>GRETL_MP_BITS</lit>. Por ejemplo, cuando
	utilizas el intérprete Bash se te podría ocurrir la siguiente instrucción
	para establecer una precisión de 1024 bits antes de comenzar GRETL.
      </para>
      <code>
	export GRETL_MP_BITS=1024
      </code>

      <para context="cli">
	Dispones de una opción (más bien rebuscada) para esta instrucción,
	principalmente con el propósito de hacer pruebas: cuando la lista
	<repl>indepvars</repl> va seguida de un punto y coma, más de una
	lista posterior de números, esos números se toman como potencias de
	<repl>x</repl> que se añaden a la regresión, donde <repl>x</repl> es la
	última variable de <repl>indepvars</repl>. Estos términos adicionales
	se calculan y se guardan con precisión múltiple. En el siguiente ejemplo,
	se hace la regresión de <lit>y</lit> sobre <lit>x</lit> más la segunda,
	tercera y cuarta potencias de ese <lit>x</lit>:
      </para>
      <code context="cli">
	mpols y 0 x ; 2 3 4
      </code>
    </description>

    <gui-access>
      <menu-path>/Modelo/Otros modelos lineales/MCO de alta precisión</menu-path>
    </gui-access>

  </command>

  <command name="nadarwat" section="Estimation" label="Nadaraya-Watson"
     context="gui">
    <description>
      <para>
	Calcula <math>m(x)</math>, el estimador no paramétrico de
	Nadaraya&ndash;Watson de la media condicionada de la variable
	dependiente, para cada valor no ausente de la variable
	independiente.
      </para>
      <para>
	La función núcleo (kernel) viene determinada por
	<math>K = exp(-x</math><sup>2</sup><math>/2h)</math>
	para <math>|x|&lt;T</math>, y cero en otro caso. <math>T</math> es
	un parámetro de recorte, por defecto igual a 4<math>h</math>.
      </para>
      <para>
	El ancho de banda <math>h</math>, que habitualmente es un número
	pequeño, controla la suavidad de <math>m(x)</math> (los valores
	más grandes producen series más suaves). Por defecto, este
	valor está determinado por los datos y resulta proporcional a
	<math>n</math><sup>-0.2</sup>, siendo <math>n</math> el tamaño
	de la muestra.
      </para>
      <para>
	Si marcas el cuadradito de <quote>dejar una fuera</quote>, se emplea
	una variante del estimador en la que la <math>i</math>-ésima observación
	no se utiliza para evaluar <math>m(x</math><sub>i</sub><math>)</math>.
	Esto hace que el algoritmo sea numéricamente más robusto, y su
	utilización se aconseja normalmente cuando el estimador se calcula
	con el propósito de hacer inferencias.
      </para>
      <para>
	Para obtener más detalles sobre la estimación no paramétrica, consulta
	<guideref targ="chap:nonparam"/>.
      </para>
     </description>
  </command>

  <command name="negbin" section="Estimation"
    label="Regresión Binomial Negativa">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	      <argument separated="true" optional="true">exposición</argument>
      </arguments>
      <options>
	<option>
	  <flag>--model1</flag>
	  <effect>Utiliza el modelo NegBin 1</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>Matriz de covarianzas CMV (QML)</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para una explicación</effect>
        </option>
	<option>
	  <flag>--opg</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
      </options>
	 <examples>
	<demos>
	  <demo>camtriv.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Estima un modelo Binomial Negativo. Se toma la variable dependiente para
	representar un recuento del número de veces que ocurre un suceso de algún
	tipo, y debe tener solo valores enteros no negativos. Por defecto,
	se utiliza el modelo NegBin 2 en el que la varianza condicionada del recuento
	viene determinada por &mu;(1 + &alpha;&mu;), donde &mu; denota la media
	condicionada. Pero si indicas la opción <opt>model1</opt>, la varianza
	condicionada es &mu;(1 + &alpha;).
      </para>
      <para>
	La serie de exposición (<lit>offset</lit>, opcional) funciona del mismo modo
	que para la instrucción <cmdref targ="poisson"/>. El modelo de Poisson es una
	forma restringida de la Binomial Negativa en la que &alpha; = 0 por construcción.
      </para>
      <para>
	Por defecto, las desviaciones típicas se calculan utilizando una
	aproximación numérica a la matriz Hessiana en la convergencia. Pero
	si indicas la opción <opt>opg</opt>, la matriz de covarianzas
	se basa en el Producto Externo del vector Gradiente, PEG (OPG), y
	si indicas la opción <opt>robust</opt>, se calculan las desviaciones
	típicas CMV (QML), utilizando un <quote>emparedado</quote>
	entre la inversa de la matriz Hessiana y el PEG.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Variable dependiente limitada/Datos de conteo</menu-path>
    </gui-access>
  </command>

  <command name="nls" section="Estimation"
    label="Mínimos Cuadrados No Lineales">

    <usage>
      <arguments>
        <argument>función</argument>
        <argument optional="true">derivadas</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta el modelo estimado</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
	</option>
	<option>
	  <flag>--no-gradient-check</flag>
	  <effect>Mira abajo</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>wg_nls.inp</demo>
	  <demo>ects_nls.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Realiza la estimación de Mínimos Cuadrados No Lineales (MCNL
	o NLS) utilizando una versión modificada del algoritmo de
	Levenberg&ndash;Marquardt. Debes proporcionar la especificación
	de una función; y aunque no es imprescindible, se recomienda que
	también proporciones las expresiones de las derivadas de esta función con
	respecto a cada uno de los parámetros, si es posible. Si no ofreces las
	derivadas, en su lugar debes indicar una lista de los parámetros
	que se van a estimar (separados por espacios o comas), precedida por la
	palabra clave <lit>params</lit>; estos pueden ser bien escalares, bien
	vectores o bien cualquier combinación de los dos.
      </para>
      <para>
	Ejemplo: Supón que tienes un conjunto de datos con las variables
	<math>C</math> e <math>Y</math> (&eg; <lit>greene11_3.gdt</lit>)
	y que deseas estimar una función no lineal de consumo con la
	expresión
	<equation status="display"
	  tex="\[C = \alpha + \beta Y^{\gamma}\]"
    ascii="C = alpha + beta * Y^gamma"
    graphic="greene_Cfunc"/>
      </para>
      <para>
	En primer lugar, debes añadir los parámetros alfa, beta
	y gamma al conjunto de datos, además de darles unos valores iniciales.
	Puedes escribir las líneas apropiadas en la ventana de especificaciones de
	MC No Lineales antes de definir la función.
      </para>
      <para>
	En la ventana MC No Lineales, escribes las siguientes líneas:
      </para>
      <code>
	C = alfa + beta * Y^gamma
	deriv alfa = 1
	deriv beta = Y^gamma
	deriv gamma = beta * Y^gamma * log(Y)
      </code>
      <para>
	La primera línea especifica la función de regresión, y las siguientes
	3 líneas proporcionan las derivadas de esa función con respecto a
	cada parámetro, de uno en uno. Si no indicas las líneas 'deriv',
	se calcula una aproximación numérica al Jacobiano.
      </para>
      <para>
	Si no enuncias previamente los parámetros alfa, beta
	y gamma, puedes preceder las líneas de arriba con algo como
	lo siguiente:
      </para>
      <code>
	scalar alfa = 1
	scalar beta = 1
	scalar gamma = 1
      </code>
      <para>
	Para otros detalles sobre la estimación MCNL (NLS), consulta <guideref targ="chap:nls"/>.
      </para>
    </description>

    <description context="cli">
      <para>
	Realiza la estimación de Mínimos Cuadrados No Lineales (MCNL
	o NLS) utilizando una versión modificada del algoritmo de
	Levenberg&ndash;Marquardt. Debes indicar la especificación
	de una función y de enunciar los parámetros de esta, además de
	darles unos valores iniciales antes de la estimación. Como
	opción, puedes especificar las derivadas de la función de regresión
	con respecto a cada uno de los parámetros. Si no proporcionas
	as derivadas, en su lugar debes indicar una lista de los
	parámetros que se van a estimar (separados por espacios o
	comas), precedida por la palabra clave <lit>params</lit>. En este
	último caso, se calcula una aproximación numérica al Jacobiano.
      </para>
      <para>
	Resulta más fácil mostrar lo que se requiere mediante un ejemplo.
	Lo que sigue es un guion completo para estimar la función no lineal
	de consumo establecida en el libro <book>Econometric Analysis</book>
	(capítulo 11 de la 4a edición o capítulo 9 de la 5a) de William Greene.
	Los números a la izquierda de las líneas son solo para tomar como referencia
	y no son parte de las instrucciones. Ten en cuenta que cualquier indicador
	de opción, como sería <opt>vcv</opt> para presentar la matriz de
	covarianzas de los estimadores de los parámetros, deberías de añadirlo
	a la instrucción final, <lit>end nls</lit>.
      </para>
      <code>
	1   open greene11_3.gdt
	2   ols C 0 Y
	3   scalar alfa = $coeff(0)
	4   scalar beta = $coeff(Y)
	5   scalar gamma = 1.0
	6   nls C = alfa + beta * Y^gamma
	7    deriv alfa = 1
	8    deriv beta = Y^gamma
	9    deriv gamma = beta * Y^gamma * log(Y)
	10  end nls --vcv
      </code>
      <para>
	Con frecuencia es conveniente iniciar los parámetros con una referencia a
	un modelo lineal relacionado; esto se logra aquí con las líneas de la 2 a la 5.
	Los parámetros alfa, beta y gamma pueden establecerse con cualquier valor
	inicial (no necesariamente basados en un modelo estimado con MCO),
	aunque la convergencia del procedimiento de MCNL no está garantizada
	para cualquier punto de inicio que se te antoje.
      </para>
      <para>
	Las auténticas instrucciones de MCNL ocupan las líneas de la 6 hasta la 10.
	En la línea 6 se indica la instrucción <cmd>nls</cmd> en la que se declara
	la variable dependiente, con un signo de igualdad a continuación, y
	seguido este de la especificación de una función. La sintaxis para el
	lado derecho de la expresión es la misma que la de la instrucción
	<cmd>genr</cmd>. Las siguientes 3 líneas especifican las derivadas
	de la función de regresión con respecto a cada uno de los parámetros,
	de uno en uno. Cada línea comienza con la palabra clave <cmd>deriv</cmd>,
	establece el nombre de un parámetro, un signo de igualdad y una
	expresión por la que puede calcularse la derivada. En lugar de
	proporcionar las derivadas analíticas, como alternativa puedes
	substituir las líneas de la 7 a la 9, por lo siguiente:
      </para>
      <code>
	params alfa beta gamma
      </code>
      <para>
	La línea 10, <cmd>end nls</cmd>, completa la instrucción y solicita
	la estimación. Cualquier opción deberás de añadirla a esta línea.
      </para>
      <para>
	Si proporcionas las derivadas analíticas, por defecto GRETL ejecuta
	una verificación numérica de su credibilidad. Algunas veces esto
	puede producir falsos positivos, por situaciones en las que las derivadas
	correctas parecen ser incorrectas y la estimación se rechaza. Para
	tener esto en cuenta o para conseguir un poco de velocidad adicional,
	puedes indicar la opción <opt>no-gradient-check</opt>. Obviamente,
	debes hacer esto solo cuando tengas certeza de que el vector gradiente
	que has especificado es correcto.
      </para>
      <subhead>Nombres de parámetros</subhead>
      <para>
	Al estimar un modelo no lineal, con frecuencia es conveniente nombrar
	los parámetros de forma sucinta. Ahora bien, al presentar los resultados,
	puede que desees utilizar etiquetas más informativas. Esto lo puedes
	lograr mediante la palabra clave adicional <lit>param_names</lit>
	dentro del bloque de instrucciones. Para un modelo con <math>k</math>
	parámetros, el argumento que sigue a esta palabra clave debe ser
	una cadena de texto literal entre comillas que contenga <math>k</math>
	nombres separados por espacios, el nombre de una variable de cadena
	que contenga <math>k</math> de esos nombres, o el nombre de un array
	con <math>k</math> cadenas de texto.
      </para>
      <para>
	Para obtener otros detalles sobre la estimación MCNL (NLS), consulta
	<guideref targ="chap:nls"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Mínimos cuadrados no lineales</menu-path>
    </gui-access>

  </command>

  <command name="normtest" section="Tests" label="Contraste de Normalidad">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--dhansen</flag>
	  <effect>Contraste de Doornik&ndash;Hansen, por defecto</effect>
        </option>
	<option>
	  <flag>--swilk</flag>
	  <effect>Contraste de Shapiro&ndash;Wilk</effect>
        </option>
	<option>
	  <flag>--lillie</flag>
	  <effect>Contraste de Lilliefors</effect>
        </option>
	<option>
	  <flag>--jbera</flag>
	  <effect>Contraste de Jarque&ndash;Bera</effect>
        </option>
	<option>
	  <flag>--all</flag>
	  <effect>Hace todos los contrastes</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Realiza un contraste de Normalidad para la <repl>serie</repl> indicada.
	El tipo concreto de contraste se controla con el indicador de opción (y
	se ejecuta el contraste de Doornik&ndash;Hansen cuando no indicas ninguna
	opción). Advertencia: Los contrastes de Doornik&ndash;Hansen y Shapiro&ndash;Wilk
	son más recomendables que los otros, teniendo en cuenta sus mejores
	propiedades en muestras pequeñas.
      </para>
      <para>
	Mediante los accesores <fncref targ="$test"/> y <fncref targ="$pvalue"/>
	puedes recuperar el estadístico de contraste y su probabilidad asociada
	(valor p), respectivamente. Ten en cuenta que cuando indicas la opción
	<opt>all</opt>, el resultado guardado es el del contraste de Doornik&ndash;Hansen.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Contraste de Normalidad</menu-path>
    </gui-access>

  </command>

  <command name="nulldata" section="Dataset"
    label="Generar una base de datos vacía">

    <usage>
      <arguments>
        <argument>longitud</argument>
      </arguments>
      <options>
	<option>
	  <flag>--preserve</flag>
	  <effect>Retiene las variables que no son series</effect>
        </option>
      </options>
      <examples>
        <example>nulldata 500</example>
      </examples>
    </usage>

    <description>
      <para>
	Establece un conjunto de datos <quote>en blanco</quote> que: incluye
	solo una constante más una variable índice, tiene periodicidad 1 y
	contiene el número de observaciones especificado en el argumento. Puedes
	utilizar esto con la intención de hacer simulaciones, pues funciones como
	<cmd>uniform()</cmd> y <cmd>normal()</cmd> generan series artificiales
	comenzando por el principio, para rellenar el conjunto de datos. Esta
	instrucción puede ser muy útil en combinación con <cmd>loop</cmd>.
	Consulta también la opción <quote>seed</quote> (semilla) de la instrucción
	<cmdref targ="set"/>.
      </para>
      <para>
	Por defecto, esta instrucción vacía todos los datos del espacio vigente
	de trabajo de GRETL, no solo las series sino también las matrices, los
	escalares, las cadenas de texto, etc. Ahora bien, cuando indicas la opción
	<opt>preserve</opt>, se retiene cualquier variable que no sea una serie
	y esté definida en ese momento.
      </para>
    </description>

    <gui-access>
      <menu-path>/Archivo/Nuevo conjunto de datos</menu-path>
    </gui-access>

  </command>

  <command name="ols" section="Estimation" label="Mínimos Cuadrados Ordinarios">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Desviaciones típicas agrupadas</effect>
        </option>
        <option>
	  <flag>--jackknife</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--simple-print</flag>
	  <effect>No presenta estadísticos auxiliares</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
        </option>
        <option>
	  <flag>--anova</flag>
	  <effect>Presenta una tabla ANOVA</effect>
        </option>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>Elimina la corrección de los grados de libertad</effect>
        </option>
        <option>
	  <flag>--print-final</flag>
	  <effect>Mira abajo</effect>
        </option>
      </options>
      <examples>
        <example>ols 1 0 2 4 6 7</example>
	<example>ols y 0 x1 x2 x3 --vcv</example>
	<example>ols y 0 x1 x2 x3 --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Calcula las estimaciones de mínimos cuadrados ordinarios (MCO u OLS)
	para el modelo especificado.
      </para>

      <para context="cli">
	Calcula las estimaciones de mínimos cuadrados ordinarios (MCO u OLS)
	siendo <repl>depvar</repl> la variable dependiente, e <repl>indepvars</repl>
	una lista de variables independientes. Puedes especificar las variables
	con el nombre o con el número; y utilizar el número cero para indicar el término
	constante.
      </para>

      <para>
	Aparte de las estimaciones de los coeficientes y de las desviaciones típicas, el programa
	también presenta las probabilidades asociadas (valores p) a los estadísticos
	<math>t</math> (con dos colas) y <math>F</math>. Un 'valor p' por debajo de
	0.01 indica significación estadística a un nivel del 1 por ciento, y se marca con
	<lit>***</lit>. La marca <lit>**</lit> indica niveles de significación entre 1
	y 5 por ciento, y la marca <lit>*</lit> indica niveles entre 5 y 10 por ciento.
	También se presentan los estadísticos para elegir modelos (el Criterio de Información
	de Akaike o AIC, y el Criterio de Información Bayesiano de Schwarz). La fórmula
	utilizada para el AIC es la proporcionada por <cite key="akaike74">Akaike (1974)</cite>,
	en concreto, menos dos veces el logaritmo de la verosimilitud maximizada más
	dos veces el número de parámetros estimados.
	    </para>

      <para context="cli">
	Si indicas la opción <opt>no-df-corr</opt>, no se aplica la corrección habitual de los grados de libertad al calcular
	la varianza estimada de la perturbación (y por lo tanto, tampoco las desviaciones típicas de los estimadores de los parámetros).
	    </para>

      <para context="cli">
	La opción <opt>print-final</opt> es aplicable solo en el contexto de un bucle
	(<cmdref targ="loop"/>), y dispone que la regresión se ejecute
	silenciosamente en todas las iteraciones del bucle, excepto en la última.
	Consulta <guideref targ="chap:looping"/> para obtener más detalles.
      </para>

      <para context="cli">
	Puedes recuperar varias variables internas después de la estimación.
	Por ejemplo:
      </para>
      <code context="cli">
	series uh = $uhat
      </code>
      <para context="cli">
	guarda los errores de la estimación bajo el nombre <lit>uh</lit>. Consulta la
	sección <quote>Accesores</quote> de la Guía de funciones de GRETL para
	obtener más detalles.
      </para>

      <para context="cli">
	Puedes ajustar la fórmula (versión <quote>HC</quote>) específica
	que se va a utilizar para generar las desviaciones típicas robustas
	cuando indicas la opción <opt>robust</opt>, mediante la instrucción
	<cmdref targ="set"/>. La opción <opt>jackknife</opt> tiene como
	consecuencia la selección de una <lit>hc_version</lit> de <lit>3a</lit>.
	La opción <opt>cluster</opt> anula la selección de la versión HC, y
	produce las desviaciones típicas robustas agrupando las observaciones
	según los distintos valores de <repl>clustvar</repl>. Consulta
	<guideref targ="chap:robust_vcv"/> para obtener más detalles.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Mínimos Cuadrados Ordinarios</menu-path>
      <other-access>Botón con el símbolo beta en la barra de herramientas</other-access>
    </gui-access>

  </command>

  <command name="omit" section="Tests" label="Excluir variables">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
	<option>
	  <flag>--test-only</flag>
	  <effect>No substituye el modelo vigente</effect>
	</option>
	<option>
	  <flag>--chi-square</flag>
	  <effect>Devuelve la forma Chi-cuadrado del contraste de Wald</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Presenta solo los resultados básicos del contraste</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas del modelo reducido</effect>
	</option>
	<option>
	  <flag>--auto</flag>
	  <optparm optional="true">alfa</optparm>
	  <effect>Eliminación secuencial, mira abajo</effect>
	</option>
      </options>
      <examples>
        <example>omit 5 7 9</example>
        <example>omit seasonals --quiet</example>
        <example>omit --auto</example>
        <example>omit --auto=0.05</example>
	 <demos>
	  <demo>restrict.inp</demo>
	  <demo>sw_ch12.inp</demo>
	  <demo>sw_ch14.inp</demo>
	 </demos>
     </examples>
    </usage>

    <description context="gui">
      <para>
	La forma básica de esta instrucción vuelve a estimar el modelo
	indicado, después de excluir las variables especificadas. Aparte del
	resultado habitual del modelo, presenta un contraste de la significación
	conjunta de las variables excluidas. La hipótesis nula supone que los
	verdaderos coeficientes de todas las variables excluidas son iguales a cero.
      </para>
      <para>
	Si eliges la opción <quote>Contraste de Wald</quote>, se evalúa la
	significación conjunta de las variables especificadas mediante un
	contraste de Wald basado en la matriz de covarianzas del modelo
	indicado, y no se vuelve a realizar la estimación.
      </para>
      <para>
	Si eliges la opción <quote>Eliminación secuencial</quote> (aviso: dicha
	opción no siempre se presenta), esta va a funcionar como se indica a
	continuación. En cada etapa se excluye la variable ligada a la mayor
	probabilidad asociada (valor p), hasta que todas las que queden estén
	ligadas a valores p que no sean mayores que algún valor de corte. Por
	defecto, este es el 10 por ciento (con 2 colas) y puedes ajustarlo con el
	botón con flechas arriba/abajo. Por defecto, este proceso opera de forma
	automática sobre todas las variables en el modelo (aparte de la constante);
	si quieres limitarlo solo a un subconjunto de las variables, marca el
	cuadradito de <quote>Contrastar solo las variables seleccionadas</quote>
	y haz la selección. Al igual que en el caso básico, se va a reestimar un
	modelo después de excluir las variables, salvo que no quede ninguna.
      </para>
    </description>

    <description context="cli">
      <para>
	Esta instrucción debe ir después de una instrucción de estimación.
	En su forma básica, calcula el estadístico de contraste de Wald para la
	significación conjunta de las variables de <repl>listavariables</repl>,
	que debe ser un subconjunto (aunque no necesariamente un subconjunto
	apropiado) de las variables independientes del último modelo estimado.
	Puedes recuperar los resultados del contraste utilizando los accesores
	<fncref targ="$test"/> y <fncref targ="$pvalue"/>.
      </para>
      <para>
	A no ser que la restricción elimine todos los regresores originales,
	por defecto, se estima el modelo restringido y este substituye al
	original como <quote>modelo vigente</quote> si tienes intención,
	por ejemplo, de recuperar los errores con <lit>$uhat</lit> o hacer
	contrastes posteriores. Puedes impedir este comportamiento mediante
	la opción <opt>test-only</opt>.
      </para>
      <para>
	Por defecto, se registra la forma <math>F</math> del contraste de Wald;
	pero puedes utilizar la opción <opt>chi-square</opt> para recoger
	la forma chi-cuadrado en su lugar.
      </para>
      <para>
	Si tanto estimas como representas el modelo restringido, la opción
	<opt>vcv</opt> tiene el efecto de presentar su matriz de covarianzas;
	en otro caso, esta opción se ignora.
      </para>
      <para>
	Como alternativa, cuando indicas la opción <opt>auto</opt>, se lleva
	a cabo la eliminación secuencial por pasos. En cada etapa se excluye
	la variable ligada a la mayor probabilidad asociada (valor p), hasta
	que todas las que queden estén ligadas a valores p que no sean
	mayores que algún valor de corte. Por defecto, este es del 10 por ciento
	(con 2 colas) y puedes ajustarlo añadiendo <quote><lit>=</lit></quote>,
	y un valor entre 0 y 1 (sin espacios), como en el cuarto ejemplo de
	arriba. Si indicas <repl>listavariables</repl>, este proceso se limita
	solo a las variables de la lista; en otro caso, todos los regresores
	aparte de la constante se tratan como candidatos a la exclusión. Ten
	en cuenta que las opciones <opt>auto</opt> y <opt>test-only</opt>
	no puedes combinarlas.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contrastes/Omitir variables</menu-path>
    </gui-access>

  </command>

  <command name="online" section="Dataset" context="gui"
    label="Acceso a bases de datos en línea">

    <description>
      <para>
	GRETL es capaz de acceder a bases de datos de la Universidad Wake
	Forest (tu ordenador debe estar conectado a Internet para
	que esto funcione).
      </para>
      <para>
	Bajo el menú <quote>Archivo: Bases de datos</quote>, escoge la
	opción <quote>Sobre servidor</quote>. Debiera de
	aparecer una ventana, mostrando un listado de las bases de datos
	de GRETL disponibles en la Wake Forest. (Dependiendo de tu localización
	y de la velocidad de tu conexión a Internet, esto puede demorar unos
	pocos segundos.) Junto con el nombre de la base de datos y una corta
	descripción, aparece una anotación <quote>Estado local</quote>:
	esta indica si tienes instalada localmente una de las bases de datos
	(en el disco duro de tu ordenador) y en caso de ser así, si está
	o no actualizada en comparación con la versión disponible en el
	servidor.
      </para>
      <para>
	Si tienes una determinada base de datos ya instalada localmente, y está
	actualizada, no tienes ninguna ventaja accediendo a ella por medio del
	servidor. Pero para una base de datos que no está aún instalada
	ni actualizada, podrías querer obtener un listado de sus series
	de datos; entonces pulsa un clic sobre <quote>Listar las series</quote>.
	Esto abre una ventana más, desde la que puedes representar los valores
	de una de las series de datos que elijas, dibujar esos valores o incluso
	importarlos al espacio de trabajo de GRETL. Puedes completar estas
	tareas utilizando el menú <quote>Series</quote>, o mediante el menú
	emergente que aparece cuando pulsas el botón derecho del ratón sobre
	una determinada serie. También puedes buscar el listado de una variable
	de interés (en el elemento <quote>Buscar</quote> del menú).
      </para>
      <para>
	Si quieres un acceso más rápido a los datos, o deseas acceder a la
	base de datos fuera de línea, entonces escoge la línea que muestra la base
	de datos que quieres (en la ventana inicial de la base de datos) y pulsa
	el botón <quote>Instalar</quote>. Esto va a descargar la base de
	datos en formato comprimido, luego descomprimirlo e instalarlo en
	tu disco duro. En adelante ya deberías ser capaz de encontrarlo
	bajo <quote>Archivo, Bases de datos, Nativa GRETL</quote>
	en el menú.
      </para>
    </description>
  </command>

  <command name="open" section="Dataset"
    label="Abrir un archivo de datos" context="cli">

    <usage>
      <arguments>
        <argument>nombrearchivo</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta la lista de las series</effect>
	</option>
	<option>
	  <flag>--preserve</flag>
	  <effect>Retiene las variables que no son series</effect>
	</option>
	<option>
	  <flag>--select</flag>
	  <optparm>seleccion</optparm>
	  <effect>Leer solo las series indicadas, mira abajo</effect>
	</option>
	<option>
	  <flag>--frompkg</flag>
	  <optparm>nombrepaquete</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--all-cols</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--www</flag>
	  <effect>Utiliza una base de datos del servidor de GRETL</effect>
	</option>
	<option>
	  <flag>--odbc</flag>
	  <effect>Utiliza una base de datos ODBC</effect>
	</option>
	<optnote>Mira abajo para opciones adicionales especiales</optnote>
      </options>
      <examples>
        <example>open data4-1</example>
        <example>open voter.dta</example>
        <example>open fedbog.bin --www</example>
        <example>open dbnomics</example>
      </examples>
    </usage>

    <description>
      <para>
	Abre un archivo de datos o una base de datos (consulta
	<guideref targ="chap:datafiles"/> para ver una explicación de esta
	distinción). Las consecuencias son algo diferentes en los dos casos.
	Cuando abres un <emphasis>archivo de datos</emphasis>, se lee su
	contenido en el espacio de trabajo de GRETL, substituyendo la base de
	datos vigente (si la hay). Para añadir datos al conjunto vigente, en
	lugar de sustituirlo, consulta <cmdref targ="append"/> o (para tener
	mayor flexibilidad) <cmdref targ="join"/>. Cuando abres una
	<emphasis>base de datos</emphasis>, no se carga inmediatamente
	ningún dato; más bien, se establece la fuente para llamadas posteriores
	de la instrucción <cmdref targ="data"/>, que se utiliza para importar series
	concretas. Para obtener más detalles respecto a las bases de datos,
	consulta la sección titulada <quote>Abriendo una base de datos</quote>
	más abajo.
      </para>
      <para>
	Si no indicas <repl>nombrearchivo</repl> con una ruta completa, GRETL
	busca en algunas rutas destacadas para tratar de encontrar el archivo, de
	las que el directorio vigente (<cmdref targ="workdir"/>) es la primera
	elección. Si no indicas el sufijo en el nombre de archivo (como en el
	primer ejemplo de arriba), GRETL asume que es un archivo de datos propio
	con sufijo <lit>.gdt</lit>. Basándose en el nombre del archivo y varias
	reglas heurísticas, GRETL tratará de detectar el formato del archivo de
	datos (propio, texto plano, CSV, MS Excel, Stata, SPSS, etc.).
      </para>
      <para>
	Cuando se utiliza la opción <opt>frompkg</opt>, GRETL va a buscar el
	archivo especificado de datos en el subdirectorio asociado al paquete
	de funciones especificado por <repl>nombrepaquete</repl>.
      </para>
      <para>
	Si el argumento <repl>nombrearchivo</repl> toma la forma de
	un identificador de recursos uniforme (URI) que comienza por
	<lit>http://</lit> o por <lit>https://</lit>, entonces GRETL tratará
	de descargar el archivo de datos indicado, antes de abrirlo.
      </para>
      <para>
	Por defecto, al abrir un nuevo archivo de datos se vacía la sesión vigente
	de GRETL, lo que incluye la eliminación de todas las variables definidas,
	incluyendo matrices, escalares y cadenas de texto. Si quieres mantener las
	variables que tengas definidas en ese momento (que no sean series, pues
	estas se eliminan obligatoriamente), utiliza la opción <opt>preserve</opt>.
      </para>
      <subhead context="cli">Archivos de hoja de cálculo</subhead>
      <para>
	Al abrir un archivo de datos con formato de hoja de cálculo (Gnumeric,
	Open Document o MS Excel), puedes facilitar tres parámetros adicionales
	después del nombre del archivo. Primero, puedes escoger una hoja de
	cálculo concreta dentro del archivo. Esto se hace, bien indicando el
	número de hoja por medio de la sintaxis (&eg;, <opt>sheet=2</opt>), o
	bien indicando el nombre de la hoja (si lo sabes) entre comillas, como
	en <opt>sheet="MacroData"</opt> pues, por defecto, se va a leer
	la primera hoja de cálculo del archivo. También puedes especificar
	un desplazamiento de columna y/o de fila dentro de la hoja de
	cálculo mediante, &eg;,
      </para>
      <code>
	--coloffset=3 --rowoffset=2
      </code>
      <para>
	lo que va a provocar que GRETL ignore las 3 primeras columnas y las 2
	primeras filas. Por defecto, hay un desplazamiento de 0 en ambas
	dimensiones, es decir, se empieza a leer en la celda de arriba a la izquierda.
      </para>
      <subhead context="cli">Archivos de texto delimitado</subhead>
      <para>
	Con archivos de texto plano, GRETL habitualmente espera encontrar
	las columnas de datos delimitadas de algún modo estándar (en general
	mediante coma, tabulador, espacio, o punto y coma). Por defecto,
	GRETL busca en la primera columna las etiquetas o las fechas de
	las observaciones, si su encabezado está vacío o bien contiene
	una cadena de texto sugerente tal como <quote>year</quote>,
	<quote>date</quote> o <quote>obs</quote>. Puedes evitar que
	GRETL trate de forma especial la primera columna indicando la opción 
	<opt>all-cols</opt>.
      </para>
      <subhead context="cli">Texto de formato fijo</subhead>
      <para>
	Un archivo de datos en texto con <quote>formato fijo</quote> es aquel que
	no tiene delimitadores de columna, pero en el que los datos se disponen
	de acuerdo con un conjunto conocido de especificaciones como, por ejemplo,
	<quote>la variable <math>k</math> ocupa 8 columnas comenzando en la columna 24</quote>.
	Para leer ese tipo de archivos, debes añadir una cadena de texto
	con <opt>fixed-cols=</opt><repl>colspec</repl>, donde <repl>colspec</repl>
	se compone de números enteros separados por comas. Estos
	enteros se interpretan como un conjunto de pares. El primer
	elemento de cada par denota una columna de inicio, medida
	en bytes desde el principio de la línea, en la que el 1 indica
	el primer byte; y el segundo elemento de cada par indica
	cuantos bytes se deben de leer para el campo indicado. Así,
	por ejemplo, si indicas
      </para>
      <code>
	open fixed.txt --fixed-cols=1,6,20,3
      </code>
      <para>
	entonces GRETL va a leer 6 bytes comenzando en la columna 1 para
	la variable 1; y para la variable 2, va a leer 3 bytes comenzando
	en la columna 20. Las líneas que están en blanco, o que comienzan
	con <lit>#</lit> se ignoran; pero en caso contrario se aplica el
	patrón de lectura de columnas, y cuando se encuentra algo distinto
	a un valor numérico válido, se muestra un fallo. Cuando se leen
	los datos satisfactoriamente, las variables se van a designar como
	<lit>v1</lit>, <lit>v2</lit>, etc. Está en manos del usuario el
	facilitar nombres con significado y/o descripciones, utilizando para ello
	las instrucciones <cmdref targ="rename"/> y/o <cmdref targ="setinfo"/>.
      </para>
      <subhead context="gui">Series con valores en formato de cadena de texto</subhead>
      <para>
	Por defecto, cuando importas un archivo que contiene series con valores
	en formato de cadena de texto, se abre una caja de texto mostrándote
	el contenido de <lit>string_table.txt</lit>, un archivo que contiene
	la correspondencia entre las cadenas y su codificación numérica.
	Puedes eliminar este proceder mediante la opción<opt>quiet</opt>.
      </para>
      <subhead context="cli">Cargando series seleccionadas</subhead>
      <para>
	El uso de <lit>open</lit> con un archivo de datos como argumento (en
	contraposición al caso con una base de datos, mira abajo) generalmente
	implica cargar todas las series del archivo indicado. Sin embargo, solo en
	el caso de archivos originales de GRETL (<lit>gdt</lit> e <lit>gdtb</lit>)
	es posible especificar un subconjunto de series a cargar, mediante su
	nombre. Esto se consigue mediante la opción <opt>select</opt>, lo que
	requiere un argumento adjunto con uno de estos formatos: el nombre de
	una única serie; una lista de nombres, separados mediante espacios y
	delimitados por comillas; o el nombre de un 'array' de cadenas de texto.
	Ejemplos:
      </para>
      <code>
	# Serie única
	open somefile.gdt --select=x1
	# Más de una serie
	open somefile.gdt --select="x1 x5 x27"
	# Método alternativo
	strings Sel = defarray("x1", "x5", "x27")
	open somefile.gdt --select=Sel
	</code>
      <subhead context="cli">Abriendo una base de datos</subhead>
      <para>
	Como se comentó antes, puedes utilizar la instrucción <lit>open</lit>
	para abrir un archivo con una base de datos, y a continuación leerlo con
	la instrucción <cmdref targ="data"/>. Los tipos de archivos que se admiten
	son las bases de datos propias de GRETL, RATS 4.0 y PcGive.
      </para>
      <para>
	Además de la lectura de estos tipos de archivos en la máquina local,
	se admiten otros tres casos más. Primero, cuando indicas la opción
	<lit>www</lit>, GRETL va a tratar de acceder a una base de datos
	propia de GRETL con el nombre que proporciones, en el servidor de
	GRETL (por ejemplo, la base de datos <lit>fedbog.bin</lit> con los
	tipos de interés de la Reserva Federal del tercer ejemplo que se
	ha indicado más arriba). En segundo lugar, puedes usar la instrucción
	<quote><lit>open dbnomics</lit></quote> para establecer que
	DB.NOMICS sea el origen para leer bases de datos; sobre esto
	consulta <mnu targ="gretlDBN">dbnomics for gretl</mnu>. En
	tercer lugar, si indicas la opción <opt>odbc</opt>, GRETL va a
	tratar de acceder a un banco de datos ODBC. Esta opción se explica
	detalladamente en <guideref targ="chap:odbc"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Archivo/Abrir archivo de datos</menu-path>
      <other-access>Arrastrar un archivo de datos hasta la ventana principal de GRETL</other-access>
    </gui-access>

  </command>

  <command name="orthdev" section="Transformations"
    label="Desviaciones ortogonales" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Aplicable solo con datos de panel. Se obtiene una serie con desviaciones
	ortogonales adelantadas para cada variable de <repl>listavariables</repl> y
	se guarda en una nueva variable con el prefijo<lit>o_</lit>. De este modo
	<cmd>orthdev x y</cmd> genera las nuevas variables <lit>o_x</lit> y
	<lit>o_y</lit>.
      </para>
      <para>
	Los valores se guardan un paso por delante de su localización temporal
	verdadera (es decir, <lit>o_x</lit> en la observación <math>t</math> va a
	contener la desviación que pertenece a <math>t</math> &minus; 1, hablando
	estrictamente). Esto es por compatibilidad con las primeras diferencias pues
	así se va a perder la primera observación de cada serie temporal, no la última.
      </para>
    </description>

  </command>

  <command name="outfile" section="Printing"
    label="Dirigir la presentación a un archivo" context="cli">

    <usage>
      <altforms>
	<altform><lit>outfile</lit> <repl>nombrearchivo</repl></altform>
	<altform><lit>outfile</lit> <lit>--buffer=</lit><repl>strvar</repl></altform>
	<altform><lit>outfile</lit> <lit>--tempfile=</lit><repl>strvar</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--append</flag>
	  <effect>Añadir a un archivo, solo la primera variante</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--buffer</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--tempfile</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--decpoint</flag>
	  <effect>Mira abajo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	La instrucción <lit>outfile</lit> inicia un bloque con el que se desvía
	todo resultado a presentar, hacia un archivo o buffer (o, si lo deseas,
	simplemente se descarta). Dicho bloque se termina con la instrucción
	<quote><lit>end outfile</lit></quote>, y después de ella los resultados
	vuelven al cauce por defecto.
      </para>

      <subhead>Desvío a un archivo señalado</subhead>
      <para>
	La primera variante que se muestra abajo envía los resultados al archivo
	señalado por el argumento <repl>nombrearchivo</repl>. Por defecto, se crea un
	nuevo archivo (o se sobrescribe uno ya existente). El archivo resultante
	se guarda en la carpeta <cmdref targ="workdir"/> de la configuración,
	vigente excepto que la cadena de texto <repl>nombrearchivo</repl> contenga
	una especificación completa de la ruta. Pero, si quieres añadir resultados
	a un archivo ya existente, utiliza la opción <opt>append</opt>.
      </para>
      <para>
	En el sencillo ejemplo que sigue, los resultados de una determinada
	regresión se escriben en el archivo señalado.
      </para>
      <code>
	open data4-10
	outfile regress.txt
	  ols ENROLL 0 CATHOL INCOME COLLEGE
	end outfile
      </code>
      <subhead>Nombres de archivos ficticios especiales</subhead>
      <para>
	Se admiten tres valores especiales para <repl>nombrearchivo</repl>,
	del siguiente modo:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>null</lit>: Se suprime la presentación de resultados hasta que
	    finalice el redireccionado.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>stdout</lit>: El resultado se redirecciona al canal de
	    <quote>resultado típico</quote>.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>stderr</lit>: El resultado se redirecciona al canal de
	    <quote>error típico</quote>.
	  </para>
	</li>
      </ilist>
      <subhead>Desvío a un buffer de cadena</subhead>
      <para>
	La opción <opt>buffer</opt> se utiliza para guardar resultados en una
	variable de cadena. El parámetro que se necesita para esta opción debe
	ser el nombre de una variable de cadena ya existente, cuyo contenido se
	sobrescribirá. Abajo se muestra el mismo ejemplo indicado anteriormente,
	modificado para guardar una cadena. En este caso, al representar el
	contenido de <lit>model_out</lit> se mostrarán los resultados redirigidos.
      </para>
      <code>
	open data4-10
	string model_out = ""
	outfile --buffer=model_out
	  ols ENROLL 0 CATHOL INCOME COLLEGE
	end outfile
	print model_out
      </code>

      <subhead>Desvío a un archivo temporal</subhead>
      <para>
	La opción <opt>tempfile</opt> se utiliza para dirigir los resultados
	hacia un archivo temporal, con un nombre generado automáticamente
	que se garantiza que es único, en el directorio <quote>punto</quote>
	del usuario. Igual que en el caso del desvío a un buffer, el parámetro
	de opción debe ser el nombre de una variable de cadena: en este caso,
	su contenido se sobrescribe con el nombre del archivo temporal.
	Atención: los archivos que se guardan en el directorio 'punto', se
	van a depurar al salir del programa, por lo que no uses esta modalidad
	si deseas que los resultados se conserven después de tu sesión
	de GRETL.
      </para>
      <para>
	Repetimos el sencillo ejemplo de arriba, con un par de líneas extra
	para ilustrar la cuestión de que <repl>strvar</repl> te indica a
	donde van los resultados, y que puedes recuperarlos utilizando la
	función <fncref targ="readfile"/>.
      </para>
      <code>
	open data4-10
	string mitemp
	outfile --tempfile=mitemp
	  ols ENROLL 0 CATHOL INCOME COLLEGE
	end outfile
	printf "Los resultados se han dirigido a %s\n", mitemp
	printf "Los resultados fueron:\n%s\n", readfile(mitemp)
	# Limpiar cuando el archivo no se necesita más
	remove(mitemp)
      </code>
      <para>
	En algunos casos, puedes querer ejercer un cierto control sobre el
	nombre del archivo temporal. Esto puedes hacerlo indicando una
	variable de cadena de texto que contenga seis <lit>X</lit> consecutivas,
	como en
      </para>
      <code>
	string mitemp = "tmpXXXXXX.csv"
	outfile --tempfile=mitemp
	...
      </code>
      <para>
	En este caso, se va a sustituir <lit>XXXXXX</lit> por una cadena de
	caracteres aleatorios que aseguren que el nombre del archivo es único,
	pero se preservará el sufijo <quote><lit>.csv</lit></quote>. Al igual
	que en el caso más simple de arriba, el archivo se escribe de forma
	automática en el directorio <quote>dot</quote> del usuario, y se modifica
	el contenido de la variable de cadena expresada mediante el indicador
	opcional, para mantener la ruta completa al archivo temporal.
      </para>

      <subhead>Discreción</subhead>
      <para>
	Los efectos de la opción <opt>quiet</opt> son: se desactiva que se vuelvan
	a presentar las órdenes de instrucción, y se muestran los mensajes auxiliares
	mientras los resultados estén redirigidos. Es equivalente a hacer
      </para>
      <code>
	set echo off
	set messages off
      </code>
      <para>
	excepto que, cuando finaliza la redirección, se restablecen los valores
	originales de las variables <lit>echo</lit> y <lit>messages</lit>.
	Esta opción está disponible en todo caso.
      </para>

      <subhead>Carácter decimal</subhead>
      <para>
	El efecto de la opción <opt>decpoint</opt> es asegurar que el carácter
	de punto decimal (en contraposición a la coma) está vigente mientras la
	salida de resultados está desviada. Cuando el bloque <lit>outfile</lit>
	finaliza, el carácter decimal vuelve al estado en que estaba antes de el.
	Esta opción resulta especialmente útil cuando el archivo texto que se
	va a crear, está destinado a ser una entrada para algún otro programa
	que requiera que los dígitos sigan las convenciones del inglés, como
	podría ser el caso de un guion de Gnuplot o de R, por ejemplo.
      </para>

      <subhead>Niveles de redirección</subhead>
       <para>
	En general, solo puedes abrir un archivo de este modo en un momento
	dado, por lo que las llamadas a esta instrucción no pueden anidarse.
	Sin embargo, la utilización de esta instrucción se permite dentro de
	funciones definidas por el usuario (siempre que el archivo de resultados
	se cierre desde dentro de la misma función) de forma que puedes desviar
	esos resultados temporalmente, y después devolverlos a un archivo de
	resultados original en caso de que <lit>outfile</lit> esté en uso en ese
	momento por el solicitante. Por ejemplo, el código
      </para>
      <code>
	function void f (string s)
	    outfile interno.txt
	      print s
	    end outfile
	end function

	outfile externo.txt --quiet
	  print "Fuera"
	  f("Dentro")
	  print "De nuevo fuera"
	end outfile
      </code>
      <para>
	producirá un archivo llamado <quote>externo.txt</quote> que contiene
	las dos líneas
      </para>
      <code>
	Fuera
	De nuevo fuera
      </code>
      <para>
	y un archivo llamado <quote>interno.txt</quote> que contiene la línea
      </para>
      <code>
	Dentro
      </code>
    </description>

  </command>

  <command name="packages" section="Utilities" label="Paquetes de funciones" context="gui">
    <description>
      <para>
	Puedes ampliar las prestaciones de GRETL mediante la utilización de
	paquetes de funciones que son de dos tipos: los <quote>Complementos</quote>
	oficiales y los paquetes de contribuciones. En conjunto, cubren muchos
	estimadores y utilidades que no están disponibles como instrucciones
	o funciones integradas en el programa.
      </para>
      <para>
	Los 'Complementos' oficiales están incluidos en los instaladores de GRETL
	para Windows y para Mac. Para Linux, si no se instalan previamente,
	entonces se descargan cuando se solicite. Puedes verificar que tus
	'Complementos' están actualizados mediante
	<mnu targ="Addons">Revisar complementos</mnu> en el menú Ayuda.
      </para>
      <para>
	Puedes echar un vistazo a los paquetes de contribuciones instalados
	en tu ordenador mediante el elemento del menú
	<mnu targ="LocalGfn">En la máquina local</mnu> y, si estás conectado
	a la red, puedes acceder a una lista de paquetes disponibles mediante
	el elemento <mnu targ="RemoteGfn">En el servidor</mnu>. Ambos
	elementos se encuentran bajo el elemento /Archivo/Paquetes de funciones.
      </para>
      <para>
	Muchos paquetes proponen agregarse por sí mismos a los menús de la Interfaz
	Gráfica de Usuario (GUI). Puedes revisar estas anexiones mediante
	<mnu targ="Registry">Registro de paquetes</mnu> (accede a él mediante
	el botón de Preferencias en el buscador de paquetes instalados).
      </para>
      <para>
	Para tener todos los detalles sobre instalar y trabajar con paquetes de
	funciones, mira <mnu targ="Pkgbook">Guía de los paquetes de funciones</mnu>
	(bajo el menú Ayuda). Esta guía también contiene detalles sobre cómo
	escribir paquetes de funciones. Puedes encontrar un agradable y
	breve punto de vista sobre la elaboración de paquetes en
	<url>http://gretl.sf.net/gfnguide/gfn_for_dummies.html</url>.
      </para>
      <para>
	Para lidiar con paquetes mediante la línea de instrucciones de GRETL,
	consulta la instrucción <cmdref targ="pkg"/>.
      </para>
    </description>
  </command>
  
  <command name="panel" section="Estimation" label="Modelos de panel">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
        <option>
	  <flag>--fixed-effects</flag>
	  <effect>Estima con efectos fijos por grupo</effect>
        </option>
        <option>
	  <flag>--random-effects</flag>
	  <effect>Modelo de efectos aleatorios o MCG (GLS)</effect>
        </option>
        <option>
	  <flag>--nerlove</flag>
	  <effect>Utiliza la transformación de Nerlove</effect>
        </option>
        <option>
	  <flag>--pooled</flag>
	  <effect>Estima mediante MCO combinados</effect>
        </option>
        <option>
	  <flag>--between</flag>
	  <effect>Estima el modelo entre-grupos</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas; mira abajo</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>cvar</optparm>
	  <effect>Desviaciones típicas conglomeradas; mira abajo</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>Incluye variables ficticias temporales</effect>
        </option>
        <option>
	  <flag>--unit-weights</flag>
	  <effect>Mínimos Cuadrados Ponderados</effect>
        </option>
        <option>
	  <flag>--iterate</flag>
	  <effect>Estimación iterativa</effect>
        </option>
        <option>
	  <flag>--matrix-diff</flag>
	  <effect>Calcula el contraste de Hausman mediante la matriz-diferencia</effect>
        </option>
        <option>
	  <flag>--unbalanced</flag>
	  <optparm>método</optparm>
	  <effect>Solo efectos aleatorios; mira abajo</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Resultados menos detallados</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Resultados más detallados</effect>
        </option>
      </options>
	<examples>
	<demos>
	  <demo>penngrow.inp</demo>
	  <demo>panel-robust.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	Estima un modelo de panel. Por defecto, se utiliza el estimador
	de efectos fijos; esto se pone en práctica restándoles las medias
	de grupo o unidad, a los datos originales.
      </para>
      <para context="cli">
	Cuando indicas la opción <opt>random-effects</opt>, se calculan las
	estimaciones de efectos aleatorios, utilizando por defecto el método
	de <cite key="swamy72">Swamy y Arora (1972)</cite>. Únicamente
	en este caso, la opción <opt>matrix-diff</opt> fuerza el uso del método
	de la matriz-diferencia (en contraposición al método de regresión)
	para llevar a cabo el contraste de Hausman sobre la consistencia del
	estimador de efectos aleatorios. También es específica del estimador
	de efectos aleatorios, la opción <opt>nerlove</opt> que escoge
	el método de <cite key="nerlove71">Nerlove (1971)</cite> en
	contraposición al de Swamy y Arora.
      </para>
      <para context="cli">
	Como alternativa, cuando indicas la opción <opt>unit-weights</opt>,
	el modelo se estima mediante mínimos cuadrados ponderados, con las
	ponderaciones basadas en la varianza residual para las unidades
	respectivas de sección cruzada de la muestra. Únicamente en este caso,
	puedes añadir la opción <opt>iterate</opt> para generar estimaciones
	iterativas y, si la iteración converge, las estimaciones resultantes
	son Máximo Verosímiles.
      </para>
      <para context="cli">
	Como alternativa posterior, si indicas la opción <opt>between</opt>,
	se estima el modelo entre-grupos (es decir, se hace una regresión MCO
	utilizando las medias de los grupos).
      </para>
      <para context="cli">
	El procedimiento por defecto para calcular Desviaciones típicas robustas
	en modelos con datos de panel, es el estimador HAC de 
	<cite key="arellano03">Arellano (2003)</cite>
	(conglomerado por unidad de panel). Las alternativas son las
	<quote>Desviaciones Típicas Corregidas de Panel</quote>
	(<cite key="beck-katz95">Beck y Katz, 1995</cite>) y las desviaciones
	típicas <quote>Consistentes de Correlación Espacial</quote>
	(<cite key="driscoll_kraay98">Driscoll y Kraay, 1998</cite>). Estas se
	pueden seleccionar mediante la instrución <lit>set panel_robust</lit> con
	los argumentos <lit>pcse</lit> y <lit>scc</lit>, respectivamente. Otras
	alternativas a estas tres opciones están disponibles mediante la opción
	<opt>cluster</opt>; por favor, consulta <guideref targ="chap:robust_vcv"/>
	para tener más detalles. Si se especifican las desviaciones típicas robustas,
	se ejecuta el contraste conjunto <math>F</math> sobre los efectos fijos
	utilizando el método robusto de <cite key="welch51">Welch (1951)</cite>.
      </para>
      <para context="gui">
	Si marcas el cuadradito <quote>Efectos aleatorios</quote>, se van a
	calcular las estimaciones (MCG) de efectos aleatorios. Por defecto, se
	utiliza el método de Swamy y Arora para la transformación MCG, pero está
	disponible el método de Nerlove como opción (mediante el botón para
	desplegar). El método de <quote>Swamy-Arora/Baltagi-Chang</quote>
	también es una opción adicional, pues en caso de un panel no equilibrado
	hace una llamada a una modificación del método de Swamy-Arora ideada
	por <cite key="baltagi-chang94">Baltagi and Chang (1994)</cite>.
	En otro caso, simplemente es equivalente al método normal de Swamy-Arora.
      </para>
      <para context="cli">
	La opción <opt>unbalanced</opt> está disponible solo para modelos
	con efectos aleatorios, y puedes usarla para elegir el método ANOVA
	que emplear con un panel desequilibrado. Por defecto, GRETL emplea
	el método de Swamy&ndash;Arora igual que se hace para los paneles
	equilibrados, excepto que utiliza la media armónica de las longitudes de las
	series de tiempo individuales en lugar de la <math>T</math> habitual.
	Bajo esta opción puedes especificar, bien <lit>bc</lit> para usar el
	método de <cite key="baltagi-chang94">Baltagi y Chang (1994)</cite>,
	o bien usar <lit>stata</lit> para emular la opción <lit>sa</lit> de la
	instrucción <lit>xtreg</lit> de Stata.
      </para>
      <para>
	Para obtener más detalles sobre la estimación de un panel, consulta
	<guideref targ="chap:panel"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Panel</menu-path>
    </gui-access>

  </command>

  <command name="panel-between" section="Estimation" context="gui"
    label="Modelo entre-grupos">

    <description>
      <para>
	Este diálogo te permite introducir una especificación para el modelo
	<quote>between</quote> en el contexto de datos de panel. Esta regresión
	utiliza las medias de grupo de los datos, ignorando por lo tanto la variación
	dentro de los grupos. Este modelo raramente resulta de gran interés por
	si mismo, pero puede serte útil con el fin de hacer comparaciones (por
	ejemplo, con el modelo de efectos fijos).
      </para>
    </description>

  </command>

  <command name="panel-mode" section="Dataset" context="gui"
    label="Organización de datos de panel">

    <description>
      <para>
	Este diálogo ofrece hasta 4 opciones para definir un conjunto de datos
	como un panel. Las dos primeras opciones requieren que el conjunto
	de datos esté ya organizado en el formato de un panel (incluso aunque
	GRETL todavía no lo tenga reconocido). La tercera opción requiere que
	el conjunto de datos contenga variables que representen la estructura
	de un panel. Y la cuarta requiere que el conjunto de datos tenga la
	estructura de una serie temporal.
      </para>
      <para>
	<emphasis>Series temporales apiladas</emphasis>: Supón que
	<repl>N</repl> es el total de unidades de sección cruzada del conjunto
	de datos, y que <repl>T</repl> = el número observaciones de las series
	temporales por unidad. Escogiendo esta opción le estás indicando a GRETL
	que el conjunto de datos se compone en ese momento de <repl>N</repl>
	bloques consecutivos de <repl>T</repl> observaciones de series temporales,
	uno por cada unidad de sección cruzada. La siguiente etapa será
	especificar el valor de <repl>N</repl>.
      </para>
      <para>
	<emphasis>Secciones cruzadas apiladas</emphasis>: Le estás indicando
	a GRETL que el conjunto de datos se compone en ese momento de
	<repl>T</repl> bloques consecutivos de <repl>N</repl> observaciones
	de sección cruzada, uno por cada período de tiempo. La siguiente etapa,
	de nuevo, será especificar el valor de
	<repl>N</repl>.
      </para>
      <para>
	Si el número total de observaciones del conjunto vigente de datos es primo,
	no tienes disponibles las dos opciones mencionadas arriba.
      </para>
      <para>
	<emphasis>Utilizar variables índice</emphasis>: Aplicado si el conjunto
	de datos está organizado en ese momento de modo descuidado (no importa
	cómo), pero contiene dos variables que indexan las unidades de sección
	cruzada y los períodos de tiempo, respectivamente. La siguiente etapa
	será escoger esas dos variables. Las variables índices de un panel no
	deben tener nada excepto valores enteros no negativos, sin valores
	ausentes. Si no hay tales variables en el conjunto de datos, no dispones
	de esta opción.
      </para>
      <para>
	<emphasis>Convertir de series temporales juntas unas con otras</emphasis>:
	Esta opción solo está disponible si el conjunto de datos vigente tiene
	una estructura de series temporales y contiene varias variables. Cuando
	se selecciona esta opción, los detalles se proporcionan mediante el
	botón de Ayuda en el siguiente paso.
      </para>
    </description>

  </command>

  <command name="ts-to-panel" section="Dataset" context="gui"
    label="Series temporales en paralelo unas con otras, a panel">

    <description>
      <para>
	Vamos a explicar para qué es conveniente esta instrucción, mediante
	dos ejemplos.
      </para>
      <para>
	<emphasis>Ejemplo 1</emphasis>: Un conjunto de datos de series temporales
	tiene cuatro series (aparte de <lit>const</lit>), que contienen el PIB de
	Francia, Alemania, Italia y España. Seleccionas 1 (el predeterminado)
	para el <quote>Número de bloques en paralelo unos con otros</quote>, y
	ves 4 para el <quote>Número de unidades de sección cruzada</quote>.
	Entonces puedes pasar las cuatro series a una única serie de panel con el
	PIB; los datos por país están apilados en el orden del conjunto de datos.
      </para>
      <para>
	<emphasis>Ejemplo 2</emphasis>: El conjunto de datos es como el descrito
	en el Ejemplo 1, excepto que las series de PIB por país están seguidas por
	cuatro series más, que contienen datos de desempleo <emphasis>para los
	mismos cuatro países, en el mismo orden que las series de PIB</emphasis>.
	Seleccionas 2 bloques en paralelo unos con otros, y ves 4 para el número
	de unidades de sección cruzada. El procesamiento va a proporcionar dos
	series de panel, una para el PIB y otra para el desempleo.
      </para>
      <para>
	Puede haber tantos bloques de series (y consiguientemente tantas series
	de panel) como desees, puesto que cada bloque contiene datos para el
	mismo conjunto de unidades de sección cruzada, proporcionados en el mismo
	orden. En caso contrario, el conjunto de datos de <quote>panel</quote>
	resultante sería absurdo.
      </para>
      <para>
	Como comprobación de corrección, el número total de series temporales
	debe ser exactamente divisible por el número de bloques en paralelo unos
	con otros. Eso significa que si el conjunto de datos original contiene
	un número primo de series, la única opción que se ofrece es convertirlas
	en una única serie de panel. Si el conjunto de datos contiene alguna
	serie adicional estraña, debes eliminarla antes de intentar esta
	operación.
      </para>
    </description>
  </command>

  <command name="panel-wls" section="Estimation" context="gui"
    label="Mínimos Cuadrados Ponderados por grupos">

    <description>
      <para>
	Mínimos cuadrados ponderados por grupos para datos de panel. Calcula
	las estimaciones de mínimos cuadrados ponderados (MCP o WLS), con las
	ponderaciones basadas en las varianzas estimadas de la perturbación para
	las respectivas unidades de sección cruzada de la muestra.
      </para>
      <para>
	Cuando seleccionas la opción de iteración, el procedimiento se repite. En
	cada ciclo, los errores se vuelven a calcular utilizando las estimaciones MCP
	actuales de los parámetros; con ellos se genera un nuevo conjunto de estimaciones
	de las varianzas de las perturbaciones y, a partir de ellas, un nuevo conjunto de
	ponderaciones. Las iteraciones terminan cuando (a) la máxima diferencia en las
	estimaciones de los parámetros de un ciclo al siguiente, cae por debajo de
	0.0001, o (b) el número de iteraciones llega a 20. Si la iteración converge,
	las estimaciones resultantes son Máximo Verosímiles.
      </para>
    </description>

  </command>

  <command name="panplot" section="Graphs"
   label="Dibuja una serie de panel" context="cli">

    <usage>
      <arguments>
        <argument>vardibujar</argument>
      </arguments>
      <options>
        <option>
	  <flag>--means</flag>
	  <effect>Serie temporal con medias de grupo</effect>
        </option>
        <option>
	  <flag>--overlay</flag>
	  <effect>Gráfico por grupo, superpuestos, N &lt;= 130</effect>
        </option>
        <option>
	  <flag>--sequence</flag>
	  <effect>Gráfico por grupo, en secuencia, N &lt;= 130</effect>
        </option>
        <option>
	  <flag>--grid</flag>
	  <effect>Gráfico por grupo, en cuadrícula, N &lt;= 16</effect>
        </option>
        <option>
	  <flag>--stack</flag>
	  <effect>Gráfico por grupo, apilados, N &lt;= 6</effect>
        </option>
        <option>
	  <flag>--boxplots</flag>
	  <effect>Gráfico de caja por grupo, en secuencia, N &lt;= 150</effect>
        </option>
        <option>
	  <flag>--boxplot</flag>
	  <effect>Gráfico único de caja, todos los grupos</effect>
        </option>
	<option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Enviar el resultado a un archivo específico</effect>
        </option>
      </options>
      <examples>
        <example>panplot x --overlay</example>
        <example>panplot x --means --output=display</example>
      </examples>
    </usage>

    <description>
      <para>
	Instrucción de dibujo específica para datos de panel: la serie
	<repl>vardibujar</repl> se dibuja del modo que se especifica
	con alguna de las opciones.
      </para>
      <para>
	Además de las opciones <opt>means</opt> y <opt>boxplot</opt>,
	el gráfico representa explícitamente las variaciones en las dos
	dimensiones, la de serie temporal y la de sección cruzada. Tales
	gráficos están limitados en lo que se refiere al número de grupos
	(o también conocidos como individuos o unidades) en el rango de la
	muestra vigente del panel. Por ejemplo, la opción <opt>overlay</opt>,
	que presenta una serie temporal para cada grupo en un único gráfico,
	solo está disponible si el número de grupos, <math>N</math>, es menor
	o igual a 130. (De otro modo, el gráfico llegaría a ser demasiado denso
	para resultar instructivo.) Si un panel es demasiado largo para permitir
	la especificación gráfica deseada, puedes escoger provisionalmente
	un rango reducido de grupos o de unidades, como en
      </para>
      <code>
	smpl 1 100 --unit
	panplot x --overlay
	smpl full
      </code>
      <para>
	Puedes usar la opción <opt>output=</opt><repl>nombrearchivo</repl>
	para controlar la forma y el destino del resultado; consulta la instrucción
	<cmdref targ="gnuplot"/> para obtener más detalles.
      </para>

    </description>

    <gui-access>
      <other-access>Ventana principal: Menú emergente (selección única)</other-access>
    </gui-access>

  </command>

  <command name="panspec" section="Tests" label="Especificación de panel">
    <usage>
      <options>
	<option>
	  <flag>--nerlove</flag>
	  <effect>Utiliza el método de Nerlove para efectos aleatorios</effect>
	</option>
	<option>
	  <flag>--matrix_diff</flag>
	  <effect>Utiliza el método de la matriz-diferencia para el contraste de Hausman</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>Suprime la presentación de resultados</effect>
	</option>
      </options>
    </usage>
    <description>
      <para>
	Esta instrucción está disponible únicamente después de estimar un modelo
	con datos de panel utilizando MCO (consulta también <cmd>setobs</cmd>).
	Contrasta la especificación combinada simple frente a las principales
	alternativas, la de efectos fijos y la de efectos aleatorios.
      </para>
      <para>
	La especificación de efectos fijos permite que la ordenada en el origen de
	la regresión varíe de una unidad de sección cruzada a otra. Se presenta
	un contraste <math>F</math> de Wald para la hipótesis nula de que
	las ordenadas en el origen no difieren. La especificación de efectos aleatorios
	descompone la varianza de cada perturbación en dos partes, una parte
	específica de la unidad de sección cruzada y otra parte específica de
	cada observación concreta. (Se puede calcular este estimador solo
	cuando el número de unidades de sección cruzada en el conjunto de
	datos supera al número de parámetros a estimar.) El estadístico de
	Multiplicadores de Lagrange de Breusch&ndash;Pagan contrasta la
	hipótesis nula de que MCO combinados es adecuado frente a la
	alternativa de efectos aleatorios.
      </para>
      <para>
	MCO combinados pueden rechazarse frente a ambas alternativas. Mientras
	la perturbación específica por unidad o grupo no esté correlacionada con
	las variables independientes, el estimador de efectos aleatorios será más
	eficiente que el de efectos fijos; en otro caso, el estimador de efectos
	aleatorios será inconsistente y serán preferibles los efectos fijos. La
	hipótesis nula del contraste de Hausman indica que la perturbación
	específica de grupo <emphasis>no</emphasis> está así correlacionada
	(y por eso se prefiere el estimador de efectos aleatorios). Un valor bajo
	de la probabilidad asociada (valor p) al estadístico de este contraste va
	en contra de los efectos aleatorios y a favor de los efectos fijos.
      </para>
      <para>
	Las dos primeras opciones de esta instrucción se corresponden con la estimación de efectos
	aleatorios. Por defecto, se utiliza el método de Swamy y Arora, mediante
	el cálculo del estadístico de contraste de Hausman, utilizando el método
	de regresión. Las opciones permiten utilizar el estimador alternativo
	de la varianza de Nerlove, y /o la aproximación de la matriz-diferencia
	al estadístico de Hausman.
      </para>
      <para>
	Cuando se completa con éxito, los accesores <fncref targ="$test"/> y
	<fncref targ="$pvalue"/> proporcionan 3 vectores que contienen los
	estadísticos de prueba y los valores p para los tres contrastes indicados
	arriba: combinabilidad (Wald), combinabilidad (Breusch&ndash;Pagan),
	y Hausman. Si solo quieres los resultados de esta forma, puedes indicar
	la opción <opt>quiet</opt> para saltarte la presentación de resultados.
      </para>
      <para>
	Ten en cuenta que luego de estimar la especificación de efectos
	aleatorios con la instrucción <cmd>panel</cmd> , el test de Hausman
	se ejecuta automáticamente y puedes recuperar los resultados mediante
	el accesor <fncref targ="$hausman"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contrastes/Especificaciones de panel</menu-path>
    </gui-access>

  </command>

  <command name="pca" section="Statistics"
    label="Análisis de Componentes Principales">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--covariance</flag>
	  <effect>Utiliza la matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--save</flag>
	  <optparm optional="true">n</optparm>
	  <effect>Guarda las componentes más importantes</effect>
        </option>
        <option>
	  <flag>--save-all</flag>
	  <effect>Guarda todas las componentes</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
	Análisis de Componentes Principales. Presenta los autovalores de la
	matriz de correlaciones (o de la matriz de covarianzas si marcas el
	cuadradito de opciones) para las variables de <repl>listavariables</repl>,
	junto con la proporción de la varianza conjunta representada por cada
	componente. También presenta los correspondientes autovectores (o
	<quote>pesos de las componentes</quote>).
      </para>
      <para>
	En la ventana que presenta los resultados, tienes la posibilidad de guardar
	las Componentes Principales como series, en el conjunto de datos.
      </para>
    </description>

    <description context="cli">
      <para>
	Análisis de Componentes Principales. Excepto cuando indicas la
	opción <opt>quiet</opt>, presenta los valores propios de la
	matriz de correlaciones (o de la matriz de covarianzas cuando
	indicas la opción <opt>covariance</opt>) para las variables
	que forman <repl>listavariables</repl>, junto con la proporción de la
	varianza conjunta representada por cada componente. También
	presenta los correspondientes autovectores o
	<quote>pesos de las componentes</quote>.
      </para>
      <para>
	Si indicas la opción <opt>save-all</opt>, entonces se guardan
	todas las componentes como series en el conjunto de datos, con los
	nombres <lit>PC1</lit>, <lit>PC2</lit>, etcétera. Estas variables
	artificiales se forman como la suma de los productos de (el peso de la
	componente) por (<math>X</math><sub>i</sub> tipificada), donde
	<math>X</math><sub>i</sub> denota la variable <math>i</math>-ésima
	de <repl>listavariables</repl>.
      </para>
      <para>
	Si indicas la opción <opt>save</opt> sin un valor del parámetro,
	se guardan las componentes con valores propios mayores que la media
	(lo que significa mayores que 1.0 cuando el análisis se basa en la
	matriz de correlaciones) en el conjunto de datos, tal como se
	describió arriba. Si indicas un valor para <repl>n</repl>
	con esta opción, entonces se guardan las <repl>n</repl> componentes
	más importantes.
      </para>
      <para>
	Consulta también la función <fncref targ="princomp"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Componentes principales</menu-path>
    </gui-access>

  </command>

  <command name="pergm" section="Statistics" label="Periodograma">

    <usage>
      <arguments>
        <argument>serie</argument>
        <argument optional="true">anchobanda</argument>
      </arguments>
      <options>
        <option>
	  <flag>--bartlett</flag>
	  <effect>Utiliza la ventana de retardo de Bartlett</effect>
        </option>
        <option>
	  <flag>--log</flag>
	  <effect>Utiliza la escala logarítmica</effect>
        </option>
        <option>
	  <flag>--radians</flag>
	  <effect>Muestra la frecuencia en radianes</effect>
        </option>
        <option>
	  <flag>--degrees</flag>
	  <effect>Muestra la frecuencia en grados</effect>
        </option>
        <option>
	  <flag>--plot</flag>
	  <optparm>modo-o-nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>Omite la presentación del resultado</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcula y muestra el espectro de la serie especificada. Por defecto,
	se indica el periodograma de la muestra, pero se utiliza opcionalmente
	una ventana de retardo de Bartlett al estimar el espectro, (consulta
	por ejemplo, el libro de Greene <book>Econometric Analysis</book>
	para ver una discusión sobre esto). La anchura por defecto de la ventana
	de Bartlett es de dos veces la raíz cuadrada del tamaño de la muestra, pero
	puedes establecer esto de modo manual utilizando el parámetro
	<repl>anchobanda</repl>, hasta un máximo de la mitad del tamaño de la muestra.
      </para>
      <para>
	Cuando indicas la opción <opt>log</opt>, se representa el espectro
	en una escala logarítmica.
      </para>
      <para>
	Las opciones (mutuamente excluyentes) <opt>radians</opt> y
	<opt>degrees</opt> afectan al aspecto del eje de frecuencias
	cuando se dibuja el periodograma. Por defecto, la frecuencia
	se escala por el número de períodos de la muestra, pero esas dos
	opciones provocan que el eje se etiquete desde 0 hasta &pi;
	radianes o desde 0 a 180&deg;, respectivamente.
      </para>
      <para>
	Por defecto, si GRETL no está en modo de procesamiento por
	lotes, se muestra un gráfico del periodograma. Puedes ajustar esto
	mediante la opción <opt>plot</opt>. Los parámetros admisibles para
	esta opción son <lit>none</lit> (para suprimir el gráfico),
	<lit>display</lit> (para representar un gráfico incluso en modo
	de procesamiento por lotes), o un nombre de archivo. El efecto de
	indicar un nombre de archivo es como se describe para la opción
	<opt>output</opt> de la instrucción <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Periodograma</menu-path>
      <other-access>Ventana principal: Menú emergente (selección única)</other-access>
    </gui-access>
  </command>

  <command name="pkg" section="Utilities" context="cli">
    <usage>
      <arguments>
      	<argument>acción</argument>
        <argument>nombrepaquete</argument>
      </arguments>
      <options>
        <option>
	  <flag>--local</flag>
	  <effect>Instala desde un archivo local</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--staging</flag>
	  <effect>Mira abajo</effect>
        </option>
      </options>
     <examples>
        <example>pkg install armax</example>
        <example>pkg install /path/to/myfile.gfn --local</example>
        <example>pkg query ghosts</example>
        <example>pkg run-sample ghosts</example>
        <example>pkg unload armax</example>
     </examples>
    </usage>

    <description>
      <para>
	Esta instrucción proporciona una manera de instalar, consultar,
	descargar, eliminar o indexar paquetes de funciones de GRETL.
	El argumento <repl>acción</repl> debe ser alguno de entre
	<lit>install</lit>, <lit>query</lit>, <lit>run&#8209;sample</lit>,
	<lit>unload</lit>, <lit>remove</lit> o <lit>index</lit>, respectivamente.
	Una extensión para dar soporte a paquetes de archivos de datos
	se describe más abajo.
      </para>
      <para>
	<lit>install</lit>: En su forma más elemental, sin ningún indicador de
	opción y con el argumento <repl>nombrepaquete</repl> expresado como
	el nombre <quote>plano</quote> de un paquete de funciones de GRETL (como
	en el primer ejemplo de arriba), el efecto de esta opción consiste
	en descargar el paquete que se especifica del servidor de GRETL,
	(excepto que <repl>nombrepaquete</repl> comience con <lit>http://</lit>),
	e instalarlo en la máquina local. En este caso, no es necesario expresar
	una extensión en el nombre del archivo. Sin embargo, cuando indicas
	la opción <opt>local</opt>, el argumento <repl>nombrepaquete</repl>
	debe ser la ruta a un archivo de paquete en la máquina local, que
	todavía no esté instalado, y expresado con una extensión correcta
	(<lit>.gfn</lit> o <lit>.zip</lit>). En este caso, el efecto consiste
	en copiar el archivo en su sitio (<lit>gfn</lit>), o descomprimirlo
	en su sitio (<lit>zip</lit>), significando <quote>en su sitio</quote>
	allí donde lo va a encontrar la instrucción <cmdref targ="include"/>	.
      </para>
      <para>
	<lit>query</lit>: Por defecto, la consecuencia de esta opción es la
	presentación de información básica sobre el paquete especificado
	(autor, versión, etc.). Si el paquete incluye recursos extra (archivos de
	datos y/o guiones adicionales) se incluye un listado de esos archivos.
	Si añades la opción <opt>quiet</opt>, no se presenta nada; en su
	lugar, se guarda la información del paquete en forma de un 'bundle'
	de GRETL, al que se puede acceder mediante <fncref targ="$result"/>.
	Si no se puede encontrar ninguna información, este 'bundle' estará
	vacío.
      </para>
      <para>
	<lit>run-sample</lit>: Proporciona un recurso mediante linea de instrucciones
	para ejecutar el guion de prueba incluido en el paquete especificado.
      </para>
      <para>
	<lit>unload</lit>: Debes indicar el argumento <repl>pkgname</repl> en
	modo 'plano', sin ruta ni extensión, como en el último ejemplo de arriba.
	La consecuencia de esto es la descarga de ese paquete en cuestión de la
	memoria de GRETL (si está cargado en ese momento), y también eliminarlo del
	menú de la Interfaz Gráfica (GUI) al que esté añadido, si lo está a alguno.
      </para>
      <para>
	<lit>remove</lit>: Realiza las acciones indicadas para <lit>unload</lit>
	y, además, elimina del disco el(los) archivo(s) asociado(s) con el
	paquete indicado.
      </para>
      <para>
	<lit>index</lit>: Es un caso especial en el que <repl>nombrepaquete</repl>
	debe sustituirse por la palabra clave <quote><lit>addons</lit></quote>:
	la consecuencia de ello es que se actualiza el índice de los paquetes estándar
	que se conocen como <quote>Complementos</quote>. Esa actualización se
	realiza automáticamente de vez en cuando, pero en algún caso puede
	resultar útil una actualización manual. En tal caso, la opción
	<opt>verbose</opt> provoca un resultado impreso sobre donde ha hecho
	GRETL la búsqueda, y lo que ha encontrado. Siendo claros, aquí tienes
	un modo de conseguir un resultado con el índice completo:
      </para>
      <code>
	pkg index addons --verbose
      </code>
	<subhead>Paquetes de archivos de datos</subhead>
	    <para>
	Además de su utilización con paquetes de funciones, la instrucción
	<lit>pkg install</lit> también se puede usar con paquetes de archivos
	de datos de tipo <lit>tar.gz</lit> como se indican en el listado de
	<url>https://gretl.sourceforge.net/gretl_data.html</url>. Por ejemplo,
	para instalar los archivos de datos de Verbeek, se puede hacer
	    </para>
	    <code>
	pkg install verbeek.tar.gz
	    </code>
	    <para>
  Ten en cuenta que <lit>install</lit> es la única operación admitida
  para esos archivos.
      </para>
  <subhead>Montaje</subhead>
      <para>
	La opción <opt>staging</opt> es un elemento de conveniencia para los
	desarrolladores y está disponible únicamente en conjunción con la
	acción <lit>install</lit> cuando se aplica a un paquete de función.
	Su efecto consiste en que se descarga el paquete en cuestión del
	área de montaje (<lit>staging</lit>) de Sourceforge en lugar de
	hacerlo de un área pública. Los paquetes en montaje todavía no están
	aprobados para uso general; por eso, ignora esta opción a no ser que
	sepas lo que estás haciendo.
      </para>
    </description>

    <gui-access>
      <menu-path>/Archivo/Paquetes de funciones/Sobre servidor</menu-path>
    </gui-access>
  </command>

  <command name="pkg-depends" section="Programming"
	   label="Dependencies" context="gui">
    <description>
      <para>
	Por <quote>dependencias</quote> queremos referirnos a los paquetes de
	funciones de los que depende tu propio paquete para alguna de
	sus funcionalidades; y que, consecuentemente, debes tener descargados
	e instalados con objeto de que tu paquete funcione correctamente. Puedes
	especificar hasta cuatro de esos paquetes en este diálogo.
      </para>
      <para>
	Por ejemplo, supón que utilizas una o más funciones del paquete
	<lit>extra</lit>, que contiene varias utilidades para la redacción con
	HANSL. En ese caso, podrías escribir
      </para>
      <code>
	extra
      </code>
      <para>
	en uno de los huecos disponibles (en el primero si no hay
	ninguna otra dependencia). Observa que debes indicar el
	nombre 'plano' del paquete, sin poner la ruta completa ni
	el sufijo <lit>.gfn</lit> ni <lit>.zip</lit>.
      </para>
      <para>
	Opcionalmente, puedes marcar la primera dependencia como un
	<quote>proveedor</quote>. El efecto de esto es el de propiciar que tu
	paquete tenga acceso a cualquier función privada del paquete especificado.
	Generalmente, esto no va a hacer falta pero puede serte útil cuando
	diseñas dos paquetes para que funcionen en estrecha colaboración.
      </para>
    </description>
  </command>

  <command name="plot" section="Graphs" context="cli">
    <usage>
      <arguments>
        <argument optional="true">datos</argument>
      </arguments>
      <options>
        <option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el resultado al archivo indicado</effect>
        </option>
        <option>
	  <flag>--outbuf</flag>
	  <optparm>nomecadea</optparm>
	  <effect>Envía el resultado a la cadena de texto indicada</effect>
        </option>
      </options>
	<examples>
	<demos>
	  <demo>nile.inp</demo>
	</demos>
	</examples>
    </usage>

    <description>
      <para>
	El bloque <lit>plot</lit> proporciona una alternativa a la instrucción
	<cmdref targ="gnuplot"/> que puede ser más conveniente cuando estás
	generando un gráfico complicado (con varias opciones y/o instrucciones
	Gnuplot para que se inserten en el archivo gráfico). Además de la siguiente
	explicación, por favor, consulta también <guideref targ="chap:graphs"/>
	para ver otros ejemplos.
      </para>
      <para>
	Un bloque de tipo <lit>plot</lit> comienza con la palabra de instrucción
	<lit>plot</lit>. Habitualmente va seguida de un argumento de
	<repl>datos</repl> que especifica los datos que se van a representar,
	y que debe indicar el nombre de una lista, de una matriz o de una
	única serie. Si no especificas datos de entrada, el bloque debe
	contener en su lugar al menos una directriz para dibujar una
	fórmula; ese tipo de directivas puedes indicarlas por medio de
	lineas de tipo <lit>literal</lit> o <lit>printf</lit> (mira más abajo).
      </para>
      <para>
	Cuando indicas una lista (o una matriz), se asume que el último término
	(o la última columna de la matriz) es la variable del eje <math>x</math>
	y que los(as) otros(as) son las variables del eje <math>y</math>, excepto
	cuando indicas la opción <opt>time-series</opt>, en cuyo caso todos los
	datos especificados van en el eje <math>y</math>. La opción de
	proporcionar el nombre de una sola serie se restringe a los datos de
	series temporales, en cuyo caso se asume que quieres un gráfico de
	series temporales; en otro caso, se muestra un fallo.
      </para>
      <para>
	La línea de comienzo se puede preceder de la expresión
	<quote><repl>savename</repl> <lit>&lt;-</lit></quote> para que
	se guarde un gráfico como icono en el programa de Interfaz Gráfica
	de Usuario (GUI). El bloque acaba con <lit>end plot</lit>.
      </para>
      <para>
	Dentro del bloque tienes cero o más líneas de los siguientes tipos,
	identificadas por la palabra clave inicial:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>option</lit>: Especifica una opción simple.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>options</lit>: Especifica múltiples opciones en una sola línea,
	  separadas por espacios.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>literal</lit>: Una instrucción que se va a pasar literalmente
	    a Gnuplot.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>printf</lit>: Un enunciado printf cuyo resultado se pasará
	    literalmente a Gnuplot.
	  </para>
	</li>
      </ilist>
      <para>
	Ten en cuenta que al lado de las opciones <opt>output</opt> y
	<opt>outbuf</opt> (que se deben añadir a la línea con que acaba el bloque),
	todas las opciones que admite la instrucción <cmdref targ="gnuplot"/>
	también las admite la instrucción <lit>plot</lit>, pero deben indicarse
	dentro del bloque, utilizando la sintaxis descrita más arriba. En este
	contexto, no es necesario proporcionar el habitual doble guion antes del
	indicador de opción. Para obtener más detalles sobre los efectos de las
	distintas opciones, consulta <cmdref targ="gnuplot"/>.
      </para>
      <para>
	La intención de utilizar el bloque <lit>plot</lit> se ilustra mejor con el
	ejemplo:
      </para>
      <code>
	string title = "Mi título"
	string xname = "Mi variable X"
	plot plotmat
	    options with-lines fit=none
	    literal set linetype 3 lc rgb "#0000ff"
	    literal set nokey
	    printf "set title '%s'", title
	    printf "set xlabel '%s'", xname
	end plot --output=display
      </code>
      <para>
	Este ejemplo asume que <lit>plotmat</lit> es el nombre de una matriz
	que tiene 2 columnas por lo menos (o una lista que tiene 2 elementos
	por lo menos). Ten en cuenta que se considera una buena praxis colocar
	(únicamente) la opción <opt>output</opt> en la última línea del bloque;
	otras opciones deberías colocarlas dentro del bloque.
      </para>
      <subhead>Dibujar un gráfico sin datos</subhead>
      <para>
	El seguiente ejemplo muestra un caso de cómo especificar la representación
	de una gráfica sin ter una fuente de datos.
      </para>
      <code>
	plot
	    literal set title 'Utilidad CRRA'
	    literal set xlabel 'c'
	    literal set ylabel 'u(c)'
	    literal set xrange[1:3]
	    literal set key top left
	    literal crra(x,s) = (x**(1-s) - 1)/(1-s)
	    printf "plot crra(x, 0) t 'sigma=0', \\"
	    printf " log(x) t 'sigma=1', \\"
	    printf " crra(x,3) t 'sigma=3"
	end plot --output=display
      </code>
    </description>

  </command>

  <command name="polyweights" section="Transformations" context="gui"
    label="Ajustar una tendencia polinómica">

    <description>
      <para>
	Al ajustar una tendencia polinómica a una serie temporal puedes
	desear darles un peso adicional a las observaciones del principio y
	del final de la muestra. (Los puntos en el medio del rango de la muestra tienen
	vecinos a ambos lados que es probable que estén tirando del ajuste
	en la misma dirección común.)
      </para>
      <para>
	Puedes utilizar los esquemas de ponderación (cuadrático, coseno-campana
	y por pasos) que se ofrecen aquí con ese propósito. Si escoges uno
	de estos esquemas, debes elegir dos opciones adicionales. Primero:
	¿Qué ponderación máxima se debe utilizar (la mínima ponderación
	básica es 1.0)? Segundo: ¿A qué fracción central de la muestra se le
	debe aplicar una ponderación uniforme (la mínima)?
      </para>
      <para>
	Supón, por ejemplo, que eliges una ponderación máxima de 3.0 y
	una fracción central de 0.4. Esto significa que el 40 por ciento
	central de los datos tienen una ponderación de 1.0. Si seleccionas
	la forma <quote>steps</quote>, el primer y el último 30 por ciento
	de las observaciones tienen una ponderación de 3.0; en otro caso, para
	el primer 30 por ciento de observaciones, las ponderaciones declinan
	gradualmente desde 3.0 hasta 1.0 y, para el último 30 por ciento, las
	ponderaciones aumentan desde 1.0 hasta 3.0.
      </para>
    </description>

  </command>

  <command name="poisson" section="Estimation"
    label="Estimación de Poisson">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
        <argument separated="true" optional="true">exposición</argument>
      </arguments>
      <options>
        <option>
          <flag>--robust</flag>
          <effect>Desviaciones típicas robustas</effect>
        </option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para más explicaciones</effect>
        </option>
        <option>
          <flag>--vcv</flag>
          <effect>Presenta la matriz de covarianzas</effect>
        </option>
        <option>
          <flag>--verbose</flag>
          <effect>Presenta los detalles de las iteraciones</effect>
        </option>
	      <option>
	        <flag>--quiet</flag>
	        <effect>No presenta los resultados</effect>
	      </option>
      </options>
      <examples>
        <example>poisson y 0 x1 x2</example>
	<example>poisson y 0 x1 x2 ; S</example>
	<demos>
	  <demo>camtriv.inp</demo>
	  <demo>greene19_3.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Estima una regresión de Poisson. Se coge la variable dependiente
	para representar el acaecimiento de sucesos de algún tipo, y debe
	tener solo valores enteros no negativos.
      </para>
      <para>
	Si una variable aleatoria discreta <math>Y</math> sigue una
	distribución de Poisson, entonces
        <equation status="display"
          tex="\[\mathrm{Pr}(Y = y) = \frac{e^{-v} v^y}{y!}\]"
          ascii="Pr(Y = y) = exp(-v) * v^y / y!"
          graphic="poisson1"/>
	para <math>y</math> = 0, 1, 2,&hellip;. La media y la varianza
	de la distribución son ambas iguales a <math>v</math>. En el modelo
	de regresión de Poisson, el parámetro <math>v</math> está
	representado como una función de una o más variables
	independientes. La versión más habitual (y la única que admite
	GRETL) cumple
        <equation status="display"
          tex="\[v = \mathrm{exp}(\beta_0+\beta_1 x_1+\beta_2 x_2 + \cdots)\]"
          ascii="v = exp(b0 + b1*x1 + b2*x2 + ...)"
          graphic="poisson2"/>
	o, en otras palabras, el logaritmo de <math>v</math>
	es una función lineal de las variables
	independientes.
      </para>
      <para>
	Como opción, puedes añadir una variable de exposición (<quote>offset</quote>)
	a la especificación. Esta es una variable de escala, y su logaritmo
	se añade a la función lineal de regresión (implícitamente, con un coeficiente de
	1.0). Esto tiene sentido si esperas que el número de ocurrencias del evento
	en cuestión es proporcional (manteniéndose lo demás constante) a algún
	factor conocido. Por ejemplo, puedes suponer que el número de accidentes
	de tráfico es proporcional al volumen de tráfico (manteniéndose lo demás
	constante) y, en ese caso, el volumen de tráfico puede expresarse como una
	variable <quote>de exposición</quote> en un modelo de Poisson del cociente
	de accidentes. La variable de exposición debe ser estrictamente positiva.
      </para>
      <para>
	Por defecto, se calculan las desviaciones típicas utilizando la inversa
	negativa de la matriz Hessiana. Si especificas la opción <opt>robust</opt>,
	entonces se calculan en su lugar las desviaciones típicas CMV (QML) o de
	Huber&ndash;White. En este caso, la matriz de covarianzas estimada es un
	<quote>emparedado</quote> entre la inversa de la matriz Hessiana estimada
	y el producto externo del vector gradiente.
      </para>
      <para>
	Consulta también <cmdref targ="negbin"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Variable dependiente limitada/Datos de conteo</menu-path>
    </gui-access>

  </command>

  <command name="print" section="Printing"
    label="Presentar datos o cadenas de texto" context="cli">

    <usage>
      <altforms>
        <altform><lit>print</lit> <repl>listavariables</repl></altform>
	<altform><lit>print</lit></altform>
	<altform><lit>print</lit> <repl>nombresobjetos</repl></altform>
        <altform><lit>print</lit> <repl>cadenaliteral</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--byobs</flag>
	  <effect>Por observaciones</effect>
	</option>
	<option>
	  <flag>--no-dates</flag>
	  <effect>Utiliza números de observación simples</effect>
	</option>
	<option>
	  <flag>--range</flag>
	  <optparm>inicio:parada</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--midas</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--tree</flag>
	  <effect>Específico para bundles; mira abajo</effect>
	</option>
      </options>
      <examples>
	<example>print x1 x2 --byobs</example>
	<example>print my_matrix</example>
	<example>print "Esto es una cadena"</example>
	<example>print my_array --range=3:6</example>
	<example>print hflist --midas</example>
      </examples>
    </usage>

    <description>
      <para>
	Ten en cuenta que <lit>print</lit> es más bien una instrucción
	<quote>básica</quote> (con la intención principal de presentar
	los valores de las series). Consulta <cmdref targ="printf"/> y
	<cmdref targ="eval"/> para otras alternativas más avanzadas
	y menos restrictivas.
      </para>
      <para>
	En la primera variante mostrada arriba (consulta el primer ejemplo
	también), <repl>listavariables</repl> debe ser una lista de series (bien
	una lista ya definida, o bien una lista especificada mediante los
	nombres o números ID de las series, separados por espacios). En este caso,
	esta instrucción presenta los valores de las series de la lista. Por defecto,
	los datos se presentan <quote>por variable</quote>, pero si añades
	la opción <opt>byobs</opt> se presentan por observación. Cuando se
	presentan por observación, por defecto se muestra la fecha (con datos
	de series temporales) o la cadena de texto de la etiqueta de observación
	(en caso de que lo haya) al comienzo de cada línea. Mediante la opción
	<opt>no-dates</opt> se elimina la presentación de las fechas o de las
	etiquetas; en su lugar se muestra un simple número de observación.
	Consulta el párrafo final de estos comentarios para ver el efecto de la
	opción <opt>midas</opt> (que se aplica solo a una lista ya definida
	de series).
      </para>
      <para>
	Cuando no indicas ningún argumento (la segunda variante mostrada arriba)
	entonces el efecto es similar al primer caso, excepto que se van a presentar
	<emphasis>todas</emphasis> las series del conjunto vigente de datos.
	Las opciones que se admiten son como se describieron más arriba.
      </para>
      <para>
	La tercera variante (con el argumento <repl>nombresobjetos</repl>;
	mira el segundo ejemplo) espera una lista de nombres, separados
	por espacios, de objetos básicos de GRETL que no sean series
	(escalares, matrices, cadenas de texto, bundles, arrays); y se muestra
	el valor de estos objetos. En el caso de los 'bundles', sus componentes
	se ordenan por tipo y alfabéticamente.
      </para>
      <para>
	En la cuarta forma (tercer ejemplo), <repl>cadenaliteral</repl>
	debe ser una cadena de texto puesta entre comillas
	(y no debe haber nada más siguiendo a la línea de instrucción).
	Se presenta la cadena de texto en cuestión, seguida de un carácter
	de línea nueva.
      </para>
      <para>
	Puedes utilizar la opción <opt>range</opt> para controlar el volumen de
	información que se presenta. Los valores (enteros) de los marcadores
	de <repl>inicio</repl> y <repl>parada</repl> pueden referirse a
	observaciones de series y de listas, a filas de matrices, a elementos
	de 'arrays', y a líneas de cadenas de texto. En todos los casos, el
	valor mínimo de <repl>inicio</repl> es 1, y el máximo valor de
	<repl>parada</repl> es el <quote>tamaño en forma de filas</quote> del
	objeto en cuestión. Los valores negativos de estos marcadores se usan
	para disponer un recuento hacia atrás, desde el final. Puedes indicar
	estos marcadores en formato numérico, o mediante nombres de variables
	escalares previamente definidas. Si omites <repl>inicio</repl>, se
	considera implícitamente igual a 1; y si omites <repl>parada</repl>,
	eso significa ir hasta el final del todo. Con series y listas, ten en
	cuenta que los marcadores se refieren al rango muestral vigente.
      </para>
      <para>
	La opción <opt>tree</opt> es específica para presentar un
	bundle de GRETL. El efecto de ello es que, si el paquete especificado
	contiene otros bundles o arrays de ellos, se presentan sus
	contenidos. De lo contrario, solo se presentan los elementos del nivel superior
	del bundle.
      </para>
      <para>
	La opción <opt>midas</opt> es especial para presentar una lista de series
	y, más aún, es específica para conjuntos de datos que contienen una
	o más series de alta frecuencia, cada una representada por una
	<cmdref targ="MIDAS_list"/>. Cuando indicas una de esas listas como
	argumento y agregas esta opción, la serie se presenta por observación
	de su frecuencia <quote>original</quote>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos/Mostrar valores</menu-path>
    </gui-access>

  </command>

  <command name="printf" section="Printing"
    label="Presentación con formato" context="cli">

    <usage>
      <arguments>
        <argument>formato</argument>
	      <argpunct>, </argpunct>
        <argument>elementos</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Presenta valores escalares, series, matrices o cadenas de texto
	bajo el control de una cadena de texto para dar formato (ofreciendo
	una parte de la función <lit>printf</lit> del lenguaje de programación
	C). Los formatos numéricos reconocidos son <lit>%e</lit>,
	<lit>%E</lit>, <lit>%f</lit>, <lit>%g</lit>, <lit>%G</lit>,
	<lit>%d</lit> y <lit>%x</lit>, en cada caso con los diversos
	reguladores disponibles en C. Ejemplos: el formato <lit>%.10g</lit>
	presenta un valor con 10 cifras significativas, y <lit>%12.6f</lit>
	presenta un valor con un ancho de 12 caracteres de los que 6 son
	decimales. Sin embargo, ten en cuenta que en GRETL el formato <lit>%g</lit>
	es una buena elección por defecto para todos los valores numéricos,
	y no tienes necesidad de complicarte demasiado. Debes
	utilizar el formato <lit>%s</lit> para las cadenas de texto.
      </para>
      <para>
	La propia cadena de formato debe estar puesta entre comillas,
	y los valores que se van a presentar deben ir después de esa cadena
	de formato, separados por comas. Estos valores deben tener la forma
	de, o bien (a) los nombres de las variables, o bien (b) expresiones que generen
	alguna clase de resultado que sea presentable, o bien (c) las funciones
	especiales <lit>varname()</lit> o <lit>date()</lit>. El siguiente
	ejemplo presenta los valores de dos variables, más el de una expresión
	que se calcula:
      </para>
      <code>
	ols 1 0 2 3
	scalar b = $coeff[2]
	scalar se_b = $stderr[2]
	printf "b = %.8g, Desviación típica %.8g, t = %.4f\n",
          b, se_b, b/se_b
      </code>
      <para>
	Las siguientes líneas ilustran el uso de las funciones 'varname' y 'date',
	que presentan respectivamente el nombre de una variable (indicado
	por su número ID) y una cadena de texto con una fecha (dada por
	un número natural positivo que indica una observación).
      </para>
      <code>
	printf "El nombre de la variable %d es %s\n", i, varname(i)
	printf "La fecha de la observación %d es %s\n", j, date(j)
      </code>
      <para>
	Cuando indicas un argumento matricial asociado a un formato
	numérico, se presenta la matriz entera utilizando el formato
	especificado para cada elemento. El mismo se aplica a las series,
	excepto que el rango de valores presentados se rige por la configuración
	vigente de la muestra.
      </para>
      <para>
	La longitud máxima de una cadena de formato es de 127 caracteres.
	Se reconocen las secuencias de escape <lit>\n</lit> (nueva línea),
	<lit>\r</lit> (salto de línea), <lit>\t</lit> (tabulación), <lit>\v</lit>
	(tabulación vertical) y <lit>\\</lit> (barra inclinada a la izquierda
	literal). Para presentar un signo por ciento literal, utiliza
	<lit>%%</lit>.
      </para>
      <para>
	Como en C, puedes indicar los valores numéricos que forman parte
	del formato (el ancho y/o la precisión) directamente como números,
	como en <lit>%10.4f</lit>, o como variables. En este último caso,
	se ponen asteriscos en la cadena de formato y se proporcionan los
	argumentos correspondientes por orden. Por ejemplo:
      </para>
      <code>
	scalar ancho = 12
	scalar precision = 6
	printf "x = %*.*f\n", ancho, precision, x
      </code>
    </description>

  </command>

  <command name="probit" section="Estimation"
    label="Modelo Probit">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
	</option>
	<option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para más explicaciones</effect>
        </option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>Muestra los valores p en lugar de las pendientes</effect>
	</option>
	<option>
	  <flag>--estrella</flag>
	  <effect>Elige la variante pseudo-R-cuadrado</effect>
	</option>
	<option>
	  <flag>--random-effects</flag>
	  <effect>Estima un modelo Probit de panel con efectos aleatorios, EA</effect>
	</option>
	<option>
	  <flag>--quadpoints</flag>
	  <optparm>k</optparm>
	  <effect>Número de puntos de cuadratura para la estimación con EA</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>ooballot.inp</demo>
	  <demo>oprobit.inp</demo>
	  <demo>reprobit.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Si la variable dependiente es una variable binaria (todos sus
	valores son 0 o 1), se obtienen estimaciones máximo verosímiles
	de los coeficientes de las variables de <repl>indepvars</repl> mediante
	el método de Newton&ndash;Raphson. Como el modelo es no lineal,
	las pendientes están condicionadas por los valores de las variables
	independientes. Por defecto, se calculan las pendientes con respecto a
	cada una de las variables independientes (en las medias de esas variables)
	y estas pendientes substituyen a los valores p habituales en el resultado
	de la regresión. Puedes prescindir de este proceder indicando la opción
	<opt>p-values</opt>. El estadístico chi-cuadrado contrasta la hipótesis
	nula de que todos los coeficientes son cero, excepto el de la
	constante.
      </para>
      <para context="cli">
	Por defecto, las desviaciones típicas se calculan utilizando la inversa negativa
	de la matriz Hessiana. Si indicas la opción <opt>robust</opt>, entonces se calculan
	en su lugar las desviaciones típicas CMV (QML) o de Huber&ndash;White. En este
	caso, la matriz de covarianzas estimadas es un <quote>emparedado</quote>
	entre la inversa de la matriz Hessiana estimada y el producto externo del vector
	gradiente. Para obtener más detalles, consulta el capítulo 10 del libro de
	<cite key="davidson-mackinnon04">Davidson y MacKinnon (2004)</cite>.
      </para>
      <para context="cli">
	Por defecto, se va a presentar el estadístico pseudo-R-cuadrado que
	fue sugerido por <cite key="mcfadden74">McFadden (1974)</cite>;
	pero en el caso binario, si indicas la opción <opt>estrella</opt>
	se va a presentar en su lugar la variante recomendada por
	<cite key="estrella98">Estrella (1998)</cite>. Esta variante
	presumiblemente imita de forma más parecida las propiedades del
	<math>R</math><sup>2</sup> habitual en el contexto de la estimación
	de mínimos cuadrados.
      </para>
      <para context="gui">
	Por defecto, las desviaciones típicas se calculan utilizando la
	inversa negativa de la matriz Hessiana. Si marcas el cuadradito de
	<quote>Desviaciones típicas robustas</quote>quote>, entonces se
	calculan en su lugar las desviaciones típicas CMV (QML) o de
	Huber&ndash;White. En este caso, la matriz de covarianzas estimadas es
	un <quote>emparedado</quote> entre la inversa de la matriz Hessiana
	estimada y el producto externo del vector gradiente. Consulta el
	capítulo 10 del libro de Davidson y MacKinnon para obtener más detalles.
      </para>
      <para>
	Si la variable dependiente no es binaria sino discreta, entonces se
	obtienen las estimaciones de un Probit Ordenado. (Si la variable elegida
	como dependiente no es discreta, se muestra un fallo.)
      </para>
      <subhead>Probit para datos de panel</subhead>
      <para>
	Con la opción <opt>random-effects</opt>, se asume que cada perturbación
	está compuesta por dos componentes Normalmente distribuidas:
	(a) un término invariante en el tiempo que es específico de la unidad de
	sección cruzada o <quote>individuo</quote> (y que se conoce
	como efecto individual), y (b) un término que es específico de la
	observación concreta.
      </para>
      <para>
	La evaluación de la verosimilitud de este modelo implica utilizar la
	cuadratura de Gauss-Hermite para aproximar el valor de las esperanzas
	de funciones de variables Normales. Puedes escoger el número de puntos
	de cuadratura utilizados mediante la opción <opt>quadpoints</opt>
	(por defecto es de 32). Utilizando más puntos se mejora la precisión
	de los resultados, pero con el coste de más tiempo de cálculo; así, con
	muchos puntos de cuadratura, la estimación con un conjunto de datos
	muy grande puede consumir demasiado tiempo.
      </para>
      <para>
	Además de las estimaciones habituales de los parámetros (y de los estadísticos
	asociados) relacionados con los regresores incluidos, se presenta
	alguna información adicional sobre la estimación de este tipo de
	modelo:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>lnsigma2</lit>: La estimación máximo verosímil del logaritmo
	    de la varianza del efecto individual;
	  </para>
	</li>
	<li>
	  <para>
	    <lit>sigma_u</lit>: La estimación de la desviación típica del efecto
	    individual; y
	  </para>
	</li>
	<li>
	  <para>
	    <lit>rho</lit>: La estimación de la parte del efecto individual en la
	    varianza compuesta de la perturbación (también conocida como la
	    correlación intra-clase).
	  </para>
	</li>
      </ilist>
      <para>
	El contraste de Razón de Verosimilitudes respecto a la hipótesis nula de que
	<lit>rho</lit> es igual a cero, proporciona un modo de evaluar si es
	necesaria la especificación de efectos aleatorios. Si la hipótesis nula
	no se rechaza, eso sugiere que es adecuada una simple especificación
	Probit combinada.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelo/Variable dependiente limitada/Probit</menu-path>
    </gui-access>

  </command>

  <command name="pvalue" section="Statistics" label="Calcular probabilidades asociadas" context="cli">

    <usage>
      <arguments>
        <argument>distribución</argument>
        <argument optional="true">parámetros</argument>
	      <argument>xvalor</argument>
      </arguments>
      <examples>
        <example>pvalue z zscore</example>
	<example>pvalue t 25 3.0</example>
	<example>pvalue X 3 5.6</example>
	<example>pvalue F 4 58 fval</example>
	<example>pvalue G shape scale x</example>
	<example>pvalue B bprob 10 6</example>
	<example>pvalue P lambda x</example>
	<example>pvalue W shape scale x</example>
    <demos>
	  <demo>mrw.inp</demo>
	  <demo>restrict.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Calcula el área que queda a la derecha del valor <repl>xvalor</repl> en la
	distribución especificada (<lit>z</lit> para la Normal, <lit>t</lit>
	para la <math>t</math> de Student, <lit>X</lit> para la Chi-cuadrado,
	<lit>F</lit> para la <math>F</math>, <lit>G</lit> para la Gamma,
	<lit>B</lit> para la Binomial, <lit>P</lit> para la Poisson,
	<lit>exp</lit> para la Exponencial, o <lit>W</lit> para la Weibull).
      </para>
      <para>
	Dependiendo del tipo de distribución, debes indicar la siguiente
	información antes del valor <repl>xvalor</repl>: para las distribuciones
	<math>t</math> y chi-cuadrado, los grados de libertad; para la
	<math>F</math>, los grados de libertad de numerador y denominador;
	para la Gamma, los parámetros de forma y de escala; para la distribución
	Binomial, la probabilidad de <quote>éxito</quote> y el número de
	intentos; para la distribución de Poisson, el parámetro &lgr; (que es
	tanto la media como la varianza); para la Exponencial, un parámetro de
	escala; y para la distribución de Weibull, los parámetros de forma y
	de escala. Como se mostró en los ejemplos de arriba, puedes indicar
	los parámetros numéricos en formato numérico o como nombres de
	variables.
      </para>
      <para>
	Los parámetros para la distribución Gamma se indican a veces como
	media y varianza en lugar de forma y escala. La media es el producto de la
	forma y la escala; la varianza es el producto de la forma y el cuadrado de la
	escala. De este modo, puedes calcular la escala dividiendo la varianza
	entre la media, y puedes calcular la forma dividiendo la media entre la
	escala.
      </para>
    </description>

    <gui-access>
      <menu-path>/Herramientas/Buscador de valores P</menu-path>
    </gui-access>

  </command>

  <command name="qlrtest" section="Tests" label="Contraste de Razón de Verosimilitudes de Quandt">

    <usage>
      <options>
	<option>
	  <flag>--limit-to</flag>
	  <optparm>lista</optparm>
	  <effect>Limita el contraste a un subconjunto de regresores</effect>
	</option>
	<option>
	  <flag>--plot</flag>
	  <optparm>modo-o-nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Para un modelo estimado con datos de series temporales mediante
	MCO, realiza el contraste de la Razón de Verosimilitudes de Quandt (QLR)
	para un cambio estructural en un punto desconocido en el tiempo, con un 15
	por ciento de recorte al comienzo y al final del período de la muestra.
      </para>
      <para>
	Para cada punto potencial de cambio dentro del 70 por ciento
	central de las observaciones, se realiza un contraste de Chow. Consulta
	<cmdref targ="chow"/> para obtener más detalles; pues, de igual
	modo que con el contraste habitual de Chow, este es un contraste robusto
	de Wald cuando el modelo original se estima con la opción
	<opt>robust</opt>, y un contraste F en otro caso. Entonces el estadístico
	QLR es el máximo de los estadísticos de contraste particulares.
      </para>
      <para>
	Se obtiene una probabilidad asociada (valor p) asintótica utilizando
	el método de <cite key="hansen97">Bruce Hansen (1997)</cite>.
      </para>
      <para>
	Además de los accesores <fncref targ="$test"/> y <fncref targ="$pvalue"/>
	típicos de los contrastes de hipótesis, puedes utilizar <fncref targ="$qlrbreak"/>
	para recuperar el índice de la observación en la que el estadístico de contraste
	se maximiza.
      </para>
      <para context="cli">
	Puedes utilizar la opción <opt>limit-to</opt> para limitar el conjunto
	de interacciones con la variable ficticia de corte en los contrastes de Chow,
	a un subconjunto de los regresores originales. El parámetro para esta
	opción debe ser una lista ya definida en la que todos sus
	elementos se encuentren entre los regresores originales, y en la que no
	debes incluir la constante.
      </para>
      <para>
	Cuando ejecutas de modo interactivo (únicamente) esta instrucción,
	se muestra por defecto un gráfico del estadístico de contraste de Chow,
	pero puedes ajustar esto mediante la opción <opt>plot</opt>. Los
	parámetros que se admiten en esta opción son <lit>none</lit> (para
	eliminar el gráfico), <lit>display</lit> (para mostrar un gráfico incluso
	cuando no se está en modo interactivo), o un nombre de archivo. El
	efecto de proporcionar un nombre de archivo es como el descrito para la
	opción <opt>output</opt> de la instrucción <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contraste/Contraste de RV de Quandt</menu-path>
    </gui-access>

  </command>

  <command name="qqplot" section="Graphs" label="Gráfico Q-Q">

    <usage>
      <altforms>
	<altform><lit>qqplot</lit> <repl>y</repl></altform>
	<altform><lit>qqplot</lit> <repl>y</repl> <repl>x</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--z-scores</flag>
	  <effect>Mira abajo</effect>
  </option>
  <option>
	  <flag>--raw</flag>
	  <effect>Mira abajo</effect>
  </option>
  <option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el gráfico al archivo especificado</effect>
  </option>
      </options>
    </usage>

    <description>
      <para context="gui">
	Con una única serie seleccionada, muestra un gráfico de los cuantiles
	empíricos de esa serie dada, frente a los cuantiles de la distribución Normal.
	La serie debe incluir cuando menos 20 observaciones válidas en el rango
	vigente de la muestra. Por defecto, los cuantiles empíricos se dibujan frente
	a los cuantiles de una distribución Normal que tiene las mismas media y
	varianza que los datos de la muestra, pero dispones de dos alternativas:
	puedes tipificar los datos (convertirlos en puntuaciones z) antes de dibujarlos,
	o puedes dibujar los cuantiles empíricos <quote>en bruto</quote> frente
	a los cuantiles de la distribución Normal estándar.
      </para>
      <para context="cli">
	Indicando como argumento una única serie, muestra un gráfico de los
	cuantiles empíricos de la serie seleccionada (indicada por su nombre o
	su número ID) frente a los cuantiles de la distribución Normal. La serie
	debe incluir cuando menos 20 observaciones válidas en el rango vigente
	de la muestra. Por defecto, los cuantiles empíricos se dibujan frente a los
	cuantiles de una distribución Normal que tiene las mismas media y varianza
	que los datos de la muestra, pero dispones de dos alternativas: si indicas
	la opción <opt>z-scores</opt>, los datos se tipifican; mientras que si
	indicas la opción <opt>raw</opt>, se dibujan los cuantiles empíricos
	<quote>en bruto</quote> frente a los cuantiles de la distribución Normal
	estándar.
      </para>
      <para context="cli">
	La opción <opt>output</opt> tiene como efecto el envío del resultado al
	archivo especificado; utiliza <quote>display</quote> para forzar
	que el resultado se presente en la pantalla. Consulta la instrucción
	<cmdref targ="gnuplot"/> para obtener más detalles sobre esta opción.
      </para>
      <para>
	Dadas dos series como argumentos, <repl>y</repl> y <repl>x</repl>,
	se muestra un gráfico de los cuantiles empíricos de <repl>y</repl> frente
	a los de <repl>x</repl>. Los valores de los datos no se tipifican.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Gráfico Q-Q normal</menu-path>
      <menu-path>/Ver/Gráficos/Gráfico Q-Q</menu-path>
    </gui-access>

  </command>

  <command name="quantreg" section="Estimation"
    label="Regresión de cuantiles">

    <usage>
      <arguments>
	      <argument>tau</argument>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
  </option>
  <option>
	  <flag>--intervals</flag>
	  <optparm optional="true">nivelconf</optparm>
	  <effect>Calcula los intervalos de confianza</effect>
  </option>
  <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
  </option>
  <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
  </option>
      </options>
      <examples>
	<example>quantreg 0.25 y 0 xlista</example>
	<example>quantreg 0.5 y 0 xlista --intervals</example>
	<example>quantreg 0.5 y 0 xlista --intervals=.95</example>
	<example>quantreg tauvec y 0 xlista --robust</example>
	<demos>
	  <demo>mrw_qr.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Regresión de cuantiles. Por defecto, las desviaciones típicas
	se calculan de acuerdo con la fórmula asintótica indicada por
	<cite key="koenker-bassett78">Koenker y Bassett (1978)</cite>, pero
	si marcas el cuadradito de <quote>Desviaciones típicas robustas</quote>,
	se utiliza la variante robusta a la heterocedasticidad
	de <cite key="koenker-zhao94">Koenker y Zhao (1994)</cite>.
      </para>
      <para>
	Si marcas la opción <quote>Calcular los intervalos de confianza</quote>,
	GRETL calcula los intervalos de confianza para los coeficientes
	en lugar de las desviaciones típicas. Y el cuadradito de validación
	de <quote>Desviaciones típicas robustas</quote> tiene otro efecto:
	si no se marca, los intervalos se calculan bajo el supuesto de
	perturbaciones IID; y al marcarlo, GRETL utiliza el estimador
	robusto desarrollado por
	<cite key="koenker-machado99">Koenker y Machado (1999)</cite>.
	Ten en cuenta que estos intervalos no son exactamente
	<quote>más o menos tantas desviaciones típicas</quote> pues, en general,
	son asimétricos respecto a las estimaciones puntuales de los coeficientes.
	    </para>
      <para>
	Puedes indicar una lista de cuantiles (consulta la lista desplegable para
	algunas posibilidades ya definidas con anterioridad). En ese caso, GRETL
	calcula las estimaciones de cuantiles y, o bien las desviaciones típicas o
	bien los intervalos de confianza para cada uno de los valores especificados.
      </para>
      <para>
	Para seguir la pista de las referencias indicadas arriba, consulta
	<guideref targ="chap:quantreg"/>.
      </para>
    </description>

    <description context="cli">
      <para>
	Regresión de cuantiles. El primer argumento (<repl>tau</repl>) es el cuantil
	condicionado para el que se quiere la estimación. Puedes indicarlo, bien con un
	valor numérico, o bien con el nombre de una variable escalar definida previamente;
	y el valor debe estar en el rango de 0.01 a 0.99. (Como alternativa, puedes
	indicar un vector de valores para <repl>tau</repl>; mira abajo para obtener
	más detalles.) El segundo y subsiguientes argumentos componen una lista
	de regresión con el mismo patrón que <cmdref targ="ols"/>.
      </para>
      <para>
	Sin la opción <opt>intervals</opt>, se presentan las desviaciones
	típicas para las estimaciones de los cuantiles. Por defecto, estas
	se calculan de acuerdo con la fórmula asintótica indicada por
	<cite key="koenker-bassett78">Koenker y Bassett (1978)</cite>,
	pero cuando indicas la opción <opt>robust</opt>, se calculan
	las desviaciones típicas que son robustas con respecto a la
	heterocedasticidad, utilizando el método de
	<cite key="koenker-zhao94">Koenker y Zhao (1994)</cite>.
      </para>
      <para>
	Cuando escoges la opción <opt>intervals</opt>, se presentan los
	intervalos de confianza para las estimaciones de los parámetros en
	lugar de las desviaciones típicas. Estos intervalos se calculan usando
	el método de la inversión del rango y, en general, son asimétricos con
	respecto a las estimaciones puntuales. Las especificidades del cálculo
	están mediatizadas por la opción <opt>robust</opt>: sin esta, los
	intervalos se calculan bajo el supuesto de perturbaciones IID
	<cite key="koenker94" p="true">(Koenker, 1994)</cite>; y con ella
	se utiliza el estimador robusto desarrollado por
	<cite key="koenker-machado99">Koenker y Machado (1999)</cite>.
      </para>
      <para>
	Por defecto, se generan intervalos de confianza del 90 por ciento. Puedes
	modificar esto añadiendo un nivel de confianza (expresado como una fracción
	decimal) a la opción de intervalos, como en <opt>intervals=0.95</opt>.
      </para>
      <para>
	Vector <repl>tau</repl> de valores: en lugar de proporcionar un escalar,
	puedes indicar el nombre de una matriz definida previamente. En este caso, las
	estimaciones se calculan para todos los valores <repl>tau</repl> indicados,
	y los resultados se presentan en un formato especial, mostrando la secuencia
	de las estimaciones de cuantiles para cada regresor, de uno en uno.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Estimación Robusta/Regresión de cuantil</menu-path>
    </gui-access>

  </command>

  <command name="quit" section="Utilities"
    label="Salir del programa" context="cli">

    <description>
      <para>
	Sale de la modalidad vigente de GRETL.
      </para>
      <ilist>
	<li>
	  <para>
	Cuando esta instrucción se invoca desde un guion, finaliza la
	ejecución de ese guion. En el contexto de gretlcli en modo de
	procesamiento por lotes, el propio gretlcli finaliza; en caso
	contrario, el programa retrocede a modo interactivo.
	  </para>
	</li>
	<li>
	  <para>
	Cuando se invoca desde la consola del programa de Interfaz Gráfica
	de Usuario (GUI), se cierra la ventana de la consola.
	  </para>
	</li>
	<li>
	  <para>
	Cuando se invoca desde gretlcli en modo interactivo, este programa
	finaliza.
	  </para>
	</li>
      </ilist>
      <para>
	Ten en cuenta que esta instrucción no puede invocarse desde dentro
	de funciones ni de bucles.
      </para>
      <para>
	La instrucción <lit>quit</lit> en ningún caso provoca que finalice el
	programa de Interfaz Gráfica de Usuario (GUI) de GRETL. Esto se
	hace mediante la opción <lit>Salir</lit> del apartado <lit>Archivo</lit>
	del menú, o mediante <lit>Ctrl+Q</lit>, o pulsando con el ratón el
	control de cierre en la barra de título de la ventana principal de GRETL.
      </para>
    </description>
  </command>

  <command name="regls" section="Estimation"
	   label="Mínimos Cuadrados Regularizados" context="gui">
    <description>
      <para>
	Este diálogo te permite el acceso a la función <lit>regls</lit> para
	Mínimos Cuadrados Regularizados.
      </para>
      <para>
	Se toleran tres estimadores: LASSO, que limita la suma de los valores
	absolutos de los coeficientes; Ridge (cresta), que limita la suma de
	los coeficientes cuadrados; y Elastic net (malla elástica), que es una
	combinación de las dos primeras regida por el 'hiperparámetro' &alpha;
	de forma que &alpha; = 1 proporciona LASSO, &alpha; = 0 proporciona
	Ridge, y valores intermedios proporcionan una combinación ponderada.
      </para>
      <para>
	El término &lgr; especifica el grado hasta el que se penaliza la suma
	de coeficientes absolutos o cuadrados. Puedes indicar una única
	fracción &lgr; desde 0 (sin penalización) hasta 1 (máxima penalización),
	o bien un grupo de valores &lgr;. En el segundo caso, los valores de
	penalización se escalan automáticamente.
      </para>
      <para>
	Si eliges varios valores para &lgr;, se va a habilitar la opción de
	validación cruzada. En ese caso, vas a poder escoger tanto el número
	de <quote>pliegues</quote> para los datos de ensayo (por defecto es 10),
	como si estos pliegues deben ser subconjuntos aleatorios o contiguos
	de observaciones. Asimismo, podrás escoger si quieres que presente
	un gráfico con las medias del Erro Cuadrático Medio (MSE) frente a las
	fracciones &lgr;.
      </para>
      <para>
	El botón <quote>Avanzado</quote> abre un nuevo diálogo que proporciona
	de cierta forma un mayor grado de control sobre el procedimiento de
	regularización. Pero ten en cuenta que puedes ejercer un control más
	detallado invocando a la función <lit>regls</lit> mediante la redacción
	de guiones; para más detalles consulta <doc>regls.pdf</doc>.
      </para>
    </description>
  </command>

  <command name="regls-advanced" section="Estimation"
	   label="Otras opciones para regls" context="gui">
    <description>
      <para>
	Las elecciones hechas mediante este diálogo se aplican solo cuando son
	relevantes, en función de las elecciones hechas en el diálogo principal
	<quote>reglsbest</quote>. Se recuerdan mientras dure la sesión de GRETL.
      </para>
      <ilist>
	<li>
	  <para>
	Elección de algoritmo: Puedes elegir el método Descenso de Coordenada
	Cíclico (CCD) tanto para el LASSO como para la regresión Ridge (cresta),
	en contraste con el método por defecto; es decir, el Método de
	Multiplicadores de Dirección Alterna (ADMM) para el LASSO y la
	Descomposición del Valor Singular (SVD) para el Ridge.
	  </para>
	</li>
	<li>
	  <para>
	El criterio por defecto para que rinda <quote>mejor</quote>
	la validación cruzada es minimizar el Error Cuadrático Medio
	(MSE), pero puedes seleccionar la regla alternativa
	<quote>una desviación típica</quote>. Esta alternativa, que
	favorece la sobriedad, escoge el mayor factor de penalización
	cuyo MSE está a menos de una desviación típica del mínimo.
	  </para>
	</li>
	<li>
	  <para>
	Semilla para los pliegues aleatorios: Si quieres obtener resultados
	replicables en la validación cruzada con pliegues aleatorios, es
	necesario especificar una semilla para el generador de números
	aleatorios.
	  </para>
	</li>
	<li>
	  <para>
	Por defecto, regls utilizará MPI (si está disponible) en un esfuerzo por
	acelerar la validación cruzada. El recuadro para MPI (que se muestra solo
	cuando se compila GRETL con soporte MPI) te permite desactivar esto,
	lo que puede producir una aceleración para bases pequeñas de datos.
	  </para>
	</li>
	<li>
	  <para>
	La opción de mostrar el tiempo de ejecución te puede ser útil si
	quieres comparar el comportamiento de diferentes algoritmos, o
	comprobar si vale la pena usar el MPI. El tiempo que se muestra en
	el resultado corresponde a la ejecución del código C subyacente.
	  </para>
	</li>
      </ilist>
    </description>
  </command>

  <command name="rename" section="Dataset" label="Cambiar el nombre de una variable" context="cli">
    <usage>
      <arguments>
	      <argument>serie</argument>
	      <argument>nuevonombre</argument>
      </arguments>
      <options>
  <option>
	  <flag>--quiet</flag>
	  <effect>Suprime la presentación de resultados</effect>
  </option>
  <option>
    <flag>--case</flag>
    <effect>Cambia el formato de los nombres de todas las series; mira abajo</effect>
  </option>
      </options>
      <examples>
        <example>rename x2 ingreso</example>
        <example>rename --case=lower</example>
      </examples>
    </usage>

    <description>
      <para>
        Sin la opción <opt>--case</opt>, esta instrucción cambia el nombre
        de <repl>serie</repl> (identificada por su nombre o su número ID) a
        <repl>nuevonombre</repl>. El nuevo nombre debe tener 31 caracteres
        como máximo, comenzar con una letra y estar formado solo por letras,
        dígitos y/o el carácter de barra baja. Además, no debe ser el nombre
        de un objeto de cualquier tipo que ya exista.
      </para>
      <para>
        La opción <opt>--case</opt> permite cambiar el formato de
        <emphasis>todos</emphasis> los nombres de las series en el conjunto
        de datos abierto vigente. Cuando se utiliza esta opción, no se debe
        indicar ningún nombre para <repl>serie</repl> ni para
        <repl>nuevonombre</repl>. Se admiten los siguientes tipos de formato:
      </para>
      <ilist>
        <li>
          <para>
      <repl>lower</repl>: Convierte todos los nombres de las series a minúsculas.
          </para>
        </li>
        <li>
          <para>
      <repl>upper</repl>: Convierte todos los nombres de las series a mayúsculas.
          </para>
        </li>
        <li>
          <para>
      <repl>camel</repl>: Convierte todos los nombres de las series a formato
      camello; lo que significa que se eliminan los guiones bajos y el carácter
      siguiente a los mismos (si hai alguno) se pone en mayúsculas. Por
      ejemplo, <lit>alguna_cosa</lit> se vuelve <lit>algunaCosa</lit>.
          </para>
        </li>
        <li>
          <para>
      <repl>snake</repl>: Convierte todos los nombres de las series a formato
      serpiente; lo que significa que cualquier letra mayúscula (excepto la
      primera del nombre) se convierte a minúscula, precedida por un guión
      bajo. Por ejemplo, <lit>algunaCosa</lit> se vuelve <lit>alguna_cosa</lit>.
          </para>
        </li>
      </ilist>
    </description>

    <gui-access>
      <menu-path>/Variable/Editar atributos</menu-path>
      <other-access>Ventana principal: Menú emergente (selección única)</other-access>
    </gui-access>

  </command>

  <command name="reprobit" section="Estimation" label="Probit de efectos aleatorios" 
     context="gui">

    <description>
      <para>
	El estimador Probit de efectos aleatorios proporciona un medio de
	estimar un modelo Probit (binario) con datos de panel. Se asume que
	cada perturbación está compuesta por dos componentes Normalmente
	distribuidas: (a) un término invariante respecto al tiempo que es
	especifico de la unidad de sección cruzada o <quote>individuo</quote>
	(y que se conoce como efecto individual), y (b) un término que es
	específico de la observación concreta.
      </para>
      <para>
	La evaluación de la verosimilitud de este modelo implica utilizar la cuadratura
	de Gauss-Hermite para aproximar el valor de las esperanzas de funciones de
	variables Normales. En este diálogo, puedes escoger el número de puntos de
	cuadratura utilizados. Usando más puntos se mejora la precisión de los
	resultados, pero con el coste de mayor tiempo de cálculo; así con muchos
	puntos de cuadratura, la estimación con un conjunto de datos muy grande
	puede consumir demasiado tiempo.
      </para>
      <para>
	Además de las estimaciones habituales de los parámetros (y de los estadísticos
	asociados) relacionados con los regresores incluidos, se presenta
	alguna información adicional sobre la estimación de este tipo de
	modelo:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>lnsigma2</lit>: La estimación máximo verosímil del logaritmo
	    de la varianza del efecto individual;
	  </para>
	</li>
	<li>
	  <para>
	    <lit>sigma_u</lit>: La estimación de la desviación típica del efecto
	    individual; y
	  </para>
	</li>
	<li>
	  <para>
	    <lit>rho</lit>: La estimación de la parte del efecto individual en la
	    varianza compuesta de la perturbación (también conocida como la
	    correlación intra-clase).
	  </para>
	</li>
      </ilist>
      <para>
	El contraste de Razón de Verosimilitudes respecto a la hipótesis nula de que
	<lit>rho</lit> es igual a cero, proporciona un modo de evaluar si es
	necesaria la especificación de efectos aleatorios. Si la hipótesis nula
	no se rechaza, eso sugiere que es adecuada una simple especificación
	Probit combinada.
      </para>
      <para>
	En modo guion, el modelo Probit de efectos aleatorios se estima
	utilizando la instrucción <lit>probit</lit> con la opción
	<opt>random-effects</opt>.
      </para>
    </description>
  </command>

  <command name="reset" section="Tests" label="RESET de Ramsey">

    <usage>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta la regresión auxiliar</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
	</option>
	<option>
	  <flag>--squares-only</flag>
	  <effect>Calcula el contraste usando solo los cuadrados</effect>
	</option>
	<option>
	  <flag>--cubes-only</flag>
	  <effect>Calcula el contraste usando solo los cubos</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>Usa errores típicos robustos en la regresión auxiliar</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Debe ir después de la estimación de un modelo mediante MCO. Lleva a
	cabo el contraste RESET de Ramsey sobre la especificación (no lineal)
	de un modelo, añadiéndole a la regresión los cuadrados y/o los cubos
	de los valores ajustados, y calculando el estadístico <math>F</math>
	para contrastar la hipótesis nula de que los parámetros de los términos
	añadidos son cero. Por razones numéricas, los cuadrados y los cubos
	se reescalan utilizando la desviación típica de los valores ajustados.
      </para>
      <para context="cli">
	Se van a añadir tanto los cuadrados como los cubos, excepto que
	indiques una de las opciones <opt>squares-only</opt> o
	<opt>cubes-only</opt>.
      </para>
      <para context="cli">
	Puedes utilizar la opción <opt>silent</opt> si tienes intención de hacer
	uso de los accesores <fncref targ="$test"/> y/o <fncref targ="$pvalue"/>
	para guardar los resultados del contraste.
      </para>
      <para context="cli">
	La opción <opt>robust</opt> está implícita cuando en la regresión que se
	va a comprobar se utilizaron errores típicos robustos.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contrastes/Contraste RESET de Ramsey</menu-path>
    </gui-access>

  </command>

  <command name="restrict" section="Tests" context="cli"
    label="Contrastar restricciones">

    <usage>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta las estimaciones restringidas</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
	</option>
	<option>
	  <flag>--wald</flag>
	  <effect>Solo estimadores de sistema, mira abajo</effect>
	</option>
	<option>
	  <flag>--bootstrap</flag>
	  <effect>Cálculo del contraste con remuestreo automático, si es posible</effect>
	</option>
	<option>
	  <flag>--full</flag>
	  <effect>Solo MCO y VECMs, mira abajo</effect>
	</option>
      </options>
    <examples>
	<demos>
	  <demo>hamilton.inp</demo>
	   <demo>restrict.inp</demo>
	</demos>
    </examples>
    </usage>

    <description>
      <para>
	Impone un conjunto de restricciones (habitualmente lineales)
	sobre: (a) el último modelo estimado o (b) un sistema de
	ecuaciones que se definió y nombró previamente. En todos
	los casos, debes comenzar el conjunto de restricciones con la
	palabra clave <quote>restrict</quote> y terminarlo con
	<quote>end restrict</quote>.
      </para>
      <para>
	En caso de una única ecuación, las restricciones siempre se aplican
	implícitamente al último modelo, y se evalúan tan pronto como se
	cierre el bloque <lit>restrict</lit>.
      </para>
      <para>
	En caso de un sistema de ecuaciones (definido mediante la instrucción
	<cmdref targ="system"/>), puedes poner el nombre del sistema de
	ecuaciones definido previamente, después del <quote>restrict</quote>
	inicial. Cuando omites eso y el último modelo fue un sistema, entonces
	las restricciones se aplican a ese último modelo. Por defecto, las
	restricciones se evalúan cuando el sistema acaba de estimarse, usando
	la instrucción <cmdref targ="estimate"/>. Pero cuando indicas la opción
	<opt>wald</opt>, la restricción se comprueba inmediatamente a través
	del contraste chi-cuadrado de Wald en relación a la matriz de covarianzas.
	Ten en cuenta que esta opción va a generar un fallo si ya has definido un
	sistema, pero aún no lo has estimado.
      </para>
      <para>
	Dependiendo del contexto, puedes expresar de varios modos las
	restricciones que quieras contrastar. El más simple es como se
	indica a continuación: cada restricción se expresa como una ecuación,
	con una combinación lineal de parámetros a la izquierda del signo
	de igualdad y un valor escalar a la derecha (bien una constante
	numérica, o bien el nombre de una variable escalar).
      </para>
      <para>
	En caso de una única ecuación, puedes referirte a sus parámetros
	con el formato <lit>b[</lit><repl>i</repl><lit>]</lit>, donde
	<repl>i</repl> representa la posición en la lista de regresores
	(comenzando en el 1), o con el formato
	<lit>b[</lit><repl>nombrevar</repl><lit>]</lit>, donde
	<repl>nombrevar</repl> es el nombre del regresor en cuestión.
	En caso de un sistema, la referencia a los parámetros se hace
	utilizando la letra <lit>b</lit> junto con dos números colocados
	entre corchetes. El primer número representa la posición de la
	ecuación dentro del sistema, y el segundo número indica la
	posición del regresor dentro de la lista de ellos. Por ejemplo,
	<lit>b[2,1]</lit> denota el primer parámetro de la segunda
	ecuación, mientras que <lit>b[3,2]</lit> denota el segundo
	parámetro de la tercera ecuación. Puedes anteponer multiplicadores
	numéricos a los elementos <lit>b</lit> de la ecuación que representa
	una restricción, por ejemplo <lit>3.5*b[4]</lit>.
      </para>
      <para>
	Aquí tienes un ejemplo de un conjunto de restricciones para un modelo
	estimado previamente:
      </para>
      <code>
	restrict
	 b[1] = 0
	 b[2] - b[3] = 0
	 b[4] + 2*b[5] = 1
	end restrict
      </code>
      <para>
	Y aquí tienes un ejemplo de un conjunto de restricciones para aplicar a
	un sistema ya definido. (Si el nombre del sistema no contiene espacios,
	no hacen falta las comillas que lo delimitan.)
      </para>
      <code>
	restrict "Sistema 1"
	 b[1,1] = 0
	 b[1,2] - b[2,2] = 0
	 b[3,4] + 2*b[3,5] = 1
	end restrict
      </code>
      <para>
	En caso de una única ecuación, las restricciones se evalúan por defecto por
	medio del contraste de Wald, usando la matriz de covarianzas del modelo en
	cuestión. Si estimaste el modelo original con MCO, entonces se presentan las
	estimaciones de los coeficientes restringidos; para eliminar esto, añade la
	opción <opt>quiet</opt> a la instrucción <lit>restrict</lit> inicial. Como
	alternativa al contraste de Wald, para modelos estimados únicamente mediante
	MCO o MCP, puedes indicar la opción <opt>bootstrap</opt> para realizar
	el contraste de la restricción con remuestreo automático (bootstrap).
      </para>
      <para>
	En caso de un sistema, el estadístico de contraste depende del estimador elegido:
	un estadístico de Razón de Verosimilitudes cuando el sistema se estima
	utilizando un método de Máxima Verosimilitud, o un estadístico
	<math>F</math> asintótico, en otro caso.
      </para>
      <subhead>Restricciones lineales: sintaxis alternativa</subhead>
      <para>
	Tienes dos alternativas al método para expresar las restricciones descrito
	más arriba. Primero, puedes escribir de forma compacta un conjunto de
	<math>g</math> restricciones sobre el vector con los <math>k</math>
	parámetros (&bgr;), como <math>R</math>&bgr; &minus; <math>q</math> = 0,
	donde <math>R</math> es una matriz de dimensión <by r="g" c="k"/> y
	<math>q</math> es un vector de dimensión <math>g</math>. Puedes expresar
	una restricción indicando los nombres de matrices definidas previamente,
	cómodas para utilizar como <math>R</math> y <math>q</math>,
	como en
      </para>
      <code>
	restrict
	  R = Rmat
	  q = qvec
	end restrict
      </code>
      <para>
	En segundo lugar, como variante que puede serte útil cando uses la
	función <lit>restrict</lit> dentro de otra función, puedes elaborar
	un conjunto de enunciados de restricción con el formato de un 'array'
	de cadenas de texto. Después utiliza la palabra clave <lit>inject</lit>
	con el nombre del 'array'. Este es un ejemplo simple:
      </para>
      <code>
	strings RS = array(2)
	RS[1] = "b[1,2] = 0"
	RS[2] = "b[2,1] = 0"
	restrict
	  inject RS
	end restrict	
      </code>
      <para>
	Con el uso actual de este método, posiblemente preferirás utilizar la
	función <fncref targ="sprintf"/> para elaborar las cadenas de texto,
	en base a la entrada para una función.
      </para>
      <subhead>Restricciones no lineales </subhead>
      <para>
	Si quieres contrastar una restricción no lineal (lo que actualmente solo
	está disponible para modelos de una única ecuación), debes indicar la
	restricción con el nombre de una función, precedida por
	<quote><lit>rfunc = </lit></quote>, como en
      </para>
      <code>
	restrict
	  rfunc = mifuncion
	end restrict
      </code>
      <para>
	La función de restricción debe tener un único argumento <lit>const matrix</lit>,
	y esto se completa automáticamente con el vector de parámetros. Y debiera
	devolver un vector que es cero bajo la hipótesis nula, y no nulo
	en otro caso. La dimensión del vector es igual al número de restricciones.
	Esta función se utiliza como una <quote>rellamada</quote> de la
	rutina numérica para el Jacobiano, de GRETL, que calcula el estadístico
	de contraste de Wald mediante el método delta.
      </para>
      <para>
	Aquí tienes un ejemplo sencillo de una función apropiada para comprobar
	una restricción no lineal, concretamente que dos pares de valores
	de los parámetros tienen una razón común.
      </para>
      <code>
	function matrix restr (const matrix b)
	  matrix v = b[1]/b[2] - b[4]/b[5]
	  return v
	end function
      </code>
      <para>
	Cuando se completa con éxito la instrucción <lit>restrict</lit>, los accesores
	<fncref targ="$test"/> y <fncref targ="$pvalue"/> proporcionan el estadístico
	de contraste y su probabilidad asociada (valor p), respectivamente.
      </para>
      <para>
	Cuando se contrastan restricciones sobre un modelo de una única ecuación que fue
	estimado mediante MCO o sobre un Modelo de Vectores de Corrección del
	Error (VECM), puedes utilizar la opción <opt>full</opt> para disponer que
	las estimaciones restringidas sean el <quote>último modelo</quote>, con la
	intención de hacer contrastes más adelante o de usar accesores como
	<lit>$coeff</lit> y <lit>$vcv</lit>. Ten en cuenta que se aplican algunos
	detalles especiales en caso de que pruebes restricciones sobre un VECM.
	Consulta <guideref targ="chap:vecm"/> para obtener más detalles.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: Contrastes/Restricciones lineales</menu-path>
    </gui-access>

  </command>

  <command name="restrict-model" section="Tests" context="gui"
    label="Restricciones en un modelo">

    <description>
      <para>
	Debes expresar cada restricción del conjunto como una ecuación, con una
	combinación lineal de parámetros a la izquierda del signo de igualdad y un
	valor numérico a la derecha. Puedes referirte a sus parámetros con el formato
	<lit>b[</lit><repl>i</repl><lit>]</lit>, donde <repl>i</repl> representa
	la posición en la lista de regresores (comenzando en el 1), o con el formato
	<lit>b[</lit><repl>nombrevar</repl><lit>]</lit>, donde <repl>nombrevar</repl>
	es el nombre del regresor en cuestión.
      </para>
      <para>
	Puedes anteponer multiplicadores numéricos a los elementos <lit>b</lit>
	de la ecuación que representa una restricción, utilizando <lit>*</lit>
	para indicar la multiplicación, por ejemplo <lit>3.5*b[4]</lit>.
      </para>
      <para>
	Aquí tienes un ejemplo de un conjunto de restricciones:
      </para>
      <code>
	b[1] = 0
	b[2] - b[3] = 0
	b[4] + 2*b[5] = 1
      </code>
    </description>

  </command>

  <command name="restrict-system" section="Tests" context="gui"
    label="Restricciones en un sistema de ecuaciones">

    <description>
      <para>
	Debes expresar cada restricción del conjunto como una ecuación, con una
	combinación lineal de parámetros a la izquierda del signo de igualdad y un
	valor numérico a la derecha. La referencia a los parámetros se hace utilizando la
	letra <lit>b</lit> junto con dos números colocados entre corchetes. El
	primer número representa la posición de la ecuación dentro del sistema, y
	el segundo número indica la posición del regresor dentro de la lista de ellos,
	comenzando por 1 en ambos casos. Por ejemplo, <lit>b[2,1]</lit> denota
	el primer parámetro de la segunda ecuación, mientras que <lit>b[3,2]</lit>
	denota el segundo parámetro de la tercera ecuación.
      </para>
      <para>
	Puedes anteponer multiplicadores numéricos a los elementos <lit>b</lit>
	de la ecuación que representa una restricción, utilizando <lit>*</lit>
	para indicar la multiplicación, por ejemplo <lit>3.5*b[1,4]</lit>.
      </para>
      <para>Aquí tienes un ejemplo de un conjunto de restricciones:
      </para>
      <code>
	b[1,1] = 0
	b[1,2] - b[2,2] = 0
	b[3,4] + 2*b[3,5] = 1
      </code>
    </description>

  </command>

  <command name="restrict-vecm" section="Tests" context="gui"
    label="Restricciones en un VECM">

    <description>
      <para>
	Utiliza esta instrucción para establecer restricciones lineales sobre
	las relaciones de cointegración (beta) y/o los coeficientes de ajuste
	(alfa) en un Modelo de Vectores de Corrección del Error (VECM).
      </para>
      <para>
	Debes expresar cada restricción del conjunto como una ecuación, con una
	combinación lineal de parámetros a la izquierda del signo de igualdad y un
	valor numérico a la derecha. Las restricciones sobre beta pueden ser no
	homogéneas (con valores distintos de cero a la derecha), pero las restricciones
	sobre alfa deben ser homogéneas (con ceros a la derecha).
      </para>
      <para>
	Si el VECM es de rango 1, la referencia a los parámetros se hace utilizando
	el formato <lit>b[</lit><repl>i</repl><lit>]</lit>, donde <repl>i</repl>
	representa la posición en el vector de cointegración, comenzando en 1. Por
	ejemplo, <lit>b[2]</lit> denota el segundo elemento de beta. Pero si el
	rango es mayor que 1, utiliza <lit>b</lit> junto con dos números
	colocados entre corchetes. Por ejemplo, <lit>b[2,1]</lit> denota el
	primer elemento del segundo vector de cointegración.
      </para>
      <para>
	Para referirte a los elementos de alfa, utiliza <lit>a</lit> en vez de
	<lit>b</lit>.
      </para>
      <para>
	Puedes anteponer multiplicadores numéricos a los identificadores de los
	parámetros de la ecuación que representa una restricción, utilizando
	<lit>*</lit> para indicar la multiplicación, por ejemplo <lit>3.5*b[4]</lit>.
      </para>
      <para>Aquí tienes un ejemplo de un conjunto de restricciones en un VECM de rango 1.
      </para>
      <code>
	b[1] + b[2] = 0
	b[1] + b[3] = 0
      </code>
      <para>
	Consulta también <guideref targ="chap:vecm"/>.
      </para>
    </description>

  </command>

  <command name="rmplot" section="Graphs" label="Gráfico Rango-Media">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--trim</flag>
	  <effect>Mira abajo</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	</option>
	<option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Gráfico Rango&ndash;Media: Esta instrucción genera un gráfico sencillo
	para ayudar a decidir si una serie temporal, <math>y</math>(t), tiene
	una varianza constante o no. Se coge la muestra completa (t=1,...,T)
	y se divide en pequeñas submuestras de tamaño arbitrario <math>k</math>.
	La primera submuestra está compuesta por
	<math>y</math>(1),...,<math>y</math>(k), la segunda por
	<math>y</math>(k+1), ..., <math>y</math>(2k), etcétera.
	Para cada submuestra, se calcula la media de la serie en la muestra y el rango
	(= máximo menos mínimo), y se construye un gráfico con las medias
	en el eje horizontal y los rangos en el vertical. Así cada submuestra
	se representa mediante un punto en este plano. Si la varianza de la
	serie es constante, se esperaría que el rango de la submuestra sea
	independiente de la media de la submuestra. Por eso, si observamos que
	los puntos se aproximan a una línea con pendiente positiva, esto
	sugiere que la varianza de las series aumenta a medida que lo hace la
	media; y si los puntos se aproximan a una línea con pendiente
	negativa, esto sugiere que la varianza decrece al aumentar la media.
      </para>
      <para>
	Además del gráfico, GRETL muestra las medias y rangos para cada
	submuestra, junto con el coeficiente de la pendiente de una regresión MCO
	do rango sobre la media, y con la probabilidad asociada al estadístico
	para contrastar la hipótesis nula de que esta pendiente es cero. Si el
	coeficiente de la pendiente es significativo con un nivel de significación
	del 10 por ciento, entonces se muestra en el gráfico la línea ajustada de la
	regresión del rango sobre la media. Se registran tanto el estadístico
	<math>t</math> para contrastar la hipótesis nula como la probabilidad
	asociada correspondiente, y puedes recuperarlos usando los accesores
	<fncref targ="$test"/> y <fncref targ="$pvalue"/>, respectivamente.
      </para>
      <para context="cli">
	Cuando indicas la opción <opt>trim</opt>, se descartan los valores
	mínimo y máximo de cada submuestra antes de calcular la media y
	el rango. Esto hace que sea menos probable que los valores atípicos
	provoquen una distorsión en el análisis.
      </para>
      <para context="cli">
	Cuando indicas la opción <opt>quiet</opt>, no se muestra el gráfico ni se
	presenta el resultado; solo se indican el estadístico <math>t</math> y su
	probabilidad asociada (valor p). Por otro lado, puedes controlar el formato
	del gráfico mediante la opción <opt>output</opt>; y esto funciona como se
	describe en conexión con la instrucción <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Gráfico rango-media</menu-path>
    </gui-access>

  </command>

  <command name="run" section="Programming"
    label="Ejecutar un guion" context="cli">

    <usage>
      <arguments>
        <argument>nombrearchivo</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Ejecuta las instrucciones de <repl>nombrearchivo</repl> y luego devuelve
	el control al indicador interactivo. Esta instrucción está pensada
	para que la utilices con el programa de líneas de instrucción
	<program>gretlcli</program> o con la <quote>consola de GRETL</quote>
	en el programa de Interfaz Gráfica de Usuario (GUI).
      </para>
      <para>
	Consulta también <cmdref targ="include"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Icono 'Ejecutar' en la ventana del editor de guiones</menu-path>
    </gui-access>

  </command>

  <command name="runs" section="Tests" label="Contraste de rachas">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--difference</flag>
	  <effect>Utiliza las primeras diferencias de la variable</effect>
	</option>
	<option>
	  <flag>--equal</flag>
	  <effect>Los valores positivos y negativos son equiprobables</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Realiza el contraste no paramétrico <quote>de rachas</quote> para
	comprobar el carácter aleatorio de la <repl>serie</repl> indicada, donde
	las rachas se definen como secuencias de valores consecutivos
	positivos o negativos. Si quieres contrastar el carácter aleatorio de las
	desviaciones respecto a la mediana, para una variable llamada
	<lit>x1</lit> que tiene una mediana no nula, puedes hacer lo siguiente:
      </para>
      <code>
	series signx1 = x1 - median(x1)
	runs signx1
      </code>
      <para>
	Cuando indicas la opción <opt>difference</opt>, se van a calcular las
	primeras diferencias de la serie antes del análisis, por lo que las rachas
	se interpretarían como secuencias de aumentos o de diminuciones
	consecutivas del valor de la variable.
      </para>
      <para>
	Cuando indicas la opción <opt>equal</opt>, la hipótesis nula también
	incorpora el supuesto de que los valores positivos y negativos son
	igual de probables; de lo contrario, el estadístico de contraste resulta
	invariante con respecto a la <quote>neutralidad</quote> del proceso
	que generó la secuencia de valores, y el contraste se centra únicamente
	en la independencia.
      </para>
    </description>

    <gui-access>
      <menu-path>/Herramientas/Contrastes no paramétricos</menu-path>
    </gui-access>

  </command>

  <command name="sampling" section="Dataset" context="gui"
    label="Configurando la muestra">

    <description>
      <para>
	El menú Muestra ofrece varios modos de seleccionar una submuestra del
	conjunto vigente de datos.
      </para>
      <para>
	Si escoges <quote>Muestra/Restringir, a partir del criterio...</quote>
	es necesario que indiques una expresión booleana (lógica), del mismo
	tipo que usarías para definir una variable ficticia. Por ejemplo, la
	expresión <quote>sqft &gt; 1400</quote> seleccionará solo los casos en los que
	la variable 'sqft' tiene un valor mayor que 1400. Puedes encadenar las condiciones
	utilizando los operadores lógicos <quote>&amp;&amp;</quote> (AND)
	y <quote>||</quote> (OR), y puedes aplicar la negación utilizando
	<quote>!</quote> (NOT). Si el conjunto de datos ya contiene variables
	ficticias, también tienes la posibilidad de escoger una de ellas para
	definir la muestra (las observaciones que tengan el valor 1 en la variable
	ficticia escogida, se van a incluir, y las otras se van a excluir).
      </para>
      <para>
	El elemento del menú <quote>Muestra/Quitar todas las observaciones con valores ausentes</quote>
	vuelve a definir la muestra, para excluir todas las observaciones para las que los valores
	de una o más variables están ausentes (dejando solo los casos completos).
      </para>
      <para>
	Para seleccionar observaciones para las que una variable concreta tiene
	valores no ausentes, usa <quote>Restringir, a partir del criterio...</quote>
	e indica la condición booleana <quote>ok(nombrevar)</quote> (substituye
	<quote>nombrevar</quote> con el nombre de la variable que quieras usar).
      </para>
      <para>
	Si las observaciones tienen etiquetas, puedes excluir observaciones
	concretas utilizando, por ejemplo, <lit>obs!="Francia"</lit> como
	criterio booleano. Debes delimitar el nombre de la observación con
	comillas.
      </para>
      <para>
	Debes tener en cuenta la siguiente cuestión en relación a la definición de una
	muestra en base a una variable ficticia, a una expresión booleana o al criterio
	de valores ausentes. Cualquier información <quote>estructural</quote> en el
	archivo cabecera de los datos se pierde (en relación a la temporalidad de las series
	o a la naturaleza de panel de los datos). Pero puedes volver a forzar la estructura con
	el elemento <quote>Estructura del conjunto de datos</quote> del menú de Datos.
      </para>
      <para>
	Consulta <guideref targ="chap:sampling"/> para obtener otros detalles.
      </para>
    </description>
  </command>

  <command name="save-labels" section="Utilities"
    label="Guardar o eliminar etiquetas de las series" context="gui">
    <description>
      <para>
	Si escoges aquí 'Exportar', GRETL escribe un archivo que contiene las
	etiquetas descriptivas de cualquier serie (que tenga etiquetas) del
	conjunto vigente de datos. Ese archivo es de texto plano con una línea
	por variable, pero la línea estará vacía para las variables que no
	tengan etiqueta descriptiva.
      </para>
      <para>
	Cuando escoges 'Borrar', se eliminan las etiquetas descriptivas de todas
	las series que tengan etiquetas. Esto únicamente será oportuno en caso
	de que las etiquetas actuales se añadieran de algún modo debido a un
	fallo.
      </para>
    </description>
  </command>

  <command name="add-labels" section="Utilities"
    label="Añadir etiquetas de las series" context="gui">
    <description>
      <para>
	Si aquí escoges la opción 'Si', se te ofrece una caja de diálogo para
	abrir archivos, con el fin de que selecciones uno de texto plano que contenga
	las etiquetas descriptivas para las series del conjunto vigente de datos. El
	archivo deberá contener una etiqueta por línea, y una línea en blanco
	significará que no hay etiqueta. GRETL tratará de leer tantas etiquetas
	como series haya en el conjunto de datos, excluyendo la constante.
      </para>
    </description>
  </command>

  <command name="save-script" section="Utilities"
    label="¿Guardar instrucciones?" context="gui">
    <description>
      <para>
	Si aquí escoges 'Si', GRETL escribe un archivo que contiene un registro
	de las instrucciones que ejecutaste en la sesión vigente. La mayor parte de las
	instrucciones que ejecutas mediante <quote>apuntar y hacer clic</quote>
	tienen una contrapartida de <quote>guion</quote>, y estas instrucciones
	de guion son las que se guardarán. Así podrás coger el archivo como base
	para escribir un guion de instrucciones de GRETL.
      </para>
      <para>
	Si no te importa que se te avise para guardar un registro de las instrucciones
	al salir, no pongas la marca en la caja del diálogo para guardar instrucciones.
      </para>
    </description>
  </command>

  <command name="save-session" section="Utilities"
    label="¿Guardar esta sesión de GRETL?" context="gui">
    <description>
      <para>
	Si aquí escoges 'Sí', GRETL escribe un archivo que contiene una
	<quote>foto instantánea</quote> de la sesión vigente, incluyendo una copia
	del conjunto de datos con el que se trabaja, junto con cualquier modelo, gráfico
	u otro objeto que guardaras <quote>como icono</quote>. Puedes volver a abrir este
	archivo más tarde para recrear el estado de GRETL tal como era en el momento en el que
	saliste de la sesión (consulta el menú <quote>Archivo/Archivos de sesión</quote>).
      </para>
      <para>
	Si trabajas con GRETL utilizando la mayoría de las veces guiones de
	instrucciones (lo que se recomienda para un trabajo econométrico
	<quote>serio</quote>), probablemente no necesites guardar la
	sesión, pero debes asegurarte de guardar cualquier cambio en
	tu guion, que quieras mantener. También puedes querer guardar cualquier
	cambio en tu conjunto de datos, excepto que sea de un tipo que puedas
	repetir fácilmente ejecutando un guion.
      </para>
      <para>
	Si trabajas con guiones y no te importa que se te avise para
	guardar tu sesión al salir, no pongas la marca en la caja del
	diálogo para guardar sesión.
      </para>
    </description>
  </command>

  <command name="scatters" section="Graphs"
    label="Varios gráficos de dos variables">

    <usage>
      <arguments>
        <argument>yvar</argument>
        <argument separated="true">xvars</argument>
	      <argument alternate="true">yvars ; xvar</argument>
      </arguments>
      <options>
	<option>
	  <flag>--with-lines</flag>
	  <effect>Genera gráficos de líneas</effect>
	</option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nombrematriz</optparm>
	  <effect>Representa las columnas de la matriz indicada</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el resultado al archivo especificado</effect>
        </option>
      </options>
      <examples>
        <example>scatters 1 ; 2 3 4 5</example>
        <example>scatters 1 2 3 4 5 6 ; 7</example>
	<example>scatters y1 y2 y3 ; x --with-lines</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Genera gráficos de dos variables, bien de <repl>yvar</repl> frente
	a todas las variables de <repl>xvars</repl>, o bien de todas las
	variables de <repl>yvars</repl> frente a <repl>xvar</repl>. En el
	primer ejemplo de arriba, se coloca la variable 1 en el eje
	<math>y</math> y se dibujan 4 gráficos: el primero tiene la
	variable 2 en el eje <math>x</math>, el segundo con la variable 3 en
	el eje <math>x</math>, etcétera. El segundo ejemplo representa
	cada una de las variables de la 1 a la 6, frente a la variable 7 en el eje
	<math>x</math>. Repasar un conjunto de esos gráficos puede ser
	un paso conveniente en el análisis exploratorio de datos. El número
	máximo de gráficos es de 16, por lo que se va a ignorar cualquier
	variable adicional en la lista.
      </para>
      <para context="cli">
	Por defecto, los datos se muestran con puntos, pero si indicas la
	opción <opt>with-lines</opt> serán gráficos de líneas.
      </para>
      <para context="cli">
	Para obtener más detalles sobre el uso de la opción <opt>output</opt>,
	consulta la instrucción <cmdref targ="gnuplot"/>.
      </para>
      <para context="cli">
	Si especificas una matriz ya definida como origen de los datos, debes
	expresar las listas <repl>x</repl> e <repl>y</repl> con números naturales
	positivos para indicar la columna. Alternativamente, si no indicas esas
	listas, se representan todas las columnas frente al tiempo o a una variable índice.
      </para>
      <para context="gui">
	Genera gráficos de dos variables, de la <quote>Variable del eje Y</quote>
	escogida, frente a cada una de las <quote>Variables del eje X</quote>
	escogidas, una por una. (O puedes escoger varias variables para
	el eje Y y una para el eje X.) Repasar un conjunto de esos gráficos
	puede ser un paso conveniente en el análisis exploratorio de datos. El
	número máximo de gráficos es de 16, por lo que se va a ignorar cualquier
	variable adicional en la lista.
      </para>
      <para context="gui">
	Por defecto, los datos se muestran con puntos, pero si indicas la
	opción <opt>Usar líneas</opt> serán gráficos de líneas.
      </para>
      <para>
	Consulta también la instrucción <cmdref targ="tsplots"/> para ver un
	modo sencillo de generar gráficos múltiples de series temporales, y la
	instrucción <cmdref targ="gridplot"/> para ver un modo más flexible
	de combinar gráficos en una parrilla.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Gráficos múltiples/Gráficos X-Y (scatters)</menu-path>
    </gui-access>

  </command>

  <command name="script-editor" section="Utilities" context="gui"
    label="Preferencias del editor de guiones">

    <description>
      <para>
	Ten en cuenta que algunas de estas preferencias solo se aplican cuando
	se editan guiones de GRETL originales (Tabulador e Intro inteligentes, Usar
	pestañas en el editor de guiones), y que otras también se aplican cuando se edita
	o mira cualquier guion (Mostrar los números de línea, Estilo de resaltado).
      </para>
      <para>
	<emphasis>Tabulador e Intro inteligentes</emphasis>: Si marcas
	esta opción, entonces cuando pulsas la tecla <lit>Tabulador</lit> al
	comienzo de una línea en un guion de HANSL, en lugar de introducir tan
	solo un salto de tabulación, el programa va a tratar de ajustar el
	nivel de sangrado de la línea consistentemente con otras líneas que
	ya se hayan introducido antes. Igualmente, cuando pulsas la tecla
	<lit>Intro</lit>, el programa va a tratar de asegurar que el sangrado
	de la línea completada es correcta.
      </para>
      <para>
	<emphasis>Mostrar los números de línea</emphasis>: Presenta los
	números de línea en el margen izquierdo del editor de guiones o del visor.
      </para>
      <para>
	<emphasis>Usar pestañas en el editor de guiones</emphasis>: Afecta
	al comportamiento del programa cuando estés editando más de un
	guion al mismo tiempo. Si marcas esto, entonces se muestra cada guion
	en una <quote>pestaña</quote> de una ventana con estilo de cuaderno
	de notas; y en otro caso, cada guion tiene su propia ventana.
      </para>
      <para>
	<emphasis>Activar autocompletado</emphasis>: Si está disponible esta
	opción y marcas el cuadro, se te ofrecerá la posibilidad de completar
	la palabra que estés tecleando, bien mientras escribes o bien en
	respuesta a la tecla de tabulación. Para escoger una de las posibilidades,
	utiliza las teclas de flechas arriba/abajo y de tabulación; o simplemente
	sigue tecleando para descartar los términos sugeridos.
      </para>
      <para>
	<emphasis>Activar paréntesis automáticos</emphasis>: Si marcas esto,
	entonces cuando tecleas un paréntesis, corchete o llave izquierdos
	al final de una línea, se va a añadir automáticamente el delimitador
	correspondiente del lado derecho, y se va a colocar el cursor entre los
	dos delimitadores.
      </para>
      <para>
	<emphasis>Número de espacios por tabulador</emphasis>: ¿Cuánto quieres
	que sea la longitud de un salto de tabulador o del nivel de sangría? Un
	valor entero de 2 a 8.
      </para>
      <para>
	<emphasis>Estilo de resaltado</emphasis>: Proporciona una lista que
	se despliega hacia abajo, con estilos para resaltar la sintaxis. Algunos
	de estos son 'oscuro sobre claro' y algunos son 'claro sobre oscuro':
	experimenta y encuentra el que te guste.
      </para>
    </description>

  </command>

  <command name="sdiff" section="Transformations"
    label="Calcular diferencias estacionales" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Se obtiene la diferencia estacional de cada una de las variables de
	<repl>listavariables</repl>, y se guarda el resultado en una nueva variable
	con el prefijo <lit>sd_</lit>. Esta instrucción está disponible solo para
	series de tiempo estacionales.
      </para>
    </description>

    <gui-access>
      <menu-path>/Añadir/Diferencias estacionales de las variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="set" section="Programming"
    label="Establecer los parámetros del programa" context="cli">

    <usage>
      <altforms>
	<altform><lit>set</lit> <repl>variable</repl> <repl>valor</repl></altform>
	<altform><lit>set --to-file=</lit><repl>nombrearchivo</repl></altform>
	<altform><lit>set --from-file=</lit><repl>nombrearchivo</repl></altform>
	<altform><lit>set stopwatch</lit></altform>
	<altform><lit>set</lit></altform>
      </altforms>
      <examples>
        <example>set svd on</example>
        <example>set csv_delim tab</example>
	<example>set horizon 10</example>
	<example>set --to-file=mysettings.inp</example>
      </examples>
    </usage>

    <description>
      <para>
	El uso más común de esta instrucción es la primera variante mostrada
	arriba, en la que se utiliza para establecer el valor de un parámetro
	escogido del programa (esto se discute con detalle más abajo).
	Los otros usos son: con <opt>to-file</opt> para escribir un
	archivo de guion que contenga todas las configuraciones actuales
	de los parámetros; con <opt>from-file</opt> para leer un archivo
	de guion que contenga las configuraciones de los parámetros y para
	aplicarlas a la sesión vigente; con <lit>stopwatch</lit> para poner
	a cero el <quote>cronómetro</quote> de GRETL que puedes usar para
	medir el tiempo de CPU (consulta los comentarios para el accesor
	<fncref targ="$stopwatch"/>); o para presentar las configuraciones
	actuales, cuando indicas solo la palabra <lit>set</lit>.
      </para>
      <para>
	Los valores establecidos mediante esta instrucción siguen vigentes
	durante la duración de la sesión de GRETL, excepto que los cambies por
	medio de una llamada posterior a <cmd>set</cmd>. Los parámetros
	que puedes establecer de este modo se enumeran más abajo. Ten en
	cuenta que se utilizan las configuraciones de <lit>hc_version</lit>,
	<lit>hac_lag</lit> y <lit>hac_kernel</lit> cuando indicas la opción
	<opt>robust</opt> en una instrucción de estimación.
      </para>
      <para>
	Las configuraciones disponibles se agrupan bajo las siguientes categorías:
	interacción y comportamiento del programa, métodos numéricos, generación
	de números aleatorios, estimación robusta, filtrado, estimación de
	series temporales e interacción con GNU R.
      </para>

      <subhead>Interacción y comportamiento del programa</subhead>

      <para>
	Estas configuraciones se utilizan para controlar diversos aspectos
	del modo en el que GRETL interactúa con el usuario.
      </para>
      <ilist>
	<li>
	  <para><lit>workdir</lit>: <repl>path</repl>. Establece el directorio
	  por defecto para escribir y leer archivos en los casos en los que no se
	  especifican las rutas completas.
	  </para>
	</li>
	<li>
	  <para><lit>use_cwd</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Maneja la configuración del directorio de trabajo (<lit>workdir</lit>)
	  inicial: si está en <lit>on</lit>, se hereda el directorio de trabajo
	  desde el intérprete; en otro caso, se establece donde quiera que se
	  seleccionó en la sesión previa de GRETL.
	  </para>
	</li>
	<li>
	  <para><lit>echo</lit>: <lit>off</lit> u <lit>on</lit> (por defecto).
	  Elimina (o acorta) la resonancia de los textos de las instrucciones en los
	  resultados de GRETL.
	  </para>
	</li>
	<li>
	  <para><lit>messages</lit>: <lit>off</lit> u <lit>on</lit> (por defecto).
	  Elimina (o acorta) la presentación de mensajes sin fallo asociados
	  a diversas instrucciones, por ejemplo cuando se genera una nueva variable
	  o cuando se cambia el rango de la muestra.
	  </para>
	</li>
	<li>
	  <para><lit>verbose</lit>: <lit>off</lit>, <lit>on</lit> (por defecto) o
	  <lit>comments</lit>. Funciona como un <quote>interruptor maestro</quote>
	  para <lit>echo</lit> y <lit>messages</lit> (mira más abajo),
	  apagando o encendiendo los dos simultáneamente. El argumento
	  <lit>comments</lit> apaga la resonancia y la aparición de mensajes,
	  pero mantiene la presentación de comentarios de un guion.
	  </para>
	</li>
	<li>
	  <para><lit>warnings</lit>: <lit>off</lit> u <lit>on</lit> (por defecto).
	  Elimina (o acorta) la presentación de mensajes de advertencia cuando
	  surgen problemas numéricos; por ejemplo, si un cálculo produce
	  valores no finitos o si la convergencia de un proceso de optimización
	  es cuestionable.
	  </para>
	</li>
	<li>
	  <para><lit>csv_delim</lit>: <lit>comma</lit> (coma, por defecto), <lit>space</lit> (espacio),
	  <lit>tab</lit> (tabulación) o <lit>semicolon</lit> (punto y coma). Establece el delimitador
	  de columnas que se usa cuando se guardan datos en un archivo con formato CSV.
	  </para>
	</li>
	<li>
	  <para><lit>csv_write_na</lit>: La cadena de texto que se utiliza para
	  representar los valores ausentes cuando se escriben datos en un archivo
	  con formato CSV. Máximo = 7 caracteres; por defecto es <lit>NA</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>csv_read_na</lit>: La cadena de texto que se coge para
	  representar valores ausentes (NAs) cuando se leen datos con el formato CSV
	  (máximo 7 caracteres). La cadena por defecto depende de que se encuentre
	  una columna de datos que contenga datos numéricos (la mayoría de las
	  veces) o valores de cadena. Para datos numéricos, se considera que lo
	  siguiente indica NAs: una celda vacía o cualquiera de las cadenas
	  <lit>NA</lit>, <lit>N.A.</lit>, <lit>na</lit>,
	  <lit>n.a.</lit>, <lit>N/A</lit>, <lit>#N/A</lit>,
	  <lit>NaN</lit>, <lit>.NaN</lit>, <lit>.</lit>,
	  <lit>..</lit>, <lit>-999</lit>, y <lit>-9999</lit>. Para datos con
	  forma de cadenas de texto con valores, tan solo se cuenta como NA una
	  celda en blanco o una celda que contenga una cadena vacía. Puedes
	  volver a imponer esos valores por defecto indicando <lit>default</lit>
	  como el valor de <lit>csv_read_na</lit>. Para especificar que tan
	  solo se leen las celdas vacías como NAs, indica el valor <lit>""</lit>.
	  Ten en cuenta que las celdas vacías siempre se leen como NAs con
	  independencia de como esté configurada esta variable.
	  </para>
	</li>
	<li>
	  <para><lit>csv_digits</lit>: Un entero positivo que especifica el
	  número de dígitos significativos a usar cuando se escriben datos en
	  formato CSV. Por defecto, se utilizan hasta 15 dígitos dependiendo de la
	  precisión de los datos originales. Ten en cuenta que el resultado CSV
	  emplea la función <lit>fprintf</lit> de la librería de C con la conversión
	  <quote><lit>%g</lit></quote> , lo que significa que se prescinde
	  de los ceros que quedan atrás.
	  </para>
	</li>
	<li>
	  <para><lit>display_digits</lit>: Un entero de 3 a 6 que especifica
	  el número de dígitos significativos a usar cuando se muestran los
	  coeficientes de la regresión y las desviaciones típicas (siendo 6
	  por defecto). También puedes utilizar esta configuración para
	  limitar el número de dígitos que se muestran con la instrucción
	  <cmdref targ="summary"/>; siendo en este caso 5 por defecto (y
	  también el máximo).
	  </para>
	</li>
	<li>
	  <para><lit>mwrite_g</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Cuando se escribe una matriz como texto en un archivo, GRETL
	  por defecto utiliza notación científica con 18 dígitos de
	  precisión, asegurando de este modo que los valores guardados
	  son una representación fiable de los números en memoria.
	  Cuando se escriben datos básicos con no más que 6 dígitos
	  de precisión, puedes preferir utilizar el formato <lit>%g</lit>
	  para tener un archivo más compacto y fácil de leer; puedes
	  hacer este cambio mediante <lit>set mwrite_g on</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>force_decpoint</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Fuerza a GRETL a utilizar el carácter de punto decimal, en un
	  escenario donde otro carácter (probablemente la coma) es el
	  separador decimal estándar.
	  </para>
	</li>
	<li>
	  <para><lit>loop_maxiter</lit>: Un valor entero no negativo
	  (por defecto es 100000). Establece el número máximo de iteraciones
	  que se le permite a un bucle <lit>while</lit>, antes de parar
	  (consulta <cmdref targ="loop"/>). Ten en cuenta que esta
	  configuración solo afecta a la variante <lit>while</lit>; su
	  intención es protegerse ante infinitos bucles que surjan de
	  forma inadvertida. Establecer que este valor sea 0 tiene el
	  efecto de inhabilitar el límite (utilízalo con precaución).
	  </para>
	</li>
	<li>
	  <para><lit>max_verbose</lit>: <lit>off</lit> (por defecto),
	  <lit>on</lit> o <lit>full</lit>. Controla la verborrea de las
	  instrucciones y de las funciones que utilizan métodos de optimización
	  numérica. La opción <lit>on</lit> solo se aplica a funciones (tales
	  como <fncref targ="BFGSmax"/> y <fncref targ="NRmax"/>) que funcionan
	  por defecto con discreción; su efecto consiste en que se muestra
	  información básica sobre las iteraciones. Puedes usar la opción
	  <lit>full</lit> para provocar un resultado más detallado, que
	  incluye los valores de los parámetros y su respectivo gradiente de
	  la función objetivo, en cada iteración. Esta opción se aplica tanto
	  a las funciones del tipo mencionado antes, como a las instrucciones
	  que se basan en optimización numérica como <cmdref targ="arima"/>,
	  <cmdref targ="probit"/> y <cmdref targ="mle"/>. En el caso de las
	  instrucciones, su efecto consiste en hacer que su opción
	  <opt>verbose</opt> proporcione un mayor detalle. Consulta
	  también <guideref targ="chap:numerical"/>.
	</para>
	</li>
	<li>
	  <para><lit>debug</lit>: <lit>1</lit>, <lit>2</lit> o <lit>0</lit> (por defecto).
	  Esto se utiliza con las funciones definidas por el usuario. Establecer
	  <lit>debug</lit> igual a 1 equivale a activar <lit>messages</lit>
	  dentro de todas esas funciones, y establecer esta variable igual a
	  <lit>2</lit> tiene el efecto adicional de activar <lit>max_verbose</lit>
	  dentro de todas las funciones.
	  </para>
	</li>
	<li>
	  <para><lit>shell_ok</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Permite ejecutar programas externos desde GRETL mediante el
	  intérprete de sistema. Esto no está habilitado por defecto
	  por razones de seguridad, y solo puedes habilitarlo mediante la
	  Interfaz Gráfica de Usuario (Herramientas/Preferencias/General).
	  Sin embargo, una vez activada, esta configuración permanecerá activa
	  para sesiones futuras hasta que se desactive explícitamente.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_verbskip</lit>: Un entero. Esta configuración
	  afecta al comportamiento de la opción <opt>verbose</opt> en aquellas
	  instrucciones que utilizan BFGS como algoritmo de optimización, y se
	  usa para compactar el resultado. Si <lit>bfgs_verbskip</lit> se
	  establece en 3, por ejemplo, entonces la opción <opt>verbose</opt>
	  va a provocar que se presenten las iteraciones 3, 6, 9, etcétera.
	  </para>
	</li>
	<li>
	  <para><lit>skip_missing</lit>: <lit>on</lit> (por defecto)
	  u <lit>off</lit>. Controla el comportamiento de GRETL cuando
	  se construye una matriz a partir de series de datos: por
	  defecto se saltan las filas de datos que contienen uno o más
	  valores ausentes, pero cuando se pone <lit>skip_missing</lit>
	  en <lit>off</lit>, los valores ausentes se convierten en NaNs.
	  </para>
	</li>
	<li>
	  <para><lit>matrix_mask</lit>: El nombre de una serie o la
	  palabra clave <lit>null</lit>. Ofrece un mayor control que
	  <lit>skip_missing</lit> cuando se construyen matrices a partir
	  de series: las filas de datos seleccionadas para las matrices
	  son aquellas con valores no nulos (y no ausentes) de las series
	  especificadas. La máscara escogida permanece en vigor hasta que se
	  substituye, o se elimina mediante la palabra clave <lit>null</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>quantile_type</lit>: Debes escoger entre <lit>Q6</lit> (por
	  defecto), <lit>Q7</lit> o <lit>Q8</lit>. Selecciona el método concreto
	  que utiliza la función <fncref targ="quantile"/>. Para obtener más
	  detalles, consulta <cite key="hyndman96">Hyndman y Fan (1996)</cite>
	  o la entrada de la Wikipedia disponible en
	  <url>https://en.wikipedia.org/wiki/Quantile</url>.
	  </para>
	</li>
	<li>
	  <para><lit>huge</lit>: Un número positivo muy grande (por
	  defecto, 1.0E100). Esta configuración controla el valor que
	  devuelve el accesor <fncref targ="$huge"/>.
	  </para>
	</li>
	<li>
	  <para><lit>assert</lit>: <lit>off</lit> (por defecto), <lit>warn</lit>
	  o <lit>stop</lit>. Controla las consecuencias de un fallo
	  (que el valor que se devuelva sea igual a 0) de la función
	  <fncref targ="assert"/>.
	  </para>
	</li>
	<li>
	  <para><lit>datacols</lit>: Un número entero de 1 a 15, cuyo valor por
	  defecto es 5. Establece el número máximo de series que se presentan
	  conjuntamente cuando los datos se representan por observación.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>plot_collection</lit>: <lit>on</lit>, <lit>auto</lit> u <lit>off</lit>.
	  Esta configuración afecta al modo en el que se muestran los gráficos
	  durante el uso interactivo. Si está en <lit>on</lit>, los gráficos del mismo
	  tamaño en pixels se reúnen en una <quote>colección de gráficos</quote>,
	  es decir, en una única pantalla de salida de resultados en la que puedes
	  navegar entre los diversos gráficos yendo adelante y hacia atrás. Con el
	  ajuste en <lit>off</lit>, por el contrario, se va a generar una pantalla
	  distinta para cada gráfico, como en las versiones anteriores de GRETL.
	  Finalmente, el ajuste en <lit>auto</lit> tiene como efecto que permite el
	  modo de colección de gráficos solo para aquellos que se generan antes de
	  que pasen 1.25 segundos después de otro (por ejemplo, como resultado de
	  ejecutar instrucciones de representación gráfica dentro de un bucle).
	  </para>
	</li>
      </ilist>

      <subhead>Métodos numéricos</subhead>

      <para>
	Estas configuraciones se utilizan para controlar los algoritmos
	numéricos que utiliza GRETL para la estimación.
	</para>
      <ilist>
	<li>
	  <para><lit>optimizer</lit>: o <lit>auto</lit> (por defecto), o
	  <lit>BFGS</lit>, o bien <lit>newton</lit>. Establece el algoritmo de
	  optimización que se utiliza para varios estimadores Máximo Verosímiles,
	  en los casos donde el BFGS y el de Newton&ndash;Raphson se pueden
	  aplicar ambos. Por defecto, se utiliza el de Newton&ndash;Raphson
	  cuando se disponga de una matriz Hessiana analítica; en otro caso, BFGS.
	  </para>
	</li>
	<li>
	  <para><lit>bhhh_maxiter</lit>: Un entero, el número máximo de
	  iteraciones para la rutina interna BHHH de GRETL, que se utiliza en la
	  instrucción <cmd>arma</cmd> para la estimación MV condicional.
	  Si la convergencia no se alcanza luego de <lit>bhhh_maxiter</lit>,
	  el programa devuelve un fallo. Por defecto, se establece en 500.
	  </para>
	</li>
	<li>
	  <para><lit>bhhh_toler</lit>: Un valor de punto flotante o la
	  cadena <lit>default</lit>. Esto se utiliza en la rutina interna
	  BHHH de GRETL para verificar si la convergencia se alcanzó.
	  El algoritmo termina de repetirse tan pronto como el incremento
	  en el logaritmo de la verosimilitud entre iteraciones sea menor que
	  <lit>bhhh_toler</lit>. El valor por defecto es 1.0E&minus;06,
	  y puedes restablecer este valor tecleando
	  <lit>default</lit> en lugar de un valor numérico.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_maxiter</lit>: Un entero, el número máximo de
	  iteraciones para la rutina BFGS de GRETL, que se utiliza para
	  <cmd>mle</cmd> (EMV), <cmd>gmm</cmd> (MXM) y varios
	  estimadores específicos. Si no se alcanza la convergencia en el
	  número indicado de iteraciones, el programa devuelve un fallo.
	  El valor por defecto depende del contexto, pero habitualmente
	  es del orden de 500.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_toler</lit>: Un valor de punto flotante o la
	  cadena <lit>default</lit>. Esto se utiliza en la rutina interna BFGS
	  de GRETL para verificar si la convergencia se alcanzó. El
	  algoritmo termina de repetirse tan pronto como la mejoría
	  relativa en la función objetivo entre iteraciones sea menor que
	  <lit>bfgs_toler</lit>. El valor por defecto es igual a la precisión
	  de máquina elevada a 3/4, y puedes restablecer este
	  valor tecleando <lit>default</lit> en lugar de un valor numérico.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_maxgrad</lit>: Un valor de punto flotante. Esto
	  se utiliza en la rutina interna BFGS de GRETL, para verificar si la norma
	  del vector gradiente está razonablemente cerca de cero cuando se
	  alcanza el criterio <lit>bfgs_toler</lit>. Se va a presentar una
	  advertencia cuando la norma del vector gradiente exceda de 1; y
	  se muestra un fallo si la norma excede <lit>bfgs_maxgrad</lit>.
	  Actualmente, por defecto el valor de tolerancia es de 5.0.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_richardson</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Utiliza la extrapolación de Richardson cuando calcules las
	  derivadas numéricas en el contexto de la maximización
	  BFGS.
	  </para>
	</li>
	<li>
	  <para><lit>initvals</lit>: El nombre de una matriz que haya sido
	  definida previamente. Permite establecer manualmente el vector
	  inicial de parámetros en determinadas instrucciones de estimación
	  que implican realizar optimización numérica como <lit>arma</lit>,
	  <lit>garch</lit>, <lit>logit</lit>, <lit>probit</lit>, <lit>tobit</lit>,
	  <lit>intreg</lit>, <lit>biprobit</lit>, <lit>duration</lit>; y
	  también cuando se imponen ciertos tipos de restricciones que están
	  vinculadas a modelos VEC. A diferencia de otras configuraciones,
	  <lit>initvals</lit> no es persistente, pues se restablece su valor
	  al de inicio por defecto, después de su primera utilización. Para
	  obtener detalles en relación con la estimación ARMA consulta
	  <guideref targ="chap:timeseries"/>.
	  </para>
	</li>
	<li>
	  <para><lit>lbfgs</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Utiliza la versión de memoria limitada de BFGS (L-BFGS-B)
	  en vez del algoritmo habitual. Esto puede ser ventajoso cuando
	  la función que se maximiza no es globalmente cóncava.
	  </para>
	</li>
	<li>
	  <para><lit>lbfgs_mem</lit>: Un valor entero en el rango de
	  3 a 20 (con un valor por defecto de 8). Esto determina el número
	  de correcciones que se utilizan en la matriz de memoria limitada
	  cuando se emplea L-BFGS-B.
	  </para>
	</li>
	<li>
	<para>
	  <lit>nls_toler</lit>: Un valor de punto flotante. Establece la
	  tolerancia que se utiliza al juzgar si la convergencia se alcanza
	  o no, en una estimación de mínimos cuadrados no lineales
	  utilizando la instrucción <cmdref targ="nls"/>. El valor por
	  defecto es igual a la precisión de máquina elevada a 3/4, y
	  puedes restablecer este valor tecleando <lit>default</lit>
	  en lugar de un valor numérico.
	</para>
	</li>
	<li>
	  <para>
	  <lit>svd</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Utiliza la Descompisición en Valores Singulares (SVD) en vez de las
	  descomposiciones de Cholesky o la QR, en los cálculos de mínimos cuadrados.
	  Esta opción se aplica a la función <lit>mols</lit> así como a varios
	  cálculos internos, pero no a la instrucción <cmdref targ="ols"/> habitual.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>force_qr</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Esto se aplica a la instrucción <cmdref targ="ols"/>. Por defecto,
	  esta instrucción calcula las estimaciones de MCO utilizando la
	  descomposición de Cholesky (el método más rápido), con QR
	  como último recurso si los datos parecen demasiado mal
	  condicionados. Puedes utilizar <lit>force_qr</lit> para saltarte
	  el paso de Cholesky, pues en los casos <quote>dudosos</quote>
	  esto puede asegurar una mayor precisión.
	  </para>
	</li>
	<li>
	  <para><lit>fcp</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Utiliza el algoritmo de Fiorentini, Calzolari y Panattoni en vez del
	  código propio de GRETL, cuando se calculan las estimaciones GARCH.
	  </para>
	</li>
	<li>
	  <para><lit>gmm_maxiter</lit>: Un entero, el número máximo de
	  iteraciones de la instrucción <cmdref targ="gmm"/> de GRETL cuando
	  se está en modo iterativo (en contraposición al de un paso o
	  al de dos pasos). El valor por defecto es 250.
	  </para>
	</li>
	<li>
	  <para><lit>nadarwat_trim</lit>: Un entero, el parámetro de
	  recorte utilizado en la función <fncref targ="nadarwat"/>.
	  </para>
	</li>
	<li>
	  <para><lit>fdjac_quality</lit>: Un entero (0, 1 o 2) que indica
	  el algoritmo utilizado por la función <fncref targ="fdjac"/>; por
	  defecto es 0.
	  </para>
	</li>
	<li>
	  <para><lit>gmp_bits</lit>: Un entero, que debe ser una potencia de
	  2 con exponente entero (el valor predeterminado y mínimo es 256,
	  y el máximo es 8192). Esto controla el número de bits que se utilizan
	  para representar un número de punto flotante cuando se invoca la GMP
	  (la Biblioteca de la Aritmética de Precisión Múltiple de GNU), sobre
	  todo mediante la instrucción <lit>mpols</lit>. Los valores más grandes
	  de ese entero proporcionan mayor precisión al coste de un mayor
	  tiempo de cálculo. Esta configuración también se puede controlar por
	  medio de la variable de entorno <lit>GRETL_MP_BITS</lit>.
	  </para>
	</li>
      </ilist>

      <subhead>Generación de números aleatorios</subhead>

      <ilist>
	<li>
	  <para><lit>seed</lit>: Un número natural positivo o la palabra clave
	  <lit>auto</lit>. Establece la semilla para el generador de números
	  pseudoaleatorios. Por defecto, esto se establece a partir del tiempo
	  del sistema; pero si quieres generar secuencias repetibles de números
	  aleatorios debes establecer la semilla manualmente. Para restablecer
	  la semilla a un valor automático basado en el tiempo, usa <lit>auto</lit>.
	  </para>
	</li>
      </ilist>

      <subhead>Estimación robusta</subhead>

      <ilist>
	<li>
	  <para><lit>bootrep</lit>: Un entero. Establece el número de
	  repeticiones de la instrucción <cmdref targ="restrict"/> con la
	  opción <opt>bootstrap</opt>.
	  </para>
	</li>
	<li>
	  <para><lit>garch_vcv</lit>: <lit>unset</lit>, <lit>hessian</lit>,
	  <lit>im</lit> (matriz de información), <lit>op</lit> (matriz de
	  producto externo), <lit>qml</lit> (estimador CMV o QML), o <lit>bw</lit>
	  (Bollerslev&ndash;Wooldridge). Especifica la variante que se va a
	  utilizar para estimar la matriz de covarianzas de los coeficientes para
	  modelos GARCH. Cuando indicas <lit>unset</lit> (caso por defecto)
	  entonces se utiliza la matriz Hessiana, excepto que se indique la opción
	  <quote>robust</quote> para la instrucción garch, en cuyo caso
	  se utiliza CMV (QML).
	  </para>
	</li>
	<li>
	  <para><lit>arma_vcv</lit>: <lit>hessian</lit> (caso por defecto)
	  u <lit>op</lit> (matriz de producto externo). Especifica la variante
	  que se va a utilizar cuando se calcula la matriz de covarianzas para
	  modelos ARIMA.
	  </para>
	</li>
	<li>
	  <para><lit>force_hc</lit>: <lit>off</lit> (por defecto) u <lit>on</lit>.
	  Por defecto, con datos de series temporales y cuando indicas la
	  opción<opt>robust</opt> con <lit>ols</lit> (MCO), se utiliza el
	  estimador HAC. Si pones <lit>force_hc</lit> en <quote>on</quote>,
	  esto fuerza el cálculo de la Matriz de Covarianzas Consistente ante
	  Heterocedasticidad (HCCM) habitual, que no tiene en cuenta la
	  autocorrelación. Ten en cuenta que los VARs se tratan como
	  un caso especial, pues cuando indicas la opción <opt>robust</opt>
	  el método por defecto es el de la HCCM habitual, pero puedes utilizar
	  la opción <opt>robust-hac</opt> para forzar que se emplee un
	  estimador HAC.
	  </para>
	</li>
	<li>
	  <para><lit>robust_z</lit>: <lit>off</lit> (por defecto) u <lit>on</lit>.
	  Esto controla la distribución que se utiliza cuando se calculan las
	  probabilidades asociadas (valores p) basadas en las desviaciones
	  típicas robustas, en el contexto de los estimadores de mínimos cuadrados.
	  Por defecto, GRETL utiliza la distribución <math>t</math> de Student
	  pero si activas <lit>robust_z</lit>, se utiliza una distribución
	  Normal.
	  </para>
	</li>
	<li>
	  <para><lit>hac_lag</lit>: <lit>nw1</lit> (por defecto), <lit>nw2</lit>,
	  <lit>nw3</lit> o un entero. Establece el valor del retardo máximo
	  o ancho de banda (<math>p</math>) utilizado cuando se calculan
	  las desviaciones típicas HAC (Consistentes ante Heterocedasticidad
	  y Autocorrelación) utilizando el enfoque de Newey-West, para datos
	  de series temporales. Las opciones <lit>nw1</lit> y <lit>nw2</lit>
	  representan dos variantes de cálculo automático basadas en el
	  tamaño de la muestra <math>T</math>: para nw1,
	  <equation status="inline"
	    tex="$p = 0.75 \times T^{1/3}$"
	    ascii="p = 0.75 * T^(1/3)"
	    graphic="nw1"/>, y para nw2,
	  <equation status="inline"
	    tex="$p = 4 \times (T/100)^{2/9}$"
	    ascii="p = 4 * (T/100)^(2/9)"
	    graphic="nw2"/>. La <lit>nw3</lit>
	  solicita una elección del ancho de banda que se basa en los datos. Consulta
	  también más abajo <lit>qs_bandwidth</lit> y <lit>hac_prewhiten</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>hac_kernel</lit>: <lit>bartlett</lit> (por defecto),
	  <lit>parzen</lit> o <lit>qs</lit> (Espectral cuadrado). Establece
	  el 'kernel', o patrón de ponderaciones, que se utiliza cuando se
	  calculan las desviaciones típicas HAC.
	  </para>
	</li>
	<li>
	  <para><lit>hac_prewhiten</lit>: <lit>on</lit> u <lit>off</lit> (por defecto).
	  Utiliza el 'blanqueo' previo y la 'vuelta a colorear' de Andrews-Monahan
	  cuando se calculan las desviaciones típicas HAC. Esto también implica
	  utilizar una elección del ancho de banda que se basa en los datos.
	  </para>
	</li>
	<li>
	  <para><lit>hac_missvals</lit>: <lit>es</lit> (predeterminado),
	  <lit>am</lit> u <lit>off</lit>. Establece la política respecto al
	  cálculo de las desviaciones típicas HAC cuando la muestra utilizada en
	  la estimación incluye observaciones incompletas: <lit>es</lit> invoca
	  el método de la Misma Separación (Equal Spacing) de
	  <cite key="datta-du12">Datta y Du (2012)</cite>; <lit>am</lit>
	  elige el método de la Modulación de la Amplitud (Amplitude Modulation)
	  de <cite key="parzen63">Parzen (1963)</cite>; y <lit>off</lit>
	  provoca que GRETL rechace dicha estimación. Para obtener más detalles,
	  consulta <guideref targ="chap:robust_vcv"/>.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>hc_version</lit>: 0, 1, 2, 3 o 3a. Establece la variante que se usa
	  al calcular las desviaciones típicas Consistentes ante Heterocedasticidad
	  (HC) con datos de sección cruzada. Las 4 primeras opciones se
	  corresponden con HC0, HC1, HC2 y HC3 discutidas por Davidson y
	  MacKinnon en el capítulo 5 de <book>Econometric Theory and Methods</book>.
	  HC0 produce las denominadas habitualmente como
	  <quote>desviaciones típicas de White</quote>. La variante 3a es el
	  procedimiento de la <quote>navaja</quote> de MacKinnon&ndash;White.
	  A configuración por defecto habitualmente es 1, pero esto se puede
	  cambiar en el cliente GUI, seleccionando la opción <quote>HCCME</quote>
	  en el menú <quote>Herramientas/Preferencias/General</quote>. Ten en
	  cuenta que una configuración realizada mediante GUI persiste a lo
	  largo de las sesiones de GRETL, en oposición al uso de la instrucción
	  <lit>set</lit> que únicamente va a afectar a la sesión vigente.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>panel_robust</lit>: <lit>arellano</lit> (por defecto),
	  <lit>pcse</lit> o <lit>scc</lit>. Esto selecciona el estimador de la
	  matriz de covarianzas robustas para ser utilizado con los modelos
	  con datos de panel. Consulta a instrución <cmdref targ="panel"/> e
	  o <guideref targ="chap:robust_vcv"/> para obter máis detalles.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>qs_bandwidth</lit>: Ancho de banda para la estimación
	  HAC en caso de que selecciones el kernel Espectral Cuadrado (QS).
	  (A diferencia de los 'kernels' de Bartlett y de Parzen, el ancho de banda
	  QS no requiere ser un entero.)
	  </para>
	</li>
      </ilist>

      <subhead>Series temporales</subhead>

      <ilist>
	<li>
	  <para>
	  <lit>horizon</lit>: Un entero (por defecto se basa en la frecuencia
	  de los datos). Establece el horizonte para las respuestas al impulso
	  y las descomposiciones de la varianza de predicción en el contexto de
	  autorregresiones de vectores.
	  </para>
	</li>
	<li>
	  <para>
	  <lit>vecm_norm</lit>: <lit>phillips</lit> (por defecto),
	  <lit>diag</lit>, <lit>first</lit> o <lit>none</lit>.
	  Usada en el contexto de la estimación VECM mediante la instrucción
	  <cmdref targ="vecm"/> para identificar los vectores de
	  cointegración. Consulta <guideref targ="chap:vecm"/>
	  para obtener más detalles.
	  </para>
	</li>
	<li>
	  <para>
    <lit>boot_iters</lit>: Un entero, <math>B</math>. Establece el
    número de iteracciones 'bootstrap' que se usan cuando se calculan
    funciones de respuesta al impulso con intervalos de confianza. El
    valor por defecto es 1999. Es recomendable que <math>B</math> + 1
    sea siempre divisible por 100&alpha;/2 de forma que, por ejemplo con
    &alpha; = 0.1, <math>B</math>+1 debería ser múltiplo de 5. El mínimo
    valor aceptable para B es 499.
	  </para>
	</li>
      </ilist>

	    <subhead>Interacción con R</subhead>

      <ilist>
	<li>
	  <para><lit>R_lib</lit>: <lit>on </lit>(por defecto) u <lit>off</lit>.
	  Cuando se envían instrucciones para que las ejecute R, utiliza
	  la biblioteca compartida de R mejor que el ejecutable de R, si la
	  biblioteca está disponible.
	  </para>
	</li>
	<li>
	  <para><lit>R_functions</lit>: <lit>off</lit> (por defecto) u <lit>on</lit>.
	  Reconoce funciones definidas en R como si fueran funciones
	  propias (para eso se requiere el prefijo de asignación de
	  nombres <quote><lit>R.</lit></quote>). Consulta
	  <guideref targ="chap:gretlR"/> para obtener más detalles
	  sobre este elemento y el anterior.
	  </para>
	</li>
      </ilist>

      <subhead>Miscelánea</subhead>

      <ilist>
	<li>
	  <para><lit>mpi_use_smt</lit>: <lit>on</lit> o bien <lit>off</lit>
	  (por defecto). Este interruptor afecta al número de procesos que
	  se inician en un bloque <lit>mpi</lit> dentro de un guion. Si el
	  interruptor está en <lit>off</lit>, la cantidad por defecto de
	  estos procesos es igual al número de núcleos físicos de la máquina
	  local; si está en <lit>on</lit>, la cantidad por defecto de estos
	  procesos es igual al número máximo de subprocesos, que coincidirá
	  con el doble del número de núcleos físicos si estos pueden soportar
	  SMT (Multiproceso Simultáneo, también denominado Hiperproceso).
	  Esto se aplica únicamente si el usuario no indica el número de
	  procesos, bien de forma directa o bien indirectamente (mediante
	  la especificación de un archivo <lit>hosts</lit> para utilizar
	  con MPI).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>graph_theme</lit>: una cadena de texto a elegir entre
	    <lit>altpoints</lit>, <lit>classic</lit>, <lit>dark2</lit>
	    (la vigente por defecto), <lit>ethan</lit>, <lit>iwanthue</lit>
	    o <lit>sober</lit>. Esto establece el <quote>tema</quote> que
	    se utiliza para los gráficos que genera GRETL. La opción
	    <lit>classic</lit> supone volver al sencillo tema que estaba
	    vigente con antelación a la versión 2020c de GRETL.
	  </para>
	</li>
      </ilist>

    </description>
  </command>

  <command name="setinfo" section="Dataset" label="Editar los atributos de una variable">

    <usage>
      <arguments>
        <argument>serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--description</flag>
	  <optparm>cadena</optparm>
	  <effect>Establece la descripción</effect>
	</option>
	<option>
	  <flag>--graph-name</flag>
	  <optparm>cadena</optparm>
	  <effect>Establece el nombre del gráfico</effect>
	</option>
	<option>
	  <flag>--discrete</flag>
	  <effect>Marca la serie como discreta</effect>
	</option>
	<option>
	  <flag>--continuous</flag>
	  <effect>Marca la serie como continua</effect>
	</option>
	<option>
	  <flag>--coded</flag>
	  <effect>Marca como una codificación</effect>
	</option>
	<option>
	  <flag>--numeric</flag>
	  <effect>Marca como no codificación</effect>
	</option>
	<option>
	  <flag>--midas</flag>
	  <effect>Marca como componente de datos de alta frecuencia</effect>
	</option>
      </options>
      <examples>
        <example>setinfo x1 --description="Descripción de x1"</example>
        <example>setinfo y --graph-name="Alguna cadena"</example>
	<example>setinfo z --discrete</example>
      </examples>
    </usage>

    <description context="cli">
      <para>
	Si activas las opciones <opt>description</opt> o <opt>graph-name</opt>,
	el argumento debe ser una única serie; de lo contrario, podrá ser
	una lista de series, en cuyo caso la instrucción funciona sobre todos
	los elementos de la lista. Esta instrucción configura 4 atributos como se
	indica a continuación.
      </para>
      <para>
	Cuando indicas la opción <opt>description</opt> seguida de una
	cadena de texto entre comillas, esa cadena se utiliza para establecer
	la etiqueta descriptiva de la variable. Esta etiqueta se muestra en respuesta
	a la instrucción <cmdref targ="labels"/>, y también se muestra en la ventana
	principal del programa de Interfaz Gráfica de Usuario (GUI).
      </para>
      <para>
	Cuando especificas la opción <opt>graph-name</opt> seguida de una
	cadena de texto entre comillas, esa cadena se va a utilizar en los gráficos
	en lugar del nombre de la variable.
      </para>
      <para>
	Cuando indicas uno de los dos indicadores de opción <opt>discrete</opt>
	o <opt>continuous</opt>, el carácter numérico de la variable se establece
	en consonancia con eso. Por defecto, se tratan todas las series como
	continuas, entonces determinar que una serie sea discreta va a afectar
	al modo en que se maneja la variable en otras instrucciones y
	funciones, como por ejemplo con <cmdref targ="freq"/> o con
	<fncref targ="dummify"/>.
      </para>
      <para>
	Cuando indicas alguna de las dos opciones <opt>coded</opt> o <opt>numeric</opt>,
	el status de la serie indicada se establece de acuerdo con eso. Por defecto,
	se tratan todos los valores numéricos como que tienen sentido como tales,
	por lo menos en la acepción habitual; pero establecer que una serie es
	<lit>coded</lit> quiere decir que los valores numéricos son una
	codificación arbitraria de características cualitativas.
      </para>
      <para>
	La opción <opt>midas</opt> establece una indicación que alude a que
	una determinada serie contiene datos de una frecuencia mayor que la
	frecuencia base del conjunto de datos; por ejemplo, si el conjunto de
	datos es trimestral, y las series contienen valores para el mes 1, 2 o 3
	de cada trimestre. (MIDAS = Mixed Data Sampling.)
      </para>
    </description>

    <description context="gui">

      <para>
	En esta caja de diálogo puedes:</para>

	<para>* Renombrar una variable (tipo serie).</para>

	    <para>* Añadir o editar la descripción de la variable que aparece al lado del nombre de estas, en la ventana principal de GRETL.
	    </para>

	    <para>* Añadir o editar el 'nombre a mostrar' de una variable (si la variable
	es una serie, no un escalar). Esta cadena de texto (de 19 caracteres como
	máximo) se muestra en lugar del nombre de la variable, cuando esta se representa en un
	gráfico. Así, por ejemplo, puedes asociar una cadena más comprensible tal como
	'Tipo de la letra del tesoro' con una variable nombrada abreviadamente 'tb3'.
	    </para>

	    <para>* Determinar el método para compactar una variable (para
	datos de series temporales). Ese método se va a utilizar cuando decidas
	reducir la frecuencia del conjunto de datos, o cuando actualices una
	variable importándola de una base de datos donde esa variable tiene una
	frecuencia mayor que en el conjunto de datos de trabajo.
      </para>

	    <para>* Marcar una variable como discreta (para series que solo
	tienen valores enteros). Esto afecta al modo en el que se maneja la
	variable cuando pides un gráfico de frecuencias.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Editar atributos</menu-path>
      <other-access>Ventana principal: Menú emergente</other-access>
    </gui-access>

  </command>

  <command name="setmiss" section="Dataset"
    label="Código de valor ausente">

    <usage>
      <arguments>
        <argument>valor</argument>
        <argument optional="true">listavariables</argument>
      </arguments>
      <examples>
        <example>setmiss -1</example>
        <example>setmiss 100 x2</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Permite que el programa interprete algún valor específico de
	dato numérico (el primer parámetro de la instrucción) como un
	código para <quote>ausente</quote>, en caso de importar datos.
	Cuando este valor es el único parámetro (como en el primer ejemplo
	de arriba), esa interpretación se va a aplicar a todas las series
	del conjunto de datos. Cuando <repl quote="true">valor</repl> va
	seguido de una lista de variables (indicadas por nombre o número),
	la interpretación se limita a la(s) variable(s) especificada(s). Así,
	en el segundo ejemplo, el valor 100 de los datos se interpreta como un
	código para <quote>ausente</quote>, pero solo para la variable
	<lit>x2</lit>.
      </para>

      <para context="gui">
	Establece un valor numérico que va a interpretarse como 'ausente' o
	'no aplicable', bien para una serie de datos en concreto (bajo el
	menú Variable) o globalmente para todo el conjunto de datos (bajo
	el menú Datos).
	    </para>

      <para context="gui">
	GRETL tiene su propia codificación interna para los valores ausentes,
	pero a veces con los datos que se importan se pudo emplear un código
	diferente. Por ejemplo, si una serie en concreto está codificada de
	modo que el valor -1 significa 'no aplicable', puedes seleccionar
	'Establecer código de valor ausente' bajo el menú Variable, y
	teclear el valor '-1' (sin comillas). Entonces GRETL leerá los valores -1
	como observaciones ausentes.
      </para>

    </description>

    <gui-access>
      <menu-path>/Datos/Establecer código de valor ausente</menu-path>
    </gui-access>

  </command>

  <command name="setobs" section="Dataset" context="cli"
    label="Establecer la frecuencia y la observación de inicio">

    <usage>
      <altforms>
        <altform><lit>setobs</lit> <repl>periodicidad</repl> <repl>obsinicio</repl></altform>
	      <altform><lit>setobs</lit> <repl>varunidades</repl> <repl>vartiempo</repl> <lit>--panel-vars</lit></altform>
      </altforms>
      <options>
        <option>
	  <flag>--cross-section</flag>
	  <effect>Interpreta como de sección cruzada</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>Interpreta como serie temporal</effect>
        </option>
        <option>
	  <flag>--special-time-series</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--stacked-cross-section</flag>
	  <effect>Interpreta como datos de panel</effect>
        </option>
        <option>
	  <flag>--stacked-time-series</flag>
	  <effect>Interpreta como datos de panel</effect>
        </option>
        <option>
	  <flag>--panel-vars</flag>
	  <effect>Utiliza variables índice, mira abajo</effect>
        </option>
        <option>
	  <flag>--panel-time</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--panel-groups</flag>
	  <effect>Mira abajo</effect>
        </option>
      </options>
      <examples>
        <example>setobs 4 1990:1 --time-series</example>
        <example>setobs 12 1978:03</example>
	<example>setobs 1 1 --cross-section</example>
        <example>setobs 20 1:1 --stacked-time-series</example>
	<example>setobs unit year --panel-vars</example>
      </examples>
    </usage>

    <description>
      <para>
	Esta instrucción fuerza al programa a interpretar que el conjunto
	de datos tiene una estructura específica.
      </para>
      <para>
	En la primera forma de la instrucción, debes indicar la <repl>periodicidad</repl>
	mediante un entero que represente la frecuencia en caso de que los datos
	sean series temporales (1 = anuales; 4 = trimestrales; 12 = mensuales;
	52 = semanales; 5, 6, o 7 = diarios; 24 = horarios). En caso de datos de
	panel, la periodicidad indica el número de líneas por bloque de datos; por lo
	tanto, esto expresa o bien el número de unidades consecutivas cuando indicas que
	son 'secciones cruzadas apiladas', o bien el número de períodos de tiempo
	consecutivos cuando indicas 'series de tiempo apiladas'. En caso de datos
	simples de sección cruzada, la periodicidad debe establecerse en 1.
      </para>
      <para>
	La observación de inicio representa la fecha inicial, en caso de tratarse de
	datos de series temporales. Puedes indicar los años mediante 2 o 4 dígitos;
	y debes separar los subperíodos (por ejemplo, trimestres o meses) del
	año mediante dos puntos. En caso de datos de panel, debes indicar
	la observación inicial como 1:1, y en caso de datos de sección cruzada,
	como 1. Debes indicar las observaciones iniciales para datos diarios o
	semanales con el formato YYYY-MM-DD (o simplemente como 1 para datos
	sin fechar).
      </para>
      <para>
	Algunas periodicidades de series temporales tienen interpretaciones
	estándar (por ejemplo, 12 = mensuales y 4 = trimestrales). Pero si
	tienes datos de series temporales poco habituales para las que no se
	aplica la interpretación estándar, puedes señalar esto indicando la
	opción <opt>special-time-series</opt>. En ese caso, GRETL no va a
	advertir de que tus datos de (por ejemplo) frecuencia igual
	a 12, sean mensuales.
      </para>
      <para>
	Cuando no seleccionas un indicador de opción explícito para determinar la
	estructura de los datos, el programa va a tratar de adivinar la estructura a partir
	de la información proporcionada.
      </para>
      <para>
	La segunda forma de la instrucción (que requiere que indiques la opción
	<opt>panel-vars</opt>) puede utilizarse para imponer una interpretación de
	panel, cuando el conjunto de datos contiene variables que identifican de forma
	inequívoca las unidades de sección cruzada y los períodos de tiempo. El conjunto
	de datos se va a ordenar como series de tiempo apiladas, en función de los
	valores ascendentes de la variable de unidades (<repl>varunidades</repl>).
      </para>
      <subhead>Opciones específicas de Panel</subhead>
      <para>
	Puedes usar opciones <opt>panel-time</opt> y <opt>panel-groups</opt>
	únicamente con un conjunto de datos que ya fue definido previamente como
	un panel.
      </para>
      <para>
	La intención de la opción <opt>panel-time</opt> es determinar información
	adicional relacionada con la dimensión temporal del panel. Debes indicar
	esta siguiendo el patrón del primer formato de <lit>setobs</lit> apuntado
	más arriba. Por ejemplo, puedes utilizar la siguiente forma de indicar
	que la dimensión temporal de un panel es trimestral, comenzando en el primer
	trimestre de 1990:
      </para>
      <code>
	setobs 4 1990:1 --panel-time
      </code>
      <para>
	La intención de la opción <opt>panel-groups</opt> es crear una serie con
	valores en cadenas de texto, que contenga los nombres de los grupos (individuos,
	unidades atemporales) del panel. (Esto se va a utilizar cuando sea adecuado
	en gráficos de panel.) Con esta opción indicas uno o dos argumentos,
	como se indica a continuación.
      </para>
      <para>
	Primer caso: Un único argumento es el nombre de una serie con valores
	en cadenas de texto. Si el número de valores diferentes es igual al
	número de grupos del panel, esa serie se utiliza para definir los nombres
	de los grupos. Si resulta necesario, el contenido numérico de la serie se va a
	ajustar de forma que los valores sean todos 1 para el primer grupo,
	todos 2 para el segundo grupo, etcétera. Cuando el número de valores
	diferentes en cadenas de texto no coincide con el número de grupos,
	se muestra un fallo.
      </para>
      <para>
	Segundo caso: El primer argumento es el nombre de una serie, y el segundo
	es una cadena de texto literal o una variable de cadena que contiene
	un nombre para cada grupo. Las series se van a generar si no existen ya.
	Cuando el segundo argumento es una cadena de texto literal o una
	variable de cadena, los nombres de los grupos deben estar separados por
	espacios; pero se un nombre incluye espacios, debe delimitarse con
	comillas precedidas (cada una) de barra inversa. Alternativamente,
	el segundo argumento puede ser un array de cadenas de texto.
      </para>
      <para>
	Por ejemplo, el siguiente código genera una serie que se va llamar
	<lit>Estado</lit> en la que los nombres de la cadena <lit>cstrs</lit> se repiten
	cada uno <math>T</math> veces, y siendo <math>T</math> la longitud de las
	series de tiempo del panel.
      </para>
      <code>
	string cstrs = sprintf("Francia Alemania Italia \"Reino Unido\"")
	setobs Estado cstrs --panel-groups
      </code>
    </description>

    <gui-access>
      <menu-path>/Datos/Estructura del conjunto de datos</menu-path>
    </gui-access>

  </command>

  <command name="setopt" section="Programming" context="cli"
    label="Configurar las opciones de la próxima instrucción">

    <usage>
      <arguments>
	      <argument>instrucción</argument>
	      <argument optional="true">acción</argument>
	      <argument>opciones</argument>
      </arguments>
      <examples>
        <example>setopt mle --hessian</example>
        <example>setopt ols persist --quiet</example>
	<example>setopt ols clear</example>
	<demos>
	  <demo>gdp_midas.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Esta instrucción permite la configuración previa de opciones para una
	instrucción concreta. Normalmente esto no hace falta, pero puede ser
	útil para los autores de funciones en HANSL, cuando quieren hacer que
	algunas opciones de las instrucciones estén condicionadas al valor de un
	argumento que proporcione quien las solicita.
      </para>
      <para>
	Por ejemplo, supón que una función ofrece un interruptor booleano
	<quote><lit>quiet</lit></quote>, cuya intención es que se
	suprima la presentación de resultados de una determinada regresión
	que se ejecuta dentro de la propia función. En ese caso, se podría
	escribir:
      </para>
      <code>
	if quiet
	  setopt ols --quiet
	endif
	ols ...
      </code>
      <para>
	Entonces, la opción <opt>quiet</opt> se va a aplicar a la siguiente instrucción
	<lit>ols</lit> únicamente si la variable <lit>quiet</lit> tiene un valor
	no nulo.
      </para>
      <para>
	Por defecto, las opciones que se establecen de este modo solo se aplican
	a la siguiente petición de la <repl>instrucción</repl>; por lo que no son
	persistentes. Sin embargo, si indicas <lit>persist</lit> como valor para
	<repl>acción</repl>, las opciones se continuarán aplicando a la instrucción
	indicada hasta nuevo aviso. El 'antídoto' a la acción <lit>persist</lit> es
	<lit>clear</lit>, pues este elimina cualquier configuración guardada
	para la instrucción especificada.
      </para>
      <para>
	Debes tener en cuenta que las opciones establecidas mediante
	<lit>setopt</lit> se combinan con cualquier opción agregada
	directamente a la instrucción apuntada. Así, por ejemplo, se puede
	añadir la opción <opt>hessian</opt> a una instrucción <lit>mle</lit>
	de forma incondicional, pero utilizar <lit>setopt</lit> para añadir
	<opt>quiet</opt> de forma condicional.
      </para>
    </description>
  </command>

  <command name="shell" section="Utilities"
    label="Ejecutar instrucciones del intérprete" context="cli">

    <usage>
      <arguments>
        <argument>instrucshell</argument>
      </arguments>
      <examples>
        <example>! ls -al</example>
        <example>! dir c:\users</example>
        <example>launch notepad</example>
        <example>launch emacs myfile.txt</example>
      </examples>
    </usage>

    <description>
      <para>
	La prestación que se describe aquí no está activada por defecto.
	Mira más abajo para los detalles.
      </para>
      <para>
	Un signo de exclamación (<cmd>!</cmd>) al comienzo de una línea de
	instrucción se interpreta como una escapada del intérprete de usuario.
	Así puedes ejecutar instrucciones del intérprete a tu antojo desde dentro
	de <program>Gretl</program>. El argumento <repl>instrucshell</repl>
	se pasa a <lit>/bin/sh</lit> en sistemas de tipo Unix como Linux y
	macOS, o a <lit>cmd.exe</lit> en MS Windows. Se ejecuta de forma
	sincrónica; es decir, <program>Gretl</program> va a esperar a que se
	complete la instrucción antes de proseguir. Si la instrucción da como
	resultado algún texto, este se presenta en la consola o en la ventana
	de resultados de guiones.
      </para>
      <para>
	Una variante del acceso síncrono con el intérprete, permite al usuario
	<quote>capturar</quote> el resultado de una instrucción en una variable
	de cadena de texto. Esto se puede lograr envolviendo la instrucción
	entre paréntesis, precedidos por un signo dólar, como en
      </para>
      <code>
	string s = $(ls -l $HOME)
      </code>
      <para>
	Por otro lado, la clave <cmd>launch</cmd>, ejecuta un programa
	externo de forma asíncrona (sin esperar a que se complete), como
	en el tercer y en el cuarto ejemplos de arriba. Esto está pensado
	para abrir una aplicación en modo interactivo. La <lit>RUTA</lit>
	del usuario se va a buscar para el ejecutable especificado. En
	MS Windows, la instrucción se ejecuta directamente, sin pasarla a
	<lit>cmd.exe</lit> (de ese modo las variables de entorno no se
	expanden automáticamente).
      </para>
      <subhead>Activación</subhead>
      <para>
	Por razones de seguridad, la prestación de acceso con el intérprete
	no se permite por defecto. Para activarla, marca el recuadro
	<quote>Permitir instrucciones de shell</quote> bajo el menú
	Herramientas/Preferencias/General en el programa de Interfaz Gráfica de usuario
	(GUI). Esto también hace que estén disponibles las instrucciones del intérprete
	en el programa de instrucciones en líneas (y resulta el único modo de hacerlo).
      </para>
    </description>

  </command>

  <command name="smpl" section="Dataset"
    label="Establecer el rango de la muestra" context="cli">

    <!-- don't break the lines below or the text version will get messed
    up -->

    <usage>
      <altforms>
	<altform><lit>smpl</lit> <repl>obsinicio obsfin</repl></altform>
	<altform><lit>smpl</lit> <repl>+i -j</repl></altform>
	<altform><lit>smpl</lit> <repl>varficticia</repl> <lit>--dummy</lit></altform>
	<altform><lit>smpl</lit> <repl>condición</repl> <lit>--restrict</lit></altform>
	<altform><lit>smpl</lit> <lit>--no-missing [ </lit><repl>listavariables</repl> <lit>]</lit></altform>
	<altform><lit>smpl</lit> <lit>--no-all-missing [ </lit><repl>listavariables</repl> <lit>]</lit></altform>
	<altform><lit>smpl</lit> <lit>--contiguous [ </lit><repl>listavariables</repl> <lit>]</lit></altform>
	<altform><lit>smpl</lit> <repl>n</repl> <lit>--random</lit></altform>
	<altform><lit>smpl full</lit></altform>
	<altform><lit>smpl</lit></altform>
      </altforms>
      <options>
        <option>
	  <flag>--dummy</flag>
	  <effect>El argumento es una variable ficticia</effect>
        </option>
        <option>
	  <flag>--restrict</flag>
	  <effect>Aplica una restricción booleana</effect>
        </option>
        <option>
	  <flag>--replace</flag>
	  <effect>Substituye cualquier restricción booleana existente</effect>
        </option>
        <option>
	  <flag>--no-missing</flag>
	  <effect>Limitarse a observaciones válidas</effect>
        </option>
        <option>
	  <flag>--no-all-missing</flag>
	  <effect>Omite observaciones vacías (mira abajo)</effect>
        </option>
        <option>
	  <flag>--contiguous</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--random</flag>
	  <effect>Genera una submuestra aleatoria</effect>
        </option>
        <option>
	  <flag>--permanent</flag>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--preserve-panel</flag>
	  <effect>Datos de panel: mira abajo</effect>
        </option>
        <option>
	  <flag>--unit</flag>
	  <effect>Datos de panel: muestra en la dimensión de sección cruzada</effect>
        </option>
        <option>
	  <flag>--time</flag>
	  <effect>Datos de panel: muestra en la dimensión temporal</effect>
        </option>
        <option>
	  <flag>--dates</flag>
	  <effect>Interpreta los números de observación como fechas</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No muestra el rango muestral</effect>
	      </option>
      </options>
      <examples>
        <example>smpl 3 10</example>
	<example>smpl 1960:2 1982:4</example>
	<example>smpl +1 -1</example>
	<example>smpl x &gt; 3000 --restrict</example>
	<example>smpl y &gt; 3000 --restrict --replace</example>
	<example>smpl 100 --random</example>
      </examples>
    </usage>

    <description>
      <para>
	Esta instrución solo puede utilizarse cuando está preparado un conjunto
	de datos. Cuando no indicas ningún argumento, presenta el rango muestral
	vigente; de outro modo, establece el rango muestral. Puedes definir el
	rango de varias formas. En la primera alternativa (y en los dos primeros
	ejemplos) de arriba, <repl>obsinicio</repl> y <repl>obsfin</repl> deben ser
	consistentes con la periodicidad de los datos. Puedes substituir cualquiera
	de los dos mediante un punto y coma para dejar ese valor sin cambiar. (Para
	más detalles sobre <repl>obsinicio</repl> y <repl>obsfin</repl>, consulta
	la sección titulada <quote>Fechas versus Índices secuenciales</quote>
	más abajo.) En la segunda forma, los números enteros <repl>i</repl> y
	<repl>j</repl> (pueden ser positivos o negativos, y deben tener su
	signo) se consideran como variaciones en relación al rango de la
	muestra existente. En la tercera forma, <repl>varficticia</repl> debe
	ser una variable de señalización con valores 0 o 1 en cada observación;
	así la muestra se va a restringir a las observaciones en las que el
	valor es 1. La cuarta forma, que utiliza <opt>restrict</opt>, restringe
	la muestra a las observaciones que cumplen la condición booleana que
	se indica.
      </para>
      <para>
	Puedes emplear las opciones <opt>no-missing</opt> y <opt>no-all-missing</opt>
	para excluir de la muestra aquellas observaciones para las que hay ausencia
	de datos. La primera variante excluye aquellas filas del conjunto de
	datos para las que, por lo menos una variable, tiene un valor ausente;
	mientras que la segunda variante excluye únicamente aquellas filas
	en las que <emphasis>todas</emphasis> las variables tienen valores
	ausentes. En cada caso, la comprobación se limita a las variables de
	<repl>listavariables</repl> cuando indicas este argumento; de lo contrario,
	se aplica a todas las series (con la reserva de que, en caso de no
	tener <repl>listavariables</repl> e indicar <opt>no-all-missing</opt>,
	las variables genéricas <lit>index</lit> y <lit>time</lit>
	se ignoran).
      </para>
      <para>
	La opción <opt>contiguous</opt> de <lit>smpl</lit> está pensada para
	usar con datos de series temporales. Su efecto consiste en recortar
	cualquier observación al comienzo y al final del rango de la muestra
	vigente que contenga valores ausentes (bien para las variables de
	<repl>listavariables</repl>, o bien para todas las series de datos si
	no indicas <repl>listavariables</repl>). Entonces se realiza una
	verificación para comprobar si hay algún valor ausente en el rango
	que queda; y si es así, se muestra un fallo.
      </para>
      <para>
	Con la opción <opt>random</opt>, el número de casos especificado
	se escoge aleatoriamente del conjunto vigente de datos (sin
	substitución). Si quieres ser capaz de replicar esa selección,
	debes establecer primero la semilla para el generador de números
	aleatorios (consulta la instrucción <cmdref targ="set"/>).
      </para>
      <para>
	La forma final (<lit>smpl full</lit>) restablece el rango completo de
	datos.
      </para>
      <para>
	Ten en cuenta que las restricciones muestrales son, por defecto, acumulativas;
	es decir, el punto de partida de cualquier instrucción <lit>smpl</lit>
	es la muestra vigente. Si quieres que la instrucción actúe substituyendo
	cualquier restricción ya existente, puedes añadir el indicador de opción
	<opt>replace</opt> al final de la instrucción. (Pero esta opción no es
	compatible con la opción <opt>contiguous</opt>.)
      </para>
      <para>
	Puedes utilizar la variable interna <lit>obs</lit> junto con la opción
	<opt>restrict</opt> de <lit>smpl</lit> para excluir observaciones
	concretas de la muestra. Por ejemplo
      </para>
      <code>
	smpl obs!=4 --restrict
      </code>
      <para>
	va a prescindir únicamente de la cuarta observación. Si los casos
	de los datos se identifican mediante etiquetas,
      </para>
      <code>
	smpl obs!="USA" --restrict
      </code>
      <para>va a prescindir de la observación con la etiqueta <quote>USA</quote>.
      </para>
      <para>
	Debe apuntarse una cuestión relacionada con las opciones
	<opt>dummy</opt>, <opt>restrict</opt> y <opt>no-missing</opt> de la
	instrucción <lit>smpl</lit>: la información <quote>estructural</quote>
	del archivo de datos (relacionada con la naturaleza de series de
	tiempo o de panel, de los datos) probablemente se va a perder cuando
	se ejecute esta instrucción; pero puedes volver a imponer la estructura
	con la instrucción <cmdref targ="setobs"/> (consulta también la opción
	<opt>preserve-panel</opt> más abajo).
      </para>

      <subhead>Fechas versus Índices secuenciales</subhead>
      <para>
	Puedes utilizar la opción <opt>dates</opt> para solucionar alguna posible
	ambigüedad al interpretar <repl>obsinicio</repl> y <repl>obsfin</repl>
	en caso de usar datos de series de tiempo anuales. Por ejemplo,
	¿debería considerarse que <lit>2010</lit> se refiere al año 2010, o
	a la dos mil décima observación? En la mayoría de los casos, esto
	debiera salir bien automáticamente, pero puedes forzar la interpretación
	en forma de fecha si lo necesitas. Esta opción también se puede
	utilizar con datos que estén fechados diariamente para lograr que
	<lit>smpl</lit> interprete, por ejemplo, 20100301 como el primero de
	marzo de 2010 en lugar de un índice secuencial corriente. Ten en
	cuenta que esta ambigüedad no aparece con las frecuencias de series
	de tiempo que sean distintas a la anual y a la diaria; fechas como
	1980:3 (tercer trimestre de 1980) y 2020:03 (marzo de 2020) no se
	pueden confundir con índices corrientes.
      </para>

      <subhead>Opciones específicas para datos de panel</subhead>
      <para>
	Las opciones <opt>unit</opt> y <opt>time</opt> son específicas para
	datos de panel. Te permiten indicar, respectivamente, un rango de
	<quote>unidades</quote> o de períodos de tiempo. Por ejemplo:
      </para>
      <code>
	# Limita la muestra a las primeras 50 unidades
	smpl 1 50 --unit
	# Limita la muestra a los períodos de tiempo de 2 a 20
	smpl 2 20 --time
      </code>
      <para>
	Cuando se especifica la dimensión temporal de un conjunto de datos de
	panel por medio de la instrucción <cmdref targ="setobs"/> con la opción
	<opt>panel-time</opt>, la instrucción <lit>smpl</lit> con la opción
	<opt>time</opt> puede expresarse en términos de fechas en lugar de
	números de observación planos. Este es un ejemplo:
      </para>
      <code>
	# Indicar el tiempo de un panel como trimestral, empezando en el primero de 1990
	setobs 4 1990:1 --panel-time
	# Limitar la muestra desde 2000:1 hasta 2007:1
	smpl 2000:1 2007:1 --time
      </code>
      <para>
	En GRETL, un conjunto de datos de panel debe estar siempre
	<quote>teóricamente equilibrado </quote>&mdash;es decir, cada unidad
	debe tener el mismo número de filas de datos, aunque algunas filas
	no contengan más que <lit>NA</lit>s. Extraer una submuestra mediante
	las opciones <opt>restrict</opt> o <opt>dummy</opt> puede destruir esta
	estructura. En tal caso, puedes añadir la opción <opt>preserve-panel</opt>
	para solicitar que se reconstituya un panel teóricamente equilibrado, por
	medio de la inserción de las <quote>filas ausentes</quote> que hagan falta.
      </para>

      <subhead>Establecer la muestra como permanente o provisional</subhead>
      <para>
	Por defecto, puedes deshacer las limitaciones que establezcas sobre el
	rango de la muestra vigente, pues ejecutando <lit>smpl full</lit> puedes
	restaurar el conjunto de datos completo. Sin embargo, puedes utilizar la
	opción <opt>permanent</opt> para sustituir el conjunto de datos
	restringido en lugar del original. El efecto de indicar la opción
	<opt>permanent</opt> sin otros argumentos ni opciones, es el de
	reducir la base de datos al rango de la muestra vigente.
      </para>

      <para>
	Consulta <guideref targ="chap:sampling"/> para obtener otros detalles.
      </para>

    </description>

    <gui-access>
      <menu-path>/Muestra</menu-path>
    </gui-access>

  </command>

  <command name="spearman" section="Statistics"
    label="Correlación por rangos de Spearman">

    <usage>
      <arguments>
        <argument>serie1</argument>
        <argument>serie2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--verbose</flag>
	  <effect>Presenta los datos por rangos</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Presenta el coeficiente de la correlación por rangos de Spearman para
	las series <repl>serie1</repl> y <repl>serie2</repl>. No tienes que
	jerarquizar manualmente las variables por adelantado, pues la función
	ya se ocupa de ello.
      </para>
      <para context="gui">
	Presenta el coeficiente de la correlación por rangos de Spearman para
	un par especificado de series. No tienes que jerarquizar manualmente
	las series por adelantado, pues la función ya se ocupa de ello.
      </para>
      <para>
	La forma automática de jerarquizar es de mayor a menor (&ie; el valor
	más grande de los datos adquiere el rango 1). Si necesitas invertir esta
	forma de jerarquizar, genera una nueva variable que sea la negativa
	de la original. Por ejemplo:
      </para>
      <code>
	series altx = -x
	spearman altx y
      </code>
    </description>

    <gui-access>
      <menu-path>/Herramientas/Contrastes no paramétricos/Correlación</menu-path>
    </gui-access>

  </command>

  <command name="square" section="Transformations"
    label="Generar cuadrados de variables" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--cross</flag>
	  <effect>Genera los productos cruzados así como los cuadrados</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Genera nuevas series que son los cuadrados de las series de <repl>listavariables</repl>
	(además de las variables con los productos cruzados entre cada dos, cuando
	indicas la opción <opt>cross</opt>). Por ejemplo, <cmd>square x y</cmd>
	va a generar las variables <lit>sq_x</lit> = <lit>x</lit> al cuadrado,
	<lit>sq_y</lit> = <lit>y</lit> al cuadrado y (opcionalmente con 'cross')
	<lit>x_y</lit> = <lit>x</lit> por <lit>y</lit>. Cuando una determinada
	variable es una variable ficticia, no se calcula su cuadrado pues
	obtendríamos la misma variable.
      </para>
    </description>

    <gui-access>
      <menu-path>/Añadir/Cuadrados de las variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="stdize" section="Transformations"
    label="Tipificar series">

    <usage>
      <arguments>
        <argument>listavar</argument>
      </arguments>
      <options>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>Sin corrección de grados de libertad</effect>
        </option>
        <option>
	  <flag>--center-only</flag>
	  <effect>Sin dividir por desviación típica</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
	Por defecto, esta instrucción añade al conjunto de datos vigente, nuevas
	series que son versiones tipificadas de las series originales, y que se
	nombran con el prefijo <lit>s_</lit>. Por ejemplo, <lit>s_x</lit> se
	forma restándole la media a <lit>x</lit>, y dividiendo el resultado por
	la desviación típica muestral de <lit>x</lit> (con la corrección de 1,
	en los grados de libertad). Pero puedes elegir que se divida por la
	desviación típica sin ninguna corrección de los grados de libertad,
	es decir, el estimador máximo-verosímil.
      </para>
      <para>
	También dispones de la opción de formar series que son el resultado
	de únicamente centrar las originales (se resta la media, pero no se
	aplica el cambio de escala). En este caso, los nombres de las nuevas
	series tienen el prefijo <lit>c_</lit> en lugar de <lit>s_</lit>.
      </para>
    </description>

    <description context="cli">
      <para>
	Por defecto, se obtiene una versión tipificada de cada una de las
	variables de <repl>listavar</repl>, y cada resultado se guarda
	en una nueva serie con el prefijo <lit>s_</lit>. Por ejemplo, la
	expresión <cmd>stdize x y</cmd> crea las nuevas series <lit>s_x</lit>
	y <lit>s_y</lit>, cada una como resultado de centrar y dividir la
	original por su desviación típica muestral (con la corrección de 1,
	en los grados de libertad).
      </para>
      <para>
	Cuando indicas la opción <opt>no-df-corr</opt>, no se aplica
	ninguna corrección de los graos de libertad en la desviación típica
	que se utiliza; será el estimador máximo-verosímil. Si indicas la
	opción <opt>center-only</opt>, las series resultan de únicamente
	restar la media y, en ese caso, los nombres de las resultantes tendrán
	el prefijo <lit>c_</lit> en lugar de <lit>s_</lit>.
      </para>
      <para>
	La funcionalidad de esta instrucción está disponible de forma en
	cierto modo más flexible, mediante la función <fncref targ="stdize"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Añadir/Tipificar las variables seleccionadas</menu-path>
    </gui-access>

  </command>

  <command name="store" section="Dataset" label="Guardar los datos">

    <usage>
      <arguments>
        <argument>nombrearchivo</argument>
        <argument optional="true">listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--omit-obs</flag>
	  <effect>Mira abajo, sobre el formato CSV</effect>
        </option>
        <option>
	  <flag>--no-header</flag>
	  <effect>Mira abajo, sobre el formato CSV</effect>
        </option>
        <option>
	  <flag>--gnu-octave</flag>
	  <effect>Utiliza el formato GNU Octave</effect>
        </option>
        <option>
	  <flag>--gnu-R</flag>
	  <effect>Formato tratable con read.table</effect>
        </option>
        <option>
	  <flag>--gzipped</flag>
	  <optparm optional="true">nivel</optparm>
	  <effect>Aplica la compresión gzip</effect>
        </option>
        <option>
	  <flag>--jmulti</flag>
	  <effect>Utiliza el formato ASCII JMulti</effect>
        </option>
        <option>
	  <flag>--dat</flag>
	  <effect>Utiliza el formato ASCII PcGive</effect>
        </option>
        <option>
	  <flag>--decimal-comma</flag>
	  <effect>Utiliza la coma como carácter decimal</effect>
        </option>
        <option>
	  <flag>--database</flag>
	  <effect>Utiliza el formato de base de datos de GRETL</effect>
        </option>
        <option>
	  <flag>--overwrite</flag>
	  <effect>Mira abajo, sobre el formato de base de datos</effect>
        </option>
        <option>
	  <flag>--comment</flag>
	  <optparm>cadena</optparm>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nombrematriz</optparm>
	  <effect>Mira abajo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Guarda los datos en <repl>nombrearchivo</repl>. Por defecto, se guardan
	todas las series ya definidas en ese momento, pero puedes utilizar el
	argumento <repl>listavariables</repl> (opcional) para escoger un
	subconjunto de series. Si el conjunto de datos es una submuestra, solo
	se guardan las observaciones del rango vigente de la muestra.
      </para>
      <para>
	El archivo resultante va a escribirse en el directorio (<cmdref targ="workdir"/>)
	establecido en ese momento, excepto que la cadena <repl>nombrearchivo</repl>
	contenga una especificación completa de la ruta.
      </para>
      <para>
	Ten en cuenta que la instrucción <lit>store</lit> se comporta de modo
	especial en el contexto de un <quote>bucle progresivo</quote>; consulta
	<guideref targ="chap:looping"/> para obtener más detalles.
      </para>
      <subhead>Formatos propios</subhead>
      <para>
	Si <repl>nombrearchivo</repl> tiene extensión <lit>.gdt</lit> o
	<lit>.gtdb</lit>, ello implica que se guarden los datos en uno de los
	formatos propios de GRETL. Además, si no indicas una extensión, se
	considera implícitamente la <lit>.gdt</lit>, añadiéndose automáticamente
	este sufijo. El formato <lit>gdt</lit> es de tipo XML, con opción de
	compresión gzip; mientras que el formato <lit>gdtb</lit> es binario. El
	primero se recomienda para conjuntos de datos de tamaño moderado
	(digamos, hasta varios cientos de kilobytes de datos); con el formato
	binario es mucho mayor la velocidad con conjuntos de datos muy grandes.
      </para>
      <para>
	Cuando guardas los datos en formato <lit>gdt</lit>, puedes utilizar la
	opción <opt>gzipped</opt> para comprimirlos. El parámetro (opcional)
	de esta opción controla el nivel de compresión (de 0 a 9): los valores
	mayores generan un archivo más pequeño, pero la compresión lleva
	más tiempo. El nivel por defecto es el 1; y un nivel de 0 significa
	que no se aplica ninguna compresión.
      </para>
      <para>
	Se admite un tipo especial de guardado <quote>propio</quote> en el
	programa de interfaz GUI: si <repl>nombrearchivo</repl> tiene extensión
	<lit>.gretl</lit> y omites el argumento <repl>listavariables</repl>,
	entonces se graba un archivo de sesión de GRETL. Este tipo de archivos
	incluyen el conjunto de datos vigente junto con cualesquiera objetos que
	tengan nombre, como modelos, gráficos y matrices.
      </para>
      <subhead>Otros formatos</subhead>
      <para>
	Hasta cierto punto, puedes controlar el formato en el que se escriben los
	datos mediante la extensión o sufijo de <repl>nombrearchivo</repl>,
	como se indica a continuación:
      </para>
      <ilist>
	<li>
	  <para>
	    <lit>.csv</lit>: Valores Separados por Comas (CSV).
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.txt</lit> o <lit>.asc</lit>: valores separados por
	    espacios.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.m</lit>: Formato matricial GNU Octave.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>.dta</lit>: Formato dta de Stata (versión 113).
	  </para>
	</li>
      </ilist>
      <para>
	Puedes usar los indicadores de opción relacionados con el formato mostrados
	arriba para forzar la elección del formato, con independencia del nombre del
	archivo (o para lograr que GRETL escriba en los formatos de PcGive o JMulTi).
      </para>
      <subhead>Opciones CSV</subhead>
      <para>
	Los indicadores de opción <opt>omit-obs</opt> y <opt>no-header</opt>
	son específicos para guardar datos en el formato CSV. Por defecto,
	si los datos son series temporales o de panel, o si el conjunto de
	datos incluye marcadores específicos de observación, el archivo resultante
	incluye una primera columna que identifica las observaciones (&eg; por fecha).
	Cuando indicas la opción <opt>omit-obs</opt>, esta columna se omite. La
	opción <opt>no-header</opt> elimina la habitual representación de los
	nombres de las variables en el encabezamiento de las columnas.
      </para>
      <para>
	El indicador de opción <opt>decimal-comma</opt> está también limitado
	a CSV. Su efecto consiste en substituir el punto decimal con la coma
	decimal; y, por añadido, se fuerza a que el separador de columnas
	sea el punto y coma, en lugar de la coma.
      </para>
      <subhead>Guardar en una base de datos</subhead>
      <para>
	La posibilidad de guardar en el formato de base de datos de GRETL
	está pensada construir conjuntos largos de series, con mezclas de
	frecuencias y rangos de observaciones. En este momento, esta opción
	solo está disponible para datos de series temporales de tipo anual,
	trimestral o mensual, o para datos sin fecha (de sección cruzada).
	Una base de datos de GRETL toma la forma de dos archivos: uno con
	sufijo <lit>.bin</lit> para guardar los datos en formato binario, y un
	archivo de texto plano con el sufijo <lit>.idx</lit> para los metadatos.
	Para indicar el nombre del archivo de salida en la linea de instrucciones,
	debes indicar el sufijo <lit>.bin</lit> o no indicar ninguno.
      </para>
      <para>
	Si se guarda en una base de datos que ya existe, el efecto por defecto
	consiste en añadir series al contenido existente en la base de datos. En
	este contexto, es un fallo que alguna de las series que se van a guardar
	tenga el mismo nombre que alguna que ya está presente en la base de datos.
	La opción <opt>overwrite</opt> tiene como efecto que, si hay nombres de
	variables en común, los datos recientemente guardados sustituyen a los valores previos.
      </para>
      <para>
	La opción <opt>comment</opt> está disponible cuando se guardan datos como
	base de datos o como CSV. El parámetro que se requiere es una
	cadena en una línea, entre comillas, ligada al indicador de opción mediante
	un signo de igualdad. La cadena de texto se inserta como comentario en el
	archivo índice de la base de datos o en el encabezamiento del CSV.
      </para>
      <subhead>Escribir una matriz como conjunto de datos</subhead>
      <para>
	La opción <opt>matriz</opt> necesita un parámetro: el nombre de una
	matriz (que no esté vacía). Entonces la consecuencia de la instrucción
	<lit>store</lit> es efectivamente convertir la matriz en un conjunto de
	datos <quote>en segundo plano</quote>, y escribirlo como tal en un archivo.
	Las columnas de la matriz pasan a ser series cuyos nombres se toman de
	los nombres adyacentes a las columnas de la matriz (si los hay), o bien
	se asignan por defecto como <lit>v1</lit>, <lit>v2</lit>, etc. Si la matriz
	tiene nombres adyacentes a las filas, estos se utilizan en el conjunto
	de datos como <quote>etiquetas de las observaciones</quote>.
      </para>
      <para>
	Ten en cuenta que puedes escribir las matrices como tales en archivos,
	consulta para ello la función <fncref targ="mwrite"/>. Pero a veces te
	puede resultar útil escribirlas en forma de conjuntos de datos.
      </para>
    </description>

    <gui-access>
      <menu-path>/Archivo/Guardar datos; /Archivo/Exportar datos</menu-path>
    </gui-access>

  </command>

  <command name="summary" section="Statistics"
    label="Estadísticas descriptivas" context="cli">

    <usage>
      <altforms>
	<altform><lit>summary [</lit> <repl>listavariables</repl> ]</altform>
	<altform><lit>summary --matrix=</lit><repl>nombrematriz</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--simple</flag>
	  <effect>Solo estadísticos básicos</effect>
        </option>
        <option>
	  <flag>--weight</flag>
	  <optparm>wtvar</optparm>
	  <effect>Variable de ponderación</effect>
        </option>
        <option>
	  <flag>--by</flag>
	  <optparm>byvar</optparm>
	  <effect>Mira abajo</effect>
        </option>
      </options>
	  <examples>
	<demos>
	  <demo>frontier.inp</demo>
	</demos>
	  </examples>
    </usage>

    <description>
      <para>
	En su primera forma, esta instrucción presenta un resumen estadístico
	de las variables de <repl>listavariables</repl>, o de todas las variables
	del conjunto de datos cuando omites <repl>listavariables</repl>. Por
	defecto, el resultado consiste en la media, mediana, mínimo, máximo,
	desviación típica (sd), coeficiente de variación (= sd/media),
	coeficiente de asimetría, exceso de curtosis, percentiles del 5% y 95%,
	rango intercuartílico y número de observaciones ausentes. Pero
	cuando indicas la opción <opt>simple</opt>, el resultado se limita
	a la media, la mediana, la desviación típica, el mínimo y el
	máximo.
      </para>
      <para>
	Si indicas la opción <opt>weight</opt>, en cuyo caso el parámetro
	<repl>wvar</repl> debería ser el nombre de una serie que ofrezca
	las ponderaciones de cada observación, los estadísticos se ponderan
	de acuerdo con ello.
      </para>
      <para>
	Cuando indicas la opción <opt>by</opt>, en cuyo caso el parámetro
	<repl>byvar</repl> debe ser el nombre de una variable discreta,
	entonces se presentan los estadísticos para las submuestras que se
	corresponden con los diferentes valores que toma <repl>byvar</repl>.
	Por ejemplo, cuando <repl>byvar</repl> es una variable ficticia
	(binaria), se presentan los estadísticos para los casos en los que
	<lit>byvar=0</lit> y <lit>byvar=1</lit>. Advertencia: En este
	momento, esta opción es incompatible con la opción
	<opt>weight</opt>.
      </para>
      <para>
	Cuando indicas la forma alternativa, utilizando una matriz ya definida,
	entonces se presenta el resumen estadístico para cada columna de la matriz.
	En este caso, la opción <opt>by</opt> no está disponible.
      </para>
      <para>
	Puedes obtener, en forma de matriz, la tabla de estadísticos
	generada con la instrucción <lit>summary</lit>, por medio del
	accesor <fncref targ="$result"/>. Cuando indiques la opción
	<opt>by</opt>, se genera el efecto de este acceso unicamente si
	<repl>varlist</repl> contiene una única serie.
      </para>
      <para>
	Consulta también la función <fncref targ="aggregate"/> para ver
	otras formas más flexibles de producción de estadísticos
	<quote>factorizados</quote>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Estadísticos principales</menu-path>
      <other-access>Ventana principal: Menú emergente</other-access>
    </gui-access>

  </command>

  <command name="system" section="Estimation" label="Sistemas de ecuaciones">

    <usage>
      <altforms>
	<altform><lit>system method=</lit><repl>estimador</repl></altform>
	<altform><repl>sysname</repl><lit> &lt;- system</lit></altform>
      </altforms>
      <examples>
	<example>"Klein Model 1" &lt;- system</example>
        <example>system method=sur</example>
	<example>system method=3sls</example>
	<demos>
	  <demo>klein.inp</demo>
	  <demo>kmenta.inp</demo>
	  <demo>greene14_2.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>

      <para context="gui">
	En esta ventana puedes definir un sistema de ecuaciones y escoger un
	estimador para el sistema. Aquí puedes indicar 4 tipos de enunciado,
	como los siguientes:
      </para>

      <para context="cli">
	Empieza un sistema de ecuaciones. Puedes indicar una de las dos
	formas de la instrucción, dependiendo de si quieres guardar el sistema
	para estimarlo de varias formas, o solo estimar el sistema una vez.
	    </para>

      <para context="cli">
	Para guardar el sistema debes asignarle un nombre como en el primer
	ejemplo (si el nombre contiene espacios, debes delimitarlo con
	comillas). En este caso, se estima el sistema utilizando la instrucción
	<cmdref targ="estimate"/>. Con un sistema de ecuaciones ya guardado,
	puedes imponer restricciones (incluidas restricciones entre ecuaciones)
	utilizando la instrucción
	<cmdref targ="restrict"/>.
      </para>

      <para context="cli">
	Como alternativa, puedes especificar un estimador para el sistema
	utilizando <lit>method=</lit> seguido de una cadena que identifique
	uno de los estimadores admitidos: <cmd>ols</cmd> (Mínimos Cuadrados
	Ordinarios), <cmd>tsls</cmd> (Mínimos Cuadrados en 2 Etapas)
	<cmd>sur</cmd> (Regresiones Aparentemente No Relacionadas),
	<cmd>3sls</cmd> (Mínimos Cuadrados en 3 Etapas), <cmd>fiml</cmd>
	(Máxima Verosimilitud con Información Total) o <cmd>liml</cmd>
	(Máxima Verosimilitud con Información Limitada). En este caso, el
	sistema se estima una vez que esté completa su definición.
      </para>

      <para context="cli">
	Un sistema de ecuaciones se termina con la línea <cmd>end system</cmd>. Dentro
	del sistema pueden indicarse 4 tipos de enunciado, como los siguientes.
      </para>

      <ilist>
	<li><para><cmdref targ="equation"/>: Especifica una ecuación del sistema.
	    </para>
	</li>
	<li><para><cmd>instr</cmd>: Para estimar un sistema mediante
	    Mínimos Cuadrados en 3 etapas, se indica una lista de instrumentos
	    (mediante el nombre de la variable o su número). Alternativamente,
	    puedes poner esta información en la línea <cmd>equation</cmd> usando
	    la misma sintaxis que en la instrucción <cmdref targ="tsls"/>.
	    </para>
	</li>
	<li><para><cmd>endog</cmd>: Para un sistema de ecuaciones simultáneas,
	    se indica una lista de variables endógenas. En principio, esto está
	    pensado para utilizar con la estimación FIML, pero puedes utilizar este
	    enfoque con Mínimos Cuadrados en 3 Etapas en lugar de indicar
	    una lista <cmd>instr</cmd>; y entonces todas las variables que no se
	    identifiquen como endógenas, se van a utilizar como instrumentos.
	    </para>
	</li>
	<li><para><cmd>identity</cmd>: Para utilizar con Máxima Verosimilitud
	    con Información Completa (MVIC, FIML), se indica una identidad que
	    enlaza dos o más variables del sistema. Este tipo de enunciado se
	    ignora cuando se utiliza un estimador diferente al de MVIC.
	  </para>
	</li>
      </ilist>
	
      <para context="cli">
	Después de hacer la estimación utilizando las instrucciones <cmd>system</cmd>
	o <cmd>estimate</cmd>, puedes usar los siguientes accesores para recoger
	información adicional:
      </para>

      <ilist context="cli">
	<li><para><lit>$uhat</lit>: Matriz con los errores de estimación, con una
	    columna por ecuación.
	  </para>
	</li>
	<li><para><lit>$yhat</lit>: Matriz con los valores ajustados, con una
	    columna por ecuación.
	  </para>
	</li>
	<li><para><lit>$coeff</lit>: Vector columna con los coeficientes de las
	    ecuaciones (todos los coeficientes de la primera ecuación, seguidos
	    por los de la segunda ecuación, etcétera).
	  </para>
	</li>
	<li><para><lit>$vcv</lit>: Matriz con las covarianzas entre los coeficientes.
	    Cuando hay <math>k</math> elementos en el vector <lit>$coeff</lit>,
	    esta matriz tiene una dimensión de <math>k</math> por
	    <math>k</math>.
	  </para>
	</li>
	<li><para><lit>$sigma</lit>: Matriz con las covarianzas entre los errores
	de estimación de las ecuaciones cruzadas.
	  </para>
	</li>
	<li><para><lit>$sysGamma</lit>, <lit>$sysA</lit> y <lit>$sysB</lit>:
	    Matrices con los coeficientes en la forma estructural (mira abajo).
	  </para>
	</li>
      </ilist>

      <para context="cli">
	Si quieres recuperar los errores de estimación o los valores ajustados
	para una ecuación en concreto, en forma de serie de datos, escoge
	una columna de la matriz <lit>$uhat</lit> o <lit>$yhat</lit>, y asígnale
	la serie como en
      </para>
      <code context="cli">
	series uh1 = $uhat[,1]
      </code>

      <para context="cli">
	Las matrices en la forma estructural se corresponden con la siguiente representación
	de un modelo de ecuaciones simultáneas:
	<equation status="display"
	  tex="\[\Gamma y_t=Ay_{t-1}+Bx_t+\epsilon_t\]"
    ascii="Gamma y(t) = A y(t-1) + B x(t) + e(t)"
    graphic="structural"/>
	Si hay <math>n</math> variables endógenas y <math>k</math> variables
	exógenas, &Gamma; es una matriz de dimensión <by r="n" c="n"/> y
	<math>B</math> es <by r="n" c="k"/>. Cuando el sistema no contiene
	ningún retardo de las variables endógenas, entonces la matriz <math>A</math>
	no está presente. Si el retardo máximo de un regresor endógeno es
	<math>p</math>, la matriz <math>A</math> es de dimensión
	<by r="n" c="np"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modelo/Ecuaciones simultáneas</menu-path>
    </gui-access>

  </command>

  <command name="tabprint" section="Printing"
    label="Presentar el modelo en formato de tabla" context="cli">

    <usage>
      <options>
        <option>
	  <flag>--output</flag>
	  <optparm>nombrearchivo</optparm>
	  <effect>Envía el resultado al archivo especificado</effect>
        </option>
        <option>
	  <flag>--format="f1|f2|f3|f4"</flag>
	  <effect>Especifica el formato TeX personalizado</effect>
        </option>
	<option>
	  <flag>--complete</flag>
	  <effect>Relacionado con TeX, mira abajo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Debe ir después de la estimación de un modelo y presenta ese
	modelo en formato de tabla. El formato se rige por la extensión
	del <repl>nombrearchivo</repl> especificado:
	<quote><lit>.tex</lit></quote> para &latex;,
	<quote><lit>.rtf</lit></quote> para RTF (Microsoft's Rich Text
	Format) o <quote><lit>.csv</lit></quote> para el formato con
	separación mediante comas. El archivo resultante va a escribirse
	en el directorio vigente (<cmdref targ="workdir"/>), excepto que la cadena
	<repl>nombrearchivo</repl> contenga una especificación completa de la ruta.
      </para>
      <para>
	Cuando seleccionas el formato CSV, los valores se separan con comas
	excepto que la coma decimal esté en vigor, en cuyo caso el separador
	es el punto y coma.
      </para>
      <subhead>Opciones específicas de resultados en &latex;</subhead>
      <para>
	Cuando indicas la opción <opt>complete</opt>, el archivo &latex;
	es un documento completo, listo para procesar; de lo contrario, debe
	incluirse en un documento.
      </para>
      <para>
	Si quieres modificar la apariencia del resultado tabular, puedes
	especificar un formato personalizado en filas utilizando la opción
	<opt>format</opt>. La cadena de formato debe estar puesta entre
	comillas y debe estar ligada a la opción con un signo de igualdad. El
	patrón para las cadenas de formato es el siguiente. Existen 4 campos que
	representan: el coeficiente, la desviación típica, el ratio <math>t</math>
	y la probabilidad asociada, respectivamente. Debes separar estos
	campos mediante barras verticales; y, o bien pueden tener una especificación
	de tipo <lit>printf</lit> para el formato del valor numérico en cuestión,
	o bien pueden dejarse en blanco para eliminar la presentación de esa
	columna (sujeto esto a la condición de que no puedes dejar todas las
	columnas en blanco). Aquí tienes unos pocos ejemplos:
      </para>
      <code>
	--format="%.4f|%.4f|%.4f|%.4f"
	--format="%.4f|%.4f|%.3f|"
	--format="%.5f|%.4f||%.4f"
	--format="%.8g|%.8g||%.4f"
      </code>
      <para>
	La primera de estas especificaciones presenta los valores de todas las
	columnas usando 4 dígitos decimales. La segunda elimina la probabilidad
	asociada y presenta las razones <math>t</math> con 3 dígitos decimales.
	La tercera omite el ratio <math>t</math>. La última también omite el
	<math>t</math>, y presenta tanto el coeficiente como la desviación
	típica con 8 cifras significativas.
      </para>
      <para>
	Una vez que estableces un formato personalizado de este modo,
	este se recuerda y se utiliza a lo largo de lo que dure la sesión de GRETL.
	Para revertir esto al formato por defecto, puedes utilizar la variante
	especial <opt>format=default</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>Ventana de modelo: LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="tdisagg" section="Dataset" context="gui"
    label="Desagregación temporal">

    <description>
      <para>
	Aquí tienes un repaso de las opciones disponibles en el cuadro de
	diálogo de la desagregación temporal. Para obtener una explicación
	detallada, consulta <guideref targ="chap:tdisagg"/>.
      </para>
      <ilist>
	<li>
	  <para>
	    Nombre del resultado: Puedes elegir entre sobrescribir una serie
	    ya existente con la versión desagregada, o dar un nuevo nombre
	    al resultado.
	  </para>
	</li>
	<li>
	  <para>
	    Tipo de agregación: Escoge <lit>sum</lit> si la suma de los valores
	    de alta frecuencia debe resultar igual al valor de baja frecuencia
	    proporcionado (ej. flujos como el PIB y sus componentes).
	    Elige <lit>avg</lit> si la media de los valores de alta frecuencia
	    debe resultar igual al valor de baja frecuencia proporcionado
	    (ej. índices, cocientes, o flujos <quote>en tasas anuales</quote>).
	    Opta por <lit>last</lit> o <lit>first</lit> si el último o el
	    primer valor de alta frecuencia debe ser igual al valor de
	    baja frecuencia (como puede ser el caso de las variables de
	    stock, como la cantidad de dinero).
	  </para>
	</li>
	<li>
	  <para>
	    Basado en regresión frente a Denton: En general, se recomienda el
	    primero. Si escoges <quote>Basado en regresión</quote>, vas a
	    poder seleccionar el método de Fernández si piensas que la serie
	    en cuestión tiene una raíz unitaria; en caso contrario, opta por
	    Chow&ndash;Lin. Si escoges Denton, se asume que sabes lo que
	    estás haciendo pues los métodos Denton son en primeras diferencias,
	    tal como los modificó Cholette.
	  </para>
	</li>
      </ilist>
    </description>
  </command>

  <command name="textplot" section="Graphs"
    label="Gráfico ASCII" context="cli">

    <usage>
      <arguments>
        <argument>listavariables</argument>
      </arguments>
      <options>
        <option>
	  <flag>--time-series</flag>
	  <effect>Gráfico por observación</effect>
        </option>
        <option>
	  <flag>--one-scale</flag>
	  <effect>Fuerza una escala única</effect>
        </option>
        <option>
	  <flag>--tall</flag>
	  <effect>Usa 40 filas</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Gráficos ASCII rápidos y sencillos. Sin la opción <opt>time-series</opt>,
	<repl>listavariables</repl> debe contener al menos 2 series, la última
	de ellas se toma como la variable para el eje <math>x</math>, y se genera un
	gráfico de dispersión. En este caso, puedes utilizar la opción <opt>tall</opt>
	para generar un gráfico en la que el eje <math>y</math> se representa
	mediante 40 filas de caracteres (por defecto son 20 filas).
      </para>
      <para>
	Con la opción <opt>time-series</opt>, se genera un gráfico por observación.
	En este caso, puedes utilizar la opción <opt>one-scale</opt> para forzar el
	uso de una escala única; de lo contrario, si <repl>listavariables</repl>
	contiene más de una serie, los datos pueden escalarse. Cada línea representa
	una observación, con los valores de los datos dibujados horizontalmente.
      </para>
      <para>
	Consulta también <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>


  <command name="tobit" section="Estimation" label="Modelo Tobit">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--llimit</flag>
	  <optparm>cotaizq</optparm>
	  <effect>Especifica la cota de la izquierda</effect>
        </option>
        <option>
	  <flag>--rlimit</flag>
	  <optparm>cotader</optparm>
	  <effect>Especifica la cota de la derecha</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
        <option>
	  <flag>--opg</flag>
	  <effect>Mira más abajo</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Consulta <cmdref targ="logit"/> para más explicaciones</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>Presenta los detalles de las iteraciones</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	      </option>
      </options>
    </usage>

    <description>
      <para>
	Estima un modelo Tobit, que puede ser lo adecuado cuando la variable
	dependiente está <quote>censurada</quote>. Por ejemplo, cuando se
	observan valores positivos y nulos en la adquisición de bienes duraderos
	por parte de los hogares, y ningún valor negativo, puede llegar a pensarse
	que las decisiones sobre esas compras son el resultado de una disposición
	subyacente e inobservada a comprar, que puede ser negativa en algunos
	casos.
      </para>
      <para context="cli">
	Por defecto, se asume que la variable dependiente está 'censurada'
	en el cero por la izquierda, y que no está 'censurada' por la derecha.
	Sin embargo, puedes usar las opciones <opt>llimit</opt> y <opt>rlimit</opt>
	para especificar un patrón diferente para hacer la 'censura'. Ten
	en cuenta que si especificas únicamente una cota por la derecha,
	entonces lo que se supone es que la variable dependiente no está
	'censurada' por la izquierda.
      </para>
      <para context="gui">
	Por defecto, se asume que la variable dependiente está 'censurada' en el
	cero por la izquierda, y que no está 'censurada' por la derecha. Sin embargo,
	puedes usar las cajas de anotación marcadas <quote>Cota izquierda</quote>
	y <quote>Cota derecha</quote> para especificar un patrón diferente
	de censura. Introduce un valor numérico o <lit>NA</lit> para no
	hacer censura.
      </para>
      <para>
	El modelo Tobit es un caso especial de la regresión de intervalos.
	Consulta la instrucción <cmdref targ="intreg"/> para obtener detalles
	adicionales, incluída una explicación de las opciones <opt>robust</opt>
	y <opt>opg</opt>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Variable dependiente limitada/Tobit</menu-path>
    </gui-access>

  </command>

  <command name="transpos" section="Dataset" label="Trasponer los datos"
    context="gui">

    <description>
      <para>
	Transpone el conjunto vigente de datos. Es decir, cada observación (fila)
	del conjunto vigente de datos se va a tratar como una variable (columna),
	y cada variable como una observación. Esta instrucción puede resultar
	útil cuando se leen los datos de algún origen externo, en el que las filas
	de la tabla de datos representan variables.
      </para>
      <para>
	Consulta también <cmdref targ="dataset"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Datos/Transponer datos</menu-path>
    </gui-access>

  </command>

  <command name="tsls" section="Estimation"
    label="Regresión con Variables Instrumentales">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	      <argument separated="true">instrumentos</argument>
      </arguments>
      <options>
        <option>
	  <flag>--no-tests</flag>
	  <effect>No hace contrastes de diagnóstico</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
	      <option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
	      </option>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>Sin corrección de los grados de libertad</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
        <option>
	  <flag>--cluster</flag>
	  <optparm>clustvar</optparm>
	  <effect>Desviaciones típicas agrupadas</effect>
        </option>
        <option>
	  <flag>--matrix-diff</flag>
	  <effect>Calcula el contraste de Hausman mediante diferencia de matrices</effect>
        </option>
        <option>
	  <flag>--liml</flag>
	  <effect>Utiliza Máxima Verosimilitud con Información Limitada</effect>
        </option>
        <option>
	  <flag>--gmm</flag>
	  <effect>Utiliza el Método Generalizado de los Momentos</effect>
        </option>
      </options>
      <examples>
        <example>tsls y1 0 y2 y3 x1 x2 ; 0 x1 x2 x3 x4 x5 x6</example>
	<demos>
		<demo>penngrow.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Calcula las estimaciones de Variables Instrumentales (VI), utilizando por
	defecto Mínimos Cuadrados en 2 Etapas (TSLS), pero mira más abajo para
	otras opciones. La variable dependiente es <repl>depvar</repl>, mientras
	que <repl>indepvars</repl> expresa una lista de regresores (se presupone
	que incluye al menos una variable endógena), e <repl>instrumentos</repl>
	indica una lista de instrumentos (variables exógenas y/o predeterminadas).
	Si la lista <repl>instrumentos</repl> no es al menos tan larga como
	<repl>indepvars</repl>, el modelo no está identificado.
      </para>

      <para context="cli">
	En el ejemplo de arriba, las <lit>y</lit>s son las variables endógenas y
	las <lit>x</lit>s son las variables exógenas. Ten en cuenta que los
	regresores exógenos deben aparecer en ambas listas.
      </para>
      <para context="cli">
	Para obtener más detalles en relación a los efectos de las opciones
	<opt>robust</opt> y <opt>cluster</opt>, consulta la ayuda para
	<cmdref targ="ols"/>.
      </para>

      <para context="gui">
	La instrucción requiere que se seleccionen 2 listas de variables:
	las variables independientes que aparecen en el modelo indicado y
	un conjunto de instrumentos. Ten en cuenta que cualquier regresor
	exógeno debe aparecer en ambas listas.
      </para>
      <subhead>Contrastes específicos para MC2E</subhead>
      <para>
	El resultado de las estimaciones de Mínimos Cuadrados en 2 Etapas incluyen
	el contraste de Hausman y (si el modelo está sobreidentificado) el contraste de
	sobreidentificación de Sargan. Para una buena explicación de los dos
	contrastes, consulta el capítulo 8 de
	<cite key="davidson-mackinnon04">Davidson y MacKinnon (2004)</cite>.
      </para>
      <para>
	En el contraste de Hausman, la hipótesis nula es que las estimaciones
	MCO son consistentes o, en otras palabras, que la estimación por
	medio de variables instrumentales en realidad no es necesaria. Por
	defecto, este contraste se aplica por el método de regresión pero si
	indicas la opción <opt>matrix-diff</opt> se utiliza el método de
	<cite key="papadopoulos23">Papadopoulos (2023)</cite>. En ambos
	casos puedes emplear una variante robusta si indicas la opción
	<opt>robust</opt>.
      </para>
      <para>
	Un modelo de este tipo está sobreidentificado si hay más instrumentos
	de los estrictamente requeridos. El contraste de sobreidentificación
	de Sargan <cite key="sargan58" p="true">(Sargan, 1958)</cite> se
	basa en una regresión auxiliar de los errores de la estimación del
	modelo, mediante Mínimos Cuadrados en 2 Etapas sobre la lista
	completa de instrumentos. La hipótesis nula sostiene que todos los
	instrumentos son válidos; pero se sospecha de la validez de esta
	hipótesis si la regresión auxiliar tiene un grado de poder explicativo
	que es significativo. 
      </para>
      <para>
	Estos estadísticos están disponibles luego de la conclusión satisfactoria
	de la instrucción, con los nombres <fncref targ="$hausman"/> y
	<fncref targ="$sargan"/> (si es aplicable), respectivamente.
      </para>
      <subhead>Instrumentos débiles</subhead>
      <para>
	Tanto para MC2E (TSLS) como para la estimación MVIL (LIML), se muestra
	el resultado de un contraste adicional, puesto que el modelo se estima bajo
	el supuesto de perturbaciones IID (es decir, no se escoge la opción
	<opt>robust</opt>). Este es un contraste de la debilidad de los instrumentos,
	pues instrumentos débiles pueden llevar a serios problemas en la regresión
	de VI: estimaciones sesgadas y/o tamaño incorrecto de los contrastes de
	hipótesis basados en la matriz de covarianzas, con tasas de rechazo
	que superan mucho el nivel de significación nominal
	<cite key="stock-wright-yogo02" p="true">(Stock, Wright y Yogo, 2002)</cite>.
	El estadístico es el del contraste <math>F</math> de la primera etapa si el
	modelo tiene tan solo un regresor endógeno; de lo contrario, es el valor
	propio más pequeño de la matriz de contrapartida del <math>F</math> de la
	primera etapa. Se muestran los puntos críticos basados en el análisis Monte
	Carlo de <cite key="stock-yogo03">Stock y Yogo (2003)</cite>, cuando
	estén disponibles.
      </para>
      <subhead>R-cuadrado</subhead>
      <para>
	El valor de R-cuadrado que se presenta para modelos estimados mediante
	Mínimos Cuadrados en 2 Etapas es el cuadrado de la correlación entre la variable
	dependiente y la variable con los valores ajustados.
      </para>
      <subhead>Estimadores alternativos</subhead>
      <para context="cli">
	Como alternativas a MC2E, el modelo puede estimarse mediante Máxima
	Verosimilitud con Información Limitada (opción <opt>liml</opt>) o
	mediante el Método Generalizado de los Momentos (opción <opt>gmm</opt>).
	Ten en cuenta que, si el modelo está simplemente identificado, estos
	métodos deberían generar los mismos resultados que MC2E; pero si está
	sobreidentificado, los resultados en general van a diferir.
      </para>

      <para context="cli">
	Cuando se escoge la estimación MGM (GMM), las siguientes opciones
	adicionales pasan a estar disponibles:
      </para>

      <ilist context="cli">
	<li>
	  <para>
	    <opt>two-step</opt>: Realiza MGM en 2 etapas en lugar de hacerlo
	    en 1 etapa (por defecto).
	  </para>
	</li>
	<li>
	  <para>
	    <opt>iterate</opt>: Reitera MGM hasta la convergencia.
	  </para>
	</li>
	<li>
	  <para>
	    <opt>weights=</opt><repl>Wmat</repl>: Especifica una matriz cuadrada de
	    ponderaciones para utilizar cuando se calcula la función del criterio MGM.
	    La dimensión de esta matriz debe ser igual al número de instrumentos.
	    Por defecto, es una matriz identidad de dimensión adecuada.
	  </para>
	</li>
      </ilist>

    </description>

    <gui-access>
      <menu-path>/Modelo/Variables instrumentales</menu-path>
    </gui-access>

  </command>

  <command name="tsplots" section="Graphs"
	   label="Gráficos de múltiples series temporales">
    <usage>
      <arguments>
        <argument>listavar</argument>
      </arguments>
      <options>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nombre</optparm>
	  <effect>Representa las columnas de la matriz citada</effect>
        </option>
        <option>
	  <flag>--output</flag>
	  <optparm>nombrearch</optparm>
	  <effect>Envía el resultado al archivo indicado</effect>
        </option>
      </options>
      <examples>
        <example>tsplots 1 2 3 4</example>
        <example>tsplots 1 2 3 4 --matrix=X</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Proporciona un modo sencillo de representar gráficamente múltiples series
	temporales (hasta un máximo de 16) en un único cuadro. Puedes indicar el
	argumento <repl>listavar</repl> como una lista de números ID (o de nombres
	de series), o como números de columnas en caso de introducir una matriz.
      </para>
      <para context="cli">
	Consulta también <cmdref targ="scatters"/> para ver formas de generar
	múltiples gráficos de dispersión, y <cmdref targ="gridplot"/> para ver
	un modo más flexible de combinar gráficos en una parrilla.
      </para>
      <para context="gui">
	Proporciona un modo sencillo de representar gráficamente múltiples series
	temporales (hasta un máximo de 16) en un único cuadro. Consulta también
	<cmdref targ="scatters"/> para ver formas de generar múltiples gráficos
	de dispersión, y <cmdref targ="gridplot"/> para ver un modo más flexible
	de combinar gráficos en una parrilla.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Gráficos múltiples/Series temporales</menu-path>
    </gui-access>
  </command>

  <command name="var" section="Estimation"
    label="Autorregresión de vectores (VAR)">

    <usage>
      <arguments>
        <argument>orden</argument>
        <argument>ylista</argument>
	      <argument separated="true" optional="true">xlista</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>Sin constante</effect>
        </option>
        <option>
	  <flag>--trend</flag>
	  <effect>Con tendencia lineal</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>Con variables ficticias estacionales</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
        <option>
	  <flag>--robust-hac</flag>
	  <effect>Desviaciones típicas HAC</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>No muestra los resultados de las ecuaciones individuales</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>Presenta las respuestas al impulso</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>Presenta las descomposiciones de la varianza</effect>
        </option>
        <option>
	  <flag>--lagselect</flag>
	  <effect>Muestra los criterios de selección de retardos</effect>
        </option>
        <option>
	  <flag>--minlag</flag>
	  <optparm>retardo mínimo</optparm>
	  <effect>Solo selección de retardo, mira abajo</effect>
        </option>
      </options>
      <examples>
        <example>var 4 x1 x2 x3 ; time mydum</example>
	<example>var 4 x1 x2 x3 --seasonals</example>
	<example>var 12 x1 x2 x3 --lagselect</example>
	<demos>
	  <demo>sw_ch14.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Esta instrucción requiere la especificación de:
      </para>
      <ilist context="gui">
	<li><para context="gui">el orden de retardos, es decir, el número de
	    retardos de cada variable que debería de incluirse en el sistema;
	    </para>
	</li>
	<li><para context="gui">cualquier variable exógena (pero ten en cuenta que se incluye
	    una constante automáticamente, excepto que indiques otra cosa; puedes añadir
	    una tendencia usando el recuadro de selección de tendencia; y puedes añadir
	    variables ficticias estacionales usando el recuadro de selección de la estacionalidad); y
	    </para>
	</li>
	<li><para context="gui">una lista de variables endógenas, de las que se incluyen
	    sus retardos en el lado derecho de cada ecuación. (Nota: No incluyas
	    variables retardadas en esta lista, pues se van a añadir automáticamente).
	    </para>
	</li>
      </ilist>
      <para context="gui">
	Se va a ejecutar una regresión por separado para cada variable del sistema.
	El resultado para cada ecuación incluye los contrastes F de restricciones cero
	sobre todos los retardos de cada una de las variables; y un contraste F para
	el retardo máximo, junto con (opcionalmente) las descomposiciones de la
	varianza de predicción y las funciones de respuesta al impulso.
      </para>
      <para context="cli">
	Establece y estima (utilizando MCO) una autorregresión de vectores
	(VAR). El primer argumento especifica el orden de retardos (o
	el orden máximo de retardos, en caso de que indiques la opción
	<opt>lagselect</opt>, mira más abajo). El orden puedes indicarlo
	numéricamente o con el nombre de una variable escalar preexistente.
	A continuación sigue la configuración de la primera ecuación. No
	incluyas retardos entre los elementos de <repl>ylista</repl> pues
	se van a añadir automáticamente. El punto y coma va a separar las
	variables estocásticas (para las que se va a incluir un
	<repl>orden</repl> de retardos) de cualquier variable exógena de
	<repl>xlista</repl>. Ten en cuenta que: (a) se incluye una constante
	automáticamente (excepto que indiques la opción <opt>nc</opt>),
	(b) puedes añadir una tendencia con la opción <opt>trend</opt>,
	y (c) puedes añadir variables ficticias estacionales utilizando la
	opción <opt>seasonals</opt>.
      </para>
      <para context="cli">
	Mientras que una especificación VAR habitualmente incluye todos los
	retardos desde 1 hasta el máximo que indiques, también puedes escoger un
	grupo de retardos. Para hacer esto, substituye el argumento rutinario
	<repl>orden</repl> (escalar), bien con el nombre de un vector ya definido
	previamente, o bien con una lista de retardos separados con comas y
	colocada entre llaves. Debajo se muestran dos modos de especificar
	que un VAR debe incluir los retardos 1, 2 y 4 (pero no el 3):
      </para>
      <code context="cli">
	var {1,2,4} ylista
	matrix p = {1,2,4}
	var p ylista
      </code>
      <para context="cli">
	Se desenvuelve una regresión por separado para cada una de las variables
	de <repl>ylista</repl>. Los resultados para cada ecuación incluyen los
	contrastes <math>F</math> para restricciones cero en todos los retardos
	de cada una de las variables, un contraste <math>F</math> sobre la
	significación del retardo máximo y, cuando especificas la opción
	<opt>impulse-responses</opt>, las descomposiciones de la varianza de la
	predicción y las respuestas al impulso.
      </para>
      <para>
	Las descomposiciones de la varianza de la predicción y las respuestas al
	impulso se basan en la descomposición de Cholesky de la matriz de
	covarianzas contemporánea y, en este contexto, tiene importancia el
	orden en el que indicas las variables (estocásticas). Así, la primera
	variable de la lista se asume que es la <quote>más exógena</quote>
	dentro del período. Puedes establecer el horizonte para las
	descomposiciones de la varianza y las respuestas al impulso, utilizando
	la instrucción <cmdref targ="set"/>. Para recuperar una función
	concreta de respuesta al impulso en forma matricial, consulta la
	función <fncref targ="irf"/>.
      </para>
      <para context="cli">
	Cuando indicas la opción <opt>robust</opt>, las desviaciones típicas
	se corrigen del efecto de la heterocedasticidad. Como alternativa, puedes
	indicar la opción <opt>robust-hac</opt> para dar lugar a desviaciones
	típicas que sean robustas con respecto tanto a la heterocedasticidad como
	a la autocorrelación (HAC). En general, esta última corrección no debiera
	de ser necesaria si el VAR incluye un número suficiente de retardos.
      </para>
      <subhead context="cli">Selección de retardo</subhead>
      <para context="cli">
	Cuando indicas la opción <opt>lagselect</opt>, no se presenta el
	resultado habitual del VAR. En su lugar, se toma el primer argumento
	como orden <emphasis>máximo</emphasis> de retardo, y la salida de
	resultados consiste en una tabla que muestra cifras comparativas
	calculadas para VARs que van desde el orden 1 (predeterminado) hasta
	el máximo especificado. La tabla incluye el logaritmo de la verosimilitud
	y el valor <math>P</math> de un contraste de Razón de Verosimilitudes
	(RV o LR), seguidos de los Criterios de Información de Akaike (AIC),
	de Schwarz (BIC) y de Hannan&ndash;Quinn (HQC). El contraste RV (LR)
	compara la especificación de la fila <math>i</math> con la de la fila
	<math>i</math> &minus; 1, considerando como hipótesis nula que todos
	los parámetros añadidos en la fila <math>i</math> tienen valores nulos.
	Puedes recuperar la tabla con los resultados, en formato de matriz,
	mediante el accesor <fncref targ="$test"/>.
      </para>
      <para>
  Únicamente en el contexto de la selección de retardo, puedes usar la
  opción <opt>minlag</opt> para ajustar el nivel mínimo de retardos.
  Ajústalo a 0 para permitir la posibilidad de que el nivel óptimo de
  retardos sea cero (queriendo ello decir realmente que no se requiere un
  VAR para nada). Por el contrario, podrías hacer que <opt>minlag=4</opt>
  si crees que necesitas 4 retardos por lo menos, de forma que se ahorre
  un poco de tiempo de cálculo.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Series temporales multivariantes</menu-path>
    </gui-access>

  </command>

  <command name="VAR-lagselect" section="Tests" context="gui"
    label="Selección de la longitud de retardos del VAR">

    <description>
      <para>
	En esta caja de diálogo, especifica un VAR como siempre, pero utiliza el botón (con
	flechas arriba/abajo) del orden de retardos, para indicar el número máximo a probar.
      </para>
      <para>
	El resultado consiste en una tabla que muestra los valores de los
	criterios de información de Akaike (AIC), de Schwarz (BIC) y de
	Hannan&ndash;Quinn (HQC), calculados para VARs de órdenes desde 1 hasta
	el máximo elegido. Además, el logaritmo de la verosimilitud se muestra
	para cada especificación, junto con el valor <math>P</math> de un
	contraste de Razón de Verosimilitudes sobre la hipótesis nula de que
	todos los parámetros añadidos en la fila <math>i</math>, en relación
	con los de la fila <math>i</math> &minus; 1, tienen valores nulos.
      </para>
      <para>
	Esto está pensado para ayudar en la selección del orden óptimo del
	retardo.
      </para>
    </description>
  </command>

  <command name="VAR-omit" section="Tests" context="gui"
    label="Contrastar las variables exógenas de un VAR">

    <description>
      <para>
	Utiliza esta caja de diálogo para especificar un subconjunto de
	variables exógenas de un VAR. Estas variables se van a quitar del VAR
	original, y el sistema vuelve a estimarse.
      </para>
      <para>
	Se presenta un contraste de Razón de Verosimilitudes, en el que la hipótesis
	nula es que los verdaderos valores de los parámetros de las variables omitidas
	son cero, en todas las ecuaciones del VAR. El contraste se basa en la diferencia
	entre el logaritmo del determinante de la matriz de varianzas del sistema
	sin restringir, y el del sistema restringido omitiendo las variables elegidas.
      </para>
    </description>

  </command>

  <command name="varlist" section="Dataset"
    label="Listar las variables" context="cli">

    <usage>
      <options>
	<option>
	  <flag>--type</flag>
	  <optparm>nombretipo</optparm>
	  <effect>Campo del listado</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Por defecto, presenta un listado de las series del conjunto vigente de
	datos (si hay alguna); y puedes utilizar <cmd>ls</cmd> como alias.
      </para>
      <para>
	Cuando indicas la opción <opt>type</opt>, debe ir seguida (después de
	un signo de igualdad) por uno de los siguientes tipos: <lit>series</lit>,
	<lit>scalar</lit>, <lit>matrix</lit>, <lit>list</lit>, <lit>string</lit>,
	<lit>bundle</lit>, <lit>array</lit> o <lit>accessor</lit>. Su efecto
	consiste en presentar los nombres de todos los objetos del tipo
	indicado que estén definidos en ese
	momento.
      </para>
      <para>
	Como caso especial, si el tipo es <lit>accessor</lit>, los nombres
	que se presentan son aquellos de las variables internas disponibles
	en ese momento como <quote>accesores</quote>, como pueden ser
	<fncref targ="$nobs"/> y <fncref targ="$uhat"/> (sean cuales sean
	sus tipos concretos).
      </para>
    </description>

  </command>

  <command name="vartest" section="Tests" label="Contrastar la diferencia de varianzas">

    <usage>
      <altforms>
        <altform><lit>vartest</lit> <repl>x</repl> <repl>y</repl> </altform>
        <altform><lit>vartest</lit> <repl>x</repl> <lit>--split-by=</lit><repl>ficticia</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>Elimina la presentación de resultados</effect>
        </option>
        <option>
	  <flag>--robust</flag>
          <optparm>método</optparm>
	  <effect>Mira abajo</effect>
        </option>
      </options>
      <examples>
        <example>vartest x y</example>
        <example>meantest x --split-by=d</example>
        <example>meantest x y --robust=median</example>
        <example>meantest x y --robust=trimmed,5</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	En su uso básico, calcula el estadístico <math>F</math> para contrastar
	la hipótesis nula de que las varianzas poblacionales son iguales para las
	series <repl>x</repl> e <repl>y</repl>, mostrando además un resultado
	que incluye su probabilidad asociada (valor p). Los resultados se
	pueden recuperar utilizando los accesores <fncref targ="$test"/> y
	<fncref targ="$pvalue"/>, en cuyo caso se puede utilizar la opción
	<opt>quiet</opt> para omitir la impresión.
      </para>
      <para>
	Por ejemplo, el siguiente código:
      </para>
      <code>
		open AWM18.gdt
		vartest EEN EXR
		eval $test
		eval $pvalue
      </code>
    <para>
	proporciona el resultado que muestra abajo:
  	</para>
  	  <code>
		Contraste de igualdad de varianzas

		EEN: Número de observaciones = 192
		EXR: Número de observaciones = 188
		Cociente entre varianzas muestrales = 3.70707
		Hipótesis nula: Las dos varianzas poblacionales son iguales
		Estadístico de contraste: F(191,187) = 3.70707
		valor p (a dos colas) = 1.94866e-18

		3.7070716
		1.9486605e-18
    	</code>
      <para context="cli">
	En su forma alternativa, con la opción <opt>split-by</opt>, las muestras
	para las que se contrasta la igualdad de sus varianzas son dos subconjuntos
	de la serie <repl>x</repl>, para las que la serie <repl>ficticia</repl>
	toma los valores 0 y 1, respectivamente.
      </para>

      <subhead context="cli">Probas robustas</subhead>
      <para context="cli">
	El contraste <math>F</math> típico se basa en el supuesto de Normalidad
	y puede provocar en exceso el rechazo de la hipótesis nula si los datos
	realmente son No-Normales. La opción <opt>robust</opt> ofrece tres
	alternativas, del siguiente modo:
      </para>
      <ilist context="cli">
        <li>
          <para>
            Cuando <repl>método</repl> es <lit>mean</lit>: el contraste
            definido por <cite key="levene60">Levene (1960)</cite>. En
            realidad esto es un ANOVA de un factor que usa las desviaciones absolutas
            de los datos originales respecto a sus respectivas medias muestrales.
          </para>
        </li>
        <li>
          <para>
            Cuando <repl>método</repl> es <lit>median</lit>: una variante
            del contraste de Levene sugerida por
            <cite key="brown-forsythe">Brown y Forsythe (1974)</cite>,
            en la que el centrado inicial utiliza la mediana muestral en
            lugar de la media. Esto se recomienda cuando los datos
            están bastante sesgados.
          </para>
        </li>
        <li>
          <para>
            Cuando <repl>método</repl> es <lit>trimmed</lit>: una segunda
            variante debida a Brown y Forsythe, en la que el centrado es
            respecto a una media recortada. Esto puede ser preferible si
            los datos tienen colas gruesas pero son razonablemente simétricos.
            Por defecto, se usa el recorte del 10 por ciento (es decir,
            se calcula la media después de omitir el 10 por ciento de las
            observaciones con menores valores y con mayores valores) pero
            esto se puede ajustar añadiendo una coma y un valor entero,
            como en <opt>robust=trimmed,5</opt> donde se especifica
            que se recorta el 5 por ciento.
          </para>
        </li>
      </ilist>
      <para context="gui">
	Calcula el estadístico <math>F</math> para contrastar la hipótesis nula de
	que las varianzas poblacionales de las dos series elegidas son iguales, y
	muestra su probabilidad asociada (valor p).
      </para>
    </description>

    <gui-access>
      <menu-path>/Herramientas/Calculadora de estadísticos de contraste</menu-path>
    </gui-access>

  </command>

  <command name="vecm" section="Estimation"
    label="Modelo de Vectores de Corrección del Error">

    <usage>
      <arguments>
        <argument>orden</argument>
        <argument>rango</argument>
        <argument>ylista</argument>
	     <argblock optional="true" separated="true">
	      <argument>xlista</argument>
	     </argblock>
	     <argblock optional="true" separated="true">
	      <argument>rxlista</argument>
	     </argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>Sin constante</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>Constante restringida</effect>
        </option>
        <option>
	  <flag>--uc</flag>
	  <effect>Constante no restringida</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>Constante y tendencia restringida</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>Constante y tendencia no restringida</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>Incluye variables ficticias estacionales centradas</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>No muestra los resultados de las ecuaciones individuales</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>No presenta nada</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>Presenta las respuestas al impulso</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>Presenta las descomposiciones de la varianza</effect>
        </option>
      </options>
      <examples>
        <example>vecm 4 1 Y1 Y2 Y3</example>
        <example>vecm 3 2 Y1 Y2 Y3 --rc</example>
	<example>vecm 3 2 Y1 Y2 Y3 ; X1 --rc</example>
	<demos>
	  <demo>denmark.inp</demo>
	  <demo>hamilton.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Un VECM es una forma de autorregresión de vectores o VAR (consulta
	<cmdref targ="var"/>), aplicable cuando las variables del modelo son
	individualmente integradas de orden 1 (por lo tanto son paseos aleatorios,
	con o sin deriva) pero presentan cointegración. Esta instrucción está
	íntimamente relacionada con el contraste de cointegración de Johansen
	(consulta <cmdref targ="johansen"/>).
      </para>
      <para context="cli">
	El parámetro <repl>orden</repl> de esta instrucción representa el orden de
	retardos del sistema VAR. El número de retardos en el propio VECM (donde la
	variable dependiente se indica como una primera diferencia) es de uno
	menos que <repl>orden</repl>.
      </para>
      <para context="gui">
	El orden de retardos escogido en la caja de diálogo del VECM es el del sistema
	VAR. El número de retardos en el propio VECM (donde la variable dependiente
	se indica como una primera diferencia) es de uno menos que ese número.
      </para>
      <para context="cli">
	El parámetro <repl>rango</repl> representa el rango de cointegración
	o, en otras palabras, el número de vectores cointegrantes. Este debe
	ser mayor que cero, y menor o igual (generalmente menor) que el número
	de variables endógenas indicadas en <repl>ylista</repl>.
      </para>
      <para context="gui">
	El <quote>rango</quote> representa el número de vectores
	cointegrantes. Este debe ser mayor que cero, y menor o
	igual (generalmente menor) que el número de variables endógenas
	escogidas.
      </para>
      <para context="cli">
	El argumento <repl>ylista</repl> proporciona la lista de variables
	endógenas, expresadas en niveles. La inclusión de términos de tipo
	determinístico en el modelo, se controla con los indicadores de opción.
	Por defecto, cuando no indicas ninguna opción, se incluye una
	<quote>Constante no restringida</quote>, lo que permite que haya
	una ordenada en el origen no nula en las relaciones de cointegración,
	así como una tendencia en los niveles de las variables endógenas. La
	literatura derivada del trabajo de Johansen (por ejemplo, puedes
	consultar su libro de 1995) habitualmente se refiere a esto como
	el <quote>caso 3</quote>. Las primeras 4 opciones indicadas arriba
	(mutuamente excluyentes) generan los casos 1, 2, 4 y 5, respectivamente.
	Los significados de estos casos y los criterios que se usan para escoger
	un caso, se explican en <guideref targ="chap:vecm"/>.
      </para>
      <para context="cli">
	Las listas (opcionales) <repl>xlista</repl> y <repl>rxlista</repl> te
	permiten especificar conjuntos de variables exógenas que forman
	parte del modelo, bien sin restricciones (<repl>xlista</repl>) o bien
	restringidas al espacio de cointegración (<repl>rxlista</repl>). Estas
	listas se separan de <repl>ylista</repl> y unas de las otras, mediante
	punto y coma.
      </para>
      <para context="gui">
	En el cuadradito <quote>Variables endógenas </quote> puedes escoger
	el vector de variables endógenas, expresadas en niveles. La inclusión
	de términos de tipo determinístico en el modelo se controla mediante
	el botón de la caja de opciones. Por defecto, se incluye una
	<quote>Constante no restringida</quote>, lo que permite que haya
	una ordenada en el origen no nula en las relaciones de cointegración, así
	como una tendencia en los niveles de las variables endógenas. La literatura
	derivada del trabajo de Johansen (por ejemplo, consulta su libro
	de 1995) habitualmente se refiere a esto como el <quote>caso 3</quote>.
	Las otras 4 opciones generan los casos 1, 2, 4 y 5, respectivamente. Los
	significados de estos casos y los criterios que se usan para escoger
	un caso, se explican en <guideref targ="chap:vecm"/>.
      </para>
      <para context="gui">
	En el cuadradito <quote>Variables exógenas</quote> puedes añadir determinadas
	variables exógenas. Por defecto, estas entran en el modelo de forma no
	restringida (indicada con una <lit>U</lit> al lado del nombre de la variable).
	Si quieres que una determinada variable exógena esté restringida al
	espacio de cointegración, pulsa un clic con el botón derecho del ratón sobre
	ella y selecciona <quote>Restringida</quote> en el menú emergente. Entonces
	el símbolo al lado de la variable va a cambiarse a R.
      </para>
      <para context="cli">
	La opción <opt>seasonals</opt>, que puedes combinar con cualquiera de las
	otras opciones, especifica la inclusión de un conjunto de variables
	ficticias estacionales centradas. Esta opción únicamente está disponible
	para datos trimestrales o mensuales.
      </para>
      <para context="gui">
	Si los datos son trimestrales o mensuales, se muestra un cuadro de verificación que
	te permite incluir un conjunto de variables ficticias estacionales centradas. En
	todos los casos, otro cuadradito de verificación (<quote>Mostrar los detalles de las regresiónes</quote>)
	permite presentar las regresiones auxiliares que forman el punto de
	inicio del procedimiento de estimación Máximo Verosímil de Johansen.
      </para>
      <para context="cli">
	El primer ejemplo de arriba especifica un VECM, con un orden de retardos de 4 y
	un único vector de cointegración. Las variables endógenas son <lit>Y1</lit>,
	<lit>Y2</lit> e <lit>Y3</lit>. El segundo ejemplo usa las mismas variables pero
	especifica un orden de retardos de 3, y dos vectores de cointegración; también
	especifica una <quote>Constante restringida</quote>, que es adecuada cuando
	los vectores de cointegración pueden tener ordenada en el origen no nula pero las
	variables <lit>Y</lit> no tienen tendencia.
      </para>
      <para context="cli">
	A continuación de la estimación de un VECM, tienes disponibles algunos accesores
	especiales: <lit>$jalpha</lit>, <lit>$jbeta</lit> y <lit>$jvbeta</lit>
	recuperan las matrices &agr; y &bgr;, y la varianza estimada de &bgr;,
	respectivamente. Para recuperar la función de respuesta ante un impulso
	determinado, en forma de matriz, consulta la función
	<fncref targ="irf"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Series temporales multivariantes</menu-path>
    </gui-access>

  </command>

  <command name="vif" section="Tests" context="cli"
    label="Factores de Inflación de la Varianza">
    <usage>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>No presenta nada</effect>
        </option>
      </options>
	  <examples>
	<demos>
	  <demo>longley.inp</demo>
	</demos>
    </examples>
    </usage>

    <description>
      <para>
	Debe ir después de la estimación de un modelo que incluya al
	menos 2 variables independientes. Calcula y muestra información de
	diagnóstico relacionada con la multicolinealidad.
      </para>
      <para>
	El Factor de Inflación de la Varianza (FIV) del regresor <math>j</math>
	se define como <equation status="display" tex="\[\frac{1}{1-R_j^2}\]"
	ascii="1/(1 - Rj^2)" graphic="vif"/>
	donde <math>R</math><sub>j</sub> es el coeficiente de correlación
	múltiple entre ese regresor <math>j</math> y los demás regresores.
	El factor tiene un valor mínimo de 1.0 cuando la variable en cuestión
	es ortogonal con respecto a las otras variables independientes.
	<cite key="neter-etal90">Neter, Wasserman y Kutner (1990)</cite>
	sugieren revisar el valor más grande de los FIV para diagnosticar
	un alto grado de multicolinealidad; así, un valor mayor que 10 se
	considera a veces indicativo de un grado de multicolinealidad
	problemático.
      </para>
      <para>
	Después de utilizar esta instrucción, puedes usar el accesor
	<fncref targ="$result"/> para obtener un vector columna que incluya
	los FIV. Para tener un enfoque más sofisticado para diagnosticar
	la multicolinealidad, consulta la instrucción <cmdref targ="bkw"/>.
      </para>
    </description>
    <gui-access>
      <menu-path>Ventana de modelo: Análisis/Colinealidad</menu-path>
    </gui-access>

  </command>

  <command name="wls" section="Estimation"
    label="Mínimos Cuadrados Ponderados">

    <usage>
      <arguments>
        <argument>varponder</argument>
        <argument>depvar</argument>
	      <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>Presenta la matriz de covarianzas</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>Desviaciones típicas robustas</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>No presenta los resultados</effect>
        </option>
	<option>
	  <flag>--allow-zeros</flag>
	  <effect>Mira abajo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Calcula las estimaciones de mínimos cuadrados ponderados (MCP, WLS)
	utilizando <repl>varponder</repl> como ponderación, <repl>depvar</repl>
	como variable dependiente e <repl>indepvars</repl> como lista de
	variables independientes. Sea <repl>w</repl> la raíz cuadrada positiva
	de <lit>varponder</lit>, entonces MCP es básicamente equivalente a la
	regresión MCO de <repl>w</repl> <lit>*</lit> <repl>depvar</repl>
	sobre <repl>w</repl> <lit>*</lit> <repl>indepvars</repl>. Sin embargo,
	el <emphasis>R</emphasis>-cuadrado se calcula de modo especial,
	concretamente como
	<equation status="display"
	  tex="\[R^2 = 1 - \frac{\rm ESS}{\rm WTSS}\]"
	  ascii="R^2 = 1 - ESS / WTSS"
	  graphic="wlsr2"/>
	donde ESS es la suma de errores cuadrados de la regresión ponderada, y WTSS
	denota la <quote>Suma de cuadrados totales ponderados</quote>, que es
	igual a la suma de errores cuadrados de la regresión de la variable dependiente
	ponderada sobre únicamente la constante ponderada.
      </para>
      <para context="cli">
	Como caso especial, si <repl>varponder</repl> es una variable ficticia
	0/1, la estimación MCP (WLS) es equivalente a MCO (OLS) en una muestra
	en la que se excluyen todas las observaciones que tienen un valor de
	cero para <repl>varponder</repl>. Por otro lado, la inclusión de
	ponderaciones iguales a cero se considera un error, pero si realmente
	quieres mezclar ponderaciones iguales a cero con ponderaciones positivas,
	puedes añadir la opción <opt>allow-zeros</opt>.
      </para>
      <para context="cli">
	Para aplicar la estimación de Mínimos Cuadrados Ponderados a datos
	de panel, basada en las varianzas del error específico de cada unidad,
	consulta la instrucción <cmdref targ="panel"/> junto con la opción
	<opt>unit-weights</opt>.
	    </para>
      <para context="gui">
	Sea 'varponder' la variable escogida en el cuadradito 'Variable de ponderaciones'.
	Se ejecuta una regresión MCO, donde la variable dependiente es el producto
	de la raíz cuadrada positiva de 'varponder' y la variable dependiente elegida,
	y las variables independientes se multiplican también por la raíz cuadrada
	de 'varponder'. Los estadísticos como <emphasis>R</emphasis>-cuadrado
	se basa en los datos ponderados. Si 'varponder' es una variable ficticia,
	la estimación de mínimos cuadrados ponderados es equivalente a la que
	resulta al eliminar todas las observaciones que tienen un valor de cero
	para 'varponder'.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modelo/Otros modelos lineales/Mínimos cuadrados ponderados</menu-path>
    </gui-access>

  </command>

  <command name="workdir" section="Utilities" label="Directorio de trabajo"
    context="gui">

    <description>
      <para>
	El directorio de trabajo (o <quote>workdir</quote>) es donde GRETL hace
	la búsqueda por defecto al leer o escribir archivos de datos o guiones,
	mediante los diálogos 'Abrir archivo de datos' y 'Guardar datos'.
	Además, es la localización por defecto para
      </para>
      <ilist>
	<li>
	  <para>
	    leer archivos mediante instrucciones tales como <lit>append</lit>,
	    <lit>open</lit>, <lit>run</lit> e <lit>include</lit>;
	    y
	  </para>
	</li>
	<li>
	  <para>
	    escribir archivos mediante instrucciones tales como <lit>eqnprint</lit>,
	    <lit>tabprint</lit>, <lit>gnuplot</lit>, <lit>outfile</lit>
	    y <lit>store</lit>.
	  </para>
	</li>
      </ilist>
      <para>
	Puedes determinar el directorio de trabajo de uno de estos dos modos:
	(a) utilizando el diálogo al que se accede mediante el elemento
	<quote>Directorio de trabajo</quote> en el menú Archivo, o (b)
	usando la instrucción <cmdref targ="set"/>, como en
      </para>
      <code>
	set workdir /ruta/a/unsitio
      </code>
      <para>
	Puedes revisar el valor vigente de la variable <lit>workdir</lit> en el
	diálogo que se acaba de mencionar, o mediante la instrucción
      </para>
      <code>
	eval $workdir
      </code>
      <para>
	Por defecto, el valor de <lit>workdir</lit> se mantiene a lo largo de las sesiones
	de GRETL. Sin embargo, los usuarios que quieran trabajar con el indicador de
	instrucciones (lanzando GRETL desde una ventana de un terminal) pueden
	preferir tener el directorio de trabajo determinado automáticamente,
	desde el principio, como directorio vigente (de acuerdo con el intérprete).
	Puedes escoger esta opción en el diálogo o mediante la instrucción
      </para>
      <code>
	set use_cwd on
      </code>
      <para>
	(<quote>cwd</quote> = directorio de trabajo vigente).
      </para>
      <para>
	El diálogo del directorio de trabajo también te permite determinar el
	comportamiento del selector de archivos de la Interfaz Gráfica de Usuario
	(GUI). Así, si abres o guardas un archivo en un determinado directorio, ¿el
	selector debe recordarlo y volver al mismo directorio en la siguiente solicitud?
	¿O el selector debe visitar siempre el directorio de trabajo elegido?
      </para>
    </description>

    <gui-access>
      <menu-path>/Archivo/Directorio de trabajo</menu-path>
    </gui-access>

  </command>

  <command name="x12a" section="Utilities" context="gui"
    label="ARIMA X-12">

    <description>
      <para>
	Aquí hay dos opciones para proceder, controladas por el conjunto
	que te ofrece el botón inferior de selección.
      </para>
      <para>
	Si escoges <quote>Ejecutar directamente ARIMA-X-12 </quote> entonces
	GRETL escribe un archivo de instrucciones para ARIMA X-12, y solicita
	que el programa 'x12a' ejecute las instrucciones. En este caso, tienes la
	posibilidad de generar un gráfico, y/o guardar series escogidas del
	resultado en el conjunto de datos de GRETL.
      </para>
      <para>
	Si escoges <quote>Preparar un archivo de instrucciones de ARIMA X-12</quote>,
	GRETL escribe un archivo de instrucciones para ARIMA X-12 (igual que en el
	caso de arriba), pero entonces abre este archivo en una ventana del editor.
	En esta ventana puedes hacer cambios y guardar el archivo con el nombre que tú
	elijas. También puedes enviar el archivo para que lo ejecute 'x12a' (pulsando
	un clic en el botón <quote>Ejecutar</quote> en la barra de herramientas de la
	ventana del editor) y comprobar el resultado. Pero en este caso, no tienes la
	posibilidad de guardar los datos como series, ni de generar un gráfico
	de GRETL.
      </para>
    </description>

  </command>

  <command name="xcorrgm" section="Statistics" label="Correlograma cruzado">

    <usage>
      <arguments>
        <argument>serie1</argument>
        <argument>serie2</argument>
        <argument optional="true">orden</argument>
      </arguments>
      <options>
       <option>
	  <flag>--plot</flag>
	  <optparm>modo-o-nombrearchivo</optparm>
	  <effect>Mira abajo</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>Omite la presentación del resultado</effect>
        </option>
      </options>
      <examples>
        <example>xcorrgm x y 12</example>
      </examples>
    </usage>

    <description>
      <para>
	Presenta y/o dibuja el correlograma cruzado de <repl>serie1</repl>
	con <repl>serie2</repl>, las que puedes especificar mediante sus
	nombres o sus números. Los valores son los coeficientes de
	correlación muestrales entre el valor vigente de <repl>serie1</repl>
	y los sucesivos adelantos y retardos de
	<repl>serie2</repl>.
      </para>
      <para>
	Si especificas un valor para <repl>orden</repl>, la longitud del
	correlograma cruzado se limita a ese número de adelantos y retardos
	(al menos); de lo contrario, la longitud se determina de forma
	automática en función de la frecuencia de los datos y del número de
	observaciones.
      </para>
      <para>
	Por defecto, cuando GRETL no está en modo de procesamiento por lotes,
	se muestra un gráfico del correlograma cruzado. Puedes ajustar esto
	mediante la opción <opt>plot</opt>. Los parámetros admisibles para esta
	opción son <lit>none</lit> (para omitir el gráfico), <lit>display</lit>
	(para generar un gráfico Gnuplot aunque sea en modo de procesamiento
	por lotes), o un nombre de archivo. El efecto de proporcionar un
	nombre de archivo es como se describió para la opción <opt>output</opt>
	de la instrucción <cmdref targ="gnuplot"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Ver/Correlograma cruzado</menu-path>
      <other-access>Ventana principal: Menú emergente (tras selección múltiple)</other-access>
    </gui-access>

  </command>

  <command name="xtab" section="Statistics" label="Tabulación cruzada de variables">

    <usage>
      <arguments>
        <argument>listay</argument>
	      <argument optional="true" separated="true">listax</argument>
      </arguments>
      <options>
        <option>
	  <flag>--row</flag>
	  <effect>Muestra los porcentajes de fila</effect>
        </option>
        <option>
	  <flag>--column</flag>
	  <effect>Muestra los porcentajes de columna</effect>
        </option>
        <option>
	  <flag>--zeros</flag>
	  <effect>Muestra un cero en las entradas nulas</effect>
        </option>
        <option>
	  <flag>--no-totals</flag>
	  <effect>Elimina la presentación de los recuentos marginales</effect>
        </option>
        <option>
	  <flag>--matrix</flag>
	  <optparm>nombrematr</optparm>
	  <effect>Usa las frecuencias de la matriz indicada</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>Suprime la presentación de resultados</effect>
        </option>
	      <option>
	  <flag>--tex</flag>
	  <optparm optional="true">nombrearchivo</optparm>
	  <effect>Salida como &latex;</effect>
	      </option>
	      <option>
	  <flag>--equal</flag>
	  <effect>Consulta el caso &latex; más abajo</effect>
	      </option>
      </options>
      <examples>
	<example>xtab 1 2</example>
	<example>xtab 1 ; 2 3 4</example>
	<example>xtab --matrix=A</example>
	<example>xtab 1 2 --tex="xtab.tex"</example>
	<demos>
	  <demo>ooballot.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="cli">
      <para>
	Indicando unicamente el argumento <repl>listay</repl>, calcula (y
	presenta por defecto) una tabla de contingencia o una tabulación
	cruzada para cada combinación de las variables incluidas en esa lista.
	Cuando indicas una segunda lista (<repl>listax</repl>), cada variable
	de <repl>listay</repl> se cruza en una tabla por fila frente a cada
	variable de <repl>lista</repl> (por columna). Puedes referirte a las
	variables de estas listas mediante sus nombres o sus números. Ten
	en cuenta que todas las variables tienen que estar marcadas como
	discretas. Como alternativa, cuando indicas la opción <opt>matrix</opt>,
	se trata la matriz indicada como un conjunto calculado previamente
	de frecuencias a presentar como tabulación cruzada (consulta también
	la función <fncref targ="mxtab"/>). En este caso deberás omitir el
	argumento <repl>list</repl>.
      </para>
      <para>
	Por defecto, la anotación de cada celda indica el recuento de la
	frecuencia de casos. Las opciones <opt>row</opt> y <opt>column</opt>
	(que se excluyen mutuamente) substituyen los recuentos con los
	porcentajes para cada fila o columna, respectivamente. Por defecto,
	las celdas con un recuento de cero casos se dejan en blanco, pero
	la opción <opt>zeros</opt> tiene como efecto la presentación
	explícita de los ceros, lo que te puede ser útil para importar la
	tabla con un programa tal como una hoja de cálculo.
      </para>
      <para>
	El contraste de independencia chi-cuadrado de Pearson se muestra si
	la frecuencia esperada bajo independencia es cuando menos de 1.0e-7
	para todas las celdas. Una regla general habitual de la validez de
	este estadístico es que, al menos el 80 por ciento de las celdas
	deben tener frecuencias esperadas iguales a 5 o más; y si este
	criterio no se cumple, se presenta una advertencia.
      </para>
      <para>
	Si una tabla de contingencia es 2 por 2, se presenta el Contraste Exacto de
	independencia de Fisher. Ten en cuenta que este contraste se basa en el
	supuesto de que los totales por fila y por columna son fijos, lo que puede
	ser o no ser adecuado dependiendo de cómo se generaron los datos. Debes
	utilizar la probabilidad asociada (valor p) de la izquierda cuando la hipótesis
	alternativa a la de independencia es la asociación negativa (los valores tienden
	a agruparse en las celdas de abajo a la izquierda y de arriba a la derecha); y
	debes utilizar el valor p de la derecha si la alternativa es la asociación
	positiva. El valor p de dos colas para este contraste se calcula mediante el
	método (b) de la sección 2.1 de <cite key="agresti92">Agresti (1992)</cite>:
	esto es la suma de las probabilidades de todas las tablas posibles que tengan
	los totales de filas y columnas indicados, y que tengan una probabilidad
	no mayor a la de la tabla observada.
      </para>

      <subhead>El caso bivariante</subhead>
      <para>
	En el caso de una tabulación cruzada bivariante (cuando se indica tan
	solo una lista que tiene dos elementos) se guardan algunos resultados.
	Puedes recuperar la tabla de contingencia en forma de matriz mediante
	el accesor <fncref targ="$result"/>. Además, si se cumple la condición
	del valor esperado, puedes recuperar el estadístico del contraste
	chi-cuadrado de Pearson y su probabilidad asociada (valor p) mediante
	los accesores <fncref targ="$test"/> y <fncref targ="$pvalue"/>. Si
	son estos los resultados que te interesan, puedes utilizar la opción
	<opt>quiet</opt> para eliminar la presentación habitual de resultados.
      </para>

      <subhead>Salida &latex;</subhead>
      <para>
	Cuando indicas la opción <opt>tex</opt>, la tabulación cruzada se
	presenta con el formato de un entorno <lit>tabular</lit> &latex; en
	línea (de donde podría copiarse y pegarse) o, cuando se añade
	el parámetro <repl>nombrearchivo</repl>, se envía al archivo ahí
	indicado. (Si en <repl>nombrearchivo</repl> no se especifica
	una ruta completa, el archivo se escribe en el directorio vigente
	establecido, <cmdref targ="workdir"/>.) No se calcula ningún
	estadístico de contraste. Puedes utilizar <opt>equal</opt> como
	opción adicional para señalar (mostrado en negrilla) el recuento
	o porcentaje de celdas en las que las variables de la fila y columna
 	tienen el mismo valor numérico. Esta opción se ignora excepto que
	indiques la opción <opt>tex</opt>; y también cuando una o las dos
	variables de la tabulación cruzada tenga valores de cadena de texto.
      </para>
    </description>

    <description context="gui">
      <para>
	Muestra una tabla de contingencia o una tabulación cruzada para
	cada combinación de las variables escogidas. Ten en cuenta que todas las
	variables deben ser discretas.
      </para>
      <para>
	Por defecto, en las celdas y en los márgenes de la tabla se muestran los valores que
	cuentan la frecuencia. Sin embargo, puedes escoger que se muestren en su lugar
	los porcentajes, bien por filas, o bien por columnas.
      </para>
      <para>
	Por defecto, las celdas con un recuento de cero casos se muestran como vacías,
	pero puedes escoger que se muestre explícitamente el valor cero.
      </para>
      <para>
	El contraste de independencia chi-cuadrado de Pearson se muestra si
	la frecuencia esperada bajo independencia es al menos de 1.0e-7
	para todas las celdas. Una regla general habitual de la validez de
	este estadístico es que, al menos el 80 por ciento de las celdas,
	deben tener frecuencias esperadas iguales a 5 o más; y si este
	criterio no se cumple, se presenta una advertencia.
      </para>
      <para>
	Si una tabla de contingencia es 2 por 2, se presenta el Contraste
	Exacto de independencia de Fisher. Ten en cuenta que este contraste
	se basa en el supuesto de que los totales por fila y por columna
	son fijos, lo que puede ser o no ser adecuado dependiendo de cómo
	se generaron los datos. Debes utilizar el valor p de la izquierda
	cuando la hipótesis alternativa a la de independencia es la de
	asociación negativa (los valores tienden a agruparse en las celdas
	de abajo a la izquierda y de arriba a la derecha); y debes utilizar
	el valor p de la derecha si la alternativa es la de asociación positiva.
	El valor p de dos colas para este contraste se calcula mediante el método
	(b) de la sección 2.1 de <cite key="agresti92">Agresti (1992)</cite>:
	esto es la suma de las probabilidades de todas las tablas posibles
	que tengan los totales de filas y columnas indicados, y que tengan
	una probabilidad menor o igual a la de la tabla observada.
      </para>
    </description>

  </command>

</commandref>
