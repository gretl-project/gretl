<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE funcref SYSTEM "gretl_functions.dtd">

<funcref language="spanish">

  <funclist name="Accessors" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
	  Debe ejecutarse después de que el último modelo se haya estimado con datos de
	  panel de efectos fijos o de efectos aleatorios. Devuelve una serie que
	  contiene las estimaciones de los efectos individuales.
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Si puede calcularse, devuelve un escalar con el valor del Criterio de
	  Información de Akaike (AIC) del último modelo estimado. Más detalles
	  sobre el cálculo en <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$allprobs" section="access" output="matrix">
      <description>
	<para>
	  Debe ir después de una estimación con probit o logit ordenados,
	  o con logit multinomial; y devolverá una matriz de orden
	  <by r="n" c="j"/>, donde <math>n</math> es el número de observaciones
	  utilizadas y <math>j</math> indica el número de resultados posibles,
	  que contiene la probabilidad estimada de cada resultado para cada
	  observación.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Si puede calcularse, devuelve un escalar con el valor del Criterio de
	  Información Bayesiano (BIC) de Schwarz del último modelo estimado.
	  Más detalles sobre el cálculo en <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Si puede calcularse, devuelve un escalar con el valor del estadístico chi-cuadrado
	  global del contraste de Razón de Verosimilitudes del último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">nombre</fnarg>
      </fnargs>
      <description>
	<para>
	  Sin argumentos <lit>$coeff</lit> devuelve un vector columna que contiene
	  los coeficientes del último modelo estimado. Con el argumento opcional de
	  texto <lit>(nombre de un regresor)</lit> la función devuelve un escalar con el
	  valor del parámetro estimado de ese regresor.
	  <seelist>
            <fncref targ="$stderr"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Ejemplo:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg
	  b = $coeff               # Devuelve un vector
	  macoef = $coeff(theta_1) # Devuelve un escalar
	</code>
	<para>
	  Si el <quote>modelo</quote> en cuestión es un sistema de ecuaciones,
	  el resultado depende de las características de este; para VARs y VECMs
	  el resultado devuelto es una matriz con una columna por cada ecuación;
	  de lo contario, es un vector columna que contiene los coeficientes de la primera
	  ecuación seguidos por los coeficientes de la segunda ecuación y así
	  sucesivamente.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Debe ejecutarse tras estimar un modelo, y devuelve la cadena con los caracteres
	  de la instrucción utilizada (ejemplo: <lit>ols</lit> o <lit>probit</lit>).
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de la estimación de un VAR o de un VECM, y devuelve la
	  matriz compañera.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Devuelve un escalar entero que representa el tipo de datos que se están
	  utilizando en ese momento: 0 = sin datos; 1 = datos de corte transversal;
	  2 = datos de series temporales; 3 = datos de panel.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Debe ejecutarse después de la estimación de un modelo con una única ecuación,
	  y devuelve una cadena de texto con el nombre de la variable dependiente.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Devuelve un escalar con los grados de libertad del último modelo estimado.
	  Si este consiste en un sistema de ecuaciones, el valor devuelto es el número de grados
	  de libertad por cada ecuación. Si los grados de libertad de las diferentes
	  ecuaciones no son los mismos en todas ellas, entonces el valor devuelto se
	  calcula restando el número de observaciones menos la media del número de
	  coeficientes de las ecuaciones (esta media se redondea al valor entero
	  inmediatamente superior).
	</para>
      </description>
    </function>

    <function name="$diagpval" section="access" output="scalar">
      <description>
	<para>
	  Debe ejecutarse después de la estimación de un sistema de ecuaciones, y devuelve
	  un escalar con la probabilidad asociada al valor del estadístico
	  <fncref targ="$diagtest"/>.
	</para>
      </description>
    </function>

    <function name="$diagtest" section="access" output="scalar">
      <description>
	<para>
	  Debe ejecutarse después de la estimación de un sistema de ecuaciones. Devuelve
	  un escalar con el valor del estadístico utilizado para contrastar la hipótesis nula
	  de que la matriz de varianzas-covarianzas de las perturbaciones de las ecuaciones
	  del sistema, es diagonal. Este es el contraste de Breusch-Pagan, excepto cuando
	  el estimador es el de un SUR iterado (sin restricciones), pues en ese caso es
	  un contraste de Razón de Verosimilitudes. Para obtener más detalles, véase
	  <guideref targ="chap:system"/> (también <fncref targ="$diagpval"/>).
	</para>
      </description>
    </function>

    <function name="$dotdir" section="access" output="string">
      <description>
	<para>
	  Este accesor devuelve una cadena de texto con la ruta donde GRETL
	  guarda archivos temporalmente, por ejemplo cuando usa la función
	  <fncref targ="mwrite"/> con un tercer argumento distinto de cero.
	</para>
      </description>
    </function>

    <function name="$dw" section="access" output="scalar">
      <description>
	<para>
	  Devuelve (si es posible) un escalar con el valor del estadístico de Durbin&ndash;Watson
	  para contrastar autocorrelación de primer orden en el último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Si se puede calcular, devuelve un escalar con el valor de la función de
	  distribución acumulada (CDF) de Durbin&ndash;Watson, evaluada en el valor
	  del estadístico de DW para el último modelo estimado; para ello se usa el
	  procedimiento de cálculo <cite key="imhof61">Imhof</cite>. Este es el
	  valor p de un contraste de una cola, en el que la hipótesis alternativa
	  es que existe autocorrelación positiva de primer orden. Si quieres el
	  valor p de un contraste de dos colas, toma 2<math>P</math> cuando
	  DW &lt; 2, o 2(1 &minus; <math>P</math>) cuando DW &gt; 2, donde
	  <math>P</math> es el valor que devuelve este accesor.
	</para>
	<para>
	  Debido a la limitada precisión de la aritmética digital, el resultado
	  del cálculo de la integral del método Imhof puede volverse negativo cuando
	  el estadístico de Durbin-Watson está próximo a su límite inferior;
	  por eso este accesor devuelve <lit>NA</lit> en esa situación. Dado que
	  cualquier otra modalidad de fallo tiene como resultado un error que se
	  señaliza, posiblemente sea seguro asumir que un resultado NA indica que
	  la verdadera probabilidad asociada es <quote>muy pequeña</quote>,
	  aunque no sea posible cuantificarla.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de la estimación de un VECM, y devuelve una matriz que
	  contiene los términos de Corrección de Errores. El número de filas es igual al
	  número de observaciones utilizadas, y el número de columnas es igual al orden
	  de cointegración del sistema.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Devuelve un escalar con uno de los códigos internos de fallo del programa. Ese
	  código es un valor no nulo cuando ocurre un fallo pero es capturado usando
	  la función <cmdref targ="catch"/>. Ten en cuenta que, al utilizar este
	  accesor, el código interno de fallo se vuelve nuevamente cero. Si deseas
	  obtener el mensaje de fallo asociado a un <lit>$error</lit> en concreto,
	  es preciso guardar su valor en una variable provisional, por ejemplo
	  utilizando el código:
	</para>
	<code>
	  err = $error
	  if (err)
	      printf "Se obtuvo el fallo %d (%s)\n", err, errmsg(err)
	  endif
	</code>
	<para>
	  <seelist>
            <cmdref targ="catch"/>
            <fncref targ="errmsg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Si puede calcularse, devuelve un escalar con la suma de los cuadrados de los errores
	  del último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de la estimación de un VECM, y devuelve un vector que
	  contiene los autovalores que se utilizan en el cálculo del contraste de la traza para
	  verificar si existe cointegración.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de la instrucción de predicción <cmdref targ="fcast"/>,
	  y devuelve una matriz con los valores previstos. Si el modelo que se utiliza
	  para hacer las predicciones es un sistema de ecuaciones, la matriz está
	  formada por una columna para cada ecuación; en caso contrario, es un vector
	  columna.
	</para>
      </description>
    </function>

    <function name="$fcse" section="access" output="matrix">
      <description>
	<para>
	  Si puede calcularse, debe ejecutarse después de procesar la instrucción
	  <cmdref targ="fcast"/> y devuelve una matriz con las desviaciones típicas
	  de las predicciones. Si el modelo que se utiliza para hacer las predicciones es
	  un sistema de ecuaciones, la matriz está formada por una columna para
	  cada ecuación; en caso contrario, es un vector columna.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de la estimación de un VAR, y devuelve una matriz que
	  contiene la descomposición de la varianza de los errores de predicción (FEVD,
	  siglas en inglés). Esa matriz tiene <math>h</math> filas que indican el
	  número de períodos del horizonte de predicción, lo que puede escogerse
	  de forma manual por medio de <lit>set horizon</lit> o de forma
	  automática en base a la frecuencia de los datos.
	</para>
	<para>
	  Para un VAR con <math>p</math> variables, la matriz tiene <math>p</math>
	  <sup>2</sup> columnas: las primeras <math>p</math> columnas contienen
	  la FEVD para la primera variable del VAR; las <math>p</math> columnas
	  siguientes contienen la FEVD para la segunda variable del VAR y así
	  sucesivamente. La fracción (decimal) del error de predicción de la variable
	  <math>i</math> causada por una innovación en la variable <math>j</math>
	  va a encontrarse entonces inspeccionando la columna (<math>i</math> &minus; 1)
	  <math>p</math> + <math>j</math>.
	</para>
	<para>
	  Para una variante más flexible de esta funcionalidad, consulta la
	  función <fncref targ="fevd"/>.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Si puede calcularse, devuelve un escalar con el estadístico F del contraste de
	  validez global del último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Debe ejecutarse después de un bloque <lit>gmm</lit> (del Método Generalizado
	  de los Momentos), y devuelve un escalar con el mínimo de la función objetivo.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Debe ejecutarse después de la instrucción <lit>garch</lit>, y devuelve una
	  serie con las varianzas condicionales estimadas.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Debe ejecutarse después de estimar un modelo por medio de <lit>tsls</lit>
	  o <lit>panel</lit> con la opción de efectos aleatorios, y devuelve un
	  vector fila <by r="1" c="3"/> que contiene en este orden: el valor del
	  estadístico del contraste de Hausman, los grados de libertad que
	  corresponden y la probabilidad asociada al valor del estadístico.
	</para>
     </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Si puede calcularse, devuelve un escalar con el valor del Criterio de
	  Información de Hannan-Quinn para el último modelo estimado. Para
	  detalles sobre el cálculo, consulta <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Devuelve un escalar con un número positivo muy grande. Por defecto es igual
	  a 1.0E100, pero puede cambiarse con la instrucción <cmdref targ="set"/>.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de estimar un VECM, y devuelve la matriz de carga.
	  El número de filas de esa matriz es igual al número de variables del VECM,
	  y el número de columnas es igual al rango de cointegración.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de estimar un VECM, y devuelve la matriz de
	  cointegración. Su número de filas es igual al número de variables del
	  VECM (más el número de variables exógenas que se restringen al espacio
	  de cointegración, si hay alguna); y su número de columnas es igual
	  al rango de cointegración.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Debe ejecutarse después de estimar un VECM, y devuelve la matriz estimada de
	  varianzas-covarianzas de los elementos de los vectores de cointegración.
	</para>
	<para>
	  En caso de tratarse de una estimación sin restricciones, el número de filas
	  de esa matriz es igual al número de elementos no restringidos del espacio
	  de cointegración, después de la normalización de Phillips. Por el contrario, si
	  se trata de la estimación de un sistema restringido por medio de la instrucción
	  <lit>restrict</lit> con la opción <lit>--full</lit>, se obtiene una matriz
	  singular con <math>(n+m)r</math> filas (donde <math>n</math> es el número
	  de variables endógenas, <math>m</math> el número de variables exógenas
	  restringidas al espacio de cointegración y <math>r</math> el rango de
	  cointegración).
	</para>
	<para>
	  Ejemplo: el código...
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	    b[1,1] = 1
	    b[1,2] = -1
	    b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  ... origina el siguiente resultado:
	</para>
	<code>
	  s0 (4 x 4)

          0,019751     0,029816  -0,00044837   -0,12227
          0,029816     0,31005   -0,45823      -0,18526
         -0,00044837  -0,45823    1,2169       -0,035437
         -0,12227     -0,18526   -0,035437      0,76062

	  s1 (5 x 5)

	  0,0000       0,0000       0,0000       0,0000       0,0000
	  0,0000       0,0000       0,0000       0,0000       0,0000
	  0,0000       0,0000      0,27398     -0,27398    -0,019059
	  0,0000       0,0000     -0,27398      0,27398     0,019059
	  0,0000       0,0000    -0,019059     0,019059    0,0014180
	</code>
      </description>
    </function>

    <function name="$lang" section="access" output="string">
      <description>
	<para>
	  Devuelve una cadena de texto que representa el idioma que se está usando
	  (si este puede determinarse). La cadena de texto está compuesta por dos
	  letras del código de lenguaje ISO 639-1 (por ejemplo, <lit>en</lit>
	  para el idioma inglés, <lit>jp</lit> para el japonés, <lit>el</lit> para
	  el griego) seguidas de un guion bajo más otras dos letras del código de
	  país ISO 3166-1. Así, por ejemplo, el idioma portugués de Portugal
	  se representa por <lit>pt_PT</lit> mientras que el idioma portugués de
	  Brasil se representa por <lit>pt_BR</lit>.
	</para>
	<para>
	  Si no es posible determinar el idioma vigente, se devuelve el texto
	  <quote><lit>unknown</lit></quote>.
	</para>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  Para una selección de modelos que se estiman por el método de Máxima
	  Verosimilitud, la función devuelve una serie con los valores del logaritmo
	  de la verosimilitud para cada observación. Por el momento esa función solo
	  está disponible para logit y probit binarios, tobit y heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Devuelve un escalar con el logaritmo de la verosimilitud del último modelo
	  estimado (si fuese aplicable).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Devuelve un escalar con el valor de la <quote>épsilon de la máquina</quote>,
	  lo que proporciona un límite superior para el error relativo debido al
	  redondeo en la aritmética de punto flotante con doble precisión.
	</para>
      </description>
    </function>

    <function name="$mapfile" section="access" output="string">
      <description>
	<para>
	  Devuelve una cadena de texto con el nombre del archivo que se debe
	  abrir para obtener los polígonos del mapa, cuando anteriormente se
	  han cargado datos de un archivo GeoJSON o de un archivo ESRI de forma;
	  en caso contrario, devuelve una cadena vacía. Esto está diseñado
	  para ser utilizado con la función <fncref targ="geoplot"/>.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse tras estimar un modelo logit multinomial (únicamente),
	  y devuelve una matriz con las probabilidades estimadas de cada resultado
	  posible, en cada observación de la muestra utilizada en la estimación del
	  modelo. Cada línea representa una observación y cada columna un
	  resultado. Dado que desde GRETL 2023a, este accesorio es obsoleto:
	  por favor, utiliza <fncref targ="$allprobs"/> en su lugar.
	</para>
      </description>
    </function>

    <function name="$model" section="access" output="bundle">
      <description>
	<para>
	  Debe ejecutarse después de estimar modelos con una única ecuación, y
	  devuelve un <quote>bundle</quote> que contiene varias unidades de
	  datos pertenecientes al modelo. Se incluyen todos los accesores habituales
	  de los modelos, que son designados mediante claves iguales a los nombres
	  de esos accesores habituales, sin el signo dólar inicial. Por ejemplo,
	  los errores aparecen bajo la clave <lit>uhat</lit> y la suma de cuadrados
	  de los errores bajo <lit>ess</lit>.
	</para>
	<para>
	  Dependiendo del estimador, puedes disponer de información adicional. Las
	  claves para tal información es de esperar que sean explicativas por sí
	  mismas. Para ver lo que está disponible, puedes guardar una copia del
	  'bundle' y mostrar su contenido, como por ejemplo con el código:
	</para>
	<code>
	  ols y 0 x
	  bundle b = $model
	  print b
	</code>
      </description>
    </function>

    <function name="$mpirank" section="access" output="int">
      <description>
	<para>
	  Cuando se prepara GRETL con soporte MPI, y el programa está
	  funcionando en modo MPI, devuelve la <quote>jerarquía</quote>
	  en base 0 o número ID del proceso vigente. En caso contrario,
	  devuelve &minus;1.
	</para>
      </description>
    </function>

    <function name="$mpisize" section="access" output="int">
      <description>
	<para>
	  Cuando se prepara GRETL con soporte MPI, y el programa está
	  funcionando en modo MPI, devuelve el número de procesos MPI
	  que están funcionando en ese momento. En caso contrario, devuelve 0.
	</para>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Devuelve un número entero con la cantidad de coeficientes estimados
	  en el último modelo.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" output="int">
      <description>
	<para>
	  Devuelve un número entero con la cantidad total de observaciones que están
	  seleccionadas en la muestra vigente. Relacionado: <fncref targ="$tmax"/>.
	</para>
	<para>
	  En caso de datos de panel, el valor que se devuelve es el número de
	  observaciones combinadas (el número de unidades de sección cruzada
	  multiplicado por el número de períodos de tempo). Si quieres saber el
	  número de unidades de tiempo de un panel, utiliza <fncref targ="$pd"/>.
	  Y el número de unidades de sección cruzada incluidas puede obtenerse
	  mediante <lit>$nobs</lit> dividido por <lit>$pd</lit>.
	</para>
      </description>
    </function>

    <function name="$now" section="access" output="vector">
      <description>
	<para>
	  Devuelve un vector con 2 elementos: el primero indica el número
	  de segundos transcurridos desde el 01-01-1970 00:00:00 +0000
	  (UTC, ou Tempo Universal Coordinado), lo que se utiliza ampliamente
	  en el mundo de la informática para representar el tiempo vigente; y
	  el segundo indica la fecha vigente en formato <quote>básico</quote>
	  ISO 8601, <lit>YYYYMMDD</lit>. Puedes utilizar la función 
	  <fncref targ="strftime"/> para procesar el primer elemento, y la función
	  <fncref targ="epochday"/> para procesar el segundo elemento.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Devuelve un número entero con la cantidad de series incluidas en el
	  conjunto vigente de datos (contando con la constante). Dado que
	  <lit>const</lit> está siempre presente en cualquier conjunto de datos,
	  la obtención del valor 0 indica que no hay conjunto de datos. Observa
	  que al usar este accesorio dentro de una función, el número vigente de
	  series accesibles puede caer por debajo de lo indicado por <lit>$nvars</lit>.
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Puede ejecutarse cuando el conjunto vigente de datos está formado por
	  series temporales con frecuencia decenal, anual, trimestral, mensual,
	  fechadas semanalmente o fechadas diariamente. También puede utilizarse con
	  datos de panel si la información temporal está ajustada correctamente
	  (consulta la instrucción <cmdref targ="setobs"/>). Devuelve una serie
	  formada por números con 8 dígitos con el patrón <lit>YYYYMMDD</lit> (el
	  formato de datos <quote>básico</quote> del ISO 8601), que corresponden
	  al día de la observación, o al primer día de la observación en caso de una
	  frecuencia temporal menor que la diaria.
	</para>
	<para>
	  Estas series pueden resultar de utilidad cuando se emplea la instrucción
	  <cmdref targ="join"/>.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  Devuelve una serie que contiene la componente mayor (de menor
	  frecuencia) de cada observación. Esto significa el año para series
	  de tiempo anuales, trimestrales, mensuales, semanales o diarias; el
	  día para datos horarios; o el individuo en el caso de los datos de
	  panel. Si los datos son de sección cruzada, la serie que se devuelve
	  es simplemente el índice entero de las observaciones.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsminor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  Puede ejecutarse cuando las observaciones del conjunto vigente de datos
	  tienen una estructura mayor:menor:micro, como en las series temporales
	  fechadas diariamente (año:mes:día). Devuelve una serie que contiene la
	  componente micro (de mayor frecuencia) de cada observación (por
	  ejemplo, el día).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  Puede ejecutarse cuando las observaciones del conjunto vigente de datos
	  tienen una estructura mayor:menor, como en series temporales trimestrales
	  (año:trimestre), series temporales mensuales (año:mes), datos de horas
	  (día:hora) y datos de panel (individuo:período). Devuelve una serie
	  que contiene la componente menor (de mayor frecuencia) de cada
	  observación (por ejemplo, el mes).
	</para>
	<para>
	  En caso de datos fechados diariamente, <lit>$obsminor</lit> devuelve
	  una serie con el mes de cada observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>
    
    <function name="$panelpd" section="access" output="int">
      <description>
	<para>
	  Específico para datos de panel, devuelve un entero con la periodicidad
	  temporal (por ejemplo: 4 para datos trimestrales). Cuando no estableces
	  la periodicidad en el conjunto de datos de panel activo, devuelve 1 de
	  forma similar a <fncref targ="$pd"/> para datos de tipo atemporal o
	  sin fecha. Si el conjunto de datos no es de panel, se devuelve NA.
	</para>
	<para>
	  <seelist>
            <fncref targ="$pd"/>
            <fncref targ="$datatype"/>
            <cmdref targ="setobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$parnames" section="access" output="strings">
      <description>
	<para>
	  Después de la estimación de un modelo uniecuacional, devuelve
	  un 'array' de cadenas de texto que contienen los nombres de los
	  parámetros del modelo. El número de nombres coincide con el
	  número de elementos que tiene el vector <fncref targ="$coeff"/>.
	</para>
	<para>
	  Para los modelos especificados mediante una lista de regresores,
	  el resultado va a ser el mismo que el de
	</para>
	<code>
	  varnames($xlist)
	</code>
	<para>
	  (consulta la función<fncref targ="varnames"/>) pero la función
	  <lit>$parnames</lit> es más general; pues también funciona para
	  los modelos que no tienen una lista de regresores
	  (<cmdref targ="nls"/>, <cmdref targ="mle"/>, <cmdref targ="gmm"/>).
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Devuelve un número entero con la frecuencia o periodicidad de los datos
	  (por ejemplo: 4 para datos trimestrales). En caso de datos de panel, el
	  valor devuelto es la cantidad de períodos de tiempo del conjunto de datos.
	</para>
	<para>
	  <seelist>
            <fncref targ="$panelpd"/>
	  </seelist>
	  </para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Devuelve un escalar con el valor de &pi; con doble precisión.
	</para>
      </description>
    </function>

    <function name="$pkgdir" section="access" output="string">
      <description>
	<para>
	  Utilidad especial para ser utilizada por los autores de paquetes de
	  función. Devuelve una cadena de texto vacía excepto que se esté
	  ejecutando una función empaquetada, en cuyo caso devuelve la ruta
	  completa (dependiendo de la plataforma) a donde está instalado el
	  paquete. Por ejemplo, el valor devuelto podría ser...
	</para>
	<code>
	  /usr/share/gretl/functions/foo
	</code>
	<para>
	  en caso de que este fuese el directorio en el que está localizado
	  <lit>foo.gfn</lit>. Esto permite que el autor de un paquete de
	  función pueda acceder a recursos tales como archivos de matrices
	  que tenga incluidos en su paquete.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Devuelve la probabilidad asociada al valor del estadístico de prueba que
	  fue generado por la última instrucción explícita de contraste de hipótesis (por
	  ejemplo: <lit>chow</lit>). Consulta <guideref targ="chap:genr"/>
	  para obtener más detalles.
	</para>
	<para>
	  Generalmente devuelve un escalar, pero en algunos casos devuelve una
	  matriz (por ejemplo, esto ocurre con las probabilidades asociadas a los
	  valores de los estadísticos de la traza y del máximo-lambda del contraste de
	  cointegración de Johansen). En este caso, los valores están dispuestos en la
	  matriz del mismo modo que en los resultados presentados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$qlrbreak" section="access" output="scalar">
      <description>
	<para>
	  Debe ejecutarse después de la instrucción <cmdref targ="qlrtest"/> (que
	  permite hacer el contraste QLR para el cambio estructural en un punto
	  desconocido). Devuelve un escalar con el número entero positivo que indexa
	  la observación en la que se maximiza el valor del estadístico de contraste.
	</para>
      </description>
    </function>

    <function name="$result" section="access" output="matrix-or-bundle">
      <description>
	<para>
	  Proporciona información reservada, a continuación de algunas
	  instrucciones que no tienen accesorios específicos. Las instrucciones
	  en cuestión incluyen <cmdref targ="bds"/>, <cmdref targ="bkw"/>
    <cmdref targ="corr"/>, <cmdref targ="fractint"/>,
	  <cmdref targ="freq"/>, <cmdref targ="hurst"/>, <cmdref targ="leverage"/>,
	  <cmdref targ="summary"/>, <cmdref targ="vif"/> y <cmdref targ="xtab"/>
	  (en cuyos casos, el resultado es una matriz), además de
	  <cmdref targ="pkg"/> (en cuyo caso, se guarda opcionalmente un 'bundle').
	</para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Sin argumentos, este accesor devuelve el coeficiente de autocorrelación
	  de primer orden para los errores del último modelo estimado. Ahora bien,
	  con la sintaxis <lit>$rho(n)</lit> después de la estimación de un modelo por medio
	  de la instrucción <lit>ar</lit>, devuelve el valor estimado correspondiente
	  al coeficiente &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Si puede calcularse, devuelve un escalar con el valor del coeficiente
	  <math>R</math><sup>2</sup> no corregido del último modelo estimado. 
	  En general, este será el <math>R</math><sup>2</sup> habitual (centrado),
	  pero si la especificación del modelo no contiene una constante (ni un
	  conjunto de regresores cuya <quote>suma</quote> resulte ser constante),
	  entonces será la versión no centrada. En ese caso, puedes acceder a la
	  versión centrada por medio de <lit>$model.centered_R2</lit>.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Debe ejecutarse después de estimar un modelo de una sola ecuación. Devuelve
	  una serie con una variable ficticia que tiene valores iguales a: 1 en las
	  observaciones utilizadas en la estimación, 0 en las observaciones de la muestra
	  vigente no utilizadas en la estimación (posiblemente debido a valores
	  ausentes), y NA en las observaciones fuera de la muestra vigente seleccionada.
	</para>
	<para>
	  Si deseas calcular estadísticos basados en la muestra que se utiliza
	  para un modelo dado, puede hacerse, por ejemplo con el código:
	</para>
	<code>
	  ols y 0 xlist
	  series sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Debe ejecutarse después de la instrucción <lit>tsls</lit>. Devuelve un vector
	  fila <by r="1" c="3"/> que contiene, en este orden: el valor del estadístico
	  del contraste de Sobreidentificación de Sargan, los correspondientes grados
	  de libertad y la probabilidad asociada al valor del estadístico. Si el
	  modelo está exactamente identificado, el estadístico no se puede
	  calcular y tratar de hacerlo provoca un fallo.
	</para>
      </description>
    </function>

    <function name="$seed" section="access" output="scalar">
      <description>
	<para>
	  Devuelve un escalar con el valor de la semilla del generador de
	  números aleatorios de GRETL. Si estableces la semilla por ti mismo,
	  este accesor no es necesario; pero puede resultar interesante
	  cuando la semilla se establece automáticamente (basándose
	  en el momento en que empezó la ejecución del programa).
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Si el último modelo estimado fue uniecuacional, devuelve un escalar con la
	  Desviación Típica de la regresión (S, o en otras palabras, la desviación
	  típica de los errores del modelo con la oportuna corrección de los grados de
	  libertad). Si el último modelo estimado fue un sistema de ecuaciones,
	  devuelve una matriz con las varianzas-covarianzas de los errores de las ecuaciones
	  del sistema.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">nombre</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando se utiliza sin argumentos, <lit>$stderr</lit> devuelve un vector
	  columna que contiene las desviaciones típicas de los coeficientes del último
	  modelo estimado. Con el argumento opcional <lit>(nombre de un regresor)</lit>
	  devuelve un escalar con el valor del parámetro estimado de ese regresor
	  <argname>s</argname>.
	</para>
	<para>
	  Si el <quote>modelo</quote> es un sistema de ecuaciones, el resultado
	  depende de las características de este: para VARs y VECMs, el valor devuelto
	  es una matriz que contiene una columna por cada ecuación; en otro caso,
	  es un vector columna que contiene los coeficientes de la primera ecuación
	  seguidos por los coeficientes de la segunda ecuación y así
	  sucesivamente.
	</para>
	<para>
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Debe ejecutarse después de la instrucción <lit>set stopwatch</lit> que activa
	  la medición de tiempo de la CPU. Al usar este accesor por primera vez
	  se obtiene un escalar con la cantidad de segundos de CPU que pasaron desde
	  la instrucción <lit>set stopwatch</lit>. Con cada acceso, se reinicia el
	  reloj, por lo que las sucesivas utilizaciones de <lit>$stopwatch</lit>
	  generan cada vez un escalar indicativo de los segundos de CPU desde el acceso previo.
	</para>
	<para>
	  Cuando una función definida por el usuario está en ejecución, al usar la
	  instrucción <lit>set stopwatch</lit> y el accesor <lit>$stopwatch</lit>,
	  estos resultan específicos para esa función &mdash;es decir, la medición
	  del tiempo dentro de una función no interrumpe cualquier medición
	  <quote>global</quote> que pueda estar haciéndose en un guion principal.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de estimar un sistema de ecuaciones simultáneas.
	  Devuelve la matriz con los coeficientes de las variables endógenas retardadas
	  (en caso de que existan), en la forma estructural del sistema. Consulta
	  también la instrucción <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de estimar un sistema de ecuaciones simultáneas.
	  Devuelve una matriz con los coeficientes de las variables exógenas, en la forma
	  estructural del sistema. Consulta la instrucción
	  <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de estimar un sistema de ecuaciones simultáneas.
	  Devuelve una matriz con los coeficientes de las variables endógenas
	  contemporáneas, en la forma estructural del sistema. Consulta la instrucción
	  <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
	<para>
	  Devuelve un <quote>bundle</quote> que contiene información de las
	  capacidades de GRETL y del sistema operativo en el que se está ejecutando.
	  Los elementos del 'bundle' se indican a continuación:
	</para>
	<ilist>
	  <li>
	          <para>
	            <lit>gui_mode</lit>: número entero igual a 1 si libgretl
	            está siendo invocado por el programa GUI, y 0 en caso contrario.
	          </para>
	  </li>
	  <li>
            <para>
              <lit>mpi</lit>: número entero igual a 1 si el sistema admite
              MPI (Interfaz de Paso de Mensajes), y 0 en caso contrario.
            </para>
	  </li>
	  <li>
            <para>
              <lit>omp</lit>: número entero igual a 1 si GRETL se compiló
              con soporte para Open MP, y 0 en caso contrario.
            </para>
	  </li>
	  <li>
            <para>
              <lit>ncores</lit>: número entero que indica el número de
              núcleos físicos de procesador disponibles.
            </para>
	  </li>
	  <li>
            <para>
              <lit>nproc</lit>: número entero que indica el número
              de procesadores disponibles, y que será mayor que
              <lit>ncores</lit> si está habilitado el Hyper-threading.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mpimax</lit>: número entero que indica el máximo número
              de procesos MPI que pueden ejecutarse en paralelo. Es igual a
              cero si no se admite MPI; en caso contrario, es igual al valor de
              <lit>nproc</lit> local, excepto que se especifique un archivo
              de hosts MPI, caso en el que es igual a la suma del número de
              procesadores o <quote>slots</quote> a lo largo de todas las
              máquinas a las que se hace referencia en el archivo.
            </para>
	  </li>
	  <li>
            <para>
              <lit>wordlen</lit>: número entero igual a 32 o a 64 en
              sistemas de 32 bit y 64 bit, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              <lit>os</lit>: cadena de texto que representa el sistema
              operativo, bien <lit>linux</lit>, <lit>macos</lit>,
              <lit>windows</lit> o <lit>outro</lit>. Ten en cuenta que
              las versiones de GRETL previas a la '2021e' proporcionan
              la cadena <lit>osx</lit> para el sistema operativo de Mac;
              por lo tanto, una expresión de comprobación para Mac
              independiente de la versión es <lit>instring($sysinfo.os, "os")</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>hostname</lit>: cadena de texto con el nombre de la máquina (o
              <quote>host</quote>) en la que se está ejecutando el proceso vigente
              de GRETL. Si no es posible determinar el nombre, se produce
              una vuelta atrás del <lit>localhost</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mem</lit>: un vector bidimensional que contiene la memoria
              física total, y la memoria libre o disponible, expresadas en
              MB. Esta información puede no estar disponible en todos los
              sistemas, pero debiera estarlo en Windows, macOS y Linux.
            </para>
	  </li>
	  <li>
	          <para>
              <lit>blas</lit>: cadena de texto que identifica el proveedor de
              la biblioteca BLAS (Subprogramas Básicos de Álgebra Lineal)
              que utiliza GRETL.
            </para>
	  </li>
	  <li>
	          <para>
              <lit>blas_version</lit>: cadena de texto que identifica el
              número de la versión de la biblioteca BLAS que se utiliza.
            </para>
	  </li>
	  <li>
	          <para>
              <lit>blascore</lit>: (si es aplicable) una cadena de texto que
              identifica el tipo de CPU para el que está optimizada la
              biblioteca BLAS vigente.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>compiler</lit>: una cadena de texto que identifica el
              compilador utilizado al generar libgretl.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>cpuid</lit>: una cadena de texto que identifica el vendedor
              y el modelo de la CPU en la que está ejecutándose libgretl.
            </para>
	  </li>
	  <li>
	    <para>
              <lit>gnuplot</lit>: una cadena de texto que identifica la
              versión disponible de Gnuplot para que GRETL haga gráficos,
              con formato de 3 números separados por puntos que indican
              la versión principal, la versión secundaria y el nivel de parche.
            </para>
	  </li>
	  <li>
            <para>
              <lit>foreign</lit>: un sub-bundle que contiene indicadores 0/1
              para mostrar la presencia en el sistema, de cada uno de los
              programas <quote>externos</quote> que admite GRETL
              bajo las claves <lit>julia</lit>, <lit>octave</lit>,
              <lit>ox</lit>, <lit>python</lit>, <lit>Rbin</lit>,
              <lit>Rlib</lit> y <lit>stata</lit>. Las dos claves que
              corresponden a R representan respectivamente, el
              ejecutable de R y la biblioteca compartida.
            </para>
	  </li>
	</ilist>
	<para>
	  Fíjate en que puedes acceder a elementos individuales del 'bundle'
	  mediante la notación del<quote>punto</quote>, sin necesidad de copiar el
	  'bundle' entero con un nombre de usuario específico. Por ejemplo con el código:
	</para>
	<code>
	  if $sysinfo.os == "linux"
	      # Haga algo que sea propio del Linux
	  endif
	</code>
      </description>
    </function>

    <function name="$system" section="access" output="bundle">
      <description>
	<para>
	  Debe seguir a la estimación de un sistema de ecuaciones, realizada
	  con la instrucción <cmdref targ="system"/>, con <cmdref targ="var"/> o
	  con <cmdref targ="vecm"/>; y devuelve un 'bundle' que contiene muchos
	  apartados de datos que se refieren al sistema. Se incluyen todos
	  los accesores importantes y habituales del sistema, que se nombran
	  mediante símbolos clave que son idénticos a los nombres habituales
	  de los accesores, menos el símbolo de dólar inicial. Así, por ejemplo,
	  los errores aparecen bajo la clave <lit>uhat</lit> y los coeficientes
	  bajo <lit>coeff</lit>. (Como excepciones están las claves <lit>A</lit>,
	  <lit>B</lit>, e <lit>Gamma</lit>, que se corresponden con los accesores
	  habituales sysA, sysB, y sysGamma.)
	  Las claves para obtener información adicional
	  se espera que debieran explicarse suficientemente por si mismas.
	  Para comprobar lo que tienes a tu disposición, puedes obtener una copia
	  del 'bundle' y representar su contenido, como en
	</para>
	<code>
	  var 4 y1 y2 y2
	  bundle b = $system
	  print b
	</code>
	<para>
	  Puedes pasar un 'bundle' obtenido de este modo como argumento
	  final (opcional) de las funciones <fncref targ="fevd"/> e
	  <fncref targ="irf"/>.
	</para>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Devuelve un número entero con el número de observaciones utilizadas en la
	  estimación del último modelo.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Devuelve un entero positivo con el número que indexa la primera
	  observación de la muestra vigente seleccionada.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Devuelve un entero positivo con el número que indexa la última
	  observación de la muestra vigente seleccionada.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Devuelve el valor del estadístico de prueba que fue generado por la última
	  instrucción explícita para un contraste de hipótesis (por ejemplo:
	  <lit>chow</lit>). Consulta <guideref targ="chap:genr"/> para
	  obtener más detalles.
	</para>
	<para>
	  Generalmente devuelve un escalar, pero en algunos casos devuelve una
	  matriz (por ejemplo, eso ocurre con los estadísticos de la traza y del
	  máximo-lambda del contraste de cointegración de Johansen). En este caso,
	  los valores están dispuestos en la matriz del mismo modo que en los
	  resultados presentados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$time" section="access" output="series">
      <description>
	<para>
	  Para datos de series temporales o de panel, genera un índice con
	  enteros positivos del período temporal. En el caso del panel, la
	  secuencia de valores se repite para cada unidad de sección cruzada.
	</para>
	<para>
	  La instrucción <quote><lit>genr time</lit></quote> es una alternativa,
	  con la diferencia de que la variante <lit>genr</lit> genera de modo
	  automático una serie denominada <lit>time</lit>, mientras que la
	  denominación de la serie corresponde al solicitante cuando se
	  utiliza <lit>$time</lit>, como en
	</para>
	<code>
	  series trend = $time
	</code>
	<para>
	  Este accesor no está disponible para datos de sección cruzada.
	</para>
      </description>
    </function>

    <function name="$tmax" section="access" output="int">
      <description>
	<para>
	  Devuelve un entero con el máximo valor válido establecido para indicar el
	  final del rango de la muestra mediante la instrucción <cmdref targ="smpl"/>.
	  En la mayoría de los casos, esto va a ser igual al número de observaciones del
	  conjunto de datos; pero en una función de HANSL, el valor <lit>$tmax</lit>
	  podría ser menor, puesto que el acceso habitual a los datos dentro de las
	  funciones, se limita al rango muestral establecido por el solicitante.
	</para>
	<para>
	  Ten en cuenta que, en general, <lit>$tmax</lit> no es igual
	  a <fncref targ="$nobs"/>, que proporciona el número de
	  observaciones del rango de la muestra vigente.
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Devuelve el escalar <math>TR</math><sup>2</sup> (el tamaño de la muestra
	  multiplicado por el R-cuadrado del último modelo), si está disponible.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Devuelve una serie con los errores del último modelo estimado. Esto puede tener
	  diferentes significados dependiendo de los estimadores utilizados. Por
	  ejemplo, después de la estimación de un modelo ARMA, <lit>$uhat</lit> contiene
	  los errores de la predicción adelantados 1 paso; después de la estimación de un
	  probit, contiene los errores generalizados.
	</para>
	<para>
	  Cuando el <quote>modelo</quote> vigente en cuestión es un sistema de
	  ecuaciones (un VAR, un VECM o un sistema de ecuaciones simultáneas),
	  el <lit>$uhat</lit> genera una matriz con los errores de estimación de cada
	  ecuación, ordenados por columnas.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Solo es válido para datos de panel. Devuelve una serie con valor igual a
	  1 en todas las observaciones en la primera unidad o grupo, 2 en todas las
	  observaciones en la segunda unidad o grupo, y así sucesivamente.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">nombre1</fnarg>
	<fnarg optional="true" type="coeffname">nombre2</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando se utiliza sin argumentos, <lit>$vcv</lit> devuelve una matriz
	  cuadrada que contiene las varianzas-covarianzas estimadas de los coeficientes
	  del último modelo estimado. Si este último era uniecuacional, se pueden
	  indicar los nombres de dos regresores entre paréntesis, para así obtener
	  un escalar con la covarianza estimada entre <argname>nombre1</argname> y
	  <argname>nombre2</argname>.
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  Este accesor no está disponible para VARs o VECMs. Para modelos
	  de ese tipo <fncref targ="$sigma"/> y <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de estimar un VECM y devuelve una matriz en la que
	  las matrices Gamma (con los coeficientes de las diferencias retardadas de las
	  variables cointegradas) se agrupan unas al lado de las otras. Cada fila
	  indica una ecuación; para un VECM con nivel de retardo <math>p</math>
	  existen <math>p</math> &minus; 1 submatrices.
	</para>
      </description>
    </function>

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Devuelve un escalar con un valor entero que designa la versión de GRETL.
	  La versión actual de GRETL está formada por una cadena de texto que
	  indica el año con formato de 4 dígitos seguido de una letra desde a hasta
	  j, que representa las sucesivas actualizaciones dentro de cada año (por
	  ejemplo, 2015d). El valor devuelto por este accesor está calculado
	  multiplicando el año por 10, y sumándole un número que representa a la
	  letra, en el orden léxico en base cero. Así, 2015d se representa mediante
	  20153.
	</para>
	<para>
	  En versiones anteriores al GRETL 2015d, el identificador tenía el siguiente
	  formato: x.y.z (tres números enteros separados por puntos); en ese caso,
	  el valor de la función se calculaba con <lit>10000*x + 100*y + z</lit>. Por
	  ejemplo, la última versión con el formato antiguo (1.10.2) se transcribía
	  mediante 11002. De este modo el orden numérico de <lit>$version</lit> fue
	  preservado aún después de cambiar el esquema de las versiones.
	</para>
      </description>
    </function>

    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse después de estimar un VAR o un VECM, y devuelve una
	  matriz que contiene la representación VMA hasta el orden especificado por
	  medio de la instrucción <lit>set horizon</lit>. Para tener más detalles,
	  consulta <guideref targ="chap:var"/>.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Devuelve un número entero con el valor 1 si GRETL se está ejecutando en Windows,
	  y 0 en caso contrario. Poniendo como condición uno de estos valores, puedes escribir instrucciones
	  <quote>shell </quote> que puedan ejecutarse en diferentes sistemas operativos.
	</para>
	<para>
	  Consulta también la instrucción <cmdref targ="shell"/>.
	</para>
      </description>
    </function>

    <function name="$workdir" section="access" output="string">
      <description>
	<para>
	  Este accesor devuelve una cadena de texto con la ruta desde la que lee
	  y en la que escribe GRETL por defecto. Se ofrece una discusión más
	  detallada en la Guía de instrucciones, en <cmdref targ="workdir"/>.
	  Ten en cuenta que el usuario puede determinar esta cadena mediante
	  la instrucción <cmdref targ="set"/>.
        </para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  Si el último modelo estimado era uniecuacional, este accesor va a
	  devolver una lista con sus regresores. Si el último modelo era un
	  sistema de ecuaciones, devuelve una lista <quote>global</quote>
	  con las variables exógenas (en el mismo orden en el que aparecen
	  con el accesor <fncref targ="$sysB"/>). Si el último modelo era un
	  VAR, devuelve una lista con los regresores exógenos (si hay alguno),
	  con excepción de los términos determinísticos habituales (la
	  constante, la tendencia y los elementos estacionales).
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Debe ejecutarse únicamente después de la estimación de un VAR o VECM, y
	  devuelve la matriz <math>X'X</math><sup>-1</sup>, donde <math>X</math>
	  es la matriz habitual con los regresores utilizados en cada ecuación.
	  Aunque este accesorio está disponible para un VECM estimado con
	  una restricción impuesta en &agr; (la matriz de <quote>cargas</quote>),
	  debe tenerse en cuenta que en ese caso no todos los coeficientes de
	  los regresores varían libremente.
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Devuelve una serie con los valores estimados de la variable explicada de la última regresión.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  Si el último modelo estimado fue un VAR, un VECM o un sistema
	  de ecuaciones simultáneas, este accesor devuelve una lista con las
	  variables endógenas. Si el último modelo estimado fue uniecuacional,
	  el accesor devuelve una lista con un único elemento, la variable dependiente.
	  En el caso especial del modelo biprobit, la lista contiene dos
	  elementos.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Built-in strings" ref="string_constants">

    <function name="$dotdir" section="straccess" output="string">
      <description>
        <para>
          Proporciona una cadena de texto con la ruta completa del directorio que
          utiliza GRETL para los archivos temporales. Para usarla en modo de
          sustitución para cadenas de texto, antepón el símbolo arroba (@dotdir).
        </para>
        </description>
    </function>

    <function name="$gnuplot" section="straccess" output="string">
        <description>
        <para>
          Proporciona una cadena de texto con la ruta hasta el ejecutable 'gnuplot'. Para
          usarla en modo de sustitución para cadenas, antepón el símbolo arroba (@gnuplot).
        </para>
        </description>
    </function>

    <function name="$gretldir" section="straccess" output="string">
        <description>
        <para>
          Proporciona una cadena de texto con la ruta completa al directorio
          de instalación de GRETL. Para usarla en modo de substitución para
          cadenas de texto, antepón el símbolo arroba (@gretldir).
        </para>
        </description>
    </function>

    <function name="$tramo" section="straccess" output="string">
        <description>
        <para>
          Proporciona una cadena de texto con la ruta hasta el ejecutable 'tramo'. Para
          usarla en modo de sustitución para cadenas, antepón el símbolo arroba (@tramo).
        </para>
        </description>
    </function>

    <function name="$tramodir" section="straccess" output="string">
        <description>
        <para>
          Proporciona una cadena de texto con la ruta hasta el directorio de datos de 'tramo'. Para
          usarla en modo de sustitución para cadenas, antepón el símbolo arroba (@tramodir).
        </para>
        </description>
    </function>

    <function name="$x12a" section="straccess" output="string">
        <description>
        <para>
          Proporciona una cadena de texto con la ruta hasta el ejecutable 'x-12-arima'. Para usarla
          en modo de sustitución para cadenas, antepón el símbolo arroba (@x12a).
        </para>
        </description>
    </function>

    <function name="$x12adir" section="straccess" output="string">
        <description>
        <para>
          Proporciona una cadena de texto con la ruta hasta el directorio de datos de 'x-12-arima'. Para
          usarla en modo de sustitución para cadenas, antepón el símbolo arroba (@x12adir).
        </para>
        </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el valor absoluto de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con los radianes del arco
	  coseno de <argname>x</argname>; es decir, proporciona el arco cuyo coseno es
	  <argname>x</argname> (el argumento debe estar entre &minus;1 y 1).
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el coseno hiperbólico
	  inverso de <argname>x</argname> (solución positiva). Este último
	  debe ser mayor que 1, pues de lo contrario la función devolverá NA.
	  <seelist>
            <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-list-or-mat">x</fnarg>
	<fnarg type="series-list-or-mat">segunvar</fnarg>
	<fnarg type="string" optional="true">nombrefunc</fnarg>
      </fnargs>
      <description>
	<para>
	  La mayor parte de lo que sigue asume que los dos primeros argumentos de
	  esta función toman la forma de series o listas, pero consulta la sección
	  <quote>Entrada matricial</quote> de abajo para un uso alternativo.
	</para>
	<para>
	  En la forma más simple de uso de esta función, <argname>x</argname>
	  se establece igual a <lit>null</lit>, <argname>segunvar</argname> es
	  una serie individual y el tercer argumento se omite (o se establece
	  igual a cero). En este caso, se devuelve una matriz con dos columnas
	  que contiene: los distintos valores de <argname>segunvar</argname>
	  ordenados de forma creciente en la primera columna, y el número de
	  observaciones en las que <argname>segunvar</argname> toma cada uno
	  de esos valores. Por ejemplo...
	</para>
	<code>
	  open data4-1
	  eval aggregate(null, bedrms)
	</code>
	<para>
	  ... mostrará que la serie <lit>bedrms</lit> tiene los valores
	  3 (en total 5 veces) y 4 (en total 9 veces).
	</para>
	<para>
	  De modo más general, si <argname>segunvar</argname> es una lista con
	  <math>n</math> elementos, entonces las <math>n</math> columnas a la
	  izquierda contienen las combinaciones de los distintos valores de cada
	  una de las <math>n</math> series, y la columna de recuento contiene
	  el número de observaciones en las que se produce cada combinación.
	  Observa que siempre puedes encontrar la columna de recuento en la
	  posición <lit>nelem(segunvar) + 1</lit>.
	</para>
	<subhead>Especificar una función de agregación</subhead>
	<para>
	  Cuando indicas el tercer argumento, entonces <argname>x</argname>
	  no debe ser <lit>null</lit>, y las <math>m</math> columnas más a
	  la derecha van a contener los valores del estadístico especificado
	  por <argname>nombrefunc</argname> para cada una de las variables
	  en <argname>x</argname>. (De este modo, <math>m</math> se iguala
	  a 1 cuando <argname>x</argname> es una única serie, y se iguala a
	  <lit>nelem(x)</lit> cuando <argname>x</argname> es una lista.)
	  El estadístico indicado se calcula en las submuestras respectivas
	  que estén definidas por medio de las combinaciones indicadas en
	  <argname>segunvar</argname> (en orden ascendente); estas
	  combinaciones se muestran en la(s) primera(s) <math>n</math>
	  columna(s) de la matriz que se devuelve.
	</para>
	<para>
	  Entonces, en el caso especial en el que <argname>x</argname> y
	  <argname>segunvar</argname> son ambas series individuales, el
	  valor que se devuelve es una matriz con tres columnas
	  que va a contener respectivamente: los distintos valores de
	  <argname>segunvar</argname> ordenados de forma creciente, el número
	  de observaciones en las que <argname>segunvar</argname> toma cada
	  uno de esos valores, y los valores del estadístico que especifica la
	  función <argname>nombrefunc</argname>, calculado para la serie
	  <argname>x</argname>, pero usando tan solo aquellas observaciones
	  en las que <argname>segunvar</argname> toma el mismo valor que se
	  especifica en la primera columna de la matriz.
	</para>
	<para>
	  Las siguientes opciones de <argname>nombrefunc</argname> se mantienen
	  de forma <quote>original</quote>: <fncref targ="sum"/>,
	  <fncref targ="sumall"/>, <fncref targ="mean"/>, <fncref targ="sd"/>,
	  <fncref targ="var"/>, <fncref targ="sst"/>, <fncref targ="skewness"/>,
	  <fncref targ="kurtosis"/>, <fncref targ="min"/>, <fncref targ="max"/>,
	  <fncref targ="median"/>, <fncref targ="nobs"/> y <fncref targ="gini"/>,
	  <fncref targ="isconst"/> e <fncref targ="isdummy"/>.
	  Cada una de estas funciones utiliza una serie como argumento y
	  devuelve un valor escalar; por eso, en este sentido, puede decirse que
	  de algún modo <quote>agregan</quote> la serie. Si no hay ninguha de
	  estas funciones originales que haga lo que necesitas, puedes utilizar
	  una función definida por el usuario como <quote>agregador</quote>;
	  en ese caso, del mismo modo que las funciones originales, esa función
	  debe tener como argumento únicamente una serie, y devolver un
	  valor escalar.
	</para>
	<para>
	  Ten en cuenta que, a pesar de que <lit>aggregate</lit> hace el
	  recuento de casos de forma automática, la opción <lit>nobs</lit>,
	  no es redundante como función <quote>agregadora</quote>, puesto que
	  proporciona el número de observaciones válidas (no ausentes) de
	  <argname>x</argname> en cada combinación de <argname>segunvar</argname>.
	</para>
	<para>
	  Como ejemplo sencillo, supón que con <lit>region</lit> se definen
	  unos códigos para representar una distribución geográfica por regiones,
	  utilizándose para ello enteros desde 1 hasta <math>n</math>, y que
	  con <lit>renta</lit> se representa la renta de los hogares. Entonces el
	  código indicado a continuación debe producir una matriz de orden
	  <by r="n" c="3"/> que contiene los códigos de las regiones, el recuento de
	  observaciones de cada una, y la renta media de los hogares en cada una:
	</para>
	<code>
	  matrix m = aggregate(renta, region, mean)
	</code>
	<para>
	  Como ejemplo de utilización con listas de variables, sea
	  <lit>genero</lit> una variable binaria hombre/mujer, sea
	  <lit>raza</lit> una variable categórica con tres valores, y
	  considera el siguiente código:
	</para>
	<code>
	  list BY = genero raza
	  list X = renta edad
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  Invocar la función <lit>aggregate</lit> producirá una matriz de
	  orden <by r="6" c="5"/>. En las dos primeras columnas se expresan las
	  6 distintas combinaciones de los valores de 'genero' y 'raza'; la columna
	  del medio contiene el recuento del número de casos para cada una de esas
	  combinaciones; y las dos columnas más a la derecha contienen las
	  desviaciones típicas muestrales de <lit>renta</lit> y <lit>edad</lit>.
	</para>
	<para>
	  Observa que si <argname>segunvar</argname> es una lista de variables,
	  algunas combinaciones de los valores de <argname>segunvar</argname> pueden
	  no estar presentes en los datos (produciéndose un recuento igual a cero).
	  En ese caso, los valores de los estadísticos para <argname>x</argname> se
	  registran como <lit>NaN</lit> (es decir, no son números). Si quieres
	  ignorar esos casos, puedes usar la función <fncref targ="selifr"/> para
	  escoger solo aquellas filas que no tengan recuento igual a cero. La columna
	  a comprobar estará una posición a la derecha de la indicada por el número de
	  variables de <argname>segunvar</argname>, por lo que puede usarse el código:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
	<subhead>Entrada matricial</subhead>
	<para>
	  En lugar de indicar <argname>x</argname> y <argname>segunvar</argname>
	  como series o listas, puedes indicarlas en formato matricial. Ahora bien,
	  si indicas los dos argumentos, deben coincidir en el mismo tipo (no
	  puedes indicar una serie o una lista para uno de los argumentos, y una
	  matriz para el otro); además, dos argumentos de tipo matricial
	  deberán tener el mismo número de filas. Ten en cuenta también, que en
	  este contexto se trata a las columnas de las matrices como si fuesen
	  series, por ello la función de agregación del tercer argumento (opcional)
	  deberá seguir el mesmo patrón descrito más arriba, tomando un
	  argumento de tipo serie y devolviendo un escalar.
	</para>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string" optional="true">pordefecto</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>s</argname> es el nombre de un parámetro hacia una función
	  definida previamente por el usuario, devuelve una cadena de texto con
	  el nombre del argumento correspondente (si este tiene un nombre a nivel
	  de la llamada). Si el argumento es anónimo, se devuelve una cadena vacía
	  excepto que indiques el argumento opcional <argname>pordefecto</argname>,
	  en cuyo caso se utiliza su valor como alternativa.
	</para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta es la función <quote>generadora</quote> básica de una nueva variable
	  de tipo <quote>array</quote>. Al usar esta función es necesario que
	  especifiques un tipo (en forma plural) para el 'array':
	  <lit>strings</lit>, <lit>matrices</lit>, <lit>bundles</lit>,
	  <lit>lists</lit> o <lit>arrays</lit>. Devuelve un 'array' del tipo
	  especificado con <argname>n</argname> elementos <quote>vacíos</quote>
	  (por ejemplo, una cadena de texto (<quote>string</quote>) vacía o
	  una matriz nula). Ejemplos de utilización:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  Consulta también <fncref targ="defarray"/>.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con los radianes del arco
	  seno de <argname>x</argname>; es decir, proporciona el arco cuyo seno es
	  <argname>x</argname> (el argumento debe estar entre &minus;1 y 1).
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el seno hiperbólico inverso de <argname>x</argname>.
	  <seelist>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="asort" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="array">a</fnarg>
	<fnarg type="string">nombrefun</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza una reordenación inmediata de los elementos del argumento
	  <argname>a</argname>, usando una función de comparación especificada
	  por el solicitante bajo el control de la rutina de ordenación rápida.
	</para>
	<para>
	  El argumento <argname>a</argname> puede ser de cualquiera de los tipos
	  que se admiten para un 'array' de GRETL; en concreto <lit>strings</lit>
	  (cadenas), <lit>matrices</lit>, <lit>bundles</lit> (paquetes),
	  <lit>lists</lit> (listas) o <lit>arrays</lit> (ordenaciones). El argumento
	  <argname>nombrefun</argname> debe ser el nombre de una función que tome
	  dos argumentos <lit>const</lit>, cuyo tipo coincida con el tipo de los
	  elementos de <argname>a</argname>. Esta función debe devolver un valor
	  entero con el siguiente patrón de comportamiento: 0 cuando los dos argumentos
	  tengan el mesmo orden de clasificación, negativo cando el primero
	  argumento clasifique antes que el segundo, o positivo cuando el segundo
	  clasifique antes que el primero. (Los valores exactos non importan.)
	</para>
	<para>
	  Por ejemplo, supón que quieres ordenar un 'array' de 'bundles', en los
	  que cada uno de ellos contiene un escalar denominado <lit>crit</lit>,
	  en función del valor creciente de <lit>crit</lit>. Entonces, la siguiente
	  función sería adecuada para usarla con <lit>asort</lit>:
	</para>
	<code>
	  function scalar my_bsort (const bundle b1, const bundle b2)
	     return b1.crit - b2.crit
	  end function
	</code>
	<para>
	  Si deseas preservar el 'array' sin ordenar, haz una copia de él antes
	  de usarlo con <lit>asort</lit>. El valor que devuelve esta función
	  cuando tiene éxito, es un 0.
	</para>
	<para>
	  Consulta también la función <fncref targ="sort"/> para una ordenación
	  sencilla de un 'array' de cadenas de texto.
	</para>
      </description>
    </function>

    <function name="assert" section="programming" output="scalar">
      <fnargs>
	<fnarg type="scalar">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función está dirigida a comprobar y depurar código HANSL.
	  Su argumento habrá de ser una expresión cuyo valor sea un
	  escalar. El valor que devuelve esta función es, o bien 1 cuando
	  el valor del argumento <argname>expr</argname> no es cero
	  (<quote>verdadero</quote> booleano o <quote>éxito</quote>),
	  o bien 0 si el valor del argumento es cero (<quote>falso</quote>
	  booleano o <quote>fallo</quote>).
	</para>
	<para>
	  Por defecto, no hay otras consecuencias de que falle una llamada
	  a <lit>assert</lit>, más que el hecho de que el valor que se
	  devuelve es cero. Sin embargo, puedes utilizar la instrucción
	  <cmdref targ="set"/> para hacer que el fallo de una afirmación
	  tenga más consecuencias. Hay tres niveles:
	</para>
	<code>
	  # Presentar un mensaje de aviso, pero continuar con la ejecución
	  set assert warn
	  # Presentar un mensaje de aviso y detener la ejecución de un guion
	  set assert stop
	  # Presentar un mensaje a 'stderr' y abortar el programa
	  set assert fatal
	</code>
	<para>
	  En la mayoría de los casos <lit>stop</lit> es suficiente para detener
	  la ejecución de un guion, pero en ciertos casos especiales (como
	  dentro de una función invocada desde un bloque de instrucciones tal
	  como en <cmdref targ="mle"/>), puede resultar necesario utilizar la
	  opción <lit>fatal</lit> para alcanzar una indicación clara de la
	  afirmación que falla. Sin embargo, observa que en este caso el mensaje
	  va a dirigirse a la salida de resultados del error típico.
	</para>
	<para>
	  Puedes restablecer el funcionamiento por defecto mediante
	</para>
	<code>
	  set assert off
	</code>
	<para>
	  A modo de sencillo ejemplo:
	  Si en cierto punto de un guion HANSL, un escalar <lit>x</lit> debe ser
	  no negativo, el siguiente código mostrará un error si este no es el caso:
	</para>
	<code>
	  set assert stop
	  assert(x >= 0)
	</code>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con los radianes del arco tangente de
	  <argname>x</argname>; es decir, devuelve el arco cuya tangente es <argname>x</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="tan"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el valor principal
	  de la arco tanxente de <argname>y</argname>/<argname>x</argname>,
	  utilizando los signos de los dos argumentos indicados para determinar
	  el cuadrante del resultado. El valor que se devuelve está en radianes,
	  dentro del rango [&minus;&pi;, &pi;].
	</para>
	<para>
	  Si los dos argumentos son de tipos difirentes, el tipo del resultado
	  es el mismo que el del <quote>mayor</quote> de los dos, donde la jerarquía
	  es matriz &gt; serie &gt; escalar. Por ejemplo, si <argname>y</argname>
	  es un escalar, y <argname>x</argname> es un vector de dimensión
	  <math>n</math> (o viceversa), el resultado es un vector de dimensión
	  <math>n</math>. Ten en cuenta que los argumentos de una matriz
	  deben ser vectores; y que, si ningún argumento es un escalar, los dos
	  argumentos deben ser de la misma longitud.
	</para>
	<para>
	  <seelist>
            <fncref targ="tan"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con la tangente hiperbólica inversa de <argname>x</argname>.
	  <seelist>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Función muy relacionada con la del lenguaje de programación C con el mismo nombre.
	  Devuelve un escalar con el resultado de convertir la cadena de texto
	  <argname>s</argname> (o su trozo relevante después de descartar
	  cualquier espacio inicial en blanco) en un número de punto flotante.
	  A diferencia de lo que ocurre en el lenguaje C, la función <lit>atof</lit>
	  siempre asume que el carácter decimal es el <quote><lit>.</lit></quote>
	  (por cuestiones de portabilidad). Se ignoran todos los caracteres
	  que siguen después de la parte de <argname>s</argname> que se convierte en
	  número de punto flotante.
	</para>
	<para>
	  Si, bajo el supuesto establecido, no pudiera convertirse ninguno de los
	  caracteres de <argname>s</argname> que queden después de descartar
	  los espacios en blanco, la función devuelve <lit>NA</lit>.
	</para>
	<code>
	  # Ejemplos:
	  x = atof("1.234") # Devuelve x = 1,234
	  x = atof("1,234") # Devuelve x = 1
	  x = atof("1.2y")  # Devuelve x = 1,2
	  x = atof("y")     # Devuelve x = NA
	  x = atof(",234")  # Devuelve x = NA
	</code>
	<para>
	  Consulta también <fncref targ="sscanf"/> si quieres tener mayor
	  flexibilidad en las conversiones de cadenas de texto en números.
	</para>
      </description>
    </function>

    <function name="bcheck" section="programming" output="scalar">
      <fnargs>
	<fnarg type="bundleref">objetivo</fnarg>
	<fnarg type="bundle" optional="true">entrada</fnarg>
	<fnarg type="strings" optional="true">claves-requeridas</fnarg>
      </fnargs>
      <description>
	<para>
	  Principalmente pensada para que la utilicen los autores de paquetes de
	  funciones. Este es el contexto en el que <lit>bcheck</lit> puede ser
	  útil: tienes una función que admite un argumento de tipo 'bundle'
	  mediante el que el solicitante puede hacer varias elecciones. Algunos
	  elementos del 'bundle' pueden tener valores predeterminados &mdash;
	  por lo que el solicitante no está obligado a hacer una elección
	  explícita &mdash; aunque pueden necesitarse otros elementos. Lo
	  que quieres es determinar si el argumento que obtienes es correcto.
	  El texto principal de abajo asume que el solicitante de tu función
	  proporciona un 'bundle' de <argname>entrada</argname>, pero consulta
	  la sección titulada <quote>Sin paquete de entrada</quote>, en caso
	  contrario.
	</para>
	<para>
	  Para utilizar <lit>bcheck</lit>, construyes un modelo de 'bundle' que
	  contenga todas las claves admitidas, con valores que ejemplifiquen
	  el tipo asociado a cada clave, y lo pasas en forma de puntero como
	  <argname>objetivo</argname>. Para el segundo argumento,
	  <argname>entrada</argname>, pasas el 'bundle' que obtienes del
	  solicitante. Entonces, esta función comprueba lo siguiente:
	</para>
	<ilist>
	  <li>
	    <para>
	      Contiene la <argname>entrada</argname> alguna clave que no
	      esté presente en el <argname>objetivo</argname>? En tal caso,
	      <lit>bcheck</lit> devuelve un valor no nulo, indicando que la
	      <argname>entrada</argname> es incorrecta. (Muy probablemente,
	      la clave en cuestión está escrita incorrectamente).
	    </para>
	  </li>
	  <li>
	    <para>
	      Contiene la <argname>entrada</argname>, bajo alguna de las
	      claves indicadas, un objeto cuyo tipo no coincida con el del
	      <argname>objetivo</argname>? En tal caso, se devuelve un valor
	      no nulo.
	    </para>
	  </li>
	  <li>
	    <para>
	      Si algunos elementos del <argname>objetivo</argname> necesitan
	      una entrada del solicitante (por lo que el valor que indicas no es
	      un valor predeterminado, si no solo un marcador de posición
	      para indicar el tipo requerido), debes indicar un tercer
	      argumento a <lit>bcheck</lit>: un 'array' de cadenas de texto
	      que contenga las claves para las que no es opcional la entrada.
	      Entonces, el valor devuelto será no nulo si falta alguno de los
	      elementos requeridos de <argname>entrada</argname>.
	    </para>
	  </li>
	</ilist>
	<para>
	  Además de lo anterior, podrías estar interesado en imponer límites
	  inferiores y/o superiores al valor de uno o más de los elementos
	  escalares del argumento de 'bundle'. En tal caso, añade un 'bundle'
	  con el nombre <lit>bounds</lit> a tu modelo de 'bundle'. Cada
	  elemento de este 'bundle' secundario deberá tener una <i>clave</i>
	  que identifique un elemento del modelo de 'bundle'; su <i>valor</i>
	  deberá ser un vector 'doble' que contenga los límites inferiores y
	  superiores. Pon un <lit>NA</lit> en el lugar de uno de los límites,
	  si no hay límite de ese lado. Así, por ejemplo, cuando se indica
	  <lit>x1</lit> en la entrada del solicitante, el siguiente código va a
	  comprobar que está entre 1 y 5; y cuando se indica <lit>x2</lit>,
	  que este no es negativo:
	</para>
	<code>
	  template.bounds = _(x1={1,5}, x2={0,NA})
	</code>
	<para>
	  Cuando no se detectan fallos en ninguno de esos puntos, los valores
	  indicados en <argname>entrada</argname> se copian a
	  <argname>objetivo</argname> (substituyéndose los predeterminados
	  por elecciones correctas en la parte del solicitante). Cuando se
	  detecten fallos, se va a presentar un mensaje que indicará qué es lo
	  que está mal en la <argname>entrada</argname>.
	</para>
	<para>
	  Para ofrecer un sencillo ejemplo, supón que tu 'bundle' de argumentos
	  de la función admite una matriz <lit>X</lit> (requerida), un escalar
	  no negativo <lit>z</lit> con valor 0 por defecto, y una cadena
	  <lit>s</lit> con el valor predeterminado <quote><lit>display</lit></quote>.
	  Entonces, el siguiente fragmento de código sería adecuado para
	  comprobar un 'bundle' de nombre <lit>uservals</lit> proporcionado
	  por el solicitante:
	</para>
	<code>
	  bundle target = _(X={}, z=0, s="display")
	  target.bounds = _(z={0,NA})
	  strings req = defarray("X")
	  err = bcheck(&amp;target, uservals, req)
	  if err
	     # Reaccionar adecuadamente
	  else
	     # Proceder utilizando los valores en el objetivo
	  endif
	</code>
	<subhead>Sin paquete de entrada</subhead>
	<para>
	  Si no se proporciona el 'bundle' de <argname>entrada</argname> a
	  <lit>bcheck</lit>, se comporta del siguiente modo. Si el argumento
    <argname>claves-requeridas</argname> no se indica, devuelve el cero
    (puesto que no puede suceder ninguna de las condiciones de fallo que se
    mencionan más arriba), y <argname>objetivo</argname> no se modifica.
    En caso contrario, devuelve un valor no nulo puesto que está claro que
    una o más especificaciones deben estar ausentes. Esto significa que es
    seguro pasar una <argname>entrada</argname> nula a <lit>bcheck</lit>.
        </para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">tipo</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite calcular una de las variantes de la función de Bessel de clase
	  <argname>v</argname> con argumento <argname>x</argname>. El valor que
	  devuelve es del mismo tipo que este <argname>x</argname>. La clase de
	  la función se escoge con el primer argumento que debe ser <lit>J</lit>,
	  <lit>Y</lit>, <lit>I</lit> o <lit>K</lit>. Una buena discusión sobre
	  las funciones de Bessel puede encontrarse en la Wikipedia, pero aquí
	  se ofrecen unos breves comentarios.
	</para>
	<para>
	  Caso <lit>J</lit>: función de Bessel de primera clase que se parece
	  a una onda sinusoidal amortiguada. Se define para <argname>v</argname>
	  real y <argname>x</argname>; pero si <argname>x</argname> fuese
	  negativo, entonces <argname>v</argname> debe ser un número entero.
	</para>
	<para>
	  Caso <lit>Y</lit>: función de Bessel de segunda clase. Se define para
	  <argname>v</argname> real y <argname>x</argname>, pero con una
	  singularidad en <argname>x</argname> = 0.
	</para>
	<para>
	  Caso <lit>I</lit>: función de Bessel modificada de primera clase que
	  presenta un crecimiento exponencial. Los argumentos que pueden usarse con
	  ella son los mismos que en el caso <lit>J</lit>.
	</para>
	<para>
	  Caso <lit>K</lit>: función de Bessel modificada de segunda clase que
	  presenta un decrecimiento exponencial. Diverge en <argname>x</argname>
	  = 0, no está definida para valores negativos de <argname>x</argname>,
	  y es simétrica en torno a <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el resultado de una maximización numérica hecha con el
	  método de Broyden, Fletcher, Goldfarb y Shanno. El argumento vectorial
	  <argname>b</argname> debe contener los valores iniciales de un conjunto
	  de parámetros, y el argumento <argname>f</argname> debe especificar
	  una llamada a la función que va a calcular el criterio objetivo (escalar)
	  que se quiere maximizar, dados los valores vigentes de los parámetros, así
	  como cualesquiera otros datos que sean relevantes. Si lo que pretendes
	  es en realidad minimizar el criterio objetivo, esta función devuelve el
	  valor negativo de ese criterio objetivo. Cuando se completa con éxito
	  su ejecución, <lit>BFGSmax</lit> devuelve el valor maximizado del
	  criterio objetivo, y <argname>b</argname> contiene finalmente los
	  valores de los parámetros que proporcionan el máximo de ese criterio.
	</para>
	<para>
	  El tercer argumento (opcional) establece una manera de proporcionar
	  derivadas analíticas (en otro caso, el gradiente se computa numéricamente).
	  La llamada <argname>g</argname> a la función gradiente debe tener como
	  primer argumento a una matriz definida previamente que tenga el
	  tamaño adecuado para poder almacenar el gradiente, indicado en forma de
	  puntero. Así mismo, también necesita tener como argumento (en forma de
	  puntero o no) al vector de parámetros. Otros argumentos son
	  opcionales.
	</para>
	<para>
	  Para más detalles y ejemplos, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
	          <fncref targ="BFGScmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alias de <fncref targ="BFGSmax"/>. Si invocas la función bajo
	  este nombre, se ejecuta haciendo una minimización.
	</para>
      </description>
    </function>

    <function name="BFGScmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="matrix">limites</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el resultado de una maximización con restricciones por
	  medio del método L-BFGS-B (BFGS con memoria limitada, consulta
	  <cite key="byrd-etal95">Byrd, Lu, Nocedal y Zhu, 1995</cite>). El argumento 
	  vectorial <argname>b</argname> debe contener los valores iniciales de un
	  conjunto de parámetros, el argumento <argname>limites</argname> debe
	  contener las restricciones aplicadas a los valores de los parámetros (consulta
	  más abajo), y el argumento <argname>f</argname> debe especificar
	  una llamada a la función que va a calcular el criterio objetivo (escalar)
	  que se quiere maximizar, dados los valores vigentes de los parámetros así
	  como cualesquiera otros datos que sean relevantes. Si lo que pretendes
	  realmente es minimizar el criterio objetivo, esta función debe devolver
	  el valor negativo de ese criterio. Al completar con éxito su ejecución,
	  <lit>BFGScmax</lit> devuelve el valor máximo del criterio objetivo, dadas
	  las restricciones de <argname>limites</argname>, y <argname>b</argname>
	  contiene finalmente los valores de los parámetros que maximizan el criterio.
	</para>
	<para>
	  La matriz <argname>limites</argname> debe tener 3 columnas, y un
	  número de filas igual al número de elementos restringidos en el vector de
	  parámetros. El primer elemento de una fila dada es el entero positivo
	  que indexa el parámetro restringido; el segundo y el tercer elementos
	  son los límites inferior y superior, respectivamente. Los valores
	  <lit>-$huge</lit> y <lit>$huge</lit> deben usarse para indicar que
	  el parámetro no posee restricciones inferiores o superiores,
	  respectivamente. Por ejemplo, la siguiente expresión es la forma de
	  especificar que el segundo elemento del vector de parámetros debe
	  ser no negativo:
	</para>
	<code>
	  matrix limites = {2, 0, $huge}
	</code>
	<para>
	  El cuarto argumento (opcional) establece una manera de proporcionar
	  derivadas analíticas (en otro caso, el gradiente se calcula numéricamente).
	  La llamada <argname>g</argname> a la función gradiente debe tener como
	  primer argumento a una matriz definida previamente que tenga el
	  tamaño adecuado para poder almacenar el gradiente, indicado en forma de
	  puntero. Así mismo, también necesita tener como argumento (en forma de
	  puntero o no) al vector de parámetros. Otros argumentos son
	  opcionales.
	</para>
	<para>
	  Para más detalles y ejemplos, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
	          <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGScmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alias de <fncref targ="BFGScmax"/>. Si invocas la función bajo
	  este nombre, se ejecuta haciendo una minimización.
	</para>
      </description>
    </function>

    <function name="bin2dec" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada una matriz <argname>B</argname> que contenga únicamente ceros
	  y unos, esta función interpreta cada fila de la matriz como si fuese
	  una representación binaria de un entero de 32 bits sin signo; y
	  devuelve un vector columna con las representaciones decimales de esos
	  enteros. La matriz del argumento no puede tener más de 32 columnas;
	  en caso contrario, se presenta un fallo.
	</para>
	<para>
	  Ten en cuenta que se considera que el último bit significativo está
	  en la primera columna. Así, la columna 1 se va a corresponder con
	  <math>2</math><sup>0</sup>, la columna 2 con <math>2</math><sup>1</sup>,
	  y así sucesivamente. Por ejemplo, la
	  expresión
	</para>
	<code>
	  scalar x = bin2dec({1,0,1})
	</code>
	<para>
	  guarda el valor 5 en <math>x</math>.
	</para>
	<para>
	  La función <fncref targ="dec2bin"/> realiza la transformación
	  inversa.
	</para>
      </description>
    </function>

    <function name="bincoeff" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">n</fnarg>
	<fnarg type="anyfloat">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el coeficiente binomial.
	  Este indica el número de formas en las que <argname>k</argname> elementos
	  se poden escoger (sin repetición) de entre <argname>n</argname>
	  elementos, independientemente de cómo estén ordenados. Esto también
	  equivale al coeficiente del elemento (<math>k</math>+1)-ésimo
	  en la expansión polinómica de la potencia de un binomio
	  <equation status="inline" ascii="(1+x)^n" tex="$(1+x)^n$"/>.
	</para>
	<para context="tex">
	  Para argumentos enteros el resultado es $n!/(k!(n-k)!)$.
	  Pero la función también acepta argumentos no enteros, y
	  la fórmula de arriba se generaliza como
	  $\frac{\Gamma(n+1)}{\Gamma(k+1) \Gamma(n-k+1)}$.
	</para>
	<para context="notex">
	  Para argumentos enteros,el resultado es <math>n!/(k!(n-k)!)</math>.
	  Pero esta función también acepta argumentos no enteros,
	  y en ese caso la fórmula de arriba
	  se generaliza como
	   Γ(<math>n</math>+1)/(Γ(<math>k</math>+1) &times; Γ(<math>n-k</math>+1)).
	</para>
	<para>
	  Cuando <argname>k</argname> &gt; <argname>n</argname> o
	  <argname>k</argname> &lt; 0, no hay una respuesta válida
	  por lo que se muestra un fallo.
	</para>
	<para>
	  Si los dos argumentos son de diferente tipo, el resultado será
	  del tipo del <quote>mayor</quote> de los dos (siendo el criterio
	  de ordenación matriz &gt; serie &gt; escalar). Por ejemplo, si
	  <argname>n</argname> es un escalar, y <argname>k</argname> es un
	  vector de dimensión <math>r</math> (o viceversa), el resultado
	  es un vector de dimensión <math>r</math>. Ten en cuenta que los
	  argumentos matriciales deberán ser vectores. También que, si ningún
	  argumento es un escalar, los dos habrán de tener la misma longitud.
	</para>
	<para>
	  Consulta también <fncref targ="gammafun"/> y <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="binperms" section="math" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Permutaciones binarias: devuelve una matriz <by r="p" c="n"/>,
	  en la que cada una de sus filas contiene una ordenación diferente
	  de <math>k</math> unos y <math>n</math> &minus; <math>k</math>
	  ceros. El valor máximo admitido para <math>n</math> es 64; tanto
	  <math>n</math> como <math>k</math> deben ser no negativos; y
	  <math>k</math> no debe ser mayor que <math>n</math>; en caso
	  contrario, se va a mostrar un fallo. Cuando
	  <math>n</math> = <math>k</math> = 0 se devuelve una matriz
	  vacía.
	</para>
	<para>
	  <emphasis>Advertencia</emphasis>: El número <math>p</math> de
	  permutaciones aumenta rápidamente en función de <math>n</math>; y
	  resulta mayor cuando <math>k</math> es aproximadamente la mitad de
	  <math>n</math>. Entonces, podría interesarte comprobar con antelación
	  la dimensión de la matriz que la función <lit>binperms</lit> va a
	  tratar de asignar. Como la función <fncref targ="bincoeff"/> devuelve
	  el valor de <math>p</math>, se puede calcular el tamaño en megabytes
	  de la matriz resultante mediante
	</para>
	<code>
	  MB = 8 * n * bincoeff(n, k) / 10^6
	</code>
	<para>
	  Para <math>n</math> = 30, esto da como resultado cerca de 34 Mb
	  cuando <math>k</math> = 25, en torno a 7.211 Mb si <math>k</math> = 20,
	  y 20.758 Mb aproximadamente si <math>k</math> = 18.
	</para>
      </description>
    </function>

    <function name="bkfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie con el resultado de la aplicación del filtro paso-banda
	  de Baxter&ndash;King a una serie <argname>y</argname>. Los
	  parámetros opcionales <argname>f1</argname> y <argname>f2</argname>
	  representan, respectivamente, los límites inferior y superior
	  del rango de frecuencias que se va a extraer, mientras que
	  <argname>k</argname> representa el orden de aproximación que se va a
	  utilizar.
	</para>
	<para>
	  Si no se proporcionan esos argumentos, entonces los valores por defecto
	  van a depender de la periodicidad del conjunto de datos. Para datos
	  anuales los valores por defecto para <argname>f1</argname>,
	  <argname>f2</argname> y <argname>k</argname> son 2, 8 y 3
	  respectivamente; para datos trimestrales son 6, 32 y 12; y para
	  datos mensuales son 18, 96 y 36. Esos valores se escogen para
	  coincidir con la elección más común entre los usuarios, que consiste
	  en la utilización de este filtro para extraer la componente de frecuencia
	  del <quote>ciclo de negocios</quote>. Esto, a su vez, se define
	  habitualmente comprendido entre 18 meses y 8 años. El filtro abarca
	  3 años de datos, en la elección por defecto.
	</para>
	<para>
	  Si <argname>f2</argname> es mayor o igual al número de observaciones
	  disponibles, entonces se ejecuta la versión <quote>paso-bajo</quote>
	  del filtro, y la serie resultante debe considerarse como una
	  estimación de la componente de tendencia, más que de la componente del
	  ciclo.
	  <seelist>
            <fncref targ="bwfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bkw" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">V</fnarg>
	<fnarg optional="true" type="strings">nombrespar</fnarg>
	<fnarg optional="true" type="bool">detallado</fnarg>
      </fnargs>
      <description>
	<para>
	  Ejecuta pruebas BKW de diagnóstico de multicolinealidad (consulta
	  <cite key="belsley-etal80">Belsley, Kuh e Welsch (1980)</cite>)
	  dada una matriz de covarianzas de las estimaciones de los parámetros,
	  <argname>V</argname>. El segundo argumento (opcional), puede ser
	  una formación (array) de cadenas de texto o una cadena que contenga
	  nombres separados por comas, y se usa para etiquetar las columnas
	  que muestran las proporciones de varianza; el número de nombres
	  debe coincidir con la dimensión de <argname>V</argname>. Después
	  de estimar un modelo en GRETL, puedes obtener argumentos adecuados
	  para indicar en esta función por medio de los accesores
	  <fncref targ="$vcv"/> y <fncref targ="$parnames"/>.
	</para>
	<para>
	  Por defecto, esta función opera silenciosamente, devolviendo tan
	  solo la tabla BKW en forma de matriz, pero si indicas como tercer
	  argumento un valor no nulo, la tabla se presenta junto con algunos
	  análisis.
	</para>
	<para>
	  También dispones de esta funcionalidad con formato de instrucción
	  mediante <cmdref targ="bkw"/>, y se va a referir automáticamente
	  al último modelo, sin requerir ningún argumento.
	</para>
      </description>
    </function>

    <function name="boxcox" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el resultado de la transformación de Box&ndash;Cox con
	  parámetro <argname>d</argname> de una serie positiva
	  <argname>y</argname> (o de las columnas de una matriz
	  <argname>y</argname>).
	</para>
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  El resultado es (<math>y</math><sup>d</sup> - 1)/<math>d</math>
	  para <math>d</math> distinto de cero, o log(<math>y</math>) para
	  <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">nombrearchivo</fnarg>
	<fnarg optional="true" type="bool">importar</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve la lectura de un <quote>bundle</quote> desde un archivo
	  especificado por el argumento <argname>nombrearchivo</argname>. Por
	  defecto, se asume que el bundle está representado en XML; y que se le
	  aplicó la compresión gzip si <argname>nombrearchivo</argname> tiene
	  extensión <lit>.gz</lit>. Pero si la extensión es <lit>.json</lit> o
	  <lit>.geojson</lit>, se asume que el contenido es de tipo JSON.
	</para>
	<para>
	  En el caso XML, el archivo debe contener un elemento
	  <lit>gretl-bundle</lit>, que se use para almacenar cero o
	  más elementos <lit>bundled-item</lit>. Por ejemplo:
	</para>
	<code>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;gretl-bundle name="temp"&gt;
          &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
          &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
	  &lt;/gretl-bundle&gt;
	</code>
	<para>
	  Como cabría esperar, los archivos que se leen de forma adecuada por
	  medio de <lit>bread</lit> se generan mediante la función asociada
	  <fncref targ="bwrite"/>.
	</para>
	<para>
	  Si el nombre del archivo no contiene la especificación completa de la ruta
	  al directorio donde está, entonces va a buscarse en varias localizaciones
	  <quote>probables</quote>, comenzando por lo establecido como
	  <cmdref targ="workdir"/> vigente. Ahora bien, cuando se proporciona un
	  valor no nulo para el argumento opcional <argname>importar</argname>,
	  el archivo va a buscarse en el directorio <quote>punto</quote> del
	  usuario. En este caso, el argumento <argname>nombrearchivo</argname>
	  deberá ser un nombre simple de archivo, sin la inclusión de la ruta al directorio.
	</para>
	<para>
	  Si ocurre algún fallo (por ejemplo,si el archivo está mal formateado
	  o es inaccesible), se devuelve el fallo por medio del accesor
	  <fncref targ="$error"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
            <fncref targ="bwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="brename" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">antiguaclave</fnarg>
	<fnarg type="string">nuevaclave</fnarg>
      </fnargs>
      <description>
	<para>
	  Si el 'bundle' <argname>B</argname> contiene un elemento que tenga
	  la clave <argname>antiguaclave</argname>, esa clave se cambia por
	  <argname>nuevaclave</argname>; en caso contrario, se muestra un fallo.
	  La función devuelve un 0 cuando se hace correctamente el cambio de nombre.
	</para>
	<para>
	  Cambiar la clave de un elemento de un 'bundle' no es una tarea habitual,
	  pero puede surgir esa necesidad en el contexto de funciones que
	  operan con 'bundles', y <lit>brename</lit> resulta ser una herramienta
	  eficiente para ese trabajo. Ejemplo:
	</para>
	<code>
	  # Establecer un 'bundle' que contiene una matriz grande
	  bundle b
	  b.X = mnormal(1000, 1000)
	  if 0
	      # 'Cambiar la clave manualmente'
	      Xcopy = b.X
	      delete b.X
	      b.Y = Xcopy
	      delete Xcopy
	  else
	      # frente a 'Cambiarla de forma eficiente'
	      brename(b, "X", "Y")
	  endif
	</code>
	<para>
	  El primer método exige que se copie esa gran matriz dos veces:
	  primero fuera del 'bundle', y luego de nuevo dentro de él bajo una
	  clave diferente. El método eficiente cambia la clave directamente.
	</para>
      </description>
    </function>

    <function name="bwfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie con lo que resulta al aplicar un filtro paso-bajo
	  de Butterworth de orden <argname>n</argname> y frecuencia de
	  corte <argname>omega</argname>, en la serie <argname>y</argname>.
	  El corte se expresa en grados y debe ser mayor o igual a cero,
	  y menor que 180. Los valores de corte más pequeños van a restringir el
	  paso-banda a menores frecuencias, y así producen una tendencia
	  más suave. Los valores mayores de <argname>n</argname> producen
	  un corte más agudo, pero con el coste de poder tener inestabilidad
	  numérica.
	</para>
	<para>
	  La inspección preliminar del periodograma de la serie de interés es muy
	  útil cuando se desea aplicar esta función. Para obtener más detalles,
	  consulta <guideref targ="chap:tsfilter"/>.
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">nombrearchivo</fnarg>
	<fnarg optional="true" type="bool">exportar</fnarg>
      </fnargs>
      <description>
	<para>
	  Escribe el 'bundle' <argname>B</argname> en un archivo, serializado
	  en XML; o como JSON, si <argname>nombrearchivo</argname> tiene extensión
	  <lit>.json</lit> o <lit>.geojson</lit>. Consulta <fncref targ="bread"/>
	  para obtener una descripción del formato cuando se usa XML. Si ya existe
	  un archivo denominado <argname>nombrearchivo</argname>, este va a
	  sobrescribirse. Esta función devuelve el valor nominal 0 en caso de
	  que concluya con éxito; si fracasa la escritura se muestra un fallo.
	</para>
	<para>
	  El archivo de salida se guarda en el directorio <cmdref targ="workdir"/>
	  vigente, excepto que <argname>nombrearchivo</argname> contenga la ruta
	  completa con el directorio en el que va a guardarse. Ahora bien, cuando
	  se indica un valor no nulo para el argumento <argname>exportar</argname>,
	  el archivo se va a guardar en el directorio <quote>punto</quote> del usuario.
	  En este caso, el argumento <argname>nombrearchivo</argname> deberá
	  ser un nombre simple de archivo, sin la inclusión de la ruta al directorio.
	</para>
	<para>
	  Dispones de la opción de compresión gzip, pero únicamente en
	  caso de que el resultado sea de tipo XML. Esto se va a aplicar si
	  <argname>nombrearchivo</argname> tiene la extensión <lit>.gz</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="carg" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz real de dimensión <by r="m" c="n"/> que contiene el
	  <quote>argumento</quote> complejo de cada elemento de la matriz compleja
	  <argname>C</argname> de dimensión <by r="m" c="n"/>. El argumento del
	  número complejo <math>z</math> = <math>x</math> + <math>yi</math>
	  también puede calcularse mediante <lit>atan2(y, x)</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="abs"/>
	    <fncref targ="cmod"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">tipificar</fnarg>
	<fnarg type="bool" optional="true">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Centra las columnas de la matriz <argname>X</argname> respecto
	  a sus medias. Si el segundo argumento (opcional) tiene un valor
	  no nulo, entonces los valores centrados se dividen además por las
	  desviaciones típicas de cada columna (que se caculan utilizando
	  <math>n</math> &minus; 1 como divisor, en el que <math>n</math>
	  es el número de filas de <argname>X</argname>).
	</para>
	<para>
	  Si indicas un valor no nulo para <argname>obviar_na</argname>
	  se van a ignorar los valores ausentes; en caso contrario, si una
	  columna de la matriz <argname>X</argname> contiene algún valor
	  ausente, la columna correspondiente de la salida va a tener todos
	  ausentes.
	</para>
	<para>
	  Ten en cuenta que <fncref targ="stdize"/> proporciona una
	  funcionalidad más flexible.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Calcula el valor de la función de distribución acumulativa, y devuelve
	  un resultado (del mismo tipo que el argumento) con la probabilidad
	  <equation status="inline" ascii="P(X &le; x)" tex="$P(X \le x)$"/>,
	  donde la distribución de <math>X</math> se especifica mediante la letra
	  <argname>d</argname>. Entre los argumentos <argname>d</argname> y
	  <argname>x</argname> puede necesitarse algún argumento adicional
	  escalar para especificar los parámetros de la distribución, tal y como
	  se indica a continuación (pero observa que la distribución Normal
	  tiene su propia función, por conveniencia, <fncref targ="cnorm"/>):
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (d = z, n o N): sin argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Normal bivariante (D): coeficiente de correlación
            </para>
	  </li>
	  <li>
            <para>
              Logística (lgt o s): sin más argumentos
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): grados de libertad
            </para>
	  </li>
	  <li>
            <para>
              Chi-cuadrado (c, x o X): grados de libertad
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f o F): grados de libertad (num.), grados de libertad (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g o G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): 2 parámetros de forma
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b o B): probabilidad, cantidad de ensayos
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p o P): media
            </para>
	  </li>
	  <li>
            <para>
              Exponencial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w o W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l o L): media; escala
            </para>
	  </li>
	  <li>
            <para>
              Error Generalizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Chi-cuadrado no central (ncX): grados de libertad, parámetro de no centralidad
	    </para>
	  </li>
	  <li>
	    <para>
	      F no central (ncF): grados de libertad (num.), grados de libertad (den.),
	      parámetro de no centralidad
	    </para>
	  </li>
	  <li>
	    <para>
	      t no central (nct): grados de libertad, parámetro de no centralidad
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribución} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Normal bivariante &amp; \texttt{D} &amp;
	  $\rho$ &amp; -- &amp; --\\
	  Logística &amp; \texttt{lgt} &amp;
	  -- &amp; -- &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  gl &amp; -- &amp; --\\
	  Chi-cuadrado &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp;
	  gl &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} o \texttt{F} &amp;
	  gl (num.) &amp; gl (den.) &amp; --\\
	  Gamma &amp; \texttt{g} o \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  Binomial &amp; \texttt{b} o \texttt{B} &amp;
	  probabilidad &amp; ensayos &amp; --\\
	  Poisson &amp; \texttt{p} o \texttt{P} &amp;
	  media &amp; -- &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp;
	  escala &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} o \texttt{W} &amp;
	  forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} o \texttt{L} &amp;
	  media &amp; escala &amp; --\\
	  Error Generalizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ no central &amp; \texttt{ncX} &amp;
	  gl &amp; no centralidad &amp; --\\
	  $F$ no central &amp; \texttt{ncF} &amp;
	  gl (num.) &amp; gl (den.) &amp; no centralidad\\
	  $t$ no central &amp; \texttt{nct} &amp;
	  gl &amp; no centralidad &amp; --\\
	</tabular>
	<para>
	  Ten en cuenta que, en la mayoría de los casos, existen alias para ayudar
	  a memorizar los códigos. El caso de la Normal bivariante es especial: la
	  la sintaxis es <lit>x = cdf(D, rho, z1, z2)</lit> donde <lit>rho</lit>
	  es el coeficiente de correlación entre las variables <lit>z1</lit>
	  y <lit>z2</lit>.
	</para>
	<para context="tex">
	  La disposición de parámetros que usa el GRETL para la variable
	  aleatoria Gamma implica que su función de densidad puede escribirse
	  \[
	  f(x; k, \theta) = \frac{x^{k-1}}{\theta^k} \frac{e^{-x/\theta}}{\Gamma(k)}
	  \]
	  donde $k&gt;0$ es el parámetro de forma, y$\theta&gt;0$ es el
	  parámetro de escala.
	</para>
	<para>
	  <seelist>
            <fncref targ="pdf"/>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta es una función heredada, anterior al soporte
	  original de GRETL para matrices complejas.
	</para>
	<para>
	  Devuelve una matriz con el resultado de dividir números complejos. Los dos
	  argumentos deben componerse del mismo número de filas, <math>n</math>, y
	  de una o dos columnas. La primera columna contiene la parte real, y la
	  segunda (si existe) contiene la parte imaginaria. El resultado que se
	  devuelve es una matriz de orden <by r="n" c="2"/> o, en caso de no
	  existir la parte imaginaria, un vector con <math>n</math> filas.
	  <seelist>
            <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función devuelve una lista en la que cada serie del argumento
	  <argname>L</argname> que tenga el atributo <quote>codificado</quote>,
	  se substituye por un conjunto de variables ficticias que representan
	  cada uno de sus valores codificados, pero omitiendo el valor
	  más pequeño. Si el argumento <argname>L</argname> no contiene
	  ninguna serie codificada, el valor que se devuelve va a ser idéntico
	  a <argname>L</argname>.
	</para>
	<para>
	  En caso de que se generen, las variables ficticias se nombran con el
	  patrón <lit>D</lit><repl>varname</repl><lit>_</lit><repl>vi</repl>,
	  en el que <repl>vi</repl> indica el <repl>i</repl><sup>-ésimo</sup>
	  valor representado de la variable que se codifica. En caso de que
	  algunos de los valores sean negativos, se va a insertar <quote>m</quote>
	  antes del valor (absoluto) de
	  <repl>vi</repl>.
	</para>
	<para>
	  Por ejemplo, supón que <argname>L</argname> contiene una serie
	  codificada llamada <lit>C1</lit> con los valores &minus;9, &minus;7,
	  0, 1 y 2. Entonces, las variables ficticias generadas van a ser
	  <lit>DC1_m7</lit> (que codifica cuando C1 = &minus;7),
	  <lit>DC1_0</lit> (que codifica cuando C1 = 0), etcétera.
	</para>
	<para>
	  <seelist>
            <fncref targ="dummify"/>
	    <fncref targ="getinfo"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Función tope: devuelve un resultado (del tipo del argumento) con el menor
	  entero que sea mayor o igual a <argname>x</argname>.
	  <seelist>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza la descomposición de Cholesky de <argname>A</argname>.
	  Cuando <argname>A</argname> sea una matriz real, deberá ser
	  simétrica y definida positiva; en ese caso, el resultado será
	  una matriz triangular inferior <math>L</math> que verificará
	  <equation status="inline" ascii="A = LL'" tex="$A = LL'$"/>.
	  Cuando <argname>A</argname> sea compleja, deberá ser
	  Hermítica y definida positiva; y el resultado será una matriz
	  compleja triangular inferior de forma que
	  <equation status="inline" ascii="A = LL^H" tex="$A = LL^{\mathrm H}$"/>.
	  En caso contrario, la función devolverá un error.
	</para>
	<para>
	  Para el caso real, consulta también <fncref targ="psdroot"/> y
	  <fncref targ="Lsolve"/>.
	</para>
      </description>
    </function>

    <function name="chowlin" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">factorx</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  No se recomienda seguir utilizando esta función; en su lugar,
	  utiliza <fncref targ="tdisagg"/>.
	</para>
	<para>
	  Devuelve una matriz como resultado de expandir los datos de
	  entrada, <argname>Y</argname>, a una frecuencia mayor, con el método
	  de <cite key="chowlin71">Chow y Lin (1971)</cite>. Se asume que las
	  columnas de <argname>Y</argname> representan series de datos.
	  La matriz que se devuelve tiene el mismo número de columnas que
	  <argname>Y</argname> y <argname>factorx</argname> veces su
	  número de filas. También se asume que cada valor de baja frecuencia
	  debe tratarse como la media de <argname>factorx</argname> valores
	  de alta frecuencia.
	</para>
	<para>
	  El valor de <argname>factorx</argname> debe ser igual a 3 para expandir
	  datos trimestrales a mensuales, 4 para hacerlo de anuales a trimestrales,
	  o 12 de anuales a mensuales. Puedes usar el tercer argumento (opcional)
	  para proveer una matriz de covariables con un objetivo de mayor frecuencia.
	</para>
	<para>
	  Los regresores que se utilizan por defecto son una constante y
	  una tendencia. Cuando se proporciona <argname>X</argname>,
	  sus columnas se utilizan como regresores adicionales. La función
	  devuelve un fallo si el número de filas de <argname>X</argname> no
	  es igual a <argname>factorx</argname> veces el número de filas de
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmod" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz real de dimensión <by r="m" c="n"/>
	  que contiene el módulo complejo de cada elemento de la matriz
	  compleja <argname>C</argname> de dimensión
	  <by r="m" c="n"/>. El módulo del número complejo
	  <math>z</math> = <math>x</math> + <math>yi</math> es igual a la raíz
	  cuadrada de <math>x</math><sup>2</sup> + <math>y</math><sup>2</sup>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="abs"/>
	    <fncref targ="carg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cmult" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta es una función heredada, anterior al soporte
	  original de GRETL para matrices complejas.
	</para>
	<para>
	  Devuelve una matriz con el resultado de multiplicar números complejos. Los dos
	  argumentos deben componerse del mismo número de filas, <math>n</math>, y
	  de una o dos columnas. La primera columna contiene la parte real y la
	  segunda (si existe) contiene la parte imaginaria. El resultado que se
	  devuelve es una matriz de orden <by r="n" c="2"/> o, en caso de no
	  existir la parte imaginaria, un vector con <math>n</math> filas.
	  <seelist>
            <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve la función de distribución acumulativa para una Normal
	  estándar.
	  <seelist>
            <fncref targ="dnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnumber" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el número de condición de una matriz
	  <argname>X</argname> de orden <by r="n" c="k"/>, conforme se define
	  en <cite key="belsley-etal80"> Belsley, Kuh y Welsch (1980)</cite>.
	  Si las columnas de <argname>X</argname> son mutuamente ortogonales,
	  el número de condición de <argname>X</argname> es la unidad. Por el
	  contrario, un valor grande del número de condición se entiende como un
	  indicio de alto grado de multicolinealidad; habitualmente se considera
	  que el valor es <quote>grande</quote> si es mayor o igual a 50 (o,
	  algunas veces, a 30).
	</para>
	<para>
	  Los pasos para hacer los cálculos son: (1) formar una matriz
	  <math>Z</math> cuyas columnas sean el resultado de dividir cada
	  columna de <argname>X</argname> por su respectiva norma
	  euclidiana; (2) construir la matriz <math>Z'Z</math> y obtener sus
	  autovalores; y (3) calcular la raíz cuadrada de la razón entre el mayor
	  y el menor autovalor.
	</para>
	
	<para>
	  <seelist>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Si indicas el argumento <argname>col</argname>, devuelve una cadena
	  de texto con el nombre de la columna <argname>col</argname> de la matriz
	  <argname>M</argname>. Si las columnas de <argname>M</argname>
	  no tienen nombre, entonces se devuelve una cadena vacía; y si
	  <argname>col</argname> está fuera de los límites del número de columnas
	  de esta matriz, se muestra un fallo.
	</para>
	<para>
	  Si no indicas el segundo argumento, devuelve un 'array' de cadenas
	  de texto que contiene los nombres de las columnas de <argname>M</argname>,
	  o un 'array' vacío si <argname>M</argname> no tiene asignados
	  nombres de columnas.
	</para>
	<para>
	  Ejemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  cnameset(A, "Col_A Col_B Col_C")
	  string name = cnameget(A, 3)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="cnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameset" section="matrix" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Añade nombres a las columnas de la matriz de orden <by r="T" c="k"/>,
	  <argname>M</argname>. Cuando <argname>S</argname> es una lista,
	  los nombres son los de las series listadas (es necesario que esa lista tenga
	  <math>k</math>elementos). Cuando <argname>S</argname> es un 'array'
	  de cadenas de texto, deberá tener <math>k</math> elementos. Como
	  segundo argumento también se acepta una única cadea de texto; en ese
	  caso, esta cadena necesita tener <math>k</math> subcadenas separadas
	  por espacios. Como caso especial, el hecho de indicar una cadena de
	  texto vacía como segundo argumento, tiene como efecto la eliminación
	  de cualquier nombre de columna existente.
	</para>
	<para>
	  Devuelve el valor nominal 0 si las columnas son nombradas con éxito;
	  en caso de que no funcione se muestra un fallo. Consulta también
	  <fncref targ="rnameset"/>.
	</para>
	<para>
	  Ejemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(2)
	  S[1] = "Col1"
	  S[2] = "Col2"
	  cnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un entero con el número de columnas de la matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="commute" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
	<fnarg optional="true" type="int">post</fnarg>
	<fnarg optional="true" type="int">add_id</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el resultado de premultiplicar la matriz <argname>A</argname>
	  por la matriz <math>K</math><sub>m,n</sub> de conmutación (utilizando
	  un algoritmo que es más eficiente que la propia multiplicación
	  explícita). Se asume que cada columna de <argname>A</argname>
	  procede de una operación de vectorización sobre una matriz
	  <math>m x n</math>. En particular,
	</para>
	<code>
	  commute(vec(B), rows(B), cols(B))
	</code>
	<para>
	  proporciona vec(<math>B'</math>). Con el objeto de calcular la matriz
	  de conmutación apropiada, aplica simplemente la función a una matriz
	  identidad con el tamaño adecuado. Por ejemplo:
	</para>
	<code>
	  K_32 = commute(I(6), 3, 2)
	</code>
	<para>
	  Por defecto, el argumento opcional <argname>n</argname> está
	  establecido que sea igual a <argname>m</argname>. Cuando
	  el argumento opcional <argname>post</argname> no es cero,
	  se lleva a cabo la multiplicación posterior en lugar de la multiplicación
	  previa; y la opción Booleana <argname>add_id</argname> va a
	  premultiplicar la matriz <argname>A</argname> por
	  <math>I + K</math><sub>m,n</sub> en lugar de
	  <math>K</math><sub>m,n</sub>.
	</para>
      </description>
    </function>

    <function name="complex" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="scalar-or-matrix">A</fnarg>
	<fnarg optional="true" type="scalar-or-matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz compleja, en la que se toma <argname>A</argname>
	  para ofrecer la parte real y <argname>B</argname> para la parte
	  imaginaria. Si <argname>A</argname> es de dimensión <by r="m" c="n"/>
	  y <argname>B</argname> es un escalar, el resultado es una matriz
	  <by r="m" c="n"/> con una parte imaginaria constante (y de forma
	  similar en el caso recíproco, pero con una parte real constante). Si
	  ambos argumentos son matrices, deben tener las mismas dimensiones.
	  Si omites el segundo argumento, la parte imaginaria se establece
	  por defecto como cero.
	  <seelist><fncref targ="cswitch"/></seelist>
	</para>
      </description>
    </function>

    <function name="conj" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz compleja de dimensión <by r="m" c="n"/>
	  que contiene el conjugado complejo de cada elemento de la matriz
	  compleja <argname>C</argname> de dimensión <by r="m" c="n"/>.
	  El conjugado de un número complejo
	  <math>z</math> = <math>x</math> + <math>yi</math> es igual a
	  <math>x</math> &minus; <math>yi</math>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="carg"/>
	    <fncref targ="abs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="contains" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
	<fnarg type="matrix">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciona un medio de determinar si un objeto numérico
	  <argname>x</argname> está contenido en alguno de los elementos
	  de una matriz <argname>S</argname> (que cumple el papel de
	  un conjunto).
	</para>
	<para>
	  El valor que se devuelve es un objeto del mismo tamaño que
	  <argname>x</argname> que contiene valores de 1 en las posiciones
	  donde el valor <argname>x</argname> coincide con algún elemento
	  de <argname>S</argname>, y ceros en las demás.
	  Por ejemplo, el código
	</para>
	<code>
	  matrix A = mshape(seq(1,9), 3, 3)
	  matrix C = contains(A, {1, 5, 9})
	</code>
	<para>
	  produce
	</para>
	<code>
	  A (3 x 3)

	  1   4   7
	  2   5   8
	  3   6   9

	  C (3 x 3)

	  1   0   0
	  0   1   0
	  0   0   1
	</code>
	<para>
	  Esta función puede ser particularmente útil cuando <argname>x</argname>
	  es una serie que contiene una codificación muy refinada para una
	  característica cualitativa, y quieres reducir esto a un número de
	  categorías menor. Puedes meter en <argname>S</argname> un conjunto
	  de valores a consolidar, y obtener una variable ficticia con el valor 1
	  para las observaciones que coinciden con este conjunto, y el valor 0
	  para las demás.
	</para>
	<para>
	  Puesto que <argname>S</argname> funciona como un conjunto, debiera
	  ser un vector sin valores repetidos para tener una mayor eficiencia;
	  sin embargo, se acepta una matriz cualquiera.
	</para>
      </description>
    </function>

    <function name="conv2d" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con el cálculo de la convolución bidimensional
	  (2D) de dos matrices <argname>A</argname> y <argname>B</argname>.
	  Si <argname>A</argname> es de orden <by r="r" c="c"/> y
	  <argname>B</argname> es de orden <by r="m" c="n"/>, entonces
	  la matriz que se devuelve tendrá <math>r+m-1</math> filas
	  y <math>c+n-1</math> columnas.
	</para>
	<para context="tex">
	    La convolución 2D de <argname>A</argname> y
	    <argname>B</argname> se define como
	    \[
	    C_{i,j} =
	    \sum_{k=1}^r\sum_{l=1}^c A_{k,l} B_{i-k+1,j-l+1},
	    \]
	    donde los sumatorios admiten solo aquellos valores de $k$ y $l$ para
	    los que los subíndices de $B$ están dentro de los límites definidos.
	</para>
	<para>
	  <seelist>
            <fncref targ="fft"/>
            <fncref targ="filter"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cquad" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">Z</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada una matriz compleja <argname>Z</argname> de orden
	  <by r="m" c="n"/>, esta instrucción devuelve una matriz real de
	  orden <by r="m" c="n"/> que contiene las "cuadranzas" de cada uno de los
	  elementos de <argname>Z</argname>. La cuadranza de un número complejo
	  <math>z</math> = <math>a</math> + <math>bi</math> se define
	  como <math>a</math><sup>2</sup> + <math>b</math><sup>2</sup>.
	  Por tanto, es igual al cuadrado del módulo de <math>z</math>, y
	  también es igual a <math>z</math> multiplicado por su conjugado
	  complejo; pero el cálculo directo que realiza <lit>cquad</lit> es
	  considerablemente más rápido que cualquiera de las otras propuestas
	  alternativas.
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el valor del coeficiente de correlación entre
	  <argname>y1</argname> e <argname>y2</argname>. Los argumentos deben
	  ser dos series o dos vectores del mismo tamaño.
	  <seelist>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
            <fncref targ="npcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corresp" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">a</fnarg>
	<fnarg type="series-or-vec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  En base a una tabulación cruzada de <argname>a</argname> y
	  <argname>b</argname>, devuelve un código de tipo entero que indica
	  la clase de correspondencia entre las dos variables, del siguiente
	  modo.
	</para>
	<ilist>
	  <li>
	    <para>
	      Código = 2: hay una relación de tipo 1 a 1.
	    </para>
	  </li>
	  <li>
	    <para>
	      Código = 1: hay una relación de tipo 1 a n
	      (<argname>a</argname> <quote>anida</quote>
	      <argname>b</argname>, puede interpretarse como una función de
	      <argname>b</argname> en sentido matemático).
	    </para>
	  </li>
	  <li>
	    <para>
	      Código = &minus;1: hay una relación de tipo n a 1
	      (<argname>b</argname> <quote>anida</quote>
	      <argname>a</argname>, puede interpretarse como una función de
	      <argname>a</argname>).
	    </para>
	  </li>
	  <li>
	    <para>
	    Código = 0: hay ninguna relación.
	    </para>
	  </li>
	</ilist>
	<para>
	  Ten en cuenta que estos códigos se basan exclusivamente en los valores
	  muestrales de los dos argumentos. En caso de que <argname>b</argname>
	  sea el cuadrado de <argname>a</argname>, por ejemplo, el resultado
	  va a diferir dependiendo de si <argname>a</argname> contiene algunos
	  pares de valores que únicamente se diferencien en el signo
	  (código = &minus;1), o no (código = 2).
	</para>
	<para>
	  Un caso de posible utilización consiste en comprobar si dos series
	  discretas codifican la misma información. Por ejemplo, las siguientes
	  expresiones
	</para>
	<code>
	  open grunfeld.gdt
	  c = corresp($unit, firm)
	</code>
	<para>
	  proporcionan <lit>c</lit> = 2, indicando que la serie <lit>firm</lit>
	  es de hecho un único identificador para las unidades de sección
	  cruzada en ese conjunto de datos de panel.
	</para>
	<para>
	  Consulta también <fncref targ="mxtab"/>.
	</para>
      </description>
    </function>

    <function name="corrgm" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando se proporcionan solo los dos primeros argumentos, la función
	  devuelve una matriz con el correlograma de <argname>x</argname> para
	  los retardos desde 1 hasta <argname>p</argname>. Si <math>k</math> es el
	  número de elementos de <argname>x</argname> (igual a 1 si
	  <argname>x</argname> es una serie, igual al número de columnas si
	  <argname>x</argname> es una matriz, o igual al número de elementos
	  si <argname>x</argname> es una lista), el valor que se devuelve es una
	  matriz con <argname>p</argname> filas y 2<math>k</math> columnas,
	  en la que las <math>k</math> primeras columnas contienen las respectivas
	  autocorrelaciones, y las restantes contienen las respectivas autocorrelaciones
	  parciales.
	</para>
	<para>
	  Cuando se indica el tercer argumento, esta función calcula el
	  correlograma cruzado desde <math>+</math><argname>p</argname>
	  hasta <math>-</math><argname>p</argname> para cada uno de los <math>k</math>
	  elementos de <argname>x</argname> e <argname>y</argname>. La matriz
	  que se devuelve se compone de 2<math>p</math> + 1 filas y <math>k</math>
	  columnas. Si <argname>x</argname> es una serie o una lista, e
	  <argname>y</argname> es un vector, este último es necesario que tenga
	  tantas filas como el número total de observaciones que hay en la muestra
	  seleccionada en vigor.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el coseno de <argname>x</argname>.
	  <seelist>
            <fncref targ="sin"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el coseno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="acosh"/>
            <fncref targ="sinh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con la covarianza entre <argname>y1</argname> e
	  <argname>y2</argname>. Los argumentos deben ser dos series,
	  o bien dos vectores de la misma longitud.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Permite calcular valores críticos, y devuelve un resultado del mismo tipo
	  que el introducido. El valor <math>x</math> que se devuelve va a cumplir
	  <equation status="inline" ascii="P(X &gt; x) = p" tex="$P(X &gt; x) = p$"/>,
	  donde la distribución de <math>X</math> se determina por la letra
	  <argname>c</argname>. Entre los argumentos <argname>d</argname> y
	  <argname>x</argname>, puede necesitarse algún otro adicional (escalar)
	  para indicar los parámetros de la distribución. Esto se hace de este modo:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (c = z, n o N): sin argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): grados de libertad
            </para>
	  </li>
	  <li>
            <para>
              Chi-cuadrado (c, x o X): grados de libertad
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f o F): grados de libertad (num.), grados de libertad (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b o B): probabilidad, cantidad de ensayos
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p o P): media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l o L): media; escala
            </para>
	  </li>
	  <li>
            <para>
              Error Generalizado (E): forma
            </para>
	  </li>
	</ilist>
	<tabular colspec="llll">
	  \textit{Distribución} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp;
	  -- &amp; -- \\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  grados de libertad &amp; -- \\
	  Chi-cuadrado &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp;
	  grados de libertad &amp; -- \\
	  $F$ de Snedecor &amp; \texttt{f} o \texttt{F} &amp;
	  grados de libertad (num.) &amp; grados de libertad (den.) \\
	  Binomial &amp; \texttt{b} o \texttt{B} &amp;
	  $p$ &amp; $n$ \\
	  Poisson &amp; \texttt{p} o \texttt{P} &amp;
	  $\lambda$ &amp; -- \\
	  Laplace &amp; \texttt{l} o \texttt{L} &amp;
	  media &amp; escala \\
	  Error Generalizado &amp; \texttt{E} &amp;
	  forma &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cswitch" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="scalar">modo</fnarg>
      </fnargs>
      <description>
	<para>
	  Reinterpreta una matriz real como si contuviese valores complejos, o
	  viceversa. La acción concreta depende de <argname>modo</argname> (que
	  deberá tener un valor de 1, 2, 3 o 4), como se explica a continuación:
	</para>
	<para>
	  Modo 1: El argumento <argname>A</argname> debe ser una matriz
	  real con un número par de columnas. La función devuelve una matriz
	  con la mitad de las columnas, con valores complejos formados usando
	  las columnas impares de <argname>A</argname> para las partes reales,
	  y las columnas pares para las partes imaginarias.
	</para>
	<para>
	  Modo 2: Permite realizar la operación inversa a la del modo 1. El
	  argumento <argname>A</argname> debe ser una matriz compleja, y el
	  resultado que se devuelve es una matriz real que tendrá el doble de
	  columnas que las de <argname>A</argname>.
	</para>
	<para>
	  Modo 3: El argumento <argname>A</argname> debe ser una matriz
	  real con un número par de filas. La función devuelve una matriz
	  con la mitad de las filas, con valores complejos formados usando
	  las filas impares de <argname>A</argname> para las partes reales,
	  y las filas pares para las partes imaginarias.
	</para>
	<para>
	  Modo 4: Permite realizar la operación inversa a la del modo 3. El
	  argumento <argname>A</argname> debe ser una matriz compleja, y el
	  resultado que se devuelve es una matriz real que tendrá el doble de
	  filas que las de <argname>A</argname>.
	</para>
	<para>
	  <seelist><fncref targ="complex"/></seelist>
	</para>
      </description>
    </function>

    <function name="ctrans" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz compleja de dimensión <by r="n" c="m"/> que contiene
	  la traspuesta conjugada de la matriz compleja <argname>C</argname>
	  de dimensión <by r="m" c="n"/>. El operador <lit>&apos;</lit> (trasponer)
	  realiza también la trasposición conjugada de matrices complejas.
	  Puedes utilizar la función <fncref targ="transp"/> con matrices
	  complejas, pero esto va a hacer la trasposición <quote>directa</quote>
	  (no la conjugada).
	</para>
      </description>
    </function>

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Acumula <argname>x</argname> (es decir, crea una suma móvil). Cuando
	  <argname>x</argname> es una serie, produce una serie <math>y</math>
	  en la que cada uno de sus elementos es igual a la suma de los valores de
	  <argname>x</argname> hasta la observación correspondiente. El punto de
	  partida para la acumulación es la primera observación no ausente de la
	  muestra vigente seleccionada. Cuando se encuentra algún valor ausente
	  en <math>x</math>, se van a establecer como ausentes los valores
	  consiguientes de <math>y</math>. Cuando <argname>x</argname>
	  es una matriz, sus elementos se acumulan por
	  columnas.
	</para>
	<para context="tex">
	  Acumula <argname>x</argname>. Cuando <math>x</math> es una serie,
	  produce una serie $y_t = \sum_{s=m}^t x_s$, en la que el punto de partida
	  <math>m</math> para la acumulación, es la primera observación
	  no ausente de la muestra provisionalmente seleccionada. Al encontrar valores
	  ausentes en <math>x</math>, los valores posteriores de <math>y</math>
	  se definen como valores ausentes. Cuando <argname>x</argname> es una
	  matriz, los elementos se acumulan por columnas.
	</para>
	<para>
	  En el caso de datos de panel, la acumulación se produce en la dimensión
	  temporal, comenzando de nuevo para cada unidad del panel.
	</para>
	<para>
	  Si deseas que la acumulación ignore los valores ausentes (es decir,
	  para tratarlos como si fuesen ceros), puedes aplicar la función
	  <fncref targ="misszero"/> al argumento, como en
	</para>
	<code>
	  series cx = cum(misszero(x))
	</code>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Ofrece un medio bastante flexible de obtener un <quote>buffer</quote> de
	  texto que contiene datos de un servidor de internet, utilizando la biblioteca
	  'libcurl'. Al escribirla, el argumento de tipo 'bundle' <argname>b</argname>,
	  debe contener una cadena de texto llamada <lit>URL</lit> que indica
	  la dirección completa del recurso en el 'host' de destino. Otros elementos
	  opcionales se presentan a continuación:
	</para>
	<ilist>
	  <li>
	    <para>
	      <quote><lit>header</lit></quote>: una cadena de texto que
	      especifica un 'header' HTTP que va a enviarse al 'host'.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>postdata</lit></quote>: una cadena de texto que
	      contiene los datos que van a enviarse al 'host'.
	    </para>
	  </li>
	</ilist>
	<para>
	  Los campos <lit>header</lit> y <lit>postdata</lit> se destinan
	  para usarse con una solicitud HTTP de tipo <lit>POST</lit>. Si
	  está presente <lit>postdata</lit>, va implícito el método
	  <lit>POST</lit>; en caso contrario, va implícito el método <lit>GET</lit>.
	  (Pero observa que para sencillas solicitudes <lit>GET</lit>, la
	  función <fncref targ="readfile"/> ofrece una interfaz más
	  simple.)
	</para>
	<para>
	  Se reconoce otro elemento opcional del 'bundle': si está presente
	  un escalar llamado <lit>include</lit> y tiene un valor no nulo, esto
	  se entiende como una solicitud para incluir el 'header' recibido del
	  'host', en el cuerpo del resultado.
	</para>
	<para>
	  Al completarse la solicitud, el texto recibido del servidor
	  se añade al 'bundle' con la clave
	  <quote><lit>output</lit></quote>.
	</para>
	<para>
	  La función va a fallar si hay una equivocación al formular la solicitud
	  (por ejemplo, si no existe una <lit>URL</lit> en la entrada); en caso contrario,
	  va a devolver el valor 0 si la solicitud prospera, o un valor no
	  nulo si no lo hace. En este último caso, se añade el mensaje de
	  fallo de la biblioteca 'curl' al 'bundle', con el identificador 
	  <quote><lit>errmsg</lit></quote>. Ten en cuenta, sin embargo, que
	  <quote>éxito</quote> en este sentido no significa necesariamente
	  que obtienes los datos que deseabas; en realidad significa tan solo 
	  que se recibió alguna respuesta del servidor. Debes comprobar el
	  contenido del <quote>buffer</quote> de salida (que de hecho puede ser
	  un mensaje tal como <quote>Página no encontrada</quote>).
	</para>
	<para>
	  Aquí tenemos un ejemplo de cómo utilizar esta función: para bajar
	  algunos datos de la web de la US Bureau of Labor Statistics, que requiere
	  el envío de una consulta JSON. Observa el uso de <fncref targ="sprintf"/>
	  para insertar comillas en los datos <lit>POST</lit>.
	</para>
	<code>
	  bundle req
	  req.URL = "http://api.bls.gov/publicAPI/v1/timeseries/data/"
	  req.include = 1
	  req.header = "Content-Type: application/json"
	  string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	  req.postdata = s
	  err = curl(&amp;req)
	  if err == 0
	      s = req.output
	      string line
	      loop while getline(s, &amp;line)
	          printf "%s\n", line
	      endloop
	  endif
	</code>
	<para>
	  Consulta también las funciones <fncref targ="jsonget"/> y
	  <fncref targ="xmlget"/> para ver modos de procesamiento
	  de datos recibidos en formato JSON y XML, respectivamente.
	</para>
      </description>
    </function>

    <function name="dayspan" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">d1</fnarg>
	<fnarg type="int">d2</fnarg>
	<fnarg type="int">duracsemana</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un número entero con el número de días (relevantes) entre los
	  días de época <argname>d1</argname> y <argname>d2</argname>, ambos
	  incluidos, considerando la duración de semana indicada por el argumento
	  <argname>duracsemana</argname>. Este debe ser igual a 5, 6 o 7
	  (indicando el valor 6 que no se cuentan los domingos, y el 5 que no se
	  cuentan ni los sábados ni los domingos).
	</para>
	<para>
	  Para obtener los días de época en el formato más familiar de las fechas,
	  consulta <fncref targ="epochday"/>. Relacionado con esto, consulta
	  <fncref targ="smplspan"/>.
	</para>
      </description>
    </function>

    <function name="dec2bin" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función devuelve la representación binaria de los números
	  contenidos en el vector columna <argname>x</argname>, guardando
	  cada dígito binario en una columna de la matriz que se devuelve, y
	  que siempre tiene 32 columnas. Cada elemento de <argname>x</argname>
	  debe ser un entero entre 0 y <math>2</math><sup>32</sup><math>-1</math>.
	  En caso contrario, se va a mostrar un
	  fallo.
	</para>
	<para>
	  Ten en cuenta que se considera que el último bit significativo está
	  en la primera columna. Así, la columna 1 se va a corresponder con
	  <math>2</math><sup>0</sup>, la columna 2 con <math>2</math><sup>1</sup>,
	  y así sucesivamente. Por ejemplo, la
	  expresión
	</para>
	<code>
	  matrix B = dec2bin(5)
	</code>
	<para>
	  produce un vector fila lleno de ceros, excepto para las posiciones
	  1 y 3.
	</para>
	<para>
	  La función <fncref targ="bin2dec"/> realiza la transformación
	  inversa.
	</para>
      </description>
    </function>

    <function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permite definir <emphasis>detalladamente</emphasis> una variable
	  de tipo <quote>array</quote>, proporcionando uno o más
	  elementos. Al utilizar esta función debes especificar el tipo de
	  'array' (en forma plural): <lit>strings</lit>, <lit>matrices</lit>,
	  <lit>bundles</lit> o <lit>lists</lit>. Cada uno de los argumentos debe
	  ser un objeto del mismo tipo que el tipo especificado en la definición
	  del 'array'. En caso de completarse con éxito, la función devuelve como
	  resultado un 'array' con <math>n</math> elementos, donde <math>n</math>
	  es igual al número de argumentos.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  Consulta también <fncref targ="array"/>.
	</para>
      </description>
    </function>

    <function name="defbundle" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Te permite la carga inicial de una variable de tipo 'bundle'
	  <emphasis>extensamente</emphasis>, proporcionando cero o
	  más parejas con el formato <repl>clave</repl>, <repl>elemento</repl>.
	  Si contamos los argumentos desde 1, cada argumento numerado
	  impar debe evaluar una cadena de texto (clave), y cada
	  argumento numerado par debe evaluar un objeto de un tipo
	  que pueda incluirse en un 'bundle'.
	</para>
	<para>
	  Un par de ejemplos sencillos:
	</para>
	<code>
	  bundle b1 = defbundle("s", "Sample string", "m", I(3))
	  bundle b2 = defbundle("yn", normal(), "x", 5)
	</code>
	<para>
	  El primer ejemplo genera un 'bundle' cuyos elementos son una cadena
	  de texto y una matriz; el segundo, un 'bundle' con un elemento que es
	  una serie y otro que es escalar. Ten en cuenta que no puedes
	  especificar un tipo para cada argumento cuando utilizas esta función,
	  entonces debes aceptar el tipo <quote>natural</quote> de argumento
	  en cuestión. Si quieres añadir una serie con un valor constante de 5
	  a un 'bundle' llamado <lit>b1</lit> sería necesario hacer algo como
	  lo siguiente (después de definir <lit>b1</lit>):
	</para>
	<code>
	  series b1.s5 = 5
	</code>
	<para>
	  Si no indicas ningún argumento para esta función, eso
	  equivale a generar un 'bundle' vacío (o a vaciar un
	  'bundle' existente de su contenido), como podrías hacer
	  mediante
	</para>
	<code>
	  bundle b = null
	</code>
	<subhead>Variantes de sintaxis</subhead>
	<para>
	  Dispones de dos formas alternativas de sintaxis para definir 'bundles'.
	  En ambos casos, la palabra clave <lit>defbundle</lit> se sustituye
	  por un carácter de subrayado. En la primera variante, los elementos
	  separados por comas tienen la forma <lit>clave=valor</lit>, donde la
	  clave se entiende que debe ser una cadena de texto literal y no
	  requiere que la pongas entre comillas. Este es un ejemplo:
	</para>
	<code>
	  bundle b = _(x=5, strval="Alguna cadena", m=I(3))
	</code>
	<para>
	  Esta forma resulta particularmente conveniente para producir un 'bundle'
	  anónimo sobre la marcha como argumento de una función, como en
	</para>
	<code>
	  b = regls(ys, LX, _(lfrac=0.35, stdize=0))
	</code>
	<para>
	  donde la función <lit>regls</lit> tiene un argumento opcional de tipo
	  'bundle' que contiene varios parámetros.
	</para>
	<para>
	  La segunda variante está pensada para el caso en que quieras empaquetar
	  varios objetos ya existentes en un 'bundle': simplemente indica sus
	  nombres sin comillas:
	</para>
	<code>
	  bundle b = _(x, y, z)
	</code>
	<para>
	  En este caso, el objeto <lit>x</lit> se copia en un 'bundle' con la
	  clave <quote><lit>x</lit></quote>. De forma similar se hace tanto
	  para <lit>y</lit> como para <lit>z</lit>.
	</para>
	<para>
	  Estas formas alternativas implican teclear menos que en la versión
	  íntegra de <lit>defbundle()</lit>, y probablemente muchas veces
	  son más convenientes, pero ten en cuenta que son menos flexibles.
	  Solo en la versión íntegra puedes manejar las claves indicándolas
	  como variables de cadena de texto en lugar de cadenas literales.
	</para>
      </description>
    </function>

    <function name="deflist" section="data-utils" output="list">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Genera una lista (de series ya definidas) dados uno o más argumentos
	  apropiados. Cada argumento debe ser, una serie ya definida
	  (indicada por su nombre o el número entero ID), una lista ya definida,
	  o una expresión que se corresponda con una lista (incluyendo un vector que
	  pueda interpretarse como un conjunto de números ID de series).
	</para>
	<para>
	  Un aspecto a tener en cuenta es que esta función simplemente encadena
	  sus argumentos para producir la lista que devuelve. Cuando se
	  pretende que el valor que devuelva no contenga duplicados (que no
	  se refiera a ninguna serie más de una vez), depende del solicitante
	  asegurarse de que se satisfaga ese requerimiento.
	</para>
      </description>
    </function>

    <function name="deseas" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="bundle">opciones</fnarg>
      </fnargs>
      <description>
	<para>
	  La intención principal de esta función es producir una versión
	  desestacionalizada de la serie <argname>x</argname> (mensual o
	  trimestral) de entrada, utilizando para ello X-13ARIMA-SEATS; esto
	  estará disponible únicamente si está instalado X-13ARIMA-SEATS. Si
	  omites el 'bundle' necesario para el segundo argumento (opcional), el
	  ajuste estacional se hace incluyendo toda las opciones de X-13ARIMA
	  establecidas en sus valores por defecto (procedimiento completamente
	  automático). Cuando indicas el 'bundle' de <argname>opciones</argname>,
	  se podría incluir cualquiera de las siguientes especificaciones para las opciones.
	</para>
	<ilist>
	  <li>
	    <para>
	      <lit>verbose</lit>: ¿Qué presentar? 0 = nada (por defecto);
	      1 = confirmación de las opciones que están seleccionadas;
	      2 = confirmación de las opciones más el resultado de
	      X-13ARIMA.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>seats</lit>: 1 para utilizar el algoritmo SEATS en lugar
	      del algoritmo predeterminado X11 para el ajuste estacional, o
	      0.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>airline</lit>: 1 para utilizar la especificación <quote>airline</quote>
	      (0,1,1)(0,1,1) de modelos ARIMA en lugar de la selección de
	      modelos automática predeterminada, o 0.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>arima</lit>: Puede utilizarse para imponer una especificación
	      ARIMA escogida, en formato de un vector de 6 elementos que contenga
	      números enteros pequeños y no negativos. Estos se indican con la
	      simbología (p,d,q,P,D,Q) de la notación tradicional de las series
	      de tiempo: los primeros tres términos representan los órdenes AR,
	      de Integración y MA no estacionales; y los tres últimos indican
	      las contrapartidas estacionales. Cuando se indican tanto la opción
	      <lit>airline</lit> como la <lit>arima</lit>, tiene prioridad la
	      <lit>arima</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>outliers</lit>: Permite la detección y corrección de valores
	      atípicos (elecciones de 1 hasta 7), o 0 (predeterminado) para
	      omitir esta característica. Los tres tipos de valores atípicos
	      disponibles con sus códigos numéricos son: 1 = valor atípico
	      aditivo (ao), 2 = paso de nivel (ls), 4 = cambio temporal (tc).
	      Para combinar las opciones puedes añadir códigos, por ejemplo:
	      1 + 2 + 4 = 7 para activar las tres a un tiempo. Ten en cuenta
	      que la elección 3 = 1 + 2 (ao con ls) es la predeterminada en
	      X-13ARIMA-SEATS, y se selecciona mediante la casilla de valores
	      atípicos en la ventana de diálogo de GRETL para el ajuste
	      estacional por medio de X13.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>critical</lit>: Un escalar positivo con el valor crítico para
	      definir los valores atípicos, siendo automático el predeterminado
	      que se hace en función del tamaño de la muestra. Relevante solo
	      cuando indicas la opción <lit>outliers</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>logtrans</lit>: Debería pasarse la serie de entrada a
	      logaritmos? 0 = no, 1 = si, 2 = selección automática (por
	      defecto). Ten en cuenta que no se recomienda que indiques
	      una serie de entrada ya en logaritmos; si quieres que se utilice
	      el logaritmo, indica el nivel <quote>de base</quote> pero
	      especificando después <lit>logtrans=1</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>trading_days</lit>: Deberían incluirse los días de operación?
	      0 = no, 1 = si, 2 = automático (por defecto).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>working_days</lit>: Una versión más simple de
	      <lit>trading_days</lit> con una única distinción entre días de la
	      semana y fines de semana, en vez de los efectos de los días
	      particulares. 0 = no (por defecto), 1 = si, 2 = automático.
	      Utiliza solo una de las dos opciones, <lit>trading_days</lit>
	      o <lit>working_days</lit>.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>easter</lit>: 1 para permitir el efecto de la Pascua, como
	      complemento a <lit>trading_days</lit> o a <lit>working_days</lit>,
	      o 0 (por defecto).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>output</lit>: Una cadena de texto para escoger el tipo de serie
	      del resultado: <lit>"sa"</lit> para desestacionalizado (por
	      defecto), <lit>"trend"</lit> para la tendencia estimada, o
	      <lit>"irreg"</lit> para la componente irregular.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>save_spc</lit>: Indicador booleano, 0 por defecto; mira abajo.
	    </para>
	  </li>
	</ilist>
	<subhead>Resultados ampliados</subhead>
	<para>
	  En algunos casos podrías desear obtener los tres resultados disponibles
	  del X-13ARIMA mediante una única llamada a <lit>deseas</lit>. Esto se
	  admite del siguiente modo. Pasa el 'bundle' <argname>opciones</argname>
	  en formato de puntero, e indica la cadena de texto <lit>"all"</lit>
	  bajo la clave <lit>output</lit>. El valor directo que se devuelve entonces
	  es la serie ajustada estacionalmente, pero cuando se completa con
	  éxito <argname>opciones</argname> va a contener una matriz denominada
	  <lit>results</lit> con tres columnas: ajustada estacionalmente,
	  tendencia e irregular. A continuación tienes un ejemplo (en el que se
	  descarta el valor del resultado directo).
	</para>
	<code>
	  bundle b = _(output="all")
	  deseas(y, &amp;b)
	  series y_dseas = b.results[,1]
	  series y_trend = b.results[,2]
	  series y_irreg = b.results[,3]
	</code>
	<subhead>Guardando la especificación de X-13ARIMA</subhead>
	<para>
	  Puedes utilizar el indicador <lit>save_spc</lit> para guardar el
	  contenido del archivo de entrada X-13ARIMA que escribe GRETL. El
	  'bundle' con las opciones debe pasarse en formato de puntero, y la
	  especificación (como cadena de texto) puede encontrarse bajo la
	  clave <lit>x13a_spc</lit>. El siguiente código ilustra como se guarda
	  esta en un archivo bajo el nombre <lit>especif.spc</lit> en el
	  directorio de trabajo del usuario. (Observa que la extensión
	  <lit>.spc</lit> es requerida por X-13ARIMA.)
	</para>
	<code>
	  bundle b = _(save_spc=1)
	  deseas(y, &amp;b)
	  outfile especif.spc
	     print b.x13a_spc
	  end outfile
	</code>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el valor del determinante de <argname>A</argname>,
	  calculado mediante la descomposición LU. Si lo que realmente quieres es el
	  logaritmo natural del determinante, debes en cambio invocar <fncref targ="ldet"/>.
	  <seelist>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diag" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna con los valores de la diagonal principal de
	  <argname>X</argname>. Observa que si <argname>X</argname> es una
	  matriz de orden <by r="m" c="n"/>, el número de elementos del vector
	  resultante es igual a min(<math>m</math>, <math>n</math>).
	  <seelist>
            <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con la suma directa de <argname>A</argname> y
	  <argname>B</argname>; es decir, una matriz que abarca a
	  <argname>A</argname> en la esquina superior izquierda y a
	  <argname>B</argname> en la esquina inferior derecha. Si
	  <argname>A</argname> y <argname>B</argname> son ambas
	  cuadradas, la matriz resultante es diagonal por bloques.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del mismo tipo que el argumento) con las primeras
	  diferencias. Si <argname>y</argname> es una serie o una lista de series,
	  los valores iniciales son <lit>NA</lit>; si <argname>y</argname> es una
	  matriz, la diferenciación se hace por columnas y los valores iniciales son 0.
	</para>
	<para>
	  Cuando esta función devuelve una lista, cada una de las variables
	  de la misma se nombra de modo automático conforme al patrón
	  <lit>d_</lit><repl>varname</repl>, donde <repl>varname</repl>
	  se substituye por el nombre de la serie original. De ser necesario, el nombre
	  se va a truncar; e incluso se ajustará en caso de que el conjunto de
	  nombres que se construye así, dé lugar a que alguno de ellos no sea
	  único.
	</para>
	<para>
	  <seelist>
            <fncref targ="cum"/>
            <fncref targ="ldiff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve un resultado (del tipo del argumento) con el valor de la función
	  digamma (o Psi) de <argname>x</argname>, es decir, la derivada del
	  logaritmo de la función Gamma.
	</para>
	<para context="tex">
	  Devuelve un resultado con el valor de la función digamma (o Psi) de $x$, es
	  decir $\frac {\mathrm{d}} {\mathrm{d} x}\, \log \Gamma(x)$.
	</para>
	<para>
	  <seelist>
            <fncref targ="lngamma"/>
            <fncref targ="trigamma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="distance" section="math" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="string">metrica</fnarg>
	<fnarg optional="true" type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula las distancias entre puntos sobre una métrica que puede ser
	  <lit>euclidean</lit> (a predeterminada), <lit>manhattan</lit>,
	  <lit>hamming</lit>, <lit>chebyshev</lit>, <lit>cosine</lit> o
	  <lit>mahalanobis</lit>. Puedes indicar la cadena de texto que identifica
	  la métrica, truncándola de forma que no resulte ambigua. Las otras
	  métricas adicionales, de correlación y la euclídea tipificada se admiten
	  mediante transformaciones simples de las anteriores (mira más abajo).
	</para>
	<para>
	  Cada fila de la matriz <argname>X</argname> (que es <by r="m" c="n"/>)
	  se trata como un punto de un espacio <math>n</math>-dimensional; en
	  un contexto econométrico, esto probablemente represente una única
	  observación que comprenda los valores de <math>n</math>
	  variables.
	</para>
	<subhead>Casos típicos</subhead>
	<para>
	  Esta sección se aplica a todas las métricas, excepto a la distancia
	  de Mahalanobis, para la que la sintaxis es levemente diferente
	  (mira más abajo).
	</para>
	<para>
	  Si no indicas <argname>Y</argname>, el valor que se devuelve es un
	  vector columna de longitud <math>m</math>(<math>m</math> &minus; 1)/2
	  que comprende el subconjunto no redundante de todas las distancias por
	  parejas entre los <math>m</math> puntos (las filas de <argname>X</argname>).
	  Entonces, dado un vector de este tipo denominado <lit>d</lit>,
	  puedes generar la matriz simétrica completa con las distancias
	  entre los puntos(con ceros en la diagonal principal, naturalmente)
	  por medio de
	</para>
	<code>
	  D = unvech(d, 0)
	</code>
	<para>
	  puesto que <lit>d</lit> es similar al vector columna resultante al usar
	  la función vech sobre <lit>D</lit>, sin los elementos de la diagonal
	  principal. El segundo argumento (opcional) de <fncref targ="unvech"/>
	  indica que debe rellenarse la diagonal con ceros.
	</para>
	<para>
	  Si indicas <argname>Y</argname>, debe ser una matriz <by r="p" c="n"/>
	  en la que cada una de sus filas se trate otra vez como un punto en el
	  espacio <math>n</math>-dimensional. En este caso, e valor que se
	  devuelve es una matriz <by r="m" c="p"/> cuyo elemento <math>i,j</math>
	  contiene la distancia que hay entre la fila <math>i</math> de la
	  matriz <argname>X</argname> y la fila <math>j</math> de la matriz
	  <argname>Y</argname>.
	</para>
	<para>
	  Para obtener las distancias desde un punto de referencia dado (por ejemplo,
	  el centroide) hasta cada uno de los <math>n</math> puntos de datos, indica
	  <argname>Y</argname> como una única fila.
	</para>
	<subhead>Definiciones de las métricas admitidas</subhead>
	<ilist>
	  <li>
	    <para>
	      <lit>euclidean</lit>: la raíz cuadrada de la suma de las desviaciones
	      elevadas al cuadrado, en cada una de las dimensiones.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>manhattan</lit>: a suma de los valores absolutos de las
	      desviaciones, en cada una de las dimensiones.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>hamming</lit>: la proporción de las dimensiones en las que
	      las desviaciones no son nulas (acotada entonces por 0 y 1).
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>chebyshev</lit>: el mayor de los valores absolutos de las
	      desviaciones en cualquiera de las dimensiones.
	    </para>
	  </li>
	  <li>
	    <para>
	      <lit>cosine</lit>: 1 menos el coseno del ángulo que se forma entre
	      los <quote>puntos</quote>, considerados como vectores.
	    </para>
	  </li>
	</ilist>
	<subhead>Distancia de Mahalanobis</subhead>
	<para>
	  Las distancias de Mahalanobis se definen como distancias euclídeas,
	  entre los puntos considerados (filas de la matriz <argname>X</argname>)
	  y un centroide dado, escaladas mediante la inversa de una matriz de
	  covarianzas. En el caso más simple, el centroide está constituido por las
	  medias muestrales de las variables (columnas de <argname>X</argname>)
	  y la matriz de covarianzas está formada por las covarianzas entre ellas
	  en la muestra.
  </para>
  <para>
	  Esto se puede obtener indicando como segundo argumento la cadena de
	  texto <quote>mahalanobis</quote> o cualquier abreviatura no ambigua,
	  como en
	</para>
	<code>
	  dmahal = distance(X, "mahal")
	</code>
	<para>
    En este caso, el tercer argumento <argname>Y</argname> no se
    admite, y el valor que se devuelve es un vector columna de longitud
    <math>m</math> con las distancias de Mahalanobis desde el centroide
    de <argname>X</argname> (es decir, su media muestral). En la práctica,
    la matriz del resultado en este caso es la misma que obtienes al
    ejecutar la instrucción <cmdref targ="mahal"/> sobre una lista de
    series que se correspondan con las columnas de la matriz
    <argname>X</argname>.
	</para>
	<para>
	  Para obtener las distancias de Mahalanobis usando un centroide
	  distinto, <lit>mu</lit>, y/o la inversa de la matriz de covarianzas,
	  <lit>ICV</lit>, puedes utilizar la siguiente sintaxis:
	</para>
	<code>
	  dmahal = distance(X*cholesky(ICV), "euc", mu)
	</code>
	<subhead>Otras métricas</subhead>
	<para>
	  Puedes obtener las distancias euclídeas tipificadas y de correlaciones
	  del modo siguiente:
	</para>
	<code>
	  # Euclídea tipificada
	  dseu = distance(stdize(X), "eu")
	  # Correlación (basada en el coseno)
	  dcor = distance(stdize(X', -1)', "cos")
	</code>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del mismo tipo que el argumento) con el valor de la
	  densidad de la distribución de probabilidad Normal estándar en
	  <argname>x</argname>. Para obtener la densidad de una distribución Normal
	  no estándar en <math>x</math>, transforma tipificando <math>x</math>
	  en <math>z</math>, aplícale a esto la función <lit>dnorm</lit> y
	  multiplica el resultado por el Jacobiano de la transformación <math>z</math>,
	  es decir , 1/&sigma;, conforme se ilustra a continuación:
	</para>
	<code>
	  mu = 100
	  sigma = 5
	  x = 109
	  fx = (1/sigma) * dnorm((x-mu)/sigma)
	</code>
	<para>
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una lista con los mismos elementos que <argname>X</argname>,
	  pero excluyendo las series que causan multicolinealidad perfecta. En
	  consecuencia, si todas las series que hay en <argname>X</argname>
	  son linealmente independientes, la lista que resulta es simplemente
	  una copia de <argname>X</argname>.
	</para>
	<para>
	  El algoritmo usa la descomposición QR (transformación de Householder),
	  por lo que está sujeto a error de precisión finita. Con el objeto de
	  calibrar la sensibilidad del algoritmo, puedes especificar un segundo
	  parámetro (opcional) <argname>epsilon</argname> para hacer el contraste
	  de multicolinealidad más o menos estricto, según desees. Por
	  defecto, el valor para <argname>epsilon</argname> es 1.0e-8, pero
	  ajustando <argname>epsilon</argname> dándole valores mayores,
	  se eleva la probabilidad de que se descarte una de las series.
	</para>
	<para>
	  El ejemplo
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # Indica un épsilon con un valor muy pequeño
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produce
	</para>
	<code>
	  ? list print X
	  foo bar foobar
	  ? list print Y
	  foo bar
	  ? list Y = dropcoll(X, 1.0e-30)
	  Se ha reemplazado la lista Y
	  ? list print Y
	  foo bar foobar
	</code>
      </description>
    </function>

    <function name="dsort" section="matrix" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordena <argname>x</argname> de forma decreciente, descartando
	  observaciones con valores ausentes cuando <argname>x</argname> es
	  una serie.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  El argumento <argname>x</argname> debe ser una serie discreta. Esta
	  función devuelve una lista con un conjunto de variables ficticias, una
	  para cada uno de los diferentes valores de la serie. Por defecto, el menor
	  valor se trata como la categoría omitida y no va a representarse
	  explícitamente.
	</para>
	<para>
	  El segundo argumento (opcional) indica el valor de <argname>x</argname>
	  que debe ser tratado como categoría omitida. Cuando se indica un único
	  argumento, el efecto es equivalente al de utilizar la instrucción:
	  <lit>dummify(x, min(x))</lit>. Para producir un conjunto completo de
	  variables ficticias, es decir, sin omitir ninguna categoría, puedes
	  usar <lit>dummify(x, NA)</lit>.
	</para>
	<para>
	  Las variables que se generan se nombran automáticamente de acuerdo con el
	  siguiente patrón:
	  <lit>D</lit><repl>nombrevariable</repl><lit>_</lit><repl>i</repl> donde
	  <repl>nombrevariable</repl> indica el nombre de la serie original e <repl>i</repl>
	  es un índice entero positivo. De ser necesario, la porción original del
	  nombre se va a truncar, e incluso se ajustará en caso de que el conjunto de
	  nombres que se construye así, dé lugar a que alguno de ellos no sea
	  único.
	</para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Poniendo un año como argumento <argname>y</argname>, devuelve un
	  resultado del mismo tipo que este, con la fecha del domingo de Pascua de ese
	  año en el calendario gregoriano, con el formato <math>mes + día/100</math>.
	  Por ejemplo, en 2014 la fecha del domingo de Pascua fue el 20 de abril,
	  lo que se representa con esta convención como 4,2. (Observa que el día
	  2 de abril se devuelve como 4,02.) El siguiente código muestra como
	  pueden extraerse el día y el mes del valor que devuelve esta función:
	</para>
	<code>
	  scalar e = easterday(2014)
	  scalar m = floor(e)
	  scalar d = round(100*(e-m))
	</code>
      </description>
    </function>

    <function name="ecdf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula la función de distribución acumulativa (CDF) empírica de
	  <argname>y</argname>. El resultado se devuelve en formato de matriz
	  con dos columnas: la primera contiene los valores únicos ordenados de
	  <argname>y</argname>; y la segunda contiene la frecuencia relativa 
	  acumulada, es decir el número de casos en los que su valor es menor o
	  igual al valor correspondiente de la primera columna, dividido por el
	  número total de observaciones.
	</para>
	<para context="tex">
	  Calcula la función de distribución acumulativa (CDF) empírica de
	  <argname>y</argname>. El resultado se devuelve en formato de matriz
	  con dos columnas: la primera contiene los valores únicos ordenados de
	  <argname>y</argname>; y la segunda contiene la frecuencia relativa acumulada
	  \[ F(y) =
	  \frac{1}{n} \sum_{i=1}^n I(y_i \leq y)
	  \]
	  donde $n$ es el número total de observaciones, e $I()$ denota la función
	  indicatriz.
	</para>
      </description>
    </function>

    <function name="eigen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
	<fnarg type="matrixref" optional="true">&amp;W</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula los autovalores (y opcionalmente los autovectores derechos
	  y/o izquierdos) de la matriz <argname>A</argname> de dimensión
	  <by r="n" c="n"/>, que puede ser real o compleja. Los autovalores
	  se devuelven en un vector columna complejo. Para obtener la norma
	  de los autovalores puedes utilizar la función <fncref targ="abs"/>,
	  que admite argumentos complejos.
	</para>
	<para>
	  Si quieres recuperar los autovectores derechos (como en el caso de
	  una matriz compleja de dimensión <by r="n" c="n"/>), indica el nombre
	  de una matriz ya existente, precedido por <lit>&amp;</lit> para
	  indicar la <quote>dirección</quote> de la matriz en cuestión, como
	  segundo argumento. De otro modo, puedes omitir este argumento.
	</para>
	<para>
	  Para recuperar los autovectores izquierdos (otra vez, como en una
	  matriz compleja), indica la dirección de una matriz como tercer
	  argumento. Ten en cuenta que, si quieres los autovectores izquierdos
	  pero no los derechos, debes usar la palabra clave <lit>null</lit>
	  como marcador para el segundo argumento.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  <emphasis>Esta es una función heredada, anterior al soporte
	  original de GRETL para matrices complejas. No debes usarla en
	  los guiones nuevos que escribas en lenguaje HANSL. Utiliza
	  </emphasis> <fncref targ="eigen"/> <emphasis> en su lugar.</emphasis>
	</para>
	<para>
	  Calcula los autovalores y, opcionalmente, los autovectores de la matriz
	  <argname>A</argname> de orden <by r="n" c="n"/>. Cuando todos los
	  autovalores son reales, se devuelve una matriz <by r="n" c="1"/>. En caso
	  contrario, el resultado es una matriz <by r="n" c="2"/>, con una primera
	  columna que contiene los elementos reales, y una segunda columna con los
	  elementos imaginarios. No se garantiza que los autovalores se vayan a
	  clasificar en ningún orden en particular.
	</para>
	<para>
	  Hay dos opciones para el segundo argumento: que se trate del nombre
	  de una matriz ya existente precedida por <lit>&amp;</lit> (para
	  indicar la <quote>dirección</quote> de la matriz en cuestión), en cuyo
	  caso en esta matriz se guarda un resultado auxiliar; o que se trate
	  de la palabra clave <lit>null</lit>, en cuyo caso no se produce el
	  resultado auxiliar.
	</para>
	<para>
	  Cuando el segundo argumento no es nulo, se va a sobrescribir la matriz
	  especificada con el resultado auxiliar (y no es necesario que la matriz
	  existente tenga la dimensión adecuada para recibir el resultado). El
	  resultado en la matriz <argname>U</argname> se organiza del siguiente modo:
	</para>
	<ilist>
	  <li>
            <para>
              Si el <math>i</math>-ésimo autovalor es real, la
              <math>i</math>-ésima columna de <math>U</math> va a
              contener el autovector correspondiente;
            </para>
	  </li>
	  <li>
            <para>
              Si el <math>i</math>-ésimo autovalor es complejo, la
              <math>i</math>-ésima columna de <math>U</math> va a
              contener la parte real del autovector correspondiente, y la
              siguiente columna la parte imaginaria. El autovector del autovalor
              conjugado es el conjugado del autovector.
            </para>
	  </li>
	</ilist>
	<para>
	  En otras palabras, los autovectores se guardan en el mismo orden que los
	  autovalores; ahora bien, los autovectores reales ocupan una columna,
	  mientras que los autovectores complejos ocupan dos (y la parte real
	  se guarda primero). Aún así, el número total de columnas es
	  <math>n</math>, pues el autovector conjugado se ignora.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="qrdecomp"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona del mismo modo que la función <fncref targ="eigen"/>,
	  excepto que el argumento <argname>A</argname> debe ser simétrico
	  (por lo que, en este caso, se pueden acortar los cálculos), y los
	  autovalores se devuelven en orden ascendente. Si deseas obtener los
	  autovalores en orden descendente (y tener los autovectores reordenados
	  en consecuencia), puedes hacer lo siguiente:
	</para>
	<code>
	  matrix U
	  e = eigensym(A, &amp;U)
	  Tmp = msortby((-e' | U)',1)'
	  e = -Tmp[1,]'
	  U = Tmp[2:,]
	  # Ahora los autovalores de mayor a menor
	  print e U
	</code>
	<para>
	  Aviso: Si lo que te interesa es la descomposición espectral de
	  una matriz de la forma <math>X'X</math>, es preferible calcular
	  el argumento mediante el operador <lit>X'X</lit>, en lugar de
	  utilizar la sintaxis más general <lit>X'*X</lit>. La primera
	  expresión utiliza un algoritmo especializado que ofrece mayor
	  eficiencia desde el punto de vista del cómputo, y garantiza que
	  el resultado va a ser exactamente simétrico.
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Resuelve el problema del autovalor generalizado de tipo
	  |<math>A</math> &minus; &lgr;<math>B</math>| = 0, donde ambas
	  <math>A</math> y <math>B</math> son matrices simétricas, y
	  <math>B</math> se define positiva. Se devuelve directamente una matriz
	  con los autovalores ordenados de forma ascendente. Cuando utilizas el
	  tercer argumento (opcional), este debe ser el nombre de una matriz ya
	  existente, precedida por <lit>&amp;</lit>. En este caso, los autovectores
	  generalizados se escriben en esta matriz que se indica.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">año</fnarg>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">día</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar o una serie, con el número del día especificado por el
	  año, mes y día, en ese orden, en la época actual. El número del día es igual
	  a 1 para el día 1 de enero del año 1 después de Cristo, en el calendario
	  Gregoriano proléptico, y a 733786 para la fecha 01-01-2010. Si alguno de
	  los argumentos es una serie, el valor que se devuelve también tendrá la
	  forma de una serie; en caso contrario, se devuelve un escalar.
	</para>
	<para>
	  Por defecto, los valores de los argumentos <argname>año</argname>,
	  <argname>mes</argname> y <argname>día</argname> se
	  presupone que se están indicando de acuerdo con calendario Gregoriano,
    pero si el año tiene un valor negativo, la interpretación cambia a la del
    calendario Juliano.
	</para>
	<para>
	  También se admite una petición alternativa: si indicas un único
	  argumento, se va a considerar que es una fecha (o una serie de
	  fechas) en formato numérico ISO 8601 <quote>básico</quote>,
	  <lit>YYYYMMDD</lit>. De esta forma, las dos siguientes peticiones
	  producen el mismo resultado, concretamente 700115.
	</para>
	<code>
	  eval epochday(1917, 11, 7)
	  eval epochday(19171107)
	</code>
	<para>
	  Para la inversa de esta función consulta <fncref targ="isodate"/>, y
	  también <fncref targ="juldate"/> (para el calendario Juliano). Para
	  ver otros medios de conversión de fechas en días de época, consulta
	  <fncref targ="strpday"/>.
	</para>
      </description>
    </function>

    <function name="errmsg" section="programming" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una cadena de texto con el mensaje de fallo de GRETL asociada
	  a <argname>errno</argname>, que debe ser un número entero.
	  Consulta también <fncref targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="errorif" section="programming" output="scalar">
      <fnargs>
	<fnarg type="bool">condicion</fnarg>
	<fnarg type="string">mensaje</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función solo se aplica en el contexto de una función definida por
	  el usuario, o dentro de un bloque <cmdref targ="mpi"/>. Si la
	  <argname>condicion</argname> se valora como no nula,
	  ello implica que la ejecución de la función vigente finalice con la
	  presentación de un mensaje condicionado a que se produzca un fallo;
	  entonces el argumento <argname>mensaje</argname> se presentará como
	  parte del mensaje de fallo que se muestra al llamar a la función en cuestión.
	</para>
	<para>
	  El valor que se devuelve con esta función (1) es simplemente nominal.
	</para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nombre</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar no nulo si <argname>nombre</argname>(que debe ser
	  un identificador válido de GRETL) denomina un objeto con una definición
	  vigente, sea un escalar, una serie, una matriz, una lista, una cadena
	  de texto, un 'bundle' o un 'array'. En otro caso devuelve 0.
	</para>
	<para>
	  El pretendido uso de esto es para el caso en que una función definida
	  por el usuario tenga un parámetro opcional con un <lit>nulo</lit> por
	  defecto. El redactor de la función puede utilizar <lit>exists()</lit>,
	  indicando el nombre del parámetro, para comprobar si el invocador
	  proporciona un argumento. Por favor, pero ten en cuenta que las listas
	  son una excepción en este aspecto: si un parámetro de una lista
	  tiene un <lit>nulo</lit> por defecto y el invocador no proporciona un
	  argumento, la función coge una lista vacía en lugar de no tomar
	  ninguna lista; por lo tanto, la función <lit>exists</lit> siempre
	  va a devolver no nulo. Para comprobar el vacío en el argumento de
	  una lista, utiliza <fncref targ="nelem"/>.
	</para>
	<para>
	  Para comprobaciones relacionadas, consulta <fncref targ="typeof"/>
	  e <fncref targ="inbundle"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con <math>e</math><sup>x</sup>.
	  Ten en cuenta que, con argumento matricial, se aplica elemento a elemento.
	  Para la función exponencial matricial consulta <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-list-or-mat">f</fnarg>
	<fnarg optional="true" type="bool">U2</fnarg>
      </fnargs>
      <description>
	<para>
	  Genera una matriz que contiene varios estadísticos que sirven
	  para evaluar <argname>f</argname> como predicción de los datos
	  observados <argname>y</argname>.
	</para>
	<para>
	  Cuando <argname>f</argname> es una serie o un vector, el resultado
	  es un vector columna. Cuando <argname>f</argname> es una lista con
	  <math>k</math> elementos o una matriz de dimensión <by r="T" c="k"/>,
	  el resultado tiene <math>k</math> columnas en las que cada una contiene
	  los estadísticos del término correspondiente (serie de la lista o columna
	  de la matriz) como predicción de <argname>y</argname>.
	</para>
	<para>
	  En todo caso, la dimensión <quote>vertical</quote> de los datos
	  introducidos (la longitud de la muestra vigente para una serie o lista,
	  y el número de filas para una matriz) debe coincidir entre los dos
	  argumentos.
	</para>
	<para>
	  Las filas de la matriz que se devuelven son como se indica a continuación:
	</para>
	<code>
	  1  Error medio
	  2  Raíz del Error cuadrático medio
	  3  Error absoluto medio
	  4  Porcentaje de error medio
	  5  Porcentaje de error absoluto medio
	  6  U de Theil (U1 o U2)
	  7  Proporción de sesgo, UM
	  8  Proporción de regresión, UR
	  9  Proporción de perturbación, UD
	</code>
	<para>
	  La variante del U de Theil que se presenta por defecto depende de la
	  naturaleza de los datos: cuando se sabe que son series de tiempo, se
	  muestra el U2; en caso contrario, se produce el U1. Pero puedes forzar
	  esta elección por medio del último argumento opcional: indica un valor
	  no nulo para forzar el U2, o un valor de cero para forzar el U1.
	</para>
	<para>
	  Para obtener más detalles sobre el cálculo de esos estadísticos y de la
	  interpretación de los valores de <math>U</math>, consulta
	  <guideref targ="chap:forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">llamaf</fnarg>
	<fnarg optional="true" type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite calcular una aproximación numérica al Jacobiano
	  asociado al <math>n</math>-vector <argname>b</argname>,
	  así como la función de transformación especificada por el
	  argumento <argname>llamaf</argname>. Al apelar a esta función
	  debes utilizar <argname>b</argname> como primer argumento
	  de la misma (bien directamente o en forma de puntero), seguido
	  de cualquier argumento adicional que pueda necesitarse; y como
	  resultado se debiera producir una matriz <by r="m" c="1"/>.
	  Cuando se ejecuta con éxito, <lit>fdjac</lit> va a devolver
	  una matriz <by r="m" c="n"/> que contiene el Jacobiano.
	</para>
	<para>
	  Puedes utilizar el tercer argumento (opcional) para determinar el
	  tamaño de la medida <math>h</math> que se usa en el mecanismo de
	  aproximación (mira más abajo). Cuando omites este argumento, el
	  tamaño de la medida se determina automáticamente.
	</para>
	<para>
	  Aquí tienes un ejemplo de su uso:
	</para>
	<code>
	  matrix J = fdjac(theta, mifunc(&amp;theta, X))
	</code>
	<para>
	  La función puede utilizar tres métodos distintos: diferencia simple hacia
	  adelante, diferencia bilateral o extrapolación de 4-nodos de Richardson.
	  Estas se corresponden respectivamente con:
	</para>
	<para context="tex">
	  \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
	</para>
	<para context="tex">
	  \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
	</para>
	<para context="tex">
	  \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
	</para>
	<para context="notex">
	  <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>2</sub>  = <math>[8(f(x+h) - f(x-h)) -
	  (f(x+2h) - f(x-2h))] /12h</math>
	</para>
	<para>
	  Estas tres alternativas generalmente proporcionan una conciliación
	  entre precisión y velocidad. Puedes elegir entre los distintos
	  métodos mediante la instrucción <cmdref targ="set"/>: especifica el
	  valor 0, 1 o 2 para la variable <lit>fdjac_quality</lit>. El valor
	  por defecto es 0.
	</para>
	<para>
	  Para más detalles y ejemplos, consulta
	  <guideref targ="chap:numerical"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	          <fncref targ="numhess"/>
            <cmdref targ="set"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="feval" section="programming" output="seebelow">
      <fnargs>
	<fnarg type="string">nombrefuncion</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Principalmente útil para los creadores de funciones. El primer
	  argumento debe ser el nombre de una función; los restantes argumentos
	  se pasarán a la función especificada. Esto permite tratar la propia
	  función identificada mediante <argname>nombrefuncion</argname>
	  como una variable en si misma. El valor que se devuelve es cualquier
	  cosa que produzca la función indicada, dados los argumentos
	  especificados.
	</para>
	<para>
	  El ejemplo de abajo, ilustra algunos de sus posibles usos.
	</para>
	<code>
	  function scalar utilidad (scalar c, scalar sigma)
	      return (c^(1-sigma)-1)/(1-sigma)
	  end function

	  strings S = defarray("log", "utilidad")

	  # Llamada a una función integrada de 1 argumento
	  x = feval(S[1], 2.5)
	  # Llamada a una función definida por el usuario
	  x = feval(S[2], 5, 0.5)
	  # Llamada a una función integrada de 2 argumentos
	  func = "zeros"
	  m = feval(func, 5-2, sqrt(4))
	  print m
	  # Llamada a una función integrada de 3 argumentos
	  x = feval("monthlen", 12, 1980, 5)
	</code>
	<para>
	  Existe una frágil analogía entre la función <lit>feval</lit> y
	  <fncref targ="genseries"/>: ambas funciones convierten en variable
	  un elemento sintáctico que habitualmente se fija al tiempo en el
	  que se redacta un guion.
	</para>
	<para>
	  <seelist>
            <fncref targ="fevalb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fevalb" section="programming" output="seebelow">
      <fnargs>
	<fnarg type="string">nombrefunc</fnarg>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta es una variante de la función <fncref targ="feval"/> que afronta
	  una situación en la que se pueden encontrar los creadores de
	  funciones, cuando no se sabe de antemano el número y los tipos de
	  argumentos que se van a pasar a la función indicada. En lugar de
	  pasar los argumentos individualmente, se pasan como miembros de
	  un argumento <argname>b</argname> de tipo 'bundle'.
	</para>
	<para>
	  Dado que el orden de los miembros de un 'bundle' de GRETL es
	  indeterminado, se requiere algún mecanismo para asegurarnos
	  de que estos se pasan a la función en cuestión, en el orden
	  correcto. Esto se asegura automáticamente si el orden lexicográfico
	  de las claves que hay en el 'bundle', indica también el orden de
	  los argumentos. Por ejemplo, las claves podrían ser <lit>arg1</lit>,
	  <lit>arg2</lit>, etcétera (o <lit>arg01</lit>, <lit>arg02</lit>,
	  etcétera en el improbable caso de que la función tuviese más de
	  nueve argumentos). Como alternativa, el 'bundle' puede contener
	  un 'array' cadenas de texto bajo la clave reservada <lit>arglist</lit>.
	  Este 'array' debe contener exactamente las claves del 'bundle'
	  <argname>b</argname> (excepto el propio <lit>arglist</lit>), en
	  el orden deseado.
	</para>
	<para>
	  Los ejemplos de abajo ilustran ambas propuestas, aplicadas a la
	  función <fncref targ="monthlen"/>.
	</para>
	<code>
	  # Utilizando el orden lexicográfico
	  bundle b = _(arg1=12, arg2=1980, arg3=5)
	  n = feval("monthlen", b)

	  # Utilizando arglist
	  bundle b = _(month=12, year=1980, wkdays=5)
	  b.arglist = defarray("month", "year", "wkdays")
	  n = feval("monthlen", b)
	</code>
	<para>
	  <seelist>
            <fncref targ="feval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fevd" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="int">efecto</fnarg>
	<fnarg type="int">motivo</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función proporciona una alternativa más flexible que el
	  accesor <fncref targ="$fevd"/> para obtener una matriz
	  de descomposición de la varianza del error de predicción (FEVD),
	  después de estimar un VAR o un VECM. Si el argumento final
	  (opcional), solo está disponible cuando el último modelo estimado
	  fue un VAR o un VECM. Como alternativa, puedes guardar en un
	  'bundle' la información sobre estos tipos de sistemas, mediante el
	  accesor <fncref targ="$system"/>, y posteriormente pasarle
	  la función <lit>fevd</lit>.
	</para>
	<para>
	  Los argumentos de la función, <argname>efecto</argname> e
	  <argname>motivo</argname>, tienen la forma de índices enteros
	  positivos de las variables endógenas del sistema, tomando el 0 para
	  representar <quote>todas</quote>. El siguiente fragmento de código,
	  ilustra su uso. En el primer ejemplo, la matriz <lit>fe1</lit>
	  contiene las partes de la FEVD para <lit>y1</lit> debidas a cada
	  parte de <lit>y1</lit>, <lit>y2</lit> e <lit>y3</lit> (por lo tanto,
	  las filas suman 1 en total). En el segundo, <lit>fe2</lit> contiene
	  la contribución de <lit>y2</lit> a la varianza del error de predicción
	  de las tres variables (entonces, las filas no suman 1 en total).
	  En el tercer caso, lo que se devuelve es un vector columna que
	  muestra la <quote>parte propia</quote> de la FEVD de
	  <lit>y1</lit>.
	</para>
	<code>
	  var 4 y1 y2 y3
	  bundle vb = $system
	  matrix fe1 = fevd(1, 0, vb)
	  matrix fe2 = fevd(0, 2, vb)
	  matrix fe3 = fevd(1, 1, vb)
	</code>
	<para>
	  El número de períodos (filas) sobre los que se traza la
	  descomposición, se determina automáticamente en base a la
	  frecuencia de los datos, pero puedes ignorar esto mediante el
	  argumento <lit>horizon</lit> de la instrucción <cmdref targ="set"/>,
    como en <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="irf"/></seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con el resultado de la transformación discreta
	  de Fourier. La matriz <argname>X</argname> del argumento puede ser
	  real o compleja. El resultado es una matriz compleja que tiene la
	  misma dimensión que <argname>X</argname>.
	</para>
	<para>
	  Si fuese necesario calcular la transformación de Fourier sobre
	  varios vectores con el mismo número de elementos, es más eficiente
	  agruparlos en una matriz, en lugar de ejecutar <lit>fft</lit> para
	  cada vector por separado.
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con <math>n</math> columnas, con el resultado de la
	  transformación inversa de Fourier discreta. Se asume que la matriz
	  <argname>X</argname> consta de <math>n</math> vectores columna complejos.
	</para>
	<para>
	  Cuando necesites aplicar la transformación inversa de Fourier
	  sobre varios vectores con el mismo número de elementos, resulta
	  más eficiente agrupar los vectores en una matriz que ejecutar
	  <lit>ffti</lit> para cada uno
	  por separado.
	  <seelist>
            <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="timeseries" output="seebelow">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
	<fnarg optional="true" type="scalar-or-vec">x0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el resultado de aplicar un filtro parecido a un ARMA, al
	  argumento <argname>x</argname>. La transformación puede escribirse como
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> =
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub><math>y</math><sub>t-p</sub>
	</para>
	<para>
	  Si el argumento <argname>x</argname> es una serie, el resultado que se
	  devuelve también es una serie. En caso contrario, si <argname>x</argname> es
	  una matriz con <math>T</math> filas y <math>k</math> columnas, lo
	  que se devuelve es la matriz del mismo tamaño que resulta de aplicar el
	  filtro columna por columna.
	</para>
	<para>
	  Los argumentos <argname>a</argname> y <argname>b</argname> son
	  opcionales. Pueden ser escalares, vectores o la palabra clave
	  <lit>null</lit>.
	</para>
	<para>
	  Cuando <argname>a</argname> es un escalar, se va a utilizar como
	  <math>a</math><sub>0</sub> y eso implicará que <math>q=0</math>.
	  Cuando es un vector con <math>q+1</math> elementos, va a contener
	  los coeficientes desde <math>a</math><sub>0</sub> hasta
	  <math>a</math><sub>q</sub>. Cuando <argname>a</argname> es
	  <lit>null</lit> o se omite, esto es equivalente a definir
	  <math>a</math><sub>0</sub> <math>=1</math> y
	  <math>q=0</math>.
	</para>
	<para>
	  Cuando <argname>b</argname> es un escalar, se va a utilizar como
	  <math>b</math><sub>1</sub> e implicará que <math>p=1</math>.
	  Cuando es un vector con <math>p</math> elementos, va a contener
	  los coeficientes desde <math>b</math><sub>1</sub> hasta
	  <math>b</math><sub>p</sub>. Cuando <argname>b</argname> es
	  <lit>null</lit> o se omite, esto es equivalente a definir
	  <math>B(L)=1</math>.
	</para>
	<para>
	  El argumento escalar opcional <argname>y0</argname> se utiliza para
	  representar todos los valores de <math>y</math> anteriores al inicio
	  de la muestra (se usa solo cuando <math>p &gt; 0</math>). Cuando se omite,
	  se entiende que es igual a 0. Similarmente, puedes usar el argumento
	  opcional <argname>x0</argname> para especificar uno o más valores
	  de <math>x</math> anteriores al inicio de la muestra (información solo
	  relevante cuando <math>q &gt; 0</math>). En caso contario, se asume que los
	  valores de <argname>x</argname> anteriores al inicio de la muestra son 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
            <fncref targ="fracdiff"/>
            <fncref targ="hpfilt"/>
            <fncref targ="movavg"/>
            <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Ejemplo:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produce
	</para>
	<code>
          index            y

          1            1     -0,40000
          2            2      1,36000
          3            3      0,27600
          4            4      1,75160
          5            5      0,92356

          x (5 x 2)

          1   1
          2   0
          3   0
          4   0
          5   0

          w (5 x 2)

          -0,40000     -0,40000
           1,3600       0,36000
           0,27600     -0,32400
           1,7516       0,29160
           0,92356     -0,26244
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">enmuestra</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el número entero positivo que indexa la primera observación
	  no ausente de la serie <argname>y</argname>. Por defecto, se analiza
	  todo el rango de la muestra, de forma que, si está activa alguna forma
	  de submuestreo, el valor que se devuelve puede ser menor que el
	  valor devuelto por el accesor <fncref targ="$t1"/>. Pero si indicas un
	  valor no nulo en <argname>enmuestra</argname>, solo se va a tener
	  en cuenta el rango de la muestra vigente.
	  <seelist>
            <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">nombresobrio</fnarg>
	<fnarg type="bool" optional="true">underscore</fnarg>
      </fnargs>
      <description>
	<para>
	  En principio, esta función está ideada para utilizarse en conjunto con la instrucción
	  <cmdref targ="join"/>. Devuelve una cadena con el resultado de la conversión
	  de <argname>nombresobrio</argname> en un identificador válido de GRETL;
	  debe iniciarse con una letra, debe contener solo letras ASCII, dígitos
	  y/o guion bajo, y no debe tener más de 31 caracteres. Las reglas
	  que se utilizan en la conversión son:
	</para>
	<para>
	  1. Quitar, del principio del nombre, cualquier carácter que no sea una letra.
	</para>
	<para>
	  2. Hasta que se alcanza el límite de los 31 caracteres o hasta que se agota lo
	  indicado en el argumento: transcribe los caracteres <quote>legales</quote>,
	  substituye uno o varios espacios consecutivos por un guion bajo
	  (excepto que el carácter anterior transcrito sea un guion bajo,
	  pues entonces se elimina el espacio), y omite los otros tipos de caracteres
	  <quote>ilegales</quote>.
	</para>
	<para>
	  Si estás convencido de que la entrada no es demasiado larga (entonces
	  susceptible de ser truncada), puedes querer substituir secuencias
	  de uno o más caracteres ilícitos mediante un guion bajo
	  (en lugar de solo eliminarlos) pues esto podría generar un identificador
	  más legible. Para lograr este efecto, proporciona un valor no
	  nulo para el segundo argumento (opcional). Pero esto no es
	  recomendable en el contexto de la instrucción <cmdref targ="join"/>,
	  puesto que el nombre <quote>fijado</quote> automáticamente no
	  va a utilizar guiones bajos de esta manera.
	</para>
      </description>
    </function>

    <function name="flatten" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="matrices-or-strings">A</fnarg>
	<fnarg optional="true" type="bool">alt</fnarg>
      </fnargs>
      <description>
	<para>
	  <quote>Allana</quote> bien una formación de matrices en una única
	  matriz, o bien una formación de cadenas de texto en una única cadena.
	</para>
	<para>
	  Los argumentos se indican entre paréntesis. Con matrices, por defecto,
	  se concatenan horizontalmente las matrices de <argname>A</argname>;
	  pero cuando indicas un valor no nulo para <argname>alt</argname>,
	  la concatenación se hace verticalmente. En cualquier caso, se muestra
	  un fallo si las matrices no son conformables para realizar esta
	  operación. Consulta <fncref targ="msplitby"/> para la operación
	  inversa.
	</para>
	<para>
	  En caso de cadenas de texto, el resultado por defecto mantiene las
	  cadenas de <argname>A</argname>, ordenadas una en cada línea.
	  Si indicas un valor numérico no nulo para <argname>alt</argname>,
	  las cadenas se separan mediante espacios en lugar de líneas nuevas,
	  pero también se admite un uso alternativo de <argname>alt</argname>:
	  puedes indicar una cadena de texto específica para utilizar como
	  separador.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el valor del mayor entero
	  que es menor o igual que <argname>x</argname>. Ten en cuenta que
	  <fncref targ="int"/> y <lit>floor</lit> tienen efectos distintos
	  con argumentos negativos:<lit>int(-3.5)</lit> genera &minus;3,
	  mientras que <lit>floor(-3.5)</lit> genera &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve una serie con la diferencia fraccionaria de orden
	  <argname>d</argname> de la serie <argname>y</argname>.
	</para>
	<para context="tex">
          \[
          \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
          \]
	  donde
          \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Observa que, en teoría, la diferenciación fraccionaria supone un filtro
	  infinitamente largo. Los valores de <math>y</math><sub>t</sub>
	  anteriores a la muestra, en la práctica se asume que son iguales a cero.
	</para>
	<para>
	  Puedes utilizar valores negativos para <argname>d</argname>, y en ese
	  caso la función realiza la integración fraccionaria.
	</para>
      </description>
    </function>

    <function name="fzero" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar-or-vec">inicio</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Trata de encontrar una raíz simple de una función continua <math>f</math>
	  (normalmente no lineal) &mdash;es decir, un valor de la variable escalar
	  <math>x</math> que hace que <math>f</math>(<math>x</math>) = 0.
	  El argumento <argname>fcall</argname> debe proporcionar una
	  llamada a la función en cuestión. <argname>fcall</argname> puede
	  incluir un número arbitrario de argumentos, pero el primero
	  debe ser un escalar que represente el papel de <math>x</math>.
	  Cuando se complete la función con éxito, se va a devolver el
	  valor de la raíz.
	</para>
	<para>
	  El método utilizado es el de <cite key="ridders79">Ridders (1979)</cite>.
	  Esto requiere un intervalo inicial
	  &lbr;<math>x</math><sub>0</sub>, <math>x</math><sub>1</sub>&rbr;
	  tal que ambos valores <math>x</math> pertenezcan al
	  dominio de la función, y que los respectivos valores de la
	  función sean de signo contrario. Probablemente, vas a
	  obtener mejores resultados si eres capaz de proporcionar,
	  mediante el segundo argumento, un vector bidimensional
	  que contenga puntos finales adecuados para el intervalo. Si
	  esto falla, puedes proporcionar un único valor escalar, y
	  <lit>fzero</lit> tratará de encontrar una pareja. Si omites
	  el segundo argumento, el valor de <math>x</math><sub>0</sub>
	  se inicia con un pequeño número positivo, y luego se va a
	  buscar un valor adecuado para <math>x</math><sub>1</sub>.
	</para>
	<para>
	  Puedes usar el argumento <argname>toler</argname> (opcional)
	  para ajustar la máxima diferencia absoluta que resulte aceptable
	  entre <math>f</math>(<math>x</math>) y cero, siendo esta igual a
	  1.0e&minus;14 por defecto.
	</para>
	<para>
	  Por defecto, esta función opera silenciosamente, pero puedes
	  mostrar la evolución del método iterativo ejecutando la instrucción
	  <quote><lit>set max_verbose on</lit></quote> antes de llamar
	  a <lit>fzero</lit>.
	</para>
	<para>
	  A continuación se indican algunos ejemplos sencillos:
	</para>
	<code>
	  # Aproximar 'pi' encontrando el valor que anula la
	  # función sin() en el intervalo de 2.8 a 3.2
	  x = fzero(sin(x), {2.8, 3.2})
	  printf "\nx = %.12f vs pi = %.12f\n\n", x, $pi

	  # Aproximar la 'constante Omega' comezando en x = 0.5
	  function scalar f(scalar x)
	      return log(x) + x
	  end function
	  x = fzero(f(x), 0.5)
	  printf "x = %.12f f(x) = %.15f\n", x, f(x)
	</code>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el valor de la función Gamma de <argname>x</argname>.
	</para>
	<para>
	  Consulta también <fncref targ="bincoeff"/> y <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="genseries" section="programming" output="scalar">
      <fnargs>
	<fnarg type="string">nombrevar</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>
      <description>
	<para>
	  Le proporciona al guionista un procedimiento adecuado para generar
	  series cuyos nombres no se conocen a priori; y/o de crear series y
	  añadirlas a una lista por medio de una única operación (devuelve
	  un escalar).
	</para>
	<para>
	  El primer argumento proporciona el nombre de la serie que se va a crear
	  (o modificar); y puede ser un texto literal, una cadena de texto o
	  una expresión cuyo resultado sea una cadena de texto. El segundo
	  argumento, <argname>rhs</argname> (<quote>lado derecho</quote> en
	  inglés), define la serie original: esto puede ser el nombre de una serie
	  existente o una expresión cuyo resultado sea una serie, en el
	  modo en que aparece habitualmente al lado derecho del símbolo de
	  igualdad cuando se definen series.
	</para>
	<para>
	  El valor que devuelve esta función es un escalar con el número ID de la serie
	  en el conjunto de datos, que es adecuado para incluir la serie en una lista
	  (o &minus;1 en caso de fallar la ejecución de la función).
	</para>
	<para>
	  Por ejemplo, supón que quieres añadir <math>n</math> series
	  aleatorias con distribución de probabilidad Normal al conjunto de
	  datos, y colocarlas en una lista. El siguiente código hace eso:
	</para>
	<code>
	  nulldata 10
	  list Normales = null
	  scalar n = 3
	  loop i = 1 .. n
	      Normales += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  Al finalizar la ejecución, la lista <lit>Normales</lit> va a contener las
	  series <lit>norm1</lit>, <lit>norm2</lit> y <lit>norm3</lit>.
	</para>
	<para>
	  A aquellos que encontréis útil la función <lit>genseries</lit>, quizás os
	  interese explorar la función <fncref targ="feval"/>.
	</para>
      </description>
    </function>

    <function name="geoplot" section="data-utils" output="none">
      <fnargs>
	<fnarg type="string">archivomap</fnarg>
	<fnarg optional="true" type="series">carga</fnarg>
	<fnarg optional="true" type="bundle">opciones</fnarg>
      </fnargs>
      <description>
	<para>
	  Solicita la producción de un mapa, cuando se dispone de datos
	  geográficos adecuados. En la mayoría de los casos el argumento
	  <argname>mapfile</argname> debe proporcionarse como
	  <fncref targ="$mapfile"/>, lo que indica un accesor con el que se va a
	  recuperar el nombre del archivo que sea relevante, de tipo GeoJSON o
	  de tipo ESRI de forma. El argumento opcional <argname>carga</argname>
	  se usa para indicar el nombre de una serie con la que se colorean las
	  regiones del mapa. Y el argumento final de tipo "bundle" te permite
	  que puedas establecer numerosas opciones.
	</para>
	<para>
	  Puedes consultar <doc>geoplot.pdf</doc> con la documentación sobre la función,
	  para obtener detalles y ejemplos completos. Ahí se explican todos los ajustes
	  que se pueden configurar mediante el argumento <argname>opciones</argname>.
	</para>
      </description>
    </function>

    <function name="getenv" section="programming" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando ya está definida una variable de entorno con el nombre del argumento
	  <argname>s</argname>, la función devuelve el valor de esa variable como
	  cadena de texto; en caso contrario, devuelve una cadena de texto vacía.
	  Consulta también <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getinfo" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve información sobre la serie especificada, la cual puedes indicar
	  mediante su nombre o su número ID. El 'bundle' que se devuelve
	  contiene todos los atributos que se pueden establecer por medio de la
	  instrucción <cmdref targ="setinfo"/>. Y también contiene información
	  adicional relevante para series que se generaron como transformaciones
	  de datos primarios (mediante retardos, logaritmos, etc.); esto incluye
	  la palabra de la instrucción de GRETL para la transformación con la 
	  clave <quote>transform</quote>, y el nombre de la serie asociada primaria
	  con la clave <quote>parent</quote>. Para las series retardadas, puedes
	  encontrar el número específico de retardos bajo la clave
	  <quote>lag</quote>.
	</para>
	<para>
	  Aquí tienes un ejemplo de su uso:
	</para>
	<code>
	  open data9-7
	  lags QNC
	  bundle b = getinfo(QNC_2)
	  print b
	</code>
	<para>
	  Al ejecutar lo anterior, podemos ver:
	</para>
	<code>
	  has_string_table = 0
	  lag = 2
	  parent = QNC
	  name = QNC_2
	  graph_name =
	  coded = 0
	  discrete = 0
	  transform = lags
	  description = = QNC(t - 2)
	</code>
	<para>
	  Para comprobar si la serie 5 de un conjunto de datos es un término retardado,
	  puedes hacer este tipo de cosas:
	</para>
	<code>
	  if getinfo(5).lag != 0
	     printf "La serie 5 es un retardo de %s\n", getinfo(5).parent
	  endif
	</code>
	<para>
	  Ten en cuenta que puedes utilizar la notación con el punto para acceder a los
	  elementos de un 'bundle', incluso cuando el 'bundle' es <quote>anónimo</quote>
	  (no guardado con su propio nombre).
	</para>
      </description>
    </function>

    <function name="getkeys" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un 'array' de las cadenas de texto que contienen las claves que
	  identifican el contenido de <argname>b</argname>. Si el 'bundle' está
	  vacío, se devuelve un 'array' vacío.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">origen</fnarg>
	<fnarg type="stringref">&amp;destino</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función lee filas consecutivas de <argname>origen</argname>,
	  que debe ser una cadena de texto ya definida. Con cada llamada a la
	  función se escribe una línea de texto en <argname>destino</argname>
	  (que también debe ser una cadena de texto indicada en formato de
	  puntero) sin el carácter de línea nueva. El valor que se devuelve
	  es un escalar igual a 1, cuando existe algo por leer (incluidas
	  filas en blanco), o igual a 0 si todas las filas de
	  <argname>origen</argname> ya se leyeron.
	</para>
	<para>
	  A continuación se presenta un ejemplo en el que el contenido de un archivo de
	  texto se divide en filas:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, &amp;line)
	      printf "line %d = '%s'\n", i++, line
	  endloop
	</code>
	<para>
	  En el ejemplo se puede asegurar que, cuando finalice el bucle, el texto de
	  <argname>origen</argname> ya está agotado. Si no deseas agotarlo
	  todo, puedes hacer una llamada normal a <lit>getline</lit>, seguida
	  de una nueva llamada de <quote>limpieza</quote>, cambiando el argumento
	  <argname>destino</argname> por <lit>null</lit> (o dejarlo en blanco),
	  con lo que se reinicia la lectura de <argname>origen</argname>, como en
	</para>
	<code>
	  getline(s, &amp;line) # Obtiene una única fila
	  getline(s, null) # Reinicia la lectura
	</code>
	<para>
	  Ten en cuenta que, aunque avanza la posición de lectura cada vez que
	  se ejecuta <lit>getline</lit>, el argumento <argname>origen</argname>
	  no se altera con esa función; solo cambia <argname>destino</argname>.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;dP</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula la aproximación GHK (Geweke, Hajivassiliou, Keane) a la función
	  de distribución Normal multivariante; puedes consultar, por ejemplo,
	  <cite key="geweke91">Geweke (1991)</cite>. El valor que se devuelve es
	  un vector <by r="n" c="1"/> de probabilidades.
	</para>
	<para>
	  El argumento matricial <argname>C</argname> (<by r="m" c="m"/>) debe
	  aportar el factor de Cholesky (matriz triangular inferior) de la matriz de
	  covarianzas de <math>m</math> variables Normales. Los argumentos
	  matriciales <argname>A</argname> y <argname>B</argname> deben ser
	  ambos <by r="n" c="m"/>; e indicar respectivamente los límites inferior
	  y superior que se aplican a las variables en cada una de las <math>n</math>
	  observaciones. Donde las variables no tengan límites, eso se debe indicar
	  usando la constante <fncref targ="$huge"/> o su negativo.
	</para>
	<para>
	  La matriz <argname>U</argname> debe ser <by r="m" c="r"/>, donde
	  <math>r</math> indica el número de extracciones pseudoaleatorias de una
	  distribución Uniforme. Para crear <argname>U</argname> son adecuadas
	  las funciones <fncref targ="muniform"/> y <fncref targ="halton"/>.
	</para>
	<para>
	  Debajo se ilustra esto con un ejemplo relativamente simple, en el que
	  las probabilidades multivariantes pueden calcularse analíticamente.
	  Las series <lit>P</lit> y <lit>Q</lit> deben ser numéricamente
	  muy semejantes una a la otra, denotando como <lit>P</lit> a la
	  probabilidad <quote>verdadera</quote> y como <lit>Q</lit> a su
	  aproximación GHK:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = halton(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
	<para>
	  El argumento opcional <argname>dP</argname> se usa para obtener la matriz
	  <by r="n" c="k"/> de derivadas analíticas de las probabilidades, donde <math>k</math>
	  equivale a 2<math>m</math> + <math>m</math>(<math>m</math> + 1)/2.
	  Las primeras <math>m</math> columnas van a contener las derivadas
	  con respecto a los límites inferiores; las <math>m</math> siguientes
	  van a recoger las derivadas con respecto a los límites superiores;
	  y las restantes columnas van a recoger las derivadas con respecto a
	  los elementos singulares de la matriz <math>C</math>, en el orden que
	  sigue la semivectorización <quote>vech</quote> de una matriz simétrica.
	</para>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el índice de desigualdad de Gini para la serie o
	  vector (no negativos) <argname>y</argname>. Un valor de Gini igual a
	  cero indica igualdad perfecta. El máximo valor de Gini para una serie
	  con <math>n</math> elementos es (<math>n</math> &minus; 1)/<math>n</math>,
	  lo que sucede cuando únicamente un elemento tiene un valor positivo;
	  por lo tanto, un valor de Gini igual a 1.0 es el límite que se alcanza cuando
	  una serie muy larga tiene máxima desigualdad.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="scalar" optional="true">tol</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve la matriz <math>A</math><sup>+</sup>, la matriz pseudoinversa
	  de Moore&ndash;Penrose o inversa generalizada de una matriz
	  <argname>A</argname> de orden <by r="r" c="c"/>, calculada mediante
	  la descomposición en valores singulares.
	</para>
	<para>
	  El resultado de esta operación depende del número de valores singulares
	  de la matriz <argname>A</argname> que numéricamente se consideran
	  iguales a 0. Puedes usar el parámetro opcional <argname>tol</argname>
	  para retocar este aspecto. Se consideran los valores singulares iguales
	  a 0 cuando son menores que <math>m &times; tol &times; s</math>,
	  donde <math>m</math> es el mayor valor de entre <math>r</math> y
	  <math>c</math>, siendo <math>s</math> lo que expresa el valor
	  singular más grande. Cuando omites el segundo argumento, se establece
	  que <argname>tol</argname> sea igual al épsilon de la máquina
	  (consulta <fncref targ="$macheps"/>). En algunos casos, puedes desear
	  establecer que <argname>tol</argname> sea un valor más grande
	  (p.e. 1.0e-9) con objeto de evitar que se sobrestime el rango de la
	  matriz <argname>A</argname> (lo que podría dar lugar a resultados
	  numéricamente inestables).
	</para>
	<para context="notex">
	  Esta matriz posee las siguientes propiedades: <math>A</math>
	  <math>A</math><sup>+</sup> <math>A</math> = <math>A</math>
	  y <math>A</math><sup>+</sup> <math>A</math>
	  <math>A</math><sup>+</sup> = <math>A</math><sup>+</sup>.
	  Además de eso, los productos <math>A</math> <math>A</math><sup>+</sup>
	  y <math>A</math><sup>+</sup> <math>A</math> son simétricos por
	  construcción.
	</para>
	<para context="tex">
	  Esta matriz posee las siguientes propiedades:
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+
	  \end{eqnarray*}
	  Además de eso, los productos $A A^+$ y $A^+ A$ son
	  simétricos por construcción.
	</para>
	<para>
	  <seelist>
            <fncref targ="inv"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="GSSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Maximización unidimensional mediante el método Golden Section Search
	  (GSS). La matriz <argname>b</argname> del argumento debe ser un
	  vector de 3 elementos. Al definirla, el primer elemento se ignora, mientras
	  que el segundo y tercer elementos establecen los límites inferior y
	  superior de la búsqueda. El argumento <argname>fncall</argname> deberá
	  especificar una llamada a la función que devuelve el valor del concepto a
	  maximizar; el término 1 de <argname>b</argname> (que deberá contener el valor
	  vigente del parámetro que se ajusta cuando se invoca la función) debe
	  indicarse como primer argumento; cualquier otro argumento requerido
	  puede ir entonces a continuación. La función en cuestión deberá ser
	  unimodal (no debe tener otro máximo local que no sea el máximo
	  global) en el rango estipulado, pues de lo contrario no se asegura que GSS
	  encuentre el máximo.
	</para>
	<para>
	  Al completarse con éxito, <lit>GSSmax</lit> devolverá el valor
	  óptimo del concepto que se quiere maximizar, mientras que
	  <argname>b</argname> contendrá el valor óptimo del parámetro
	  junto con los límites de su ventana de valores.
	</para>
	<para>
	  El tercer argumento (opcional) puede utilizarse para establecer
	  la tolerancia para alcanzar la convergencia; es decir, la amplitud
	  máxima admisible de la ventana final de valores del parámetro.
	  Si no indicas este argumento, se utiliza el valor 0.0001.
	</para>
	<para>
	  Si tu objetivo realmente es alcanzar un mínimo, puedes
	  bien cambiar la función considerando el negativo del criterio,
	  o bien, alternativamente, puedes invocar la función
	  <lit>GSSmax</lit>bajo el alias <lit>GSSmin</lit>.
	</para>
	<para>
	  Aquí tienes un ejemplo sencillo de utilización:
	</para>
	<code>
	  function scalar trigfunc (scalar theta)
	      return 4 * sin(theta) * (1 + cos(theta))
	  end function

	  matrix m = {0, 0, $pi/2}
	  eval GSSmax(&amp;m, trigfunc(m[1]))
	  printf "\n%10.7f", m
	</code>
      </description>
    </function>

    <function name="GSSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alias de <fncref targ="GSSmax"/>. Si invocas la función bajo
	  este nombre, se ejecuta haciendo una minimización.
	</para>
      </description>
    </function>

    <function name="halton" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">desfase</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz <by r="m" c="r"/> que contiene <math>m</math>
	  secuencias de Halton de longitud <math>r</math>. Las secuencias
	  se construyen utilizando los primeros <math>m</math> números primos.
	  Por defecto, se descartan los primeros 10 elementos de cada una de las
	  secuencias, aunque puedes ajustar esto por medio del argumento
	  opcional <argname>desfase</argname>, que debe ser un número
	  entero no negativo. Para obtener más detalles puedes consultar
	  <cite key="halton64">Halton y Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve la matriz que resulta del producto directo horizontal de dos
	  matrices. Los dos argumentos deben tener el mismo número <math>r</math>
	  de filas. El valor que se devuelve es una matriz que tiene <math>r</math>
	  filas, y en la que la <math>i</math>-ésima fila es el producto de
	  Kronecker de las respectivas filas de las matrices <argname>X</argname>
	  e <argname>Y</argname>. Si omites <argname>Y</argname>, se aplica
	  la sintaxis <quote>breve</quote> (mira abajo).
	</para>
	<para context="tex">
	  Si $X$ es una matriz $r \times k$, $Y$ es una matriz $r \times m$
	  y $Z$ es la matriz resultante del producto directo horizontal de
	  $X$ times $Y$, entonces $Z$ va a tener $r$ filas y $k\cdot m$ columnas;
	  más aún, \[ Z_{in} = X_{ij} Y_{il} \]
	  donde $n = (j-1) m + l$.
	</para>
	<para context="notex">
	  Si <argname>X</argname> es una matriz <math>r x k</math> e
	  <argname>Y</argname> es una matriz <math>r x m</math>, el resultado
	  será una matriz con <math>r</math> filas y con <math>k x m</math>
	  columnas.
	</para>
	<para>
	  Esta operación se llama <quote>producto directo horizontal</quote>
	  de acuerdo con la forma en la que se pone en funcionamiento, y se aplica
	  en el lenguaje de programación GAUSS. Su equivalente en el álgebra
	  matricial estándar podría denominarse producto horizontal (row-wise)
	  de Khatri-Rao, o producto <quote>de división de caras</quote>
	  (face-splitting) en la literatura sobre el procesado de señales.
	</para>
	<para>
	  Ejemplo: el código...
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produce la siguiente matriz:
	</para>
	<code>
          0    1    0    2    0    3
         -4    4   -5    5   -6    6
	</code>
	<subhead>Sintaxis breve</subhead>
	<para>
	  Si <argname>X</argname> e <argname>Y</argname> son la misma
	  matriz, entonces cada fila del resultado representa la vectorización
	  de una matriz simétrica. En estos casos, puedes omitir el segundo
	  argumento; sin embargo, la matriz que se va a devolver contendrá
	  solo las columnas no redundantes y, consecuentemente, tendrá
	  <math>k(k+1)/2</math> columnas. Por ejemplo,
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  C = hdprod(A)
	</code>
	<para>
	  genera
	</para>
	<code>
	  1    2    3    4    6    9 
	  16   20   24   25   30   36 
	</code>
	<para context="tex">
	  Ten en cuenta que la $i$-ésima fila de $C$ es $\mathrm{vech}(a_i a_i')$,
	  donde $a_i$ es la $i$-ésima fila de $A$.
	</para>
	<para context="notex">
	  Ten en cuenta que la <math>i</math>-ésima fila de <math>C</math> es
	  <math>vech(a</math><sub>i</sub> <math>a</math><sub>i</sub><math>')</math>,
	  donde
	  <math>a</math><sub>i</sub> es la <math>i</math>-ésima fila de
	  <math>A</math>.
	</para>
	<para>
	  Cuando utilices la sintaxis breve con matrices complejas, el segundo
	  argumento que se va a suponer implícito será el <i>conjugado</i> del
	  primero, de tal forma que hará que cada fila del resultado sea la
	  vectorización simétrica de una matriz Hermítica.
	</para>
      </description>
    </function>

    <function name="hfdiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplicador</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada una <cmdref targ="MIDAS_list"/>, la función devuelve otra lista
	  de la misma longitud que contiene las primeras diferencias de alta
	  frecuencia. El segundo argumento es opcional y, por defecto, igual a 1:
	  puedes utilizarlo para multiplicar las diferencias por alguna constante.
	</para>
      </description>
    </function>

    <function name="hfldiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplicador</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada una <cmdref targ="MIDAS_list"/>, la función devuelve otra lista
	  de la misma longitud que contiene las diferencias logarítmicas de alta
	  frecuencia. El segundo argumento es opcional y, por defecto, igual a 1:
	  puede utilizarse para multiplicar las diferencias por alguna constante;
	  por ejemplo, podrías darle el valor 100 para obtener aproximadamente
	  las variaciones porcentuales.
	</para>
      </description>
    </function>

    <function name="hflags" section="midas" output="list">
      <fnargs>
	<fnarg type="int">retardomin</fnarg>
	<fnarg type="int">retardomax</fnarg>
	<fnarg type="list">hfvars</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada una <cmdref targ="MIDAS_list"/>, <repl>hfvars</repl>, la función
	  devuelve otra lista con los retardos de alta frecuencia desde
	  <repl>retardomin</repl> hasta <repl>retardomax</repl>. Debes utilizar valores
	  positivos para indicar los retardos, y negativos para indicar los
	  adelantos. Por ejemplo, si <repl>retardomin</repl> es &minus;3, y
	  <repl>retardomax</repl> es 5, entonces la lista que se va a devolver contendrá
	  9 series: 3 adelantos, el valor actual y 5 retardos.
	</para>
	<para>
	  Ten en cuenta que el retardo 0 de alta frecuencia se corresponde con el
	  primer período de alta frecuencia, dentro de un período de baja
	  frecuencia; por ejemplo, correspondería con el primer mes dentro de un
	  trimestre o con el primer día dentro de un mes.
	</para>
      </description>
    </function>

    <function name="hflist" section="midas" output="list">
      <fnargs>
	<fnarg type="vector">x</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg type="string">prefijo</fnarg>
      </fnargs>
      <description>
  <para>
	  Produce una <cmdref targ="MIDAS_list"/> de <repl>m</repl> series
	  a partir del vector <repl>x</repl>, donde <repl>m</repl> indica la
	  razón entre la frecuencia (mayor) de las observaciones de la variable
	  <repl>x</repl> y la frecuencia base (menor) del conjunto vigente
	  de datos. El valor de <repl>m</repl> debe ser mayor o igual a 3, y
	  el tamaño de <repl>x</repl> debe ser igual a <repl>m</repl> veces
	  el tamaño del rango de la muestra vigente.
  </para>
  <para>
	  Los nombres de las series de la lista que se devuelve, se construyen a partir del
	  <repl>prefijo</repl> indicado (que debe ser una cadena de texto,
	  de una longitud máxima de 24 caracteres ASCII, y válida como
	  identificador de GRETL), a la que se añade uno o más dígitos que
	  representan el subperíodo de la observación. Si alguno de esos nombres repite
	  el de algún objeto ya existente, se muestra un fallo.
  </para>
      </description>
    </function>

    <function name="hpfilt" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
	<fnarg type="bool" optional="true">una-parte</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie que recoge la componente cíclica del filtro de
	  Hodrick&ndash;Prescott aplicado a la serie <argname>y</argname>. Si
	  no se indica el parámetro de suavizado <argname>lambda</argname>,
	  GRETL usa valores por defecto basados en la periodicidad de los datos;
	  en concreto, el parámetro es igual a 100 veces el cuadrado de la
	  periodicidad (100 para datos anuales, 1600 para datos trimestrales, etc).
	</para>
	<para>
	  Por defecto, el filtro es el de la habitual versión de dos partes
	  (pasado y futuro), pero si indicas el tercer argumento (opcional)
	  mediante un valor no nulo, se calcula la variante de una sola
	  parte (sin mirada hacia adelante) del modo que se indica en
	  <cite key="stock-watson1999">Stock y Watson (1999)</cite>.
	</para>
	<para>
	  El uso más habitual del filtro HP es para la eliminación de la tendencia,
	  pero si estás interesado en la propia tendencia, es fácil obtenerla
	  mediante substracción, como en el ejemplo siguiente:
	</para>
	<code>
	  series hptrend = y - hpfilt(y)
	</code>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="hyp2f1" section="math" output="scalar-or-matrix">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg type="scalar">c</fnarg>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve el valor de la función hipergeométrica de Gauss para el
	  argumento real <argname>x</argname>.
	</para>
	<para context="tex">
	  Devuelve el valor de la función hipergeométrica de Gauss
    <math>{}_2F_1(a,b;c;z) = \sum_{n=0}^\infty \frac{(a)_n (b)_n}{(c)_n} \frac{z^n}{n!}.</math>
    para el argumento real
	  <argname>x</argname>.
	</para>
	<para>
	  Cuando <argname>x</argname> es un escalar, el valor que se devuelve
	  va a ser un escalar; en caso contrario, va a ser una matriz con la
	  misma dimensión que <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="I" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg optional="true" type="int">m</fnarg>
      </fnargs>
      <description>
	<para>
	  Si omites <argname>m</argname>, devuelve una matriz identidad de
	  orden <argname>n</argname>. En caso contrario, devuelve una matriz
	  <by r="n" c="m"/> que tiene unos en la diagonal principal y ceros
	  en el resto de la matriz.
	</para>
      </description>
    </function>

    <function name="Im" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz real con la misma dimensión que <argname>C</argname>,
	  que contiene la parte imaginaria de la matriz del argumento. Consulta
	  también <fncref targ="Re"/>.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila que indica cual es la fila que tiene el valor más grande,
	  por cada columna de la matriz <argname>X</argname>.Para columnas que tengan
	  valores <lit>NA</lit>s, el resultado también se establece como <lit>NA</lit>,
	  excepto cuando no sea cero el argumento opcional <argname>obviar_na</argname>,
	  en cuyo caso se devuelve el índice de la mayor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna que indica cual es la columna que tiene el valor más grande,
	  por cada fila de la matriz <argname>X</argname>.Para filas que tengan
	  valores <lit>NA</lit>s, el resultado también se establece como <lit>NA</lit>,
	  excepto cuando no sea cero el argumento opcional <argname>obviar_na</argname>,
	  en cuyo caso se devuelve el índice de la mayor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula la Prob(<math>u'Au</math> &lt; <math>x</math>) para una forma
	  cuadrática de variables Normales estándar, <math>u</math>, usando el
	  procedimiento desarrollado por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Calcula la ${\rm Prob}(u'Au &lt; x)$ para una forma cuadrática de
	  variables Normales estándar, $u$, usando el procedimiento desarrollado
	  por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  Si el primer argumento <argname>M</argname> es una matriz cuadrada,
	  se toma para que represente a <math>A</math>. Si es un vector columna,
	  se toman sus elementos como si fuesen los autovalores calculados
	  previamente de <math>A</math>, y en otro caso se presenta un fallo.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila que indica cual es la fila que tiene el valor más pequeño,
	  por cada columna de la matriz <argname>X</argname>.Para columnas que tengan
	  valores <lit>NA</lit>s, el resultado también se establece como <lit>NA</lit>,
	  excepto cuando no sea cero el argumento opcional <argname>obviar_na</argname>,
	  en cuyo caso se devuelve el índice de la menor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="imaxc"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna que indica cual es la columna que tiene el valor más pequeño,
	  por cada fila de la matriz <argname>X</argname>.Para filas que tengan
	  valores <lit>NA</lit>s, el resultado también se establece como <lit>NA</lit>,
	  excepto cuando no sea cero el argumento opcional <argname>obviar_na</argname>,
	  en cuyo caso se devuelve el índice de la menor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="imaxr"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">llave</fnarg>
      </fnargs>
      <description>
	<para>
	  Comprueba si el 'bundle' <argname>b</argname>
	  contiene un elemento con el nombre <argname>llave</argname>. Devuelve un entero
	  con el código del tipo de elemento: 0 en caso de no encontrarlo y, en caso de
	  hacerlo, 1 para un escalar, 2 para una serie, 3 para una matriz, 4 para
	  una cadena de texto, 5 para un 'bundle', 6 para un 'array' y 7 para una lista.
	  En base al valor de su código, la función <fncref targ="typestr"/> se puede
	  usar para obtener la cadena de texto que expresa el tipo de elemento que es.
	</para>
      </description>
    </function>

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve un escalar con la norma-infinito de la matriz <argname>X</argname>,
	  es decir, el máximo valor que se obtiene al sumar los valores absolutos
	  de los elementos de la matriz <argname>X</argname> que hay en cada fila.
	</para>
	<para context="tex">
	  Devuelve un escalar con la norma-$\infty$ de la matriz $r\times c$,
	  <argname>X</argname>, concretamente
          \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un entero positivo con la posición de <argname>y</argname> en la
	  lista <argname>L</argname>, o 0 si <argname>y</argname> no está
	  presente en <argname>L</argname>.
	</para>
	<para>
	  El segundo argumento puedes indicarlo tanto con el nombre de la serie como con el
	  entero positivo que identifica la serie (ID). Cuando sabes que existe
	  una serie con un nombre concreto (por ejemplo, <lit>foo</lit>), puedes
	  ejecutar esta función de la siguiente forma:
	</para>
  <code>
	  pos = inlist(L, foo)
  </code>
  <para>
	  Con la expresión anterior estás pidiendo: <quote>Indícame con un entero la
	  posición de la serie <lit>foo</lit> en la lista <lit>L</lit> (o 0 si no
	  está incluida en esa lista)</quote>. De cualquier modo, si no tienes
	  certeza de que exista una serie con un nombre concreto, debes indicar
	  ese nombre entre comillas de esta forma:
	</para>
	<code>
	  pos = inlist(L, "foo")
  </code>
  <para>
	  En este caso, lo que estás solicitando es: <quote>Si existe una serie
	  llamada <lit>foo</lit> en la lista <lit>L</lit>, indícame su posición;
	  en caso de que no exista, devuelve un 0.</quote>
	</para>
      </description>
    </function>

    <function name="instring" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="bool">ign_mayus</fnarg>
      </fnargs>
      <description>
	<para>
	  Este es un booleano relativo de <fncref targ="strstr"/>:
	  devuelve 1 si <argname>s1</argname> contiene
	  <argname>s2</argname>, y 0 en caso contrario. De este modo,
	  la expresión condicional
	</para>
	<code>
	  if instring("gatada", "gata")
	</code>
	<para>
	  es equivalente lógicamente (pero más eficiente) que
	</para>
	<code>
	  if strlen(strstr("gatada", "gata")) &gt; 0
	</code>
	<para>
	  Si el argumento opcional <argname>ign_mayus</argname> no es cero,
	  la búsqueda no distinguirá mayúsculas de minúsculas. Por ejemplo:
	</para>
	<code>
	  instring("Gatada", "gata")
	</code>
	<para>
	  devuelve 0, pero
	</para>
	<code>
	  instring("Gatada", "gata", 1)
	</code>
	<para>
	  devuelve 1.
	</para>
      </description>
    </function>

    <function name="instrings" section="strings" output="seebelow">
      <fnargs>
	<fnarg type="strings">S</fnarg>
	<fnarg type="string">cotejo</fnarg>
	<fnarg type="bool" optional="true">simple</fnarg>
      </fnargs>
      <description>
	<para>
	  Comprueba si los elementos del 'array' de cadenas de texto
	  <argname>S</argname> son iguales a <argname>cotejo</argname>.
	  Por defecto, devuelve un vector columna de longitud igual al número de
	  coincidencias que se producen, y que contiene la posición que
	  ocupa cada coincidencia dentro del 'array' (o bien una matriz
	  vacía en caso de no haber coincidencias).
	</para>
	<para>
	  Ejemplo:
	</para>
	<code>
	  strings S = defarray("A", "B", "C", "B")
	  eval instrings(S, "B")
	  2
	  4
	</code>
	<para>
	  Cuando se indica un valor no nulo para el argumento opcional
	  <argname>simple</argname>, el valor que se devuelve es un escalar:
	  1 si <argname>cotejo</argname> se encuentra en <argname>S</argname>,
	  y 0 de lo contrario. En este caso, la implementación es capaz de coger
	  un atajo, por lo que es más eficiente si solo quieres una respuesta
	  booleana.
	</para>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con la parte entera de
	  <argname>x</argname>, truncando la parte decimal; o <lit>NA</lit>
	  si no se puede representar el resultado como un entero de 32-bit con
	  signo (si no cae en el intervalo [&minus;2147483648, 2147483647]).
	</para>
	<para>
	  Nota: <lit>int</lit> y <fncref targ="floor"/> producen distintos
	  efectos con argumentos negativos: <lit>int(-3.5)</lit> genera &minus;3,
	  mientras que <lit>floor(-3.5)</lit> genera &minus;4.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="round"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="interpol" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie en la que los valores ausentes de <argname>x</argname>
	  se imputan mediante interpolación lineal, tanto para datos de series
	  temporales como para la dimensión temporal de un conjunto de datos de
	  panel. Pero no se hace extrapolación; los valores ausentes se reemplazan
	  únicamente si están precedidos y seguidos a la vez de observaciones
	  válidas.
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve la matriz inversa de <argname>A</argname>. Cuando esta última
	  es una matriz singular o no cuadrada, se produce un mensaje de fallo
	  y no se devuelve nada. Ten en cuenta que GRETL comprueba
	  automáticamente la estructura de <argname>A</argname>, y utiliza el
	  procedimiento numérico más eficiente para realizar la inversión.
	</para>
	<para>
	  Los tipos de matriz que GRETL comprueba automáticamente son:
	  identidad, diagonal, simétrica definida positiva, simétrica definida
	  no positiva, y triangular.
	</para>
	<para>
	  Nota: En buena lógica, solo debes utilizar esta función cuando tratas de
	  aplicar la inversa de <argname>A</argname> más de una vez. Cuando
	  únicamente necesitas calcular, por ejemplo, una expresión de la forma
	  <math>A</math><sup>-1</sup><math>B</math>, es preferible que
	  utilices los operadores de <quote>división</quote>: <lit>\</lit> y
	  <lit>/</lit>. Para obtener más detalles, puedes consultar
	  <guideref targ="chap:matrices"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ginv"/>
            <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">u</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula la inversa de la función de distribución acumulativa.
	  Para una distribución continua devuelve un resultado (del tipo
	  del argumento) con el valor de <math>x</math> que cumple
	  <equation status="inline" ascii="P(X &le; x) = u" tex="$P(X \le x) = u$"/>,
	  con <argname>u</argname> dentro del intervalo entre 0 y 1.
	  Para una distribución discreta (Binomial o Poisson), devuelve
	  el valor más pequeño de <math>x</math> para el que se cumple
	  <equation status="inline" ascii="P(X &le; x) &ge; u" tex="$P(X \le x) \ge u$"/>.
	</para>
	<para>
	  La distribución de <math>X</math> se especifica mediante la letra
	  <argname>d</argname>. Entre los argumentos <argname>d</argname> y
	  <argname>u</argname>, puedes necesitar algún argumento escalar
	  adicional para especificar los parámetros de la distribución de que
	  se trate. Esto se hace del modo que se indica a continuación:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (c = z, n o N): sin argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g o G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): grados de libertad
            </para>
	  </li>
	  <li>
            <para>
              Chi-cuadrado (c, x o X): grados de libertad
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f o F): grados de libertad (num.), grados de libertad (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b o B): probabilidad, cantidad de ensayos
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p o P): media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l o L): media, escala
            </para>
	  </li>
	  <li>
            <para>
              Error Generalizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Chi-cuadrado no central (ncX): grados de libertad, parámetro de no centralidad
	    </para>
	  </li>
	  <li>
	    <para>
	      F no central (ncF): grados de libertad (num.), grados de libertad (den.),
	      parámetro de no centralidad
	    </para>
	  </li>
	  <li>
	    <para>
	      t no central (nct): grados de libertad, parámetro de no centralidad
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribución} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Gamma &amp; \texttt{g} o \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  gl &amp; -- &amp; --\\
	  Chi-cuadrado &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp;
	  gl &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} o \texttt{F} &amp;
	  gl (num.) &amp; gl (den.) &amp; --\\
	  Binomial &amp; \texttt{b} o \texttt{B} &amp;
	  $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} o \texttt{P} &amp;
    $\lambda$ &amp; --  &amp; --\\
	  Laplace &amp; \texttt{l} o \texttt{L} &amp;
    media &amp; escala  &amp; -- \\
	  Error Generalizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ no central &amp; \texttt{ncX} &amp;
	  gl &amp; no centralidad &amp; --\\
	  $F$ no central &amp; \texttt{ncF} &amp;
	  gl (num.) &amp; gl (den.) &amp; no centralidad\\
	  $t$ no central &amp; \texttt{nct} &amp;
	  gl &amp; no centralidad &amp; --\\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="critical"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con la razón inversa de
	  Mills en <argname>x</argname>, es decir, la razón entre la densidad
	  Normal estándar y el complementario de la función de distribución
	  Normal estándar, ambas evaluadas en <argname>x</argname>.
	</para>
	<para>
	  Esta función utiliza un algoritmo adecuado que proporciona una
	  precisión mucho mejor que la que se alcanza haciendo los cálculos con
	  <fncref targ="dnorm"/> y <fncref targ="cnorm"/>; ahora bien, la
	  diferencia entre los dos métodos es considerable solo para valores
	  muy negativos de <argname>x</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
	<fnarg optional="true" type="scalarref">&amp;logdet</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve la matriz cuadrada resultante de invertir la matriz simétrica
	  definida positiva <argname>A</argname>. Para matrices muy grandes,
	  esta función es ligeramente más rápida que <fncref targ="inv"/> puesto
	  que con ella no se comprueba si la matriz es simétrica. Por esta razón,
	  la función debe utilizarse con prudencia.
	</para>
	<para>
	  Si está presente el argumento <argname>&amp;logdet</argname>
	  (opcional), el escalar resultante va a contener (si acaba con éxito la
	  función) el logaritmo del determinante de la matriz <argname>A</argname>.
	  Disponer de esto puede ser muy interesante en algunos casos; por
	  ejemplo, en el contexto de evaluación del logaritmo de una versosimilitud
	  de tipo Normal (Gaussiana), porque el logaritmo del determinante
	  es un subproducto del algoritmo de la inversion, y conseguirlo
	  mediante el argumento <argname>&amp;logdet</argname> evita cálculos
	  adicionales.
	</para>
	<para>
	  Nota: Si pretendes invertir una matriz de la forma <math>X'X</math>,
	  donde <math>X</math> es una matriz muy grande, es preferible que la
	  calcules mediante el operador principal <lit>X'X</lit> en lugar
	  de usar la sintaxis más general <lit>X'*X</lit>. La primera expresión
	  utiliza un algoritmo especializado que tiene una doble ventaja:
	  resulta más eficiente desde el punto de vista del cómputo; y va a
	  garantizar que la matriz resultante esté libre, por construcción, de los
	  artefactos de precisión de máquina que pudieran convertirla en
	  numéricamente no simétrica.
	</para>
      </description>
    </function>

    <function name="irf" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="int">efecto</fnarg>
	<fnarg type="int">impacto</fnarg>
	<fnarg type="pscalar" optional="true">alfa</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciona una matriz con las funciones estimadas de respuesta al
	  impulso correspondientes a un VAR o un VECM, trazadas sobre un
	  determinado horizonte de predicción. Sin el argumento final (opcional),
	  esta función sirve solo cuando el último modelo estimado fue un VAR o
	  un VECM. Como alternativa, puedes guardar la información sobre uno de esos
	  sistemas como 'bundle', mediante el accesor <fncref targ="$system"/>,
	  y posteriormente aplicarle la función <lit>irf</lit>.
	</para>
	<para>
	  Los argumentos <argname>efecto</argname> e <argname>impacto</argname>
	  son índices, con formato de números enteros, de las variables endógenas
	  del sistema; y se usa 0 para indicar <quote>todas</quote>. Las respuestas
	  (expresadas en las unidades de la variable <argname>efecto</argname>)
	  lo son ante una innovación de una desviación típica en la variable
	  <argname>impacto</argname>. Cando le asignas un valor positivo
	  adecuado a <argname>alfa</argname>, las estimaciones incluyen
	  un intervalo de confianza de 1 &minus; &agr; (de esta forma, por
	  ejemplo, indica 0.1 si deseas obtener un intervalo del 90 por
	  ciento).
	</para>
	<para>
	  El siguiente fragmento de código ilustra su uso. En el primer ejemplo,
	  la matriz <lit>ir1</lit> contiene las respuestas de <lit>y1</lit> ante las
	  innovaciones en cada una de las <lit>y1</lit>, <lit>y2</lit> e <lit>y3</lit>
	  (son estimaciones por punto ya que se omite <argname>alfa</argname>).
	  En el segundo ejemplo, <lit>ir2</lit> contiene las respuestas de todas las
	  variables de efecto a una innovación en <lit>y2</lit>, con intervalos
	  de confianza del 90 por ciento. En este caso, la matriz que se devuelve
	  tendrá 9 columnas: cada vía de respuesta ocupa 3 columnas contiguas que
	  indican la estimación por punto, el límite inferior y el límite superior.
	  El último ejemplo produce una matriz con 27 columnas: 3 columnas
	  para cada respuesta ante cada variable de efecto, multiplicadas por
	  cada una de las tres variables de choque.
	</para>
	<code>
	  var 4 y1 y2 y3
	  matrix ir1 = irf(1, 0)
	  matrix ir2 = irf(0, 2, 0.1)
	  matrix ir3 = irf(0, 0, 0.1)
	</code>
	<para>
	  El número de períodos (filas) sobre los que se traza la respuesta se
	  determina automáticamente dependiendo de la frecuencia de los datos; pero
	  eso puede ajustarse por medio de la instrucción <cmdref targ="set"/>,
	  como por ejemplo con <lit>set horizon 10</lit>.
	</para>
	<para>
	  Cuando se presentan los intervalos de confianza, estos se generan
	  mediante la técnica de muestreo repetido 'bootstrapping' de los residuos
	  originales. Se asume que el orden del retardo del VAR o del VECM ya
	  es suficiente como para eliminar la autocorrelación de los residuos. Por
	  defecto, el número de repeticiones del muestreo 'bootstrap' es de 1999,
	  pero puedes ajustar esto mediante la instrucción <cmdref targ="set"/>,
	  como en
	</para>
	<code>
	  set boot_iters 2999
	</code>
	<para>
	  <seelist>
	    <fncref targ="fevd"/>
	    <fncref targ="vma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con la Tasa Interna de Rendimiento (TIR) para
	  <argname>x</argname>, considerada como una secuencia de pagos
	  (negativos) e ingresos (positivos).
	  <seelist>
            <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iscomplex" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">nombre</fnarg>
      </fnargs>
      <description>
	<para>
	  Comprueba si <argname>nombre</argname> es el identificador de una matriz
	  compleja. El valor que se devuelve es alguno de los siguientes:
	</para>
  <para>
    <lit>NA</lit>: <argname>nombre</argname> no identifica a una
    matriz.
  </para>
  <para>
    <lit>0</lit>: <argname>nombre</argname> identifica una matriz real,
    en su totalidad formada por números normales de punto flotante
    (<quote>dobles</quote>, en la terminología de C).
  </para>
  <para>
    <lit>1</lit>: <argname>nombre</argname> identifica una matriz
    <quote>en principio</quote> compleja, formada por números que
    tienen tanto una parte real como otra imaginaria, pero en los que
    las partes imaginarias son nulas.
  </para>
  <para>
    <lit>2</lit>: la matriz en cuestión contiene, al menos, un valor
    <quote>auténticamente</quote> complejo, con una parte imaginaria
    que no es nula.
  </para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">codigo-panel</fnarg>
      </fnargs>
      <description>
	<para>
	  Sin el segundo argumento (opcional), devuelve el número entero igual
	  a 1 cuando <argname>y</argname> tenga un valor constante a lo largo de la
	  muestra vigente seleccionada (o a lo largo de toda su extensión si
	  <argname>y</argname> es un vector); en otro caso, devuelve el entero 0.
	</para>
	<para>
	  El segundo argumento solo se acepta cuando <argname>y</argname> es una
	  serie, y el conjunto vigente de datos es un panel. En este caso, un valor
	  de <argname>codigo-panel</argname> igual a 0 solicita que la función
	  verifique si la serie no varía con el paso del tiempo; y un valor igual a
	  1 hace que la función verifique si la serie no varía transversalmente
	  (es decir, si el valor de <argname>y</argname> en cada período de
	  tiempo, es el mismo para todos los grupos).
	</para>
	<para>
	  Si <argname>y</argname> es una serie, las observaciones con valores
	  ausentes se ignoran durante la verificación de la invariabilidad de la serie.
	</para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nombre</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>nombre</argname> es una cadena que identifica una serie ya
	  definida, y si está marcada como de tipo discreto, la función devuelve
	  un entero igual a1; en caso contrario, devuelve 0. Si <argname>nombre</argname>
	  no identifica una serie, la función devuelve <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Si todos los valores contenidos en <argname>x</argname> son iguales a 0 o
	  a 1 (o ausentes), devuelve un entero con el recuento de unos; si no, devuelve 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado un argumento escalar, devuelve 1 si <argname>x</argname> no es un
	  número, <quote>Not a Number</quote> (NaN); en caso contrario, devuelve 0. Dada
	  una matriz como argumento, devuelve otra matriz de la misma dimensión
	  que contiene valores iguales a 1 en las posiciones en las que los elementos que les
	  corresponden de la matriz de entrada son NaN, y 0 en las demás posiciones.
	</para>
      </description>
    </function>

    <function name="isoconv" section="calendar" output="int">
      <fnargs>
	<fnarg type="series">fecha</fnarg>
	<fnarg type="seriesref">&amp;año</fnarg>
	<fnarg type="seriesref">&amp;mes</fnarg>
	<fnarg type="seriesref" optional="true">&amp;día</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada la serie <argname>fecha</argname> que contiene fechas en el formato
	  ISO 8601 <quote>básico</quote> (<lit>YYYYMMDD</lit>), esta función
	  convierte las componentes de año, mes y (opcionalmente) día en nuevas
	  series designadas por el segundo y siguientes argumentos. Un ejemplo
	  de su aplicación, asumiendo que la serie <lit>fechas</lit> contiene valores
	  adecuados de 8 dígitos, sería:
	</para>
	<code>
	  series y, m, d
	  isoconv(fechas, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  Esta función devuelve el valor nominal 0 en caso de completarse con
	  éxito; en caso de que no funcione, se muestra un fallo.
	</para>
      </description>
    </function>

    <function name="isocountry" section="strings" output="asinput">
      <fnargs>
	<fnarg type="string-or-strings">origen</fnarg>
	<fnarg type="int" optional="true">resultado</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función está relacionada con las cuatro notaciones para países
	  que están incluídas en el estándar ISO 3166; concretamente
	</para>
	<nlist>
	  <li><para>
	    Nombre de país
	  </para></li>
	  <li><para>
	    Código alfa-2 (dos letras mayúsculas)
	  </para></li>
	  <li><para>
	    Código alfa-3 (tres letras mayúsculas)
	  </para></li>
	  <li><para>
	    Código numérico (3 dígitos)
	  </para></li>
	</nlist>
	<para>
	  Cuando indicas un país con alguna de esas formas, el resultado es
	  su representación en la forma (de 1 a 4) que elijas mediante el
	  argumento opcional <argname>resultado</argname>. Si omites ese
	  argumento, la conversión por defecto se hace del siguiente modo:
	  cuando el argumento <argname>origen</argname> es un nombre de un país,
	  el resultado es el código de 2 letras del país; en caso contrario, el
	  resultado es el nombre del país. Debajo se ilustran varias solicitudes
	  válidas con formato interactivo.
	</para>
	<code>
	  ? eval isocountry("Bolivia")
	  BO
	  ? eval isocountry("Bolivia", 3)
	  BOL
	  ? eval isocountry("GB")
	  United Kingdom of Great Britain and Northern Ireland
	  ? eval isocountry("GB", 3)
	  GBR
	  ? strings S = defarray("ES", "DE", "SD")
	  ? strings C = isocountry(S)
	  ? print C
	  Array de strings, longitud 3
	  [1] "Spain"
	  [2] "Germany"
	  [3] "Sudan"
	  ? matrix m = {4, 840}
	  ? C = isocountry(m)
	  ? print C
	  Array de strings, longitud 2
	  [1] "Afghanistan"
	  [2] "United States of America"
	</code>
	<para>
	  Cuando <argname>origen</argname> tiene la forma 4 (código numérico),
	  esto puede indicarse mediante una cadena de texto o un 'array' de
	  cadenas (por ejemplo, <quote>032</quote> para Argentina) o con
	  formato numérico. En este último caso, <argname>origen</argname>
	  puede indicarse como una serie o como un vector, pero se va a mostrar
	  un fallo si alguno de los números está fuera del rango de 0 a 999.
	</para>
	<para>
	  En todos los casos (incluso cuando elijas el formato 4 de resultados) se
	  devuelve una cadena de texto o un 'array' de cadenas; si necesitas los
	  valores numéricos, puedes obtenerlos usando la función <fncref targ="atof"/>.
	  Cuando <argname>origen</argname> no coincide con ninguna entrada
	  de la tabla ISO 3166, el resultado es una cadena vacía, y en ese caso
	  se muestra una advertencia.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat">ed</fnarg>
	<fnarg type="bool" optional="true">como-cadena</fnarg>
      </fnargs>
      <description>
	<para>
	  El argumento <argname>ed</argname> se interpreta como un día de
	  época (que tomará el valor 1 para el primer día de enero del año 1
	  después de Cristo, en el calendario Gregoriano proléptico). El valor que
	  se devuelve por defecto es un número de 8 dígitos del mismo tipo que
	  <argname>ed</argname>, o una serie compuesta por números de esa
	  clase. Se sigue el patrón <lit>YYYYMMDD</lit> (formato ISO 8601
	  <quote>básico</quote>) para proporcionar la fecha en el calendario
	  Gregoriano que se corresponde al día en la época actual.
	</para>
	<para>
	  Si el segundo argumento <argname>como-cadena</argname> (opcional) es
	  no nulo, la función no devuelve un valor numérico sino más bien
	  una cadena de texto que sigue el patrón <lit>YYYY-MM-DD</lit>
	  (formato ISO 8601 <quote>extendido</quote>), o una serie con
	  valores en formato de texto si <argname>ed</argname> es una serie,
	  o un 'array' de cadenas de texto si <argname>ed</argname> es un vector.
	  Para ver un medio más flexible de obtener representaciones de los días
	  de época con cadenas de texto, consulta <fncref targ="strfday"/>.
	</para>
	<para>
	  En relación a la función inversa consulta <fncref targ="epochday"/>.
	  Consulta también <fncref targ="juldate"/>.
	</para>
      </description>
    </function>

    <function name="isoweek" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">año</fnarg>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">dia</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el número de semana (en formato ISO 8601) que se corresponde
	  con la(s) fecha(s) especificada(s) por los tres argumentos, o <lit>NA</lit>
	  si la fecha no es válida. Ten en cuenta que los tres argumentos deben
	  ser todos del mismo tipo, bien escalares (enteros) o bien series.
	</para>
	<para>
	  Las semanas en formato ISO se numeran de 01 a 53. La mayoría de
	  los años teñen 52 semanas, pero una media de 71 de 400 años tienen
	  53 semanas. La semana 01, según la definición ISO 8601, es la semana
	  que contiene el primer jueves del año en el calendario Gregoriano.
	  Para obtener una explicación completa, consulta
	  <url>https://en.wikipedia.org/wiki/ISO_week_date</url>.
	</para>
	<para>
	  También se admite una solicitud alternativa: cuando se indica un
	  único argumento, se considera que es una fecha (o una serie de
	  fechas) en formato numérico <quote>básico</quote> ISO 8601,
	  <lit>YYYYMMDD</lit>. De este modo, las siguientes dos solicitudes
	  generan el mismo resultado, concretamente 13.
	</para>
	<code>
	  eval isoweek(2022, 4, 1)
	  eval isoweek(20220401)
	</code>
      </description>
    </function>

    <function name="iwishart" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada <argname>S</argname> (una matriz de orden <by r="p" c="p"/>
	  definida positiva), esta función devuelve una matriz generada a partir
	  de una realización de la distribución Inversa de Wishart con
	  <argname>v</argname> grados de libertad. El resultado que se devuelve
	  también es una matriz <by r="p" c="p"/>. Se utiliza el algoritmo de
	  <cite key="odell-feiveson66">Odell y Feiveson (1966)</cite>.
	</para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">ruta</fnarg>
	<fnarg optional="true" type="scalarref">&amp;nleer</fnarg>
      </fnargs>
      <description>
	<para>
	  Como argumento <argname>buf</argname> deberás utilizar
	  un buffer JSON, tal como puede recuperarse de un sitio web
	  adecuado mediante la función <fncref targ="curl"/>; y como
	  argumento <argname>ruta</argname> deberás usar una
	  especificación de tipo JsonPath.
	</para>
	<para>
	  Esta función devuelve una cadena de texto que representa los datos que
	  se encuentran en el buffer en la ruta especificada. Se admiten los tipos de datos
	  <quote>double</quote> (punto flotante), <quote>int</quote> (entero)
	  y cadena de texto. En caso de enteros o de puntos flotantes, se
	  devuelve su representación como cadenas de texto (usando para los
	  segundos, <quote>C</quote> local). Si el objeto al que se refiere
	  la <argname>ruta</argname> es un 'array', sus elementos
	  se imprimen en la cadena de texto devuelta, uno por cada fila.
	</para>
	<para>
	  Por defecto, se muestra un fallo si <argname>ruta</argname>
	  no coincide en el buffer JSON; pero este comportamiento
	  se modifica si indicas el tercer argumento (opcional) pues, en este
	  caso, el argumento recupera un recuento de las coincidencias, devolviéndose
	  una cadena vacía si no hay ninguna. Llamada de ejemplo:
	</para>
	<code>
	  ngot = 0
	  ret = jsonget(jbuf, "$.some.thing", &amp;ngot)
	</code>
	<para>
	  Ahora bien, todavía se va a mostrar un fallo en caso de hacer una solicitud
	  mal configurada.
	</para>
	<para>
	  Puedes encontrar una exposición fidedigna de la sintaxis JsonPath en
	  <url>http://goessner.net/articles/JsonPath/</url>. De cualquier
	  modo, observa que el soporte de <lit>jsonget</lit> lo proporciona
	  <lit>json-glib</lit>, que no necesariamente soporta todos los
	  elementos de JsonPath. Y además, la funcionalidad concreta
	  que desarrolla <lit>json-glib</lit> puede ser muy diferente,
	  dependiendo de la versión que tengas en tu sistema. Puedes consultar
	  <url>https://wiki.gnome.org/Projects/JsonGlib</url> si necesitas
	  tener más detalles.
	</para>
	<para>
	  Dicho esto, los siguientes operadores debieran de estar disponibles
	  para <lit>jsonget</lit>:
	</para>
	  <ilist>
	    <li>
              <para>
		nodo raíz, por medio del carácter <lit>$</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador descendente recursivo: <lit>..</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador comodín: <lit>*</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador subíndice: <lit>[]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de notación de conjunto, por ejemplo <lit>[i,j]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de truncado: <lit>[principio:fin:paso]</lit>
              </para>
	    </li>
	  </ilist>
      </description>
    </function>

    <function name="jsongetb" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string" optional="true">ruta</fnarg>
      </fnargs>
      <description>
	<para>
	  Como argumento <argname>buf</argname> deberás utilizar un buffer
	  JSON, tal como puede recuperarse de un sitio web adecuado mediante
	  la función <fncref targ="curl"/>. La especificación y el efecto del
	  argumento opcional <argname>ruta</argname> se describe
	  más abajo.
	</para>
	<para>
	  Lo que se devuelve es un 'bundle' cuya estructura básicamente
	  refleja la de la entrada: los objetos JSON se convierten en 'bundles'
	  de GRETL, y los 'arrays' JSON se convierten en 'arrays' de GRETL; cada
	  uno de ellos puede contener cadenas de texto, 'bundles' o 'arrays'.
	  Los nodos de <quote>valor</quote> JSON se convierten en componentes
	  de 'bundles' o elementos de 'arrays'; en el último caso, los valores
	  numéricos se convierten en cadenas de texto utilizando <lit>sprintf</lit>.
	  Ten en cuenta que, aunque la especificación JSON permite 'arrays' de
	  tipo mixto, estos no se poden manejar mediante <lit>jsongetb</lit>
	  puesto que los 'arrays' de GRETL deben ser de tipo único.
	</para>
	<para>
	  Puedes usar el argumento <argname>ruta</argname> para limitar
	  los elementos JSON incluidos en el 'bundle' que se devuelve. Ten en
	  cuenta que esto no es un <quote>JsonPath</quote> tal como se
	  describe en la ayuda para <fncref targ="jsonget"/>; esto es una
	  sencilla composición sujeta a la siguiente especificación:
	</para>
	<ilist>
	  <li>
	    <para>
	      <argname>ruta</argname> es una formación de elementos separados
	      por una barra, donde esta barra (<quote>/</quote>) indica el
	      desplazamiento a un nivel <quote>más bajo</quote> en el árbol
	      JSON representado por <argname>buf</argname>. Se permite una
	      barra inicial pero no es necesaria, pues implícitamente la ruta
	      siempre comienza en la raíz. No debes incluir caracteres extraños
	      para espacios en blanco.
	    </para>
	  </li>
	  <li>
	    <para>
	      Cada elemento que se separa con una barra debe tener
	      una de las siguientes formas: (a) un nombre únicamente, en
	      cuyo caso solo se va a incluir un elemento JSON cuyo nombre
	      coincida en el nivel estructural indicado; o (b) <quote>*</quote>
	      (asterisco), en cuyo caso se van a incluir todos aquellos
	      elementos del nivel indicado; o (c) un 'array' de nombres
	      separados con comas y delimitados por llaves
	      (<quote>{</quote> y <quote>}</quote>), en cuyo caso solo
	      se van a incluir los elementos JSON cuyos nombres coincidan
	      con uno de los nombres indicados.
	    </para>
	  </li>
	</ilist>
	<para>
	  Consulta también la función orientada a cadenas <fncref targ="jsonget"/>;
	  pues, dependiendo de tu intención, una de estas funciones puede serte
	  de más ayuda que la otra.
	</para>
      </description>
    </function>

    <function name="juldate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat">ed</fnarg>
	<fnarg type="bool" optional="true">como-cadena</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta funcion simplemente opera como <fncref targ="isodate"/>,
	  excepto en que las fechas del resultado son relativas al calendario
	  Juliano en vez del Gregoriano.
	</para>
      </description>
    </function>

    <function name="kdensity" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-list-or-mat">x</fnarg>
	<fnarg type="scalar" optional="true">escala</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula una estimación (o un conjunto de estimaciones) de la densidad
	  kernel para el argumento <argname>x</argname>, que puede ser una serie
	  única, una lista o una matriz con más de una columna. La matriz que
	  se devuelve tiene <math>k</math> + 1 columnas, siendo <math>k</math>
	  el número de elementos (series o columnas) de <argname>x</argname>.
	  La primera columna incluye un conjunto de abscisas equidistantes, y
	  el resto de las columnas incluyen la densidad (o densidades) estimada
	  correspondiente a cada una de ellas.
	</para>
  <para>
    La fórmula utilizada para calcular la densidad estimada en
    cada punto de referencia (<math>x</math>) es
    <equation status="display"
	           tex="\[f(x)=(1/nh) \sum_{t-1}^{n} k\left((x-x_t)/h\right)\]"
	           ascii="f(x) = (1/nh) sum(t=1 to n) k((x - x(t)) / h)"
	           graphic="kernel1"/>
	  donde <math>n</math> denota el número de puntos con datos,
	  <math>h</math> es un parámetro de <quote>ancho de banda</quote>,
	  y <math>k</math>() es la función Kernel. Cuanto mayor sea el valor
	  del parámetro de ancho de banda, más suave va a ser la densidad
	  estimada.
  </para>
	<para>
	  El parámetro <argname>escala</argname> (opcional) puedes usarlo
	  para ajustar el grado de suavizado en relación al valor por defecto
	  que es 1.0; este se corresponde con la regla general propuesta por
	  <cite key="silverman86">Silverman (1986)</cite>, concretamente
	  <equation status="display"
	     tex="\[h=0.9 {\rm min}(s, {\rm IQR}/1.349) n^{-1/5}\]"
	     ascii="h = 0.9 min(s, IQR/1.349) n^{-1/5}"
	     graphic="kernel2"/>
	  donde <math>s</math> indica la desviación típica de los datos e
	  IQR es el rango intercuartil. El parámetro <argname>control</argname>
	  (opcional) actúa como un booleano: 0 (valor por defecto) significa
	  que se utiliza el kernel gaussiano; un valor no nulo cambia al
	  kernel de Epanechnikov.
	</para>
	<para>
	  Puedes obtener un gráfico de los resultados utilizando la instrucción
	  <cmdref targ="gnuplot"/>, como se indica abajo. Ten en cuenta que la
	  columna que contiene las abscisas debe ir al final para representar
	  el gráfico.
	</para>
	<code>
	  matrix d = kdensity(x)
	  # Si x tiene un único elemento
	  gnuplot 2 1 --matrix=d --with-lines --fit=none
	  # Si x tiene dos elementos
	  gnuplot 2 3 1 --matrix=d --with-lines --fit=none
	</code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza el suavizado de las perturbaciones de un 'bundle' de Kalman,
	  configurado previamente mediante la instrucción <fncref targ="ksetup"/>;
	  y devuelve el entero 0 cuando se completa con éxito, o un número no
	  nulo cuando se encuentran problemas numéricos. Y deberías comprobar
	  el valor que se devuelve, antes de hacer uso de los resultados.
	</para>
	<para>
	  Cuando se completa con éxito la operación, las perturbaciones suavizadas
	  van a estar disponibles como <lit>kb.smdist</lit>.
	</para>
	<para>
	  El argumento <argname>MSE</argname> (opcional) determina el contenido
	  de la clave <lit>kb.smdisterr</lit>. Cuando es 0 o se omite, esta
	  matriz va a estar compuesta por las desviaciones típicas incondicionales
	  de las perturbaciones suavizadas, que habitualmente se utilizan para
	  calcular los denominados <emphasis>errores auxiliares</emphasis>.
	  Pero, en caso contrario, <lit>kb.smdisterr</lit> va a contener las
	  raíces de las desviaciones cuadradas medias entre los errores
	  auxiliares y sus valores verdaderos.
	</para>
	<para>
	  Para obtener más detalles, consulta <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza el filtrado hacia adelante de un 'bundle' de Kalman configurado
	  previamente mediante la instrucción <fncref targ="ksetup"/>, y
	  devuelve el escalar 0 cuando se completa con éxito, o el escalar 1
	  cuando se encuentran problemas numéricos.
	</para>
	<para>
	  Cuando se completa con éxito, los errores de predicción adelantados un paso
	  van a estar disponibles como <lit>kb.prederr</lit>, y la secuencia de
	  sus matrices de covarianzas como <lit>kb.pevar</lit>. Por otro
	  lado, <lit>kb.llt</lit> permitirá que tengas acceso a un
	  <math>T</math>-vector que va a contener el logaritmo de la verosimilitud
	  de cada observación.
	</para>
	<para>
	  Para obtener más detalles, consulta <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kmeier" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con el cálculo del estimador no paramétrico
	  de Kaplan&ndash;Meier de la función de supervivencia
	  (<cite key="kaplan-meier">Kaplan y Meier, 1958</cite>), dada una
	  muestra <argname>d</argname> de datos de duración, posiblemente
	  acompañada de un registro de estado de censura, <argname>cens</argname>.
	  La matriz que se devuelve tiene tres columnas que contienen,
	  respectivamente: los valores únicos ordenados en <argname>d</argname>,
	  la estimación de la función de supervivencia que se corresponde con los
	  valores de duración de la columna 1, y la desviación típica (para muestras
	  grandes) del estimador, calculados mediante el método de
	  <cite key="greenwood26">Greenwood (1926)</cite>.
	</para>
	<para>
	  Cuando indicas la serie <argname>cens</argname>, se utiliza el valor 0
	  para señalar que una observación no está censurada, mientras
	  que el valor 1 indica que una observación está censurada del lado
	  derecho (es decir, el período de observación del individuo en cuestión
	  concluyó antes de la duración, o el período se registró como finalizado).
	  Cuando no indicas <argname>cens</argname>, se asume que todas las
	  observaciones son no censuradas. (Aviso: la semántica de
	  <argname>cens</argname> puede extenderse en algún punto para cubrir
	  otros tipos de censura.)
	</para>
	<para>
	  <seelist>
            <fncref targ="naalen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">tendenc</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila que contiene los valores críticos a los niveles de
	  10, 5 y 1 por ciento del contraste KPSS para la estacionariedad de una
	  serie temporal. El argumento <argname>T</argname> debe indicar el
	  número de observaciones, y el argumento <argname>tendenc</argname> debe
	  ser igual a 1 si el contraste incluye una constante (o 0 en caso contrario).
	</para>
	<para>
	  Los valores críticos que se ofrecen están basados en superficies
	  de respuesta estimadas del modo que está establecido por
	  <cite key="sephton95">Sephton (Economics Letters,1995)</cite>.
	  Consulta también la instrucción <cmdref targ="kps"/>.
 	</para>
      </description>
    </function>

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">Z</fnarg>
	<fnarg type="scalar-or-matrix">T</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">R</fnarg>
      </fnargs>
      <description>
	<para>
	  Configura un 'bundle' de Kalman, es decir, un objeto que contiene toda
	  la información necesaria para definir un modelo de espacio de los estados
	  lineal, de la forma
	  <equation status="display"
		    tex="\[y_t=Z\alpha_t + u_t\]"
		    ascii="y(t) = Za(t) + u(t)"
		    graphic="kalman1"/>
	  en la que Var<math>(u) = R</math>, y con la ecuación de transición
	  de estado
	  <equation status="display"
		    tex="\[\alpha_{t+1}=T \alpha_t + v_t\]"
		    ascii="a(t+1) = T a(t) + v(t)"
		    graphic="kalman2"/>
	  en la que Var<math>(v) = Q</math>.
	</para>
	<para>
	  Los objetos que creas mediante esta función puedes utilizalos más
	  adelante, con la intervención de las siguientes funciones específicas:
	  <fncref targ="kfilter"/> para hacer filtrado, <fncref targ="ksmooth"/>
	  y <fncref targ="kdsmooth"/> para suavizado, y <fncref targ="ksimul"/>
	  para hacer simulaciones.
	</para>
	<para>
	  En realidad, el tipo de modelos que GRETL puede manejar es mucho más
	  amplio que el implicado en la anterior representación: es posible disponer
	  de modelos variantes en el tiempo, de modelos con precedentes difusos
	  y con variable exógena en la ecuación de medida, y de modelos con
	  innovaciones con correlaciones cruzadas. Para obtener más detalles,
	  consulta <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksimul" section="sspace" output="matrix">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="bool" optional="true">extra</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz. Utiliza un 'bundle' de tipo Kalman previamente
	  definido con la función <fncref targ="ksetup"/> para llevar a cabo
	  simulaciones, tomando las perturbaciones de la matriz <argname>U</argname>.
	  Por defecto, la matriz que se devuelve (que tendrá tantas filas como
	  <argname>U</argname>) contiene valores simulados de lo(s) observable(s),
	  pero cuando indicas un valor no nulo para <argname>extra</argname>,
	  también se va a incluir el estado simulado. En este último caso,
	  cada fila contiene primero el estado, y después lo(s)
	  observable(s).
	</para>
	<para>
	  Para obtener más detalles, consulta <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksmooth" section="sspace" output="int">
      <fnargs>
	<fnarg type="bundleref">&amp;kb</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza un suavizado de punto fijo (hacia atrás) de un 'bundle' de
	  Kalman previamente configurado mediante <fncref targ="ksetup"/>;
	  y devuelve un 0 cuando se ejecuta con éxito, o un número no nulo
	  cuando se encuentran problemas numéricos. Y deberías comprobar
	  el valor que se devuelve, antes de hacer uso de los resultados.
	</para>
	<para>
	  Cuando se completa con éxito, vas a tener a tu disposición el estado ya
	  suavizado como <lit>kb.state</lit>, y la secuencia de sus matrices
	  de varianzas-covarianzas como <lit>kb.stvar</lit>. Para obtener más
	  detalles, consulta <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el exceso de curtosis de la serie <argname>x</argname>,
	  descartando cualquier observación ausente.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list-or-mat">
      <fnargs>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="series-list-or-mat">y</fnarg>
	<fnarg type="bool" optional="true">xretardo</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando el primer argumento es un escalar, genera los retardos del 1 al
	  <argname>p</argname> de la serie <argname>y</argname>. Cuando
	  <argname>y</argname> es una lista, genera esos retardos para todas las
	  series que contiene esa lista. Cuando <argname>y</argname> es una matriz,
	  genera esos retardos para todas las columnas de la matriz. En caso de que
	  <argname>p</argname> = 0, e <argname>y</argname> sea una serie
	  o una lista, el retardo máximo toma por defecto la periodicidad de los
	  datos; aparte de eso <argname>p</argname> deberá ser positivo.
	</para>
	<para>
	  Cuando el primer argumento es un vector, los retardos generados son los
	  que están especificados en ese vector. En este caso, un uso habitual
	  podría ser el de poner, por ejemplo, <argname>p</argname> como
	  <lit>seq(3,7)</lit>, omitiendo entonces el primer y segundo retardos.
	  Así y todo, también es correcto indicar un vector con saltos como en
	  <lit>{3,5,7}</lit>, aunque los retardos deberán indicarse siempre
	  en orden ascendente.
	</para>
	<para>
	  En caso de que el resultado sea una lista, se nombran automáticamente las
	  variables generadas con el patrón <repl>nombrevar</repl><lit>_</lit><repl>i</repl>,
	  en el que <repl>nombrevar</repl> estará indicando el nombre de la serie original,
	  e <repl>i</repl> expresará el retardo concreto de cada caso. La parte
	  original del nombre se va a truncar cuando así resulte necesario, e incluso
	  podrá ajustarse oportunamente para garantizar que resulte único dentro
	  del conjunto de nombres que así se vayan a construir.
	</para>
	<para>
	  Cuando el segundo argumento <argname>y</argname> es una lista o una
	  matriz con más de una columna, y el nivel de retardo es mayor que 1, la
	  disposición por defecto de los elementos en la lista que se devuelve es por orden
	  de variable: primero se devuelven todos los retardos de la primera serie
	  o columna contenida en ese argumento, seguidos de todos los de la segunda, y
	  así sucesivamente. El tercer argumento (opcional) puedes usarlo para
	  cambiar esto: si <argname>xretardo</argname> es no nulo, entonces los elementos
	  se ordenan por retardo: el primer retardo de todas las series o columnas,
	  después el segundo retardo de todas las series o columnas, etc.
	</para>
	<para>
	  Consulta también <fncref targ="mlag"/> para la utilización con matrices.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">enmuestra</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el número entero positivo que indexa la última observación
	  no ausente de la serie <argname>y</argname>. Por defecto, se analiza
	  todo el rango de la muestra, de forma que, si está activa alguna forma
	  de submuestreo, el valor que se devuelve puede ser mayor que el
	  valor devuelto por el accesor <fncref targ="$t2"/>. Pero si indicas un
	  valor no nulo en <argname>enmuestra</argname>, solo se va a tener
	  en cuenta el rango de la muestra vigente.
	  <seelist>
            <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el logaritmo natural del determinante de
	  <math>A</math>, calculado mediante la descomposición LU.
	  Ten en cuenta que esto es más eficiente que invocar
	  <fncref targ="det"/> y tomar el logaritmo del resultado. Además,
	  en algunos casos <lit>ldet</lit> es capaz de devolver un resultado
	  válido incluso cuando el determinante de <math>A</math> es
	  numéricamente <quote>infinito</quote> (excediendo el número
	  máximo de doble precisión de la librería de C).
	  <seelist>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con las primeras diferencias
	  del logaritmo de este; los valores iniciales se consideran <lit>NA</lit>.
	</para>
	<para>
	  Cuando se devuelve una lista, las variables individuales se nombran de
	  forma automática siguiendo el patrón <lit>ld_</lit><repl>varname</repl>,
	  en el que <repl>varname</repl> indica el nombre de la serie original. La parte
	  original del nombre se va a truncar cuando así resulte necesario, e incluso
	  podrá ajustarse para garantizar que sea único dentro del conjunto de
	  nombres que así se vayan a construir.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una nueva serie calculada como una combinación lineal de las
	  series de la lista <argname>L</argname>. Los coeficientes vienen dados
	  por el vector <argname>b</argname>, cuyo tamaño debe ser igual al
	  número de series que hay en <argname>L</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="linearize" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Para ejecutarlo es preciso tener instalado el TRAMO. Devuelve una serie
	  que es una versión <quote>linealizada</quote> del argumento; es decir,
	  una serie en la que cualquier valor ausente se substituye por valores
	  interpolados, y en la que las observaciones anómalas se ajustan. Para eso
	  se utiliza un mecanismo completamente automático del TRAMO. Para obtener
	  más detalles, consulta la documentación del TRAMO.
	</para>
	<para>
	  Ten en cuenta que, si la serie del argumento no posee valores
	  ausentes ni observaciones que el TRAMO considere anómalas, esta
	  función devuelve una copia de la serie original.
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el cálculo del estadístico Q de Ljung&ndash;Box
	  para la serie <argname>y</argname>, utilizando el nivel de retardo
	  <argname>p</argname>, a lo largo de la muestra seleccionada en ese momento.
	  El nivel de retardo debe ser mayor o igual a 1, y menor que el número
	  de observaciones disponibles.
	</para>
	<para>
	  Ese valor del estadístico puedes cotejarlo con la distribución Chi-cuadrado
	  con <argname>p</argname> grados de libertad, para verificar la
	  hipótesis nula de que la serie <argname>y</argname> no tiene
	  autocorrelación.
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el logaritmo de la función Gamma de <argname>x</argname>.
	</para>
	<para>
	  Consulta también <fncref targ="bincoeff"/> y <fncref targ="gammafun"/>.
	</para>
      </description>
    </function>

    <function name="loess" section="nonparam" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robusta</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza una regresión polinómica ponderada localmente, y devuelve
	  una serie que contiene los valores previstos de <argname>y</argname>
	  para cada valor no ausente de <argname>x</argname>. El método que
	  se utiliza es del tipo que está descrito por
	  <cite key="cleveland79">William Cleveland (1979)</cite>.
	</para>
	<para>
	  Los argumentos <argname>d</argname> y <argname>q</argname> (opcionales)
	  permiten especificar: el grado del polinomio de <argname>x</argname>
	  y que proporción de los puntos de datos se van a utilizar en la estimación
	  local, respectivamente. Los valores que se les suponen por defecto
	  son <argname>d</argname> = 1 y <argname>q</argname> = 0.5; y otros
	  valores admisibles para <argname>d</argname> son 0 y 2. Cuando
	  establezcas <argname>d</argname> = 0, vas a reducir la regresión local
	  a una forma de media móvil. El valor de <argname>q</argname> debe
	  de ser mayor que 0, y no puede ser mayor que 1; los valores más grandes
	  producen un resultado final más suavizado.
	</para>
	<para>
	  Cuando se especifica un valor no nulo para el argumento
	  <argname>robusta</argname>, las regresiones locales se reiteran dos veces,
	  con modificaciones en las ponderaciones en base a los errores de la iteración
	  previa, y de modo que tengan menos influencia las observaciones anómalas.
	</para>
	<para>
	  Revisa también la función <fncref targ="nadarwat"/> y, por añadido,
	  consulta <guideref targ="chap:nonparam"/> para obtener más detalles
	  sobre métodos no paramétricos.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el logaritmo natural de
	  <argname>x</argname>, generando <lit>NA</lit> si este no es positivo.
	  Aviso: <lit>ln</lit> es un seudónimo admisible para <lit>log</lit>.
	</para>
	<para>
	  Cuando se devuelve una lista, las variables individuales se nombran de
	  forma automática siguiendo el patrón <lit>l_</lit><repl>varname</repl>,
	  en el que <repl>varname</repl> indica el nombre de la serie original. La parte
	  original del nombre va a truncarse cuando así resulte necesario, e incluso
	  podrá ajustarse para garantizar que sea único dentro del conjunto de
	  nombres que así se vayan a construir.
	</para>
	<para>
	  Observa que, en caso de que el argumento sea una matriz, la función
	  opera elemento a elemento. Para la función logarítmica matricial,
	  consulta <fncref targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el logaritmo en base 10 de
	  <argname>x</argname>, generando <lit>NA</lit> si este no es positivo.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el logaritmo en base 2 de
	  <argname>x</argname>, generando <lit>NA</lit> si este no es positivo.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Devuelve un resultado (del mismo tipo que el argumento <argname>x</argname>)
	  con la función FDA logística de este; esto es, $\Lambda(x) = 1/(1+e^{-x})$. Si
	  <argname>x</argname> es una matriz, la función se aplica a cada elemento.
	</para>
	<para context="notex">
	  Devuelve un resultado (del mismo tipo que el argumento <argname>x</argname>)
	  con la función FDA logística de este; es decir,
	  1/(1+<math>e</math><sup>&minus;x</sup>). Si <argname>x</argname> es
	  una matriz, la función se aplica a cada elemento.
	</para>
      </description>
    </function>

    <function name="lpsolve" section="math" output="bundle">
      <fnargs>
	<fnarg type="bundle">specs</fnarg>
      </fnargs>
      <description>
	<para>
	  Soluciona un problema de programación lineal, utilizando la biblioteca
	  lpsolve. Consulta <doc>gretl-lpsolve.pdf</doc> para obtener más
	  detalles y ejemplos de uso.
	</para>
      </description>
    </function>

    <function name="lower" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve una matriz triangular inferior de orden <by r="n" c="n"/>: los
	  elementos de la diagonal principal y de debajo de esta son iguales a los elementos
	  correspondientes de <argname>A</argname>, y los demás son iguales a cero.
	</para>
	<para context="tex">
	  Devuelve <math>B</math>, una matriz triangular inferior $n\times n$,
	  en la que para cada $B_{ij} = A_{ij}$ si $i \ge j$, y 0 en otro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrcovar" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="bool" optional="true">sinmedia</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con las varianzas y covarianzas de largo plazo
	  de las columnas de la matriz <argname>A</argname>. Primero, a los datos
	  se les resta la media, excepto que se asigne un cero al segundo
	  argumento (opcional). Puedes escoger el tipo de kernel y el parámetro
	  de truncado del retardo (el tamaño de la ventana), antes de llamar a
	  esta función mediante las opciones relacionadas con el HAC que ofrece
	  la instrucción <cmdref targ="set"/>, tales como <lit>hac_kernel</lit>,
	  <lit>hac_lag</lit>, o <lit>hac_prewhiten</lit>. Consulta también
	  la sección sobre datos de series de tiempo y matrices de covarianzas
	  HAC en <guideref targ="chap:robust_vcv"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="lrvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrvar" section="timeseries" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
	<fnarg type="scalar" optional="true">mu</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con la varianza de largo plazo del argumento
	  <argname>y</argname>, calculada usando un núcleo (<quote>kernel</quote>) de
	  Bartlett con tamaño de ventana igual a <argname>k</argname>. Si omites el
	  segundo argumento (o le asignas un valor negativo), el tamaño de la ventana
	  se establece por defecto igual a la parte entera de la raíz cúbica del tamaño de la muestra.
	</para>
	<para context="tex">
	  Fórmula:
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \mu) (y_{t-i} - \bar{Y})
	  \right] \]
	  con
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
	<para>
	  Para el cálculo de la varianza, la serie <argname>y</argname> se
	  centra con respecto al parámetro opcional <argname>mu</argname>;
	  y cando este se omite o es <lit>NA</lit>, se utiliza la media
	  muestral.
	</para>
	<para>
	  Para una contrapartida multivariante, consulta <fncref targ="lrcovar"/>.
	</para>
      </description>
    </function>

    <function name="Lsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">L</fnarg>
	<fnarg type="matrix">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Soluciona <math>x</math> en <math>Ax = b</math>, donde
	  <argname>L</argname> es el factor de Cholesky triangular
	  inferior de la matriz definida positiva <math>A</math>, que
	  cumple <math>LL' = A</math>. Puedes obtener un <argname>L</argname>
	  apropiado utilizando la función <fncref targ="cholesky"/> con
	  <math>A</math> como argumento.
	</para>
	<para>
	  Los siguientes dos cálculos deberían producir el mismo resultado
	  (dependiendo de la precisión de la máquina), pero la primera variante
	  permite la reutilización de un factor de Cholesky calculado previamente,
	  y por lo tanto debería ser substancialmente más rápido si estás
	  solucionando de forma repetida para una misma <math>A</math>,
	  y distintos valores de <math>b</math>. El aumento de velocidad será
	  mayor, cuanto mayor sea la dimensión de columnas de <math>A</math>.
	</para>
	<code>
	  # Variante 1
	  matrix L = cholesky(A)
	  matrix x = Lsolve(L, b)
	  # Variante 2
	  matrix x = A \ b
	</code>
      </description>
    </function>

    <function name="mat2list" section="data-utils" output="list">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="string">prefijo</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta es una función conveniente para elaborar una lista de series
	  utilizando las columnas de una matriz apropiada como entrada. La
	  dimensión de las filas de <argname>X</argname> debe ser igual a la
	  longitud del conjunto de datos vigente, o al número de observaciones
	  del rango de la muestra vigente.
	</para>
	<para>
	  Las series de la lista que se devuelve se nombran del siguiente modo.
	  Primero, cuando se proporciona el argumento opcional
	  <argname>prefijo</argname>, la serie creada de la columna <math>i</math>
	  de <argname>X</argname> se nombra añadiendo <math>i</math> a la cadena
	  de texto proporcionada, como en <lit>prefijo1</lit>, <lit>prefijo2</lit>,
	  etcétera. En caso contrario, si la matriz <argname>X</argname> tiene un
	  conjunto de nombres de las columnas (consulta <fncref targ="cnameset"/>),
	  se utilizan esos nombres. Finalmente, si no se cumple ninguna de las
	  condiciones anteriores, los nombres son <lit>columna1</lit>,
	  <lit>columna2</lit>, etcétera. Ten en cuenta que esta política puede
	  tener como consecuencia que se sobrescriban series ya existentes;
	  si no quieres que ello suceda, toma la precaución de nombrar las
	  columnas explícitamente mediante la función <lit>cnameset</lit>, o
	  indica la opción <argname>prefix</argname>.
	</para>
	<para>
	  Aquí tienes un ejemplo ilustrativo de su uso:
	</para>
	<code>
	  matrix X = mnormal($nobs, 8)
	  list L = mat2list(X, "xnorm")
	  # o alternativamente, si no necesitas crear la propia X
	  list L = mat2list(mnormal($nobs, 8), "xnorm")
	</code>
	<para>
	  Esto va a añadir al conjunto de datos, ocho series de longitud completa
	  nombradas <lit>xnorm1</lit>, <lit>xnorm2</lit>, etcétera.
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Si el argumento <argname>y</argname> es una serie, la función devuelve
	  un escalar con el valor máximo de esa serie (en las observaciones no ausentes).
	  Si el argumento es una lista, devuelve una serie en la que cada uno de sus
	  valores indica el máximo de entre las series listadas, para cada
	  observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="min"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila que contiene el valor más grande de cada columna
	  de la matriz <argname>X</argname>. Para columnas que tengan valores
	  <lit>NA</lit>s, el resultado también se establece como <lit>NA</lit>, excepto
	  cuando no sea cero el argumento opcional <argname>obviar_na</argname>,
	  en cuyo caso se devuelve la mayor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna que contiene el valor más grande de cada fila
	  de la matriz <argname>X</argname>. Para filas que tengan valores
	  <lit>NA</lit>s, el resultado también se establece como <lit>NA</lit>, excepto
	  cuando no sea cero el argumento opcional <argname>obviar_na</argname>,
	  en cuyo caso se devuelve la mayor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula una matriz de correlaciones (de Pearson), tratando cada columna
	  de la matriz argumento <argname>X</argname> como si fuese una variable.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int" optional="true">gl_corr</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula una matriz de varianzas-covarianzas, tratando cada columna
	  de la matriz argumento <argname>X</argname> como si fuese una
	  variable. El divisor es <math>n</math> &minus; 1, en el que
	  <math>n</math> es el número de filas de <argname>X</argname>;
	  excepto que indiques el segundo argumento (opcional), en cuyo caso
	  se utiliza <math>n</math> &minus; <argname>gl_corr</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve la matriz covariograma para otra matriz <argname>X</argname>
	  de orden <by r="T" c="k"/> (que generalmente contiene regresores), un
	  vector <argname>u</argname> de orden <math>T</math> (opcional,
	  que suele contener los errores), un vector <argname>w</argname> de orden
	  <math>p</math>+1 (opcional, que contiene unas ponderaciones), y un
	  número entero <argname>p</argname> que indica el nivel de retardo
	  y debe ser mayor o igual a 0.
	</para>
	<para context="tex">
	  La matriz que se devuelve viene dada por
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t u_t
	  u_{t-j} X_{t-j}')\]
	</para>
	<para context="notex">
	  La matriz que se devuelve es la suma para <math>j</math> desde
	  <math>-p</math> hasta <math>p</math> de
	  <math>w(|j|) * X(t)X(t-j)' * u(t)u(t-j)</math>, donde <math>X(t)'</math> es
	  la <math>t</math>-ésima fila de <argname>X</argname>.
	</para>
	<para>
	  Si <argname>u</argname> viene indicado como <lit>nulo</lit>,
	  los términos <math>u</math> se omiten, y si
	  <argname>w</argname> viene indicado como <lit>nulo</lit>,
	  todas las ponderaciones se asume que son 1.0.
	</para>
	<para>
	  Por ejemplo, el siguiente trozo de código
	</para>
	<code>
	  set seed 123
	  X = mnormal(6,2)
	  Retardo = mlag(X,1)
	  Adelanto = mlag(X,-1)
	  print X Retardo Adelanto
	  eval X'X
	  eval mcovg(X, , , 0)
	  eval X'(X + Retardo + Adelanto)
	  eval mcovg(X, , , 1)
	</code>
	<para>
	  produce este resultado:
	</para>
	<code>
	  ? print X Retardo Adelanto
	  X (6 x 2)

	    -0,76587      -1,0600
	    -0,43188      0,30687
	    -0,82656      0,40681
	     0,39246      0,75479
	     0,36875       2,5498
	     0,28855     -0,55251

	  Retardo (6 x 2)

	      0,0000       0,0000
	    -0,76587      -1,0600
	    -0,43188      0,30687
	    -0,82656      0,40681
	     0,39246      0,75479
	     0,36875       2,5498

	  Adianto (6 x 2)

	    -0,43188      0,30687
	    -0,82656      0,40681
	     0,39246      0,75479
	     0,36875       2,5498
	     0,28855     -0,55251
	      0,0000       0,0000

	  ? eval X'X
	      1,8295       1,4201
	      1,4201       8,7596

	  ? eval mcovg(X,,, 0)
	      1,8295       1,4201
	      1,4201       8,7596

	  ? eval X'(X + Retardo + Adianto)
	      3,0585       2,5603
	      2,5603       10,004

	  ? eval mcovg(X,,, 1)
	      3,0585       2,5603
	      2,5603       10,004
	</code>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>x</argname> es una serie, la función devuelve un escalar
	  con su media muestral, ignorando cualquier observación ausente.
	</para>
	<para>
	  Si <argname>x</argname> es una lista, la función devuelve una
	  serie <math>y</math> tal que <math>y</math><sub>t</sub> indica
	  la media de los valores de las variables de esa lista en la
	  observación <math>t</math>. Por defecto, la media se registra
	  como <lit>NA</lit>, si hay algún valor ausente en <math>t</math>;
	  pero si le das un valor no nulo a <argname>parcial</argname>,
	  cualquier valor no ausente se usará para crear el
	  estadístico.
	</para>
	<para>
	  El siguiente ejemplo ilustra el funcionamiento de la función:
	</para>
	<code>
	  open denmark.gdt
	  eval mean(LRM)
	  list L = dataset
	  eval mean(L)
	</code>
	<para>
    La primera solicitud devolverá un escalar con el valor medio de la
    serie <argname>LRM</argname>, y la segunda devolverá una
    serie.
	</para>
	<para>
	  <seelist>
            <fncref targ="median"/>
            <fncref targ="sum"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
            <fncref targ="sd"/>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila con cada una de las medias de cada columna de
	  <argname>X</argname>. Si indicas un valor no nulo para el segundo
	  argumento (opcional), se ignoran los valores ausentes; de otra forma, el
	  resultado es <lit>NA</lit> para cada columna que contenga valores ausentes.
	</para>
	<para>
	  Por ejemplo, la siguiente porción de código...
	</para>
	<code>
	  matrix m = mnormal(5, 2)
	  m[1,2] = NA
	  print m
	  eval meanc(m)
	</code>
	<para>
	  genera este resultado:
	</para>
	<code>
	  ? print m
	  m (5 x 2)

	   -0,098299          nan
	      1,1829      -1,2817
	     0,46037     -0,92947
	      1,4896     -0,91970
	     0,91918      0,47748

	  ? eval meanc(m)
	     0,79075          nan
	</code>
	<para>
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
            <fncref targ="maxc"/>
            <fncref targ="minc"/>
            <fncref targ="sdc"/>
            <fncref targ="prodc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna con cada una de las medias de cada fila de
	  <argname>X</argname>. Si indicas un valor no nulo para el segundo
	  argumento (opcional), se ignoran los valores ausentes; de otra forma, el
	  resultado es <lit>NA</lit> para cada fila que contenga valores ausentes.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>x</argname> es una serie, la función devuelve un escalar
	  con su mediana muestral, ignorando cualquier observación ausente.
	</para>
	<para>
	  Si <argname>x</argname> es una lista, la función devuelve una serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> indica la mediana
	  de los valores de las variables de esa lista en la observación <math>t</math>,
	  o <lit>NA</lit> en caso de que exista algún valor ausente en
	  <math>t</math>.
	</para>
	<para>
	  El siguiente ejemplo ilustra el funcionamiento de la función:
	</para>
	<code>
	  set verbose off
	  open denmark.gdt
	  eval median(LRM)
	  list L = dataset
	  series m = median(L)
	</code>
	<para>
    La primera solicitud devolverá un escalar con el valor mediano
    de la serie <argname>LRM</argname>, y la segunda devolverá una
    serie.
	</para>
	<para>
	  <seelist>
            <fncref targ="mean"/>
            <fncref targ="sum"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
            <fncref targ="sd"/>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula la matriz exponencial de una matriz cuadrada <argname>A</argname>.
	  Si <argname>A</argname> es una matriz real, se utiliza para ello el
	  algoritmo 11.3.1 de <cite key="golub96">Golub y Van Loan (1996)</cite>.
	  Si <argname>A</argname> es una matriz compleja, el algoritmo utiliza
	  la descomposición en autovalores y <argname>A</argname> debe ser
	  diagonalizable.
	</para>
	<para context="tex">
	  Calcula y devuelve la matriz exponencial de una matriz cuadrada,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\]
	  (La serie que está implícita en esta expresión seguramente va a converger.)
	  Si <argname>A</argname> es una matriz real, se utiliza para ello el
	  algoritmo 11.3.1 de <cite key="golub96">Golub e Van Loan (1996)</cite>.
	  Si <argname>A</argname> es una matriz compleja, el algoritmo utiliza
	  la descomposición en autovalores y <argname>A</argname> debe ser
	  diagonalizable.
	</para>
	<para>
	  Consulta también <fncref targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="mgradient" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Derivadas analíticas para las ponderaciones de un MIDAS. Denotando como
	  <math>k</math> al número de elementos que componen el vector
	  <repl>theta</repl> de hiperparámetros, esta función devuelve una
	  matriz de orden <by r="p" c="k"/>, que contiene el gradiente del vector de
	  ponderaciones (tal como lo calcula la función <fncref targ="mweights"/>)
	  con respecto a los elementos de <repl>theta</repl>. El primer
	  argumento representa el nivel de retardo deseado, y el último
	  argumento especifica el tipo de disposición de parámetros. Consulta
	  la función <lit>mweights</lit> para tener una relación de los valores
	  admisibles para <repl>tipo</repl>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="midasmult"/>
	    <fncref targ="mlincomb"/>
	    <fncref targ="mweights"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="midasmult" section="midas" output="matrix">
      <fnargs>
	<fnarg type="bundle">mod</fnarg>
	<fnarg type="bool">acumular</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el cálculo de los multiplicadores MIDAS. El argumento
	  <argname>mod</argname> debe ser un 'bundle' que incluya un
	  modelo MIDAS, del tipo que se genera mediante la instrucción
	  <cmdref targ="midasreg"/> y que es accesible por medio de la clave
	  <fncref targ="$model"/>. La función devuelve una matriz con los
	  multiplicadores implícitos MIDAS para la variable <argname>v</argname>
	  en la primera columna, y las desviaciones típicas correspondientes en la
	  segunda columna. Si el argumento <argname>acumular</argname> no
	  es cero, los multiplicadores se acumulan.
	</para>
	<para>
	  Observa que automáticamente se proporciona la matriz que se devuelve con
	  etiquetas adecuadas para las filas, de forma que resultan indicadas para
	  usar como primer argumento de la instrucción <cmdref targ="modprint"/>.
	  Por ejemplo, el código
	</para>
	<code>
	  open gdp_midas.gdt
	  list dIP = ld_indpro*
	  smpl 1985:1 ;
	  midasreg ld_qgdp 0 ; mds(dIP, 0, 6, 2)
	  matrix ip_m = midasmult($model, 0, 1)
	  modprint ip_m
	</code>
	<para>
	  genera el siguiente resultado:
	</para>
	<code>
             Coeficiente   Desv. típica     z       Valor p
  ---------------------------------------------------------
  dIP_0      0,343146      0,0957752     3,583     0,0003   ***
  dIP_1      0,402547      0,0834904     4,821     1,43e-06 ***
  dIP_2      0,176437      0,0673776     2,619     0,0088   ***
  dIP_3      0,0601876     0,0621927     0,9678    0,3332
  dIP_4      0,0131263     0,0259137     0,5065    0,6125
  dIP_5      0,000965260   0,00346703    0,2784    0,7807
  dIP_6      0,00000       0,00000      NA        NA
	</code>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
            <fncref targ="mweights"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando el argumento <argname>y</argname> es una serie, devuelve un
	  escalar con el valor mínimo de las observaciones no ausentes de la serie.
	  Cuando el argumento es una lista, devuelve una serie en la que cada
	  elemento es el valor mínimo de entre las series listadas, en cada
	  observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="max"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila que contiene el valor más pequeño de cada columna
	  de la matriz <argname>X</argname>. Para columnas que tengan valores
	  <lit>NA</lit>s, el resultado también se establece como <lit>NA</lit>, excepto
	  cuando no sea cero el argumento opcional <argname>obviar_na</argname>,
	  en cuyo caso se devuelve la menor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna que contiene el valor más pequeño de cada fila
	  de la matriz <argname>X</argname>. Para filas que tengan valores
	  <lit>NA</lit>s, el resultado también se establece como <lit>NA</lit>, excepto
	  cuando no sea cero el argumento opcional <argname>obviar_na</argname>,
	  en cuyo caso se devuelve la menor entrada válida.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una variable binaria (del mismo tipo que el argumento) que toma
	  el valor 1 cuando <argname>x</argname> es <lit>NA</lit>. Si ese argumento
	  es una serie, se hace la comprobación para cada elemento. Cuando sea
	  <argname>x</argname> una lista de series, devuelve una serie que toma el
	  valor 1 en las observaciones en las que al menos una de las series presenta
	  un valor ausente, y el 0 en otro caso. Por ejemplo, el siguiente código
	</para>
	<code>
    nulldata 3
    series x = normal()
    x[2] = NA
		series x_ismiss = missing(x)
		print x x_ismiss --byobs
	</code>
	<para>
	  establece un valor ausente en la segunda observación de <argname>x</argname>,
    y crea una nueva serie booleana <argname>x_ismiss</argname> que
	  identifica la observación ausente.
	</para>
	<code>
		             y     y_ismiss

		1    -1,551247            0
		2                         1
		3    -2,244616            0
	</code>
	<para>
	  <seelist>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado del tipo del argumento, cambiando los
	  <lit>NA</lit>s por ceros. Si <argname>x</argname> es una serie o una
	  matriz, se cambia elemento a elemento. Por ejemplo, el siguiente código
	</para>
	<code>
		nulldata 3
		series x = normal()
		x[2] = NA
		y = misszero(x)
		print x y --byobs
	</code>
	<para>
	  establece un valor ausente en la segunda observación de
	  <argname>x</argname>, y crea una nueva serie <argname>y</argname>
	  en la que se sustituye la observación ausente por un cero:
	</para>
	<code>
	             x            y

		1    0,7355250    0,7355250
		2                     0,000
		3   -0,2465936   -0,2465936
	</code>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Mueve hacia arriba o abajo las filas de la matriz <argname>X</argname>.
	  Cuando <argname>p</argname> es un escalar positivo, la función devuelve
	  una matriz semejante a <argname>X</argname>, pero con los valores de
	  cada columna desplazados <argname>p</argname> filas hacia abajo,
	  y con las primeras <argname>p</argname> filas cubiertas con el valor
	  <argname>m</argname>. Cuando <argname>p</argname> es un número
	  negativo, la matriz que se devuelve se parece a <argname>X</argname>,
	  pero con los valores de cada columna desplazados hacia arriba, y las últimas
	  filas cubiertas con el valor <argname>m</argname>. Si omites
	  <argname>m</argname>, se entiende que es igual a cero.
	</para>
	<para context="tex">
	  Mueve hacia arriba o abajo las filas de la matriz <argname>X</argname>.
	  Cuando $p$ es un escalar positivo, la función devuelve una matriz
	  $Y$ cuyo elemento característico es $Y_{i,j} = X_{i-p,j}$ para $i \ge p$,
	  y cero en otro caso. En otras palabras, devuelve una matriz semejante
	  a <argname>X</argname>, pero con los valores de cada columna desplazados
	  <argname>p</argname> filas hacia abajo, y con las primeras
	  <argname>p</argname> filas cubiertas con el valor <argname>m</argname>.
	  Cuando <argname>p</argname> es un número negativo, la matriz que se
	  devuelve se parece a <argname>X</argname>, pero con los valores de cada
	  columna desplazados hacia arriba, y las últimas filas cubiertas con el valor
	  <argname>m</argname>. Si omites <argname>m</argname>, se entiende que
	  es igual a cero.
	</para>
	<para>
	  Si <argname>p</argname> es un vector, la operación indicada en el párrafo
	  anterior se realiza con cada uno de los elementos de <argname>p</argname>,
	  y las matrices resultantes se unen horizontalmente. El siguiente código
	  ilustra este uso, introduciendo para ello una matriz <argname>X</argname>
	  que tiene dos columnas, y el argumento <argname>p</argname> que indica
	  los retardos 1 y 2. También se determina que los valores ausentes tengan
	  el valor NA, en contraposición al 0 establecido por defecto.
	</para>
	<code>
	matrix X = mnormal(5, 2)
	print X
	eval mlag(X, {1, 2}, NA)
	</code>
	<code>
	m (5 x 2)

	    1,5953    -0,070740
    -0,52713     -0,47669
	   -2,2056     -0,28112
	   0,97753       1,4280
	   0,49654      0,18532

	       nan          nan          nan          nan
     1,5953    -0,070740          nan          nan
	   -0,52713     -0,47669       1,5953    -0,070740
	   -2,2056     -0,28112     -0,52713     -0,47669
	   0,97753       1,4280      -2,2056     -0,28112
	</code>
	<para>
	  Consulta también <fncref targ="lags"/>.
	</para>
      </description>
    </function>

    <function name="mlincomb" section="midas" output="series">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta es una función MIDAS muy oportuna que combina las funciones
	  <fncref targ="lincomb"/> y <fncref targ="mweights"/>. Dada la lista
	  <repl>hfvars</repl>, elabora una serie que es una suma ponderada
	  de los elementos de esa lista. Las ponderaciones se basan en el vector
	  <repl>theta</repl> de hiperparámetros y en el tipo de disposición de
	  parámetros: consulta la función <lit>mweights</lit> para obtener más
	  detalles. Ten en cuenta que <fncref targ="hflags"/> generalmente
	  es el mejor modo de crear una lista apropiada para que sea el
	  primer argumento de esta función.
	</para>
	<para>
	  Para ser más explícitos, la expresión
	</para>
	<code>
	  series s = mlincomb(hfvars, theta, 2)
	</code>
	<para>
	  es equivalente a
	</para>
	<code>
	  matrix w = mweights(nelem(hfvars), theta, 2)
	  series s = lincomb(hfvars, w)
	</code>
	<para>
	  pero utilizar la función <lit>mlincomb</lit>, permite economizar algo
	  al teclear y también en algunos ciclos de uso de CPU.
	</para>
      </description>
    </function>

    <function name="mlog" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con el logaritmo matricial de <argname>A</argname>.
	  El algoritmo que se usa se basa en la descomposición en autovalores, por
	  lo que necesita que la matriz <argname>A</argname> sea diagonalizable.
	  Consulta también <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz formada con valores generados de forma pseudoaleatoria
	  mediante variables con distribución Normal estándar, y que va a tener
	  <argname>r</argname> filas y <argname>c</argname> columnas. Si lo omites,
	  el número de columnas se establece en 1 (vector columna) por defecto.
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz <by r="k" c="n"/> de estimaciones de parámetros
	  obtenidos mediante la regresión de Mínimos Cuadrados Ordinarios de la matriz
	  <argname>Y</argname> de orden <by r="T" c="n"/> sobre la matriz
	  <argname>X</argname> de orden <by r="T" c="k"/>.
	</para>
	<para>
	  Cuando se indica el tercer argumento, y no es <lit>null</lit>, la
	  función va a generar una nueva matriz <argname>U</argname> de orden
	  <by r="T" c="n"/>, que contiene los errores. Cuando se indica el último
	  argumento, y no es <lit>null</lit>, la matriz <argname>V</argname>
	  que se genera va a ser de orden <by r="k" c="k"/>, y contiene (a) la matriz
	  de covarianzas de los estimadores de los parámetros, si <argname>Y</argname>
	  tiene solo una columna, o (b) la matriz <math>X'X</math><sup>-1</sup>
	  si <argname>Y</argname> tiene varias columnas.
	</para>
	<para>
	  Por defecto, las estimaciones se obtienen por medio de la descomposición de
	  Cholesky, con un último recurso a la descomposición QR si las columnas de
	  <argname>X</argname> tienen alto grado de multicolinealidad. Puedes forzar
	  el uso de la descomposición SVD mediante la instrucción <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mpols"/>
            <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">año</fnarg>
	<fnarg type="int">duracsemana</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del mismo tipo que el argumento) que expresa
	  cuántos días (relevantes) tiene un mes de un año (en el calendario
	  Gregoriano proléptico). El argumento <argname>duracsemana</argname>,
	  que debe ser igual a 5, 6 o 7, indica el número de días de la semana
	  que se deben contar (con el valor 6 no se cuentan los domingos, y
	  con 5 no se cuentan ni los sábados ni los domingos).
	</para>
	<para>
	  El valor que se devuelva va a ser un escalar si son escalares tanto
	  <argname>mes</argname> como <argname>año</argname>; en caso
	  contrario será una serie.
	</para>
	<para>
	  Por ejemplo, si tienes abierto un conjunto de datos mensuales, la expresión
	</para>
	<code>
	  series wd = monthlen($obsminor, $obsmajor, 5)
	</code>
	<para>
	  devolverá una serie que va contener el número de días laborables
	  de cada uno de los meses de la muestra.
	</para>
      </description>
    </function>

    <function name="movavg" section="timeseries" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
	<fnarg type="scalar" optional="true">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie que es una media móvil de <argname>x</argname>
	  y, dependiendo del valor del parámetro <argname>p</argname>, resultará
	  una media móvil simple o ponderada exponencialmente.
	</para>
	<para context="notex">
	  Cuando <argname>p</argname> &gt; 1, la función calcula una media
	  móvil simple de <argname>p</argname> elementos; es decir, calcula
	  la media aritmética de <math>x</math> desde el período <math>t</math>
	  hasta el período <math>t-p+1</math>. Cuando indicas un valor no nulo
	  para el argumento <argname>control</argname> (opcional), la media
	  móvil <quote>se centra</quote>; en caso contrario, <quote>se retarda</quote>.
	  El otro argumento <argname>y0</argname> no se va a tener en
	  cuenta.
	</para>
	<para context="tex">
	  Cuando $p&gt;1$, la función calcula una media móvil simple de
	  <argname>p</argname> elementos; es decir, calcula
	  $\frac{1}{p} \sum_{i=0}^{p-1} x_{t-i}$. Cuando indicas un valor no
	  nulo para el argumento <argname>control</argname> (opcional), la media
	  móvil <quote>se centra</quote>; en caso contrario, <quote>se retarda</quote>.
	  El otro argumento <argname>y0</argname> no se va a tener en cuenta.
	</para>
	<para context="notex">
	  Cuando <argname>p</argname> es un fracción decimal entre 0 y 1, la
	  función calcula una media móvil exponencial:
	</para>
	<para context="notex">
	  <math>y(t) = p*x(t) + (1-p)*y(t-1)</math>
	</para>
	<para context="notex">
	  Por defecto, la serie <math>y</math> que se devuelve, se inicia
	  utilizando el primer valor válido de <argname>x</argname>. Pero
	  puedes utilizar el parámetro <argname>control</argname> para
	  especificar un número de observaciones iniciales, de forma que
	  su media se tomará como <math>y(0)</math>; un valor de cero para
	  <argname>control</argname> indica que deben tomarse todas las
	  observaciones para calcular ese valor. Otra posibilidad consiste en
	  que puedes especificar el valor inicial utilizando el argumento
	  opcional <argname>y0</argname>; en ese caso, el argumento
	  <argname>control</argname> no va a tenerse en cuenta.
	</para>
	<para context="tex">
	  Cuando $0 &lt; p &lt; 1$, la función calcula una media móvil
	  exponencial: \[y_t = p x_t + (1-p)y_{t-1}\]. Esta es la fórmula de
	  <cite key="roberts59">Roberts (1959)</cite>. Por defecto, la serie
	  $y$ que se devuelve, se inicia utilizando el primer valor válido de
	  $x$. Pero puedes utilizar el parámetro <argname>control</argname>
	  para especificar un número de observaciones iniciales, de forma que
	  su media se tomará como $y_0$; un valor de cero para
	  <argname>control</argname> indica que deben tomarse todas las
	  observaciones para calcular ese valor. Otra posibilidad consiste en
	  que puedes especificar el valor inicial utilizando el argumento
	  opcional <argname>y0</argname>; en ese caso, el argumento
	  <argname>control</argname> no va a tenerse en cuenta.
	</para>
      </description>
    </function>

    <function name="mpiallred" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;object</fnarg>
	<fnarg type="string">op</fnarg>
      </fnargs>
      <description>
	<para>
	  Solo disponible cuando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocarlo todos
	  los procesos. Esta función opera igual que <fncref targ="mpireduce"/>
	  excepto por el hecho de que todos los procesos (no solo el proceso
	  principal) reciben una copia del objeto <quote>reducido</quote> en
	  lugar del original. Por lo tanto, esto es equivalente a lo que hace
	  la función <lit>mpireduce</lit> seguida por una llamada a la función
	  <fncref targ="mpibcast"/>, pero más eficiente.
	</para>
      </description>
    </function>

    <function name="mpibarrier" section="mpi" output="int">
      <description>
	<para>
	  Solo disponible cuando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); no requiere
	  argumentos. Fuerza la sincronización de los procesos MPI:
	  ningún proceso puede continuar más allá de la barrera hasta
	  que la alcancen todos ellos.
	</para>
	<code>
	  # Ninguno pasa hasta que todos lleguen aquí
	  mpibarrier()
	</code>
      </description>
    </function>

    <function name="mpibcast" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;objeto</fnarg>
	<fnarg type="int" optional="true">raíz</fnarg>
      </fnargs>
      <description>
	<para>
	  Solo disponible cuando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocarlo
	  todos los procesos. Difunde el argumento <argname>objeto</argname>,
	  que deberás indicar en forma puntero, a todos los procesos. El
	  objeto en cuestión (una matriz, un 'bundle', un escalar, un 'array'
	  una cadena de texto o una lista) debe indicarse en todos los procesos
	  anteriores a la difusión. Ningún proceso puede continuar después
	  de una llamada a <lit>mpibcast</lit> hasta que todos los procesos
	  lo consigan ejecutar con éxito.
	</para>
	<para>
	  Por defecto, se entiende que la <quote>raíz</quote> u origen de la
	  difusión es el proceso MPI con rango 0; pero puedes ajustar esto
	  mediante el segundo argumento (opcional), que deberá ser un
	  número entero entre 0 y el número de procesos MPI menos 1.
	</para>
	<para>
	  A continuación, tenemos un ejemplo sencillo. Cuando se complete con
	  éxito, cada proceso va a tener una copia de la matriz <lit>X</lit>
	  definida en el rango 0.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	      X = mnormal(T, k)
	  endif
	  mpibcast(&amp;X)
	</code>
      </description>
    </function>

    <function name="mpirecv" section="mpi" output="object">
      <fnargs>
	<fnarg type="int">src</fnarg>
      </fnargs>
      <description>
	<para>
	  Solo disponible cuando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>). Para mayor aclaración,
	  mira la función <fncref targ="mpisend"/>, con la que <lit>mpirecv</lit>
	  deberá siempre emparejarse. El argumento <argname>src</argname>
	  especifica la jerarquía del proceso del que se va a recibir el objeto,
	  en el rango que va desde 0 hasta el número de procesos MPI
	  menos 1.
	</para>
      </description>
    </function>

    <function name="mpireduce" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;objeto</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">raíz</fnarg>
      </fnargs>
      <description>
	<para>
	  Solo disponible cuando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocarlo todos
	  los procesos. Esta función reúne objetos (escalares, matrices o
	  'arrays') con un nombre determinado indicados en forma de puntero,
	  de todos los procesos, y los <quote>reduce</quote> a un único
	  objeto en el nodo raíz.
	</para>
	<para>
	  El argumento <lit>op</lit> especifica la operación o método
	  de reducción. Los métodos admitidos para los escalares son
	  <lit>sum</lit> (suma), <lit>prod</lit> (producto), <lit>max</lit>
	  (máximo) y <lit>min</lit> (mínimo). Para las matrices, los métodos
	  son <lit>sum</lit>, <lit>prod</lit> (producto de Hadamard),
	  <lit>hcat</lit> (concatenación horizontal) y <lit>vcat</lit>
	  (concatenación vertical). Para los 'arrays' solo se admite
	  <lit>acat</lit> (concatenación).
	</para>
	<para>
	  Por defecto, se entiende que la <quote>raíz</quote> o meta de la
	  reducción es el proceso MPI con rango 0; pero puedes ajustar esto
	  mediante el tercer argumento (opcional), que deberá ser un entero
	  entre 0 y el número de procesos MPI menos 1.
	</para>
	<para>
	  A continuación, tenemos un ejemplo. Cuando se complete con éxito lo
	  dicho antes, el proceso raíz va a tener una matriz <lit>X</lit> que
	  será la suma de las matrices <lit>X</lit> de todos los procesos.
	</para>
	<code>
	  matrix X
	  X = mnormal(T, k)
	  mpireduce(&amp;X, sum)
	</code>
      </description>
    </function>

    <function name="mpiscatter" section="mpi" output="int">
      <fnargs>
	<fnarg type="matrixref">&amp;M</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">raíz</fnarg>
      </fnargs>
      <description>
	<para>
	  Solo disponible cuando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocarlo
	  todos los procesos. Esta función distribuye trozos de una matriz
	  del proceso raíz, a todos los procesos. Debes anunciar la matriz en
	  todos los procesos que preceden a invocar a <lit>mpiscatter</lit>,
	  y debes indicarlo en forma de puntero.
	</para>
	<para>
	  El argumento <lit>op</lit> debe ser <lit>byrows</lit> o bien
	  <lit>bycols</lit>. Denotemos con <math>q</math> al cociente
	  entre el número de filas de la matriz que se va a dispersar,
	  y el número de procesos. En el caso <lit>byrows</lit>, el proceso
	  raíz va a enviar las primeras <math>q</math> filas al proceso 0;
	  las siguientes <math>q</math> al proceso 1, etcétera. Si queda un
	  remanente del reparto de filas, se añade a la última asignación.
	  El caso <lit>bycols</lit> es exactamente análogo pero el reparto
	  de la matriz se hace por columnas.
	</para>
	<para>
	  A continuación, tenemos un ejemplo. Si tenemos 4 procesos, cada uno
	  (incluido el raíz) va a tener una porción <by r="2500" c="10"/>
	  de la <lit>X</lit> original, tal como se encontraba en el proceso
	  raíz. Si quisieras mantener la matriz completa en el proceso raíz,
	  es necesario que hagas una copia de la misma antes de invocar a
	  <lit>mpiscatter</lit>.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	      X = mnormal(10000, 10)
	  endif
	  mpiscatter(&amp;X, byrows)
	</code>
      </description>
    </function>

    <function name="mpisend" section="mpi" output="int">
      <fnargs>
	<fnarg type="object">objeto</fnarg>
	<fnarg type="int">destino</fnarg>
      </fnargs>
      <description>
	<para>
	  Solo disponible cuando GRETL está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>). Envía el objeto indicado
	  (una matriz, un 'bundle', un 'array', un escalar, una cadena de texto
	  o una lista) desde el proceso vigente hasta el identificado por el
	  entero <argname>destino</argname> (desde 0 hasta el número de
	  procesos MPI menos 1).
	</para>
	<para>
	  Una llamada a esta función debe siempre estar emparejada con una
	  llamada a <fncref targ="mpirecv"/> en el proceso <argname>destino</argname>,
	  como en el siguiente ejemplo en el que se envía una matriz desde el
	  rango 2 hasta el rango 3.
	</para>
	<code>
	  if $mpirank == 2
	      matrix C = cholesky(A)
	      mpisend(C, 3)
	  elif $mpirank == 3
	      matrix C = mpirecv(2)
	  endif
	</code>
      </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona igual que <fncref targ="mols"/>, devolviendo una matriz, salvo
	  que los cálculos se hacen con alta precisión utilizando la biblioteca GMP.
	</para>
	<para>
	  Por defecto, GMP utiliza 256 bits para cada número de punto flotante,
	  pero puedes ajustar esto utilizando la variable de contexto
	  <lit>GRETL_MP_BITS</lit>; por ejemplo, <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-matrix">p1</fnarg>
	<fnarg type="scalar-or-matrix" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">filas</fnarg>
	<fnarg type="int">columnas</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
      </examples>
      <description>
	<para>
	  Funciona de la misma forma que la función <fncref targ="randgen"/> excepto
	  por el hecho de que devuelve una matriz en lugar de una serie. Los
	  argumentos iniciales (cuyo número depende de la distribución escogida)
	  para esta función ya se describen para <lit>randgen</lit>, pero deben
	  estar seguidos por dos números enteros para especificar el número
	  de filas y de columnas que va a tener la matriz aleatoria deseada.
	  Si indicas <argname>p1</argname> o <argname>p2</argname>
	  en forma matricial, deben tener un número de elementos que sea
	  igual al producto de <argname>filas</argname> por
	  <argname>columnas</argname>.
	</para>
	<para>
	  El primero de los ejemplos precedentes crea un vector columna con 50
	  elementos, a partir de una distribución Uniforme. El segundo ejemplo
	  crea una matriz aleatoria de orden <by r="20" c="20"/>, con valores
	  generados de la distribución <math>t</math> con 14 grados de libertad.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="string">nombrearchivo</fnarg>
	<fnarg optional="true" type="bool">importar</fnarg>
      </fnargs>
      <description>
	<para>
	  Lee una matriz guardada en el archivo llamado
	  <argname>nombrearchivo</argname>. Si en el nombre no está especificada
	  la ruta completa hasta el archivo, se va a buscar en algunas localizaciones
	  que se consideren <quote>probables</quote>, empezando por el directorio
	  de trabajo establecido en ese momento en <cmdref targ="workdir"/>. No
	  obstante, cuando se indica un valor no nulo para el segundo argumento
	  <argname>importar</argname> (opcional) de la función, el archivo se
	  busca en el directorio <quote>punto</quote> del usuario. Esto tiene la
	  intención de que se use esta función junto con las que exportan matrices,
	  y que se ofrecen en el contexto de la instrucción <cmdref targ="foreign"/>.
	  En ese caso, el argumento <argname>nombrearchivo</argname> debe ser un
	  nombre de archivo simple, sin indicar la ruta hasta el archivo.
	</para>
	
	<para>Actualmente la función reconoce cuatro formatos de archivo:
	</para>

	<subhead>Formato de texto original</subhead>
	<para>
	  Estos archivos se identifican mediante la extensión
	  <quote><lit>.mat</lit></quote>, y son completamente compatibles con
	  el formato de archivo de matriz Ox. Cuando el nombre del archivo tiene
	  la extensión <quote><lit>.gz</lit></quote>, se asume que al guardar
	  los datos se ha aplicada la compresión gzip.

	  El archivo se asume que es de texto plano, de acuerdo con la siguiente
	  especificación:
	</para>
	<ilist>
	  <li>
            <para>
	          El archivo comienza con ningún o con un número cualquiera de
	          comentarios, definidos por líneas que comienzan con el carácter
	          numeral, <lit>#</lit>; estas líneas se ignoran.
            </para>
	  </li>
	  <li>
            <para>
              La primera línea que no sea un comentario debe contiene dos
              enteros, separados por un carácter de tabulación, para
              indicar el número de filas y de columnas, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              Las columnas se separan por medio de tabulaciones.
            </para>
	  </li>
	  <li>
            <para>
              El separador decimal es el carácter punto,
              <quote><lit>.</lit></quote>.
            </para>
	  </li>
	</ilist>

	<subhead>Archivos binarios</subhead>
	<para>
	  Los archivos con extensión <quote><lit>.bin</lit></quote> se asume
	  que están en formato binario. La extensión <quote><lit>.gz</lit></quote>
	  también se reconoce para la compresión gzip. Los primeros 19 bytes
	  contienen los caracteres <lit>gretl_binary_matrix</lit>; los siguientes
	  8 bytes contienen dos enteros de 32 bits que proporcionan
	  el número de filas y de columnas; y lo que resta del archivo contiene
	  los elementos de la matriz ordenados por orden de mayor columna,
	  con formato <quote>dobles</quote> en extremo menor (little-endian).
	  Si ejecutas GRETL en un sistema de extremo mayor (big-endian), los
	  valores binarios se convierten a extremo menor cuando se escriben,
	  y se convierten a extremo mayor cuando se leen.
	</para>

	<subhead>Archivos con texto delimitado</subhead>
	<para>
	  Si el nombre del archivo que se va a leer tiene la extensión
	  <quote><lit>.csv</lit></quote>, las reglas que administran la lectura
	  del archivo según su formato son diferentes, y más laxas.
	  En este caso, el conjunto de datos presentes <emphasis>no</emphasis>
	  debe estar precedido por una línea que especifique el número de
	  filas y de columnas. GRETL tratará de determinar el delimitador
	  utilizado (coma, espacio, o punto y coma), y hará lo que pueda para
	  importar la matriz, admitiendo el uso de la coma como separador decimal,
	  si es necesario. Ten en cuenta que el delimitador no debe ser el
	  carácter de tabulación, dado el riesgo de confundir ese tipo de archivos
	  con los que tienen el formato de matrices <quote>original</quote> de GRETL.
	</para>

	<subhead>Archivos de conjuntos de datos de GRETL</subhead>
	<para>
	  Los archivos que tengan extensión <quote><lit>.gdt</lit></quote> o
	  <quote><lit>.gdtb</lit></quote> se tratan como archivos originales de
	  datos de GRETL, tal como los crea la instrucción <cmdref targ="store"/>
	  (guardar). En tal caso, la matriz que se va a devolver contiene los valores
	  numéricos de las series del conjunto de datos, ordenadas en columnas.
	  Ten en cuenta que las series con valores en cadenas de texto no se leen
	  como tales; la matriz solo va a contener sus codificaciones numéricas.
	</para>

	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">porcolumna</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz que contiene las filas de <argname>X</argname>
	  en orden inverso; o las columnas en orden inverso si el segundo
	  argumento tiene un valor no nulo.
	</para>
      </description>
    </function>

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Mínimos cuadrados restringidos: Genera la matriz de orden <by r="k" c="n"/>
	  con los parámetros estimados mediante la regresión de mínimos cuadrados de la
	  matriz <argname>Y</argname> de orden <by r="T" c="n"/>, sobre la matriz
	  <argname>X</argname> de orden <by r="T" c="k"/>, sujeta al conjunto
	  de restricciones lineales de los parámetros <math>RB </math> = <math>q</math>,
	  donde <math>B</math> representa el vector que formarían los parámetros
	  apilados unos sobre los otros. <argname>R</argname> debe tener
	  <math>kn</math> columnas, y cada línea de ella indica los coeficientes de una
	  de las restricciones lineales. El número de filas de <argname>q</argname>
	  debe coincidir con el número de filas de <argname>R</argname>.
	</para>
	<para>
	  Si el quinto argumento de la función no es <lit>null</lit>, entonces la
	  matriz <argname>U</argname> de orden <by r="T" c="n"/> va a contener
	  los errores. Cuando proporcionas un argumento final que no es
	  <lit>null</lit>, entonces la matriz <argname>V</argname> de orden
	  <by r="k" c="k"/> va a guardar la contrapartida restringida de la matriz
	  <math>X'X</math><sup>-1</sup>. Puedes construir la matriz de
	  varianzas-covarianzas de los estimadores de la ecuación <math>i</math>
	  multiplicando la submatriz apropiada de <argname>V</argname> por
	  una estimación de la varianza de la perturbación de esa
	  ecuación.
	</para>
      </description>
    </function>

    <function name="mshape" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Reordena los elementos de la matriz <argname>X</argname> en una nueva matriz
	  que tiene <argname>r</argname> filas y <argname>c</argname> columnas. Los
	  elementos se leen y se guardan comenzando por el de la primera columna y primera fila
	  de <argname>X</argname>, y siguiendo con los de las siguientes filas hasta acabar
	  con los de esa columna; y luego con las demás columnas. Si <argname>X</argname>
	  tiene menos elementos que <math>k</math>= <math>rc</math>, estos se van a
	  repetir de forma cíclica. En otro caso, si <argname>X</argname> tiene
	  más elementos, solo se utilizan los primeros <math>k</math> elementos.
	</para>
	<para>
	  Si omites e tercer argumento, por defecto <argname>c</argname> se
	  establece igual a 1 si <argname>X</argname> es <by r="1" c="1"/>;
	  en otro caso, se establece igual a <math>N</math>/<argname>r</argname>
	  donde <math>N</math> representa el número total de elementos que
	  hay en <argname>X</argname>. Sin embargo, cuando <math>N</math>
	  no es un múltiplo entero de <argname>r</argname> se presenta un
	  error.
	</para>
	<para>
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con las mismas filas de la matriz del argumento
	  <argname>X</argname> reordenadas de forma creciente de acuerdo con los
	  elementos de la columna <argname>j</argname>. Este orden es estable: las
	  filas que comparten el mismo valor en la columna <argname>j</argname>
	  no se intercambian.
	</para>
      </description>
    </function>

    <function name="msplitby" section="matrix" output="matrices">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-matrix">v</fnarg>
	<fnarg type="bool">porcolum</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una formación de matrices, como resultado de separar
	  horizontal o verticalmente la matriz <argname>X</argname>, bajo
	  el control de los argumentos <argname>v</argname> y
	  <argname>porcolum</argname>. Si el argumento <argname>porcolum</argname>
	  no es nulo, la matriz se va a separar por columnas; en caso contrario
	  y como predeterminado, se hará por filas.
	</para>
	<para>
	  El argumento <argname>v</argname> puede ser un vector o un escalar.
	  En el primer caso, el vector debe tener una longitud igual a la
	  dimensión relevante (de filas o de columnas) de la matriz
	  <argname>X</argname>; además debe contener números enteros con
	  un valor mínimo de 1, y un máximo igual al número de matrices que
	  tendrá el 'array' que se quiere. Cada elemento de <argname>v</argname>
	  representa el índice que tiene en el 'array', la matriz a la que deberá
	  asignarse la correspondiente fila de <argname>X</argname>. Si, en cambio,
	  <argname>v</argname> es un escalar, entonces se va a separar la matriz
	  <argname>X</argname> en trozos que tendrán <argname>v</argname>
	  filas/columnas cada uno (según lo exija el argumento
	  <argname>porcolum</argname>); y se mostrará un fallo si la
	  dimensión de la matriz relevante no es un múltiplo exacto de
	  <argname>v</argname>.
	</para>
	<para>
	  En el siguiente ejemplo se separan las filas de una matriz <by r="4" c="3"/>
	  en tres matrices: las dos primeras filas se asignan a la primera
	  matriz; la segunda matriz se deja vacía; la tercera y cuarta
	  matrices incluye la tercera y cuarta filas de <argname>X</argname>,
	  respectivamente.
	</para>
	<code>
	  matrix X = {1,2,3; 4,5,6; 7,8,9; 10,11,12}
	  matrices M = msplitby(X, {1,1,3,4})
	  print M
	</code>
	<para>
	  La orden de impresión depara
	</para>
	<code>
	  Array de matrices, longitud 4
	  [1] 2 x 3
	  [2] null
	  [3] 1 x 3
	  [4] 1 x 3
	</code>
	<para>
	  El siguiente ejemplo separa <argname>X</argname> equitativamente:
	</para>
	<code>
	  matrix X = {1,2,3; 4,5,6; 7,8,9; 10,11,12}
	  matrices MM = msplitby(X, 2)
	  print MM[1]
	  print MM[2]
	</code>
	<para>
	  que depara
	</para>
	<code>
	  ? print MM[1]
	  1   2   3 
	  4   5   6 

	  ? print MM[2]
	  7    8    9 
	  10   11   12 
	</code>
	<para>
	  Consulta la función <fncref targ="flatten"/> para la operación inversa.
	</para>
      </description>
    </function>

    <function name="muniform" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz formada con números generados de forma pseudoaleatoria
	  mediante variables con distribución Uniforme (0,1), y que va a tener
	  <argname>r</argname> filas y <argname>c</argname> columnas. Si lo omites,
	  el número de columnas se establece en 1 (vector columna), por defecto.
	  Aviso: El método predilecto para generar números pseudoaleatorios con
	  distribución Uniforme es el que usa la función <fncref targ="randgen1"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mweights" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector de orden <math>p</math> con las ponderaciones MIDAS
	  que se aplican a los <math>p</math> retardos de una serie de alta
	  frecuencia, basado en el vector <repl>theta</repl> de hiperparámetros.
	</para>
	<para>
	  El argumento <repl>tipo</repl> identifica el tipo de disposición de
	  parámetros que va a regular el número <math>k</math> de elementos
	  que se solicitan para <repl>theta</repl>: 1 = para Almon exponencial
	  normalizada (<math>k</math> debe ser cuando menos igual a1,
	  habitualmente 2); 2 = para Beta normalizada con el retardo final nulo
	  (<math>k</math> = 2); 3 = para Beta normalizada con el retardo final
	  no nulo (<math>k</math> = 3); y 4 = para Almon polinómico
	  (<math>k</math> debe ser cuando menos igual a 1). Ten en cuenta
	  que, en el caso de Beta normalizada, los dos primeros elementos de
	  <repl>theta</repl> deben ser positivos.
	</para>
	<para>
	  Puedes indicar el <repl>tipo</repl> como un código entero, tal y
	  como se muestra más abajo, o mediante una de las siguientes cadenas
	  de texto (respectivamente): <lit>nealmon</lit>, <lit>beta0</lit>,
	  <lit>betan</lit> o <lit>almonp</lit>. Si utilizas una cadena de
	  texto, esta deberá estar situada entre comillas. Por ejemplo,
	  las dos siguientes expresiones son equivalentes:
	</para>
	<code>
	  W = mweights(8, theta, 2)
	  W = mweights(8, theta, "beta0")
	</code>
	<para>
	  <seelist>
	    <fncref targ="mgradient"/>
	    <fncref targ="midasmult"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">nombrearchivo</fnarg>
	<fnarg optional="true" type="bool">exportar</fnarg>
      </fnargs>
      <description>
	<para>
	  Escribe la matriz del argumento <argname>X</argname> en un archivo
	  con el nombre <argname>nombrearchivo</argname>. Por defecto, este
	  archivo va a ser de texto plano y, en la primera línea, va a contener
	  dos números enteros que representan el número de filas y de columnas
	  separados (respectivamente) por un carácter de tabulación. En las
	  siguientes filas, los elementos de la matriz se muestran con notación
	  científica, separados por tabulaciones (una línea por fila). Para evitar
	  confusiones al leerlos, los archivos que se escriban en este formato
	  deben ser denominados con el sufijo <quote><lit>.mat</lit></quote>.
	  Para formatos alternativos, mira más abajo.
	</para>
	<para>
	  Cuando ya existe un archivo llamado <argname>nombrearchivo</argname>,
	  se va a sobrescribir. La ejecución de la función devuelve un valor nominal
	  de 0 si se completa con éxito; si fracasa la escritura, se muestra un fallo.
	</para>
	<para>
	  El archivo con los resultados va a escribirse en el directorio establecido
	  como vigente, <cmdref targ="workdir"/>, excepto que la cadena de texto
	  del argumento <repl>nombrearchivo</repl> especifique el directorio con la
	  ruta completa. No obstante, si indicas un valor no nulo para el
	  argumento <argname>exportar</argname>, el archivo con los resultados va a
	  escribirse en el directorio <quote>punto</quote> del usuario, donde estará
	  accesible por defecto mediante las funciones para cargar matrices
	  que se ofrecen en el contexto de la instrucción <cmdref targ="foreign"/>.
	  En este caso, debes indicar un simple nombre de archivo para el
	  segundo argumento, sin la parte que expresa la ruta al directorio.
	</para>
	<para>
	  Las matrices guardadas mediante la forma que tiene por defecto la función
	  <lit>mwrite</lit>, pueden leerse fácilmente con otros programas.
	  Consulta <guideref targ="chap:matrices"/> para obtener más detalles.
	</para>
	<para>
	  Tres matizaciones, que se excluyen mutuamente, de esta función están
	  disponibles como se indica a continuación:
	</para>
	<ilist>
	  <li>
	    <para>
	      Si el argumento <argname>nombrearchivo</argname> tiene la extensión
	      <quote><lit>.gz</lit></quote>, entonces el archivo se guarda con
	      el formato descrito más arriba, pero usando la compresión gzip.
	    </para>
	  </li>
	  <li>
	    <para>
	      Si el argumento <argname>nombrearchivo</argname> tiene la extensión
	      <quote><lit>.bin</lit></quote>, entonces la matriz se guarda con
	      formato binario. En este caso, los primeros 19 bytes contienen
	      los caracteres <lit>gretl_binary_matrix</lit>; los siguientes
	      8 bytes contienen dos enteros de 32 bits que proporcionan
	      el número de filas y de columnas; y lo que resta del archivo contiene
	      los elementos de la matriz ordenados por orden de mayor columna,
	      con formato <quote>dobles</quote> en extremo menor (little-endian).
	      Si ejecutas GRETL en un sistema de extremo mayor (big-endian), los
	      valores binarios se convierten a extremo menor cuando se escriben,
	      y se convierten a extremo mayor cuando se leen.
	    </para>
	  </li>
	  <li>
	    <para>
	      Si el argumento <argname>nombrearchivo</argname> tiene la extensión
	      <quote><lit>.csv</lit></quote>, entonces la matriz se guarda con
	      formato de separación con comas, sin la línea de encabezamiento
	      que indique el número de filas y de columnas que la siguen.
	      Esto podría hacer más sencillo el tratamiento con programas
	      de terceros, pero no es recomendable cuando se pretende leer
	      el archivo con los elementos de la matriz mediante GRETL.
	    </para>
	  </li>
	</ilist>
	<para>
	  Ten en cuenta que, si vas a leer el archivo con la matriz utilizando
	  otro software ajeno, no resulta aconsejable que utilices las
	  opciones gzip ni binario. Pero si lo quieres para que lo lea GRETL,
	  estos dos formatos alternativos permiten ahorrar espacio; y con el
	  formato binario logras una lectura más rápida de matrices
	  grandes. El formato gzip no es recomendable para matrices muy
	  grandes porque la descompresión puede ser bastante lenta.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
	  </seelist>
	  Para escribir una matriz en un archivo, como conjunto de datos,
	  consulta <cmdref targ="store"/>.
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz que incluye la tabulación cruzada de los valores
	  contenidos en <argname>x</argname> (por filas) e <argname>y</argname>
	  (por columnas). Los dos argumentos de esta función deben ser
	  del mismo tipo (ser series ambas o vectores columna ambos). Generalmente
	  se espera (aunque no es imprescindible) que los argumentos tengan
	  valores discretos, con menos valores diferentes que observaciones.
	  De otro modo, la tabulación cruzada puede resultar muy grande y
	  no muy informativa.
	</para>
	<para>
	  <seelist>
            <fncref targ="values"/>
            <fncref targ="corresp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="naalen" section="nonparam" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el cálculo del estimador no paramétrico de Nelson&ndash;Aalen
	  de la función de riesgo (<cite key="nelson72">Nelson, 1972</cite>;
	  <cite key="aalen78">Aalen, 1978</cite>), dada una muestra
	  <argname>d</argname> de datos de duración, que posiblemente esté
	  acompañada de un registro de estado de censura, <argname>cens</argname>.
	  La matriz que devuelve la función tiene tres columnas que contienen,
	  respectivamente: los valores únicos ordenados en
	  <argname>d</argname>, la estimación de la función de riesgo acumulado
	  que se corresponde con los valores de duración de la columna 1, y la desviación
	  típica del estimador.
	</para>
	<para>
	  Cuando indicas la serie <argname>cens</argname>, se utiliza el valor 0
	  para señalar que una observación no está censurada, mientras
	  que el valor 1 indica que una observación está censurada del lado
	  derecho (es decir, el período de observación del individuo en cuestión
	  concluyó antes de la duración o el período se registró como finalizado).
	  Cuando no indicas <argname>cens</argname>, se asume que todas las
	  observaciones son no censuradas. (Aviso: la semántica de
	  <argname>cens</argname> puede extenderse en algún punto para cubrir
	  otros tipos de censura.)
	</para>
	<para>
	  <seelist>
            <fncref targ="kmeier"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="nonparam" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar" optional="true">h</fnarg>
	<fnarg type="bool" optional="true">LOO</fnarg>
	<fnarg type="scalar" optional="true">recorte</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula una serie con la estimación no paramétrica de la media
	  condicional de <argname>y</argname> dado <argname>x</argname>,
	  de Nadaraya-Watson. La serie que devuelve la función, contiene
	  <math>m(x</math><sub>i</sub><math>)</math>, los valores de las estimaciones
	  de <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  para cada uno de los elementos no ausentes de la serie
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i - x_j)}
	  {\sum_{j=1}^{n} K_h(x_i - x_j)} \]
	  donde la función kernel <math>K_h(\cdot)</math> viene dada por
	  \[ K_h(x) = \exp\left(-\frac{x^2}{2h}\right) \]
	  para $|x| &lt; \tau$, y cero en otro caso.
	  ($\tau$ = Parámetro de recorte.)
	</para>
	<para context="notex">
	  La función núcleo (kernel) empleada por este estimador viene dada por
	  <math>K = exp(-x</math><sup>2</sup><math>/2h)</math> cuando
	  <math>|x|&lt;T</math>, y es igual a cero en otro caso.
	  (<math>T</math> = Parámetro de recorte.)
	</para>
	<para>
	  Los tres argumentos opcionales modulan el comportamiento del
	  estimador tal como se describe más abajo.
	</para>
	<subhead>Ancho de banda</subhead>
	<para>
	  Puedes usar el argumento <argname>h</argname> para controlar el ancho
	  de banda (<quote>bandwidth</quote>), mediante un número real positivo.
	  Habitualmente este es un número pequeño, pues valores más grandes de
	  <argname>h</argname> hacen que <math>m(x)</math> sea más suave. Una
	  elección popular es hacer que <argname>h</argname> sea proporcional a
	  <math>n</math><sup>-0.2</sup>. Si omites <argname>h</argname> o lo
	  igualas a cero, el ancho de banda se establece por defecto con un valor
	  determinado por los datos, utilizando la proporcionalidad que se acaba de
	  mencionar, pero introduciendo la dispersión de los datos de <argname>x</argname>
	  tal como la mide el rango inter-cuartil o la desviación estándar; consulta
	  <guideref targ="chap:nonparam"/> para obtener más detalles.
	</para>
	<subhead>Dejar-una-fuera</subhead>
	<para>
	  <quote>Dejar-una-fuera</quote> es una variante del algoritmo,
	  que omite la observación <math>i</math>-ésima cando se evalúa
	  <math>m(x</math><sub>i</sub><math>)</math>. Esto hace que el
	  estimador de Nadaraya&ndash;Watson sea numéricamente más
	  robusto, y por eso se recomienda habitualmente utilizarlo cuando el
	  estimador se calcula con intención de hacer inferencias. Esta
	  variante no está permitida por defecto, pero se activa cuando se
	  indica un valor no nulo para el argumento <argname>LOO</argname>.
	</para>
	<para context="tex">
          En las fórmulas, este estimador es
          \[
          m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i - x_j)}
          {\sum_{j \ne i} K_h(x_i - x_j)}
          \]
	</para>
	<subhead>Recorte</subhead>
	<para>
	  Puedes usar el argumento <argname>recorte</argname> para controlar
	  el grao de <quote>recorte</quote> que se impone para prevenir
	  problemas numéricos, cuando la función 'kernel' se está evaluando
	  demasiado lejos de cero. Este parámetro se expresa como un
	  múltiplo de <argname>h</argname>, siendo 4 el valor por defecto.
	  En algunos casos, puede ser preferible utilizar un valor mayor que 4.
	  De nuevo, consulta <guideref targ="chap:nonparam"/> para
	  obtener más detalles.
	</para>
	<para>
	  Consulta también <fncref targ="loess"/>.
	</para>
      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="listetc">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un entero con el número de elementos que hay en el argumento;
	  este puede ser una lista, una matriz, un 'bundle' o un 'array'
	  (pero no una serie).
	</para>
      </description>
    </function>

    <function name="ngetenv" section="programming" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el valor numérico de una variable de contexto que
	  tiene el nombre del argumento <argname>s</argname>, se esa variable está
	  definida y se tiene un valor numérico; en otro caso devuelve NA.
	  Consulta también <fncref targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con la cantidad de filas completas (es decir, filas
	  que rematan con el carácter de nueva línea) en <argname>buf</argname>.
	</para>
    <para>
        Ejemplo:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        scalar number = nlines(web_page)
        print number
    </code>
      </description>
    </function>

    <function name="NMmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="int">maxevalfunc</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el resultado de una maximización numérica hecha con el
	  método del simplex sin derivadas de Nelder&ndash;Mead. El argumento
	  <argname>b</argname> debe contener los valores iniciales de un conjunto
	  de parámetros, y el argumento <argname>f</argname> debe especificar
	  una llamada a la función que va a calcular el criterio objetivo (escalar)
	  que se quiere maximizar, dados los valores vigentes de los parámetros, así
	  como cualesquiera otros datos que sean relevantes. Cuando se completa
	  con éxito su ejecución, <lit>NMmax</lit> devuelve el valor maximizado
	  del criterio objetivo, y <argname>b</argname> contiene finalmente los
	  valores de los parámetros que producen el máximo.
	</para>
	<para>
	  Puedes utilizar el tercer argumento (opcional) para indicar el número
	  máximo de evaluaciones de la función; si lo omites o lo estableces igual
	  a cero, el máximo se toma por defecto igual a 2000. Como indicación
	  especial para esta función, puedes poner un valor negativo para o
	  argumento <argname>maxevalfunc</argname>. En ese caso, se toma su
	  valor absoluto y <lit>NMmax</lit> muestra un fallo si el mejor valor
	  encontrado para la función objetivo después de realizar el máximo número
	  de evaluaciones de la función, no es un óptimo local. Por otra parte,
	  en este sentido la no convergencia no se trata como un fallo.
	</para>
	<para>
	  Si tu objetivo realmente es alcanzar un mínimo, puedes
	  bien cambiar la función considerando el negativo del criterio,
	  o bien, alternativamente, puedes invocar la función
	  <lit>NMmax</lit>bajo el alias <lit>NMmin</lit>..
	</para>
	<para>
	  Para más detalles y ejemplos, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NMmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alias de <fncref targ="NMmax"/>. Si invocas la función bajo
	  este nombre, se ejecuta haciendo una minimización.
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>x</argname> es una serie, devuelve el número de
	  observaciones no ausentes de esa serie, en la muestra vigente
	  seleccionada.
	</para>
	<para>
	  Si <argname>x</argname> es una lista, devuelve una serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> representa
	  el recuento de las series de la lista que no tienen un valor ausente
	  en la observación <math>t</math>.
	</para>
	<para>
	  <seelist>
            <fncref targ="pnobs"/>
            <fncref targ="pxnobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie generada con una variable pseudoaleatoria gaussiana
	  de media &mu; y desviación típica &sigma;. Si no indicas ningún
	  argumento, los valores que se devuelven son los de una variable con
	  distribución de probabilidad Normal estándar, <math>N</math>(0,1).
	  Los valores se producen utilizando el método Ziggurat
	  (<cite key="marsaglia00" p="true">Marsaglia y Tsang, 2000</cite>).
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normtest" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">método</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con los resultados de realizar un(os) contraste(s) de
	  Normalidad sobre <argname>y</argname>. La función realiza por defecto
	  el contraste de Doornik&ndash;Hansen, pero puedes utilizar el argumento
	  <argname>método</argname> (opcional) para escoger una alternativa.
	  Indica: <lit>swilk</lit> para ejecutar el contraste de Shapiro&ndash;Wilk,
	  <lit>jbera</lit> para realizar el contraste de Jarque&ndash;Bera, o
	  <lit>lillie</lit> para efectuar el contraste de KS-Lilliefors. O indica
	  <lit>all</lit> en el argumento del <argname>método</argname> para
	  realizar los cuatro contrastes.
	</para>
	<para>
	  Puedes indicar el segundo argumento con formato entre comillas o sin
	  ellas. En este último caso, también puedes indicar una cadena de texto cuyo
	  valor sea el nombre de uno de los métodos, por el que se va a substituir cuando se
	  ejecuta.
	</para>
	<para>
	  La matriz que se devuelve es de orden <by r="1" c="2"/> para un único
	  contraste, o <by r="4" c="2"/> cuando se hacen todos los contrastes.
	  Los estadísticos de prueba se encuentran en la primera columna, y las
	  probabilidades asociadas en la segunda. El estadístico de prueba no
	  sigue la misma distribución de probabilidad en todos los casos. Para
	  Doornik&ndash;Hansen y Jarque&ndash;Bera es una Chi-cuadrado(2); en
	  los otros métodos se trata de un estadístico peculiar para cuyas
	  probabilidades asociadas se requiere un cálculo especial.
	</para>
	<para>
	  Consulta también la instrucción <cmdref targ="normtest"/>.
	</para>
      </description>
    </function>

    <function name="npcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">método</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila con los cálculos de una medida de correlación entre
	  <argname>x</argname> e <argname>y</argname>, utilizando un método
	  no paramétrico. Si indicas el tercer argumento, este debe ser
	  <lit>kendall</lit> (para el método por defecto, el tau de Kendall,
	  versión b) o bien <lit>spearman</lit> (para el rho de Spearman).
	</para>
	<para>
	  El resultado que se devuelve es un vector fila con 3 valores que indican:
	  la medición de la correlación, el valor del estadístico de contraste de la hipótesis
	  nula de incorrelación, y la probabilidad asociada a ese valor. Observa
	  que, si el tamaño de la muestra es muy pequeño, el estadístico de contraste y/o
	  la probabilidad puede ser <lit>NaN</lit> (no es número, o ausente).
	</para>
	<para>
	  Consulta también <fncref targ="corr"/> para la correlación de Pearson.
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el Valor Actual Neto de <argname>x</argname>,
	  considerado este como una secuencia de pagos (negativos) e ingresos
	  (positivos), evaluados a una tasa de descuento anual que debes
	  indicar en el argumento <argname>r</argname> como fracción decimal entre
	  0 y 1, no como porcentaje (por ejemplo 0.05, y no 5<lit>%</lit>).
	  El primer valor de la serie/vector del primer argumento se considera
	  que está fechado <quote>ahora</quote>, y no se descuenta. Para imitar
	  una función VAN en la que se descuente el primer valor, añade un cero
	  al principio de la serie/vector del primer argumento.
	</para>
	<para>
	  El tipo de frecuencia de los datos que admite esta función puede ser anual,
	  trimestral, mensual y sin fecha (este tipo se trata como si fuera anual).
	</para>
	<para>
	  <seelist>
            <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el resultado de una maximización numérica hecha con el
	  método de Newton&ndash;Raphson. El argumento <argname>b</argname>
	  debe contener los valores iniciales del conjunto de parámetros, y el
	  argumento <argname>f</argname> debe indicar una llamada a la función
	  que va a calcular el criterio objetivo (escalar) que quieres maximizar,
	  dados los valores vigentes de los parámetros, así como cualquier otro dato
	  relevante. Si lo que quieres realmente es minimizar el criterio objetivo,
	  esta función debería devolver el valor negativo del mismo. Cuando se
	  completa con éxito su ejecución, <lit>NRmax</lit> devuelve el valor
	  maximizado del criterio objetivo, y <argname>b</argname> va a contener
	  los valores de los parámetros que proporcionan el máximo de ese criterio.
	</para>
	<para>
	  El tercer y cuarto argumentos (opcionales) proporcionan modos de
	  indicar, respectivamente, las derivadas analíticas y una matriz
	  hessiana analítica (negativa). Las funciones a las que se refieren estos
	  argumentos <argname>g</argname> y <argname>h</argname>
	  deben tener, como primer elemento, una matriz definida con
	  anterioridad que sea del rango correcto para poder contener el vector
	  gradiente o la matriz hessiana, indicados en forma de puntero.
	  Además, otro de sus elementos, debe ser el vector de parámetros
	  (en forma de puntero o no). Otro tipo de elementos son opcionales.
	  Si omites cualquiera de los argumentos opcionales (o los dos), se utiliza
	  una aproximación numérica.
	</para>
	<para>
	  Para más detalles y ejemplos, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alias de <fncref targ="NRmax"/>. Si invocas la función bajo
	  este nombre, se ejecuta haciendo una minimización.
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve una matriz con el cálculo del espacio nulo a la derecha correspondiente
	  a la matriz <argname>A</argname>, hecho mediante la descomposición en
	  valores singulares: el resultado es una matriz <math>B</math> que hace
	  que el producto <math>AB</math> sea una matriz nula. Como excepción,
	  si la matriz <argname>A</argname> tiene rango completo por columnas, el
	  resultado que se devuelve es una matriz vacía. Por otro lado, si
	  <argname>A</argname> es de orden <by r="m" c="n"/>, entonces <math>B</math>
	  va a ser <math>n</math> por (<math>n</math> &minus; <math>r</math>),
	  donde <math>r</math> es el rango de <argname>A</argname>.
	</para>
	<para context="notex">
	  Si <argname>A</argname> no tiene rango completo por columnas,
	  entonces al concatenar verticalmente la matriz <argname>A</argname> y
	  la matriz traspuesta de <argname>B</argname>, se genera una matriz con
	  rango completo.
	</para>
	<para context="tex">
	  Devuelve una matriz con el cálculo del espacio nulo a la derecha correspondiente
	  a la matriz <argname>A</argname>, hecho mediante la descomposición en
	  valores singulares: el resultado es una matriz $B$ que hace que
	  \begin{itemize}
	  \item $AB = [0]$. Como excepción, si la matriz $A$ tiene rango completo
	  por columnas, el resultado que se devuelve es una matriz vacía. Por
	  otro lado, si $A$ es de orden $m \times n$, entonces $B$ va a ser una
	  matriz de orden $n \times (n-r)$, donde $r$ es el rango $A$.
	  \item Si $A$ no tiene rango completo por columnas, entonces al concatenar
	  verticalmente $A$ y $B'$, se genera una matriz con rango completo.
	  \end{itemize}
	</para>
    <para>
        Ejemplo:
    </para>
    <code>
      A = mshape(seq(1,6),2,3)
      B = nullspace(A)
      C = A | B'

      print A B C

      eval A*B
      eval rank(C)
    </code>
    <para>
        produce...
    </para>
    <code>
      ? print A B C
      A (2 x 3)

      1   3   5
      2   4   6

      B (3 x 1)

      -0,5
         1
      -0,5

      C (3 x 3)

         1      3      5
         2      4      6
      -0,5      1   -0,5

      ? eval A*B
      -4,4409e-16
      -4,4409e-16

      ? eval rank(C)
      3
    </code>
    <para>
      <seelist>
        <fncref targ="rank"/>
        <fncref targ="svd"/>
      </seelist>
	</para>
      </description>
    </function>

    <function name="numhess" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula una aproximación numérica a la matriz hessiana asociada
	  al vector <math>n</math>-dimensional <argname>b</argname>,
	  y a la función objetivo que se especifique mediante el argumento
	  <argname>fcall</argname>. La llamada a la función debe tener
	  <argname>b</argname> como primer argumento (bien directamente
	  o bien en forma de puntero), seguido de cualquier argumento
	  adicional que pueda ser necesario, y debe devolver como
	  resultado un escalar. Al completarse con éxito <lit>numhess</lit>
	  devuelve una matriz <by r="n" c="n"/> que contiene la hessiana,
	  y que es exactamente simétrica por construcción.
	</para>
	<para>
	  El método utiliza la extrapolación de Richardson, con cuatro pasos.
	  Puedes usar el tercer argumento (opcional) para establecer la
	  fracción <math>d</math> del valor del parámetro que se utiliza
	  para determinar el tamaño del paso inicial. Cuando omites este
	  argumento, por defecto va a ser <math>d</math> = 0.01.
	</para>
	<para>
	  Aquí tienes un ejemplo de su uso:
	</para>
	<code>
	  matrix H = numhess(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	          <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Devuelve una serie de números enteros consecutivos, correspondiendo el
	  1 con el inicio del conjunto de datos. Ten en cuenta que el resultado no va a
	  depender de que tengas escogida una submuestra. Esta función es útil
	  especialmente con conjuntos de datos de series temporales. Advertencia:
	  Puedes escribir <lit>t</lit> en lugar de <lit>obs</lit>, con el mismo efecto.
	</para>
	<para>
	  <seelist>
            <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string-or-strings">
      <fnargs>
	<fnarg type="scalar-or-vec">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>t</argname> es un escalar, devuelve una única cadena de
	  texto que representa el marcador de etiquetado de la observación
	  <argname>t</argname>. Puedes realizar la operación inversa mediante
	  la función <fncref targ="obsnum"/>.
	</para>
	<para>
	  Si <argname>t</argname> es un vector, devuelve un 'array' de cadenas de
	  texto que representan los marcadores de etiquetado de las observaciones
	  indicadas por los elementos de <argname>t</argname>.
	</para>
	<para>
	  En cualquier caso, los valores <argname>t</argname> deben ser enteros
	  que puedan resultar válidos como índices enteros de las observaciones en
	  el conjunto de datos vigente; en otro caso, se muestra un aviso de fallo.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el número entero que indica la observación que se corresponde
	  con la cadena del argumento <math>s</math>. Ten en cuenta que el resultado
	  no va a depender de que tengas escogida una submuestra. Esta función es útil
	  con conjuntos de datos de series temporales. Por ejemplo, el siguiente código ...
	</para>
	<code>
	  open denmark
	  k = obsnum(1980:1)
	</code>
	<para>
	  ... genera <lit>k = 25</lit>, indicando que el primer trimestre de 1980
	  es la vigésimo quinta observación de la base de datos <lit>denmark</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="obs"/>
            <fncref targ="obslabel"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando el argumento <argname>x</argname> es un escalar, esta función
	  devuelve 1 se <argname>x</argname> no es <lit>NA</lit>, y 0 en otro
	  caso. Cuando <argname>x</argname> es una serie, devuelve otra serie que
	  toma el valor 1 en las observaciones en las que el argumento no tiene valores
	  ausentes, y toma el valor cero en los demás. Si <argname>x</argname> es
	  una lista, el resultado es una serie con 0 en las observaciones en las que
	  al menos una serie de la lista tiene un valor ausente, y 1 en otro caso.
	</para>
	<para>
	  Cuando el argumento <argname>x</argname> es una matriz,
	  la función devuelve otra matriz de la misma dimensión que
	  <argname>x</argname>, con el valor 1 en las posiciones que se corresponden
	  con elementos finitos de <argname>x</argname>, y con el valor 0 en las
	  posiciones en las que los elementos no son finitos (o bien infinitos, o bien
	  <quote>no números</quote>, para el estándar IEEE 754).
	</para>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	  Pero ten en cuenta que estas funciones no son aplicables a matrices.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve un escalar con la norma 1 de la matriz <argname>X</argname>,
	  es decir, el máximo de los resultados de sumar los valores absolutos de los
	  elementos de <argname>X</argname> por columnas.
	</para>
	<para context="tex">
	  Devuelve un escalar con la norma 1 de la matriz
	  <argname>X</argname> de orden $r \times c$:
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
            <fncref targ="infnorm"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con <math>r</math> filas y <math>c</math>
	  columnas, cubierta con valores iguales a 1. Si lo omites, el número
	  de columnas se establece en 1 (vector columna), por defecto.
	</para>
	<para>
	  <seelist>
            <fncref targ="seq"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura
	  de panel, y devuelve una serie con el cálculo de las desviaciones ortogonales
	  adelantadas para la variable <argname>y</argname>.
	</para>
	<para context="tex">
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura
	  de panel, y devuelve una serie con el cálculo de las desviaciones ortogonales
	  adelantadas para la variable <argname>y</argname>, es decir
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t}{T_i - t + 1}} \left( y_{i,t} -
	  \frac{1}{T_i - t} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  Algunas veces se utiliza esta transformación en lugar de la
	  diferenciación para eliminar los efectos individuales de los datos de
	  panel. Por compatibilidad con las primeras diferencias, las desviaciones
	  se guardan adelantadas un paso de su localización temporal verdadera
	  (es decir, el valor en la observación <math>t</math> es la desviación que,
	  expresándolo de manera estricta, pertenece a <math>t</math> &minus; 1).
	  De este modo, se pierde la primera observación en cada serie temporal,
	  no la última.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, forma, escala, y)</example>
      </examples>
      <description>
	<para>
	  Calcula el valor de la función de densidad de probabilidad, y devuelve
	  un resultado (del mismo tipo que el argumento) con la densidad en
	  <argname>x</argname> de la distribución identificada por el código
	  <argname>d</argname>. Consulta <fncref targ="cdf"/> para obtener más
	  detalles acerca de los argumentos (escalares) exigidos. Esta función
	  <lit>pdf</lit> acepta las distribuciones: Normal, <math>t</math> de
	  Student, Chi-cuadrado, <math>F</math>, Gamma, Beta, Exponencial, Weibull,
	  Laplace, Error Generalizado, Binomial y Poisson. Ten en cuenta que
	  para la Binomial y la Poisson, lo que se calcula de hecho es la masa de
	  probabilidad en el punto especificado. Para <math>t</math> de Student,
	  Chi-cuadrado y <math>F</math> también están disponibles sus
	  variantes no centrales.
	</para>
	<para>
	  Para la distribución Normal, consulta también <fncref targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">anchobanda</fnarg>
      </fnargs>
      <description>
	<para>
	  Si solo indicas la serie o vector del primer argumento, se calcula su
	  periodograma en la muestra. Si indicas el escalar del segundo argumento,
	  calcula la estimación del espectro de <argname>x</argname> con una ventana
	  de retardos de Bartlett con un ancho de banda igual a ese escalar, hasta un
	  máximo igual a la mitad del número de observaciones (<math>T</math>/2).
	</para>
	<para>
	  Devuelve una matriz con <math>T</math>/2 filas y dos columnas: la
	  primera de estas contiene la frecuencia (&omega;) desde 2&pi;/<math>T</math>
	  hasta &pi;, y la segunda de las columnas contiene la densidad espectral
	  correspondiente.
	</para>
      </description>
    </function>

    <function name="pexpand" section="panel" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
	<fnarg type="bool" optional="true">por_elemento</fnarg>
      </fnargs>
      <description>
	<para>
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura
	  de panel, y por defecto realiza la operación inversa a la que hace
	  <fncref targ="pshrink"/>. Es decir, dado un vector que tiene una
	  longitud igual al número de elementos de la muestra (de panel) vigente
	  seleccionada, esta función devuelve una serie en la cual cada valor
	  del argumento se repite <math>T</math> veces, donde <math>T</math>
	  expresa la longitud temporal del panel. De este modo, la serie
	  resultante es invariante con respecto al tiempo.
	</para>
	<para>
    Si indicas un valor para <argname>por_elemento</argname> que no
    sea cero, la longitud de <argname>v</argname> deberá ser igual a
    <math>T</math>, y la repetición se realiza a través de los elementos
    del panel.
	</para>
      </description>
    </function>

    <function name="pmax" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie que contiene cada uno de los valores máximos
	  de la variable <argname>y</argname> en cada unidad de corte transversal
	  (repitiéndolo en los períodos temporales de cada una de estas).
	</para>
	<para>
	  Cuando indicas el segundo argumento (opcional), se van a ignorar aquellas
	  observaciones en las que el valor de <argname>máscara</argname> sea igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie que contiene cada una de las medias temporales
	  de la variable <argname>y</argname> en cada unidad de corte transversal
	  (repitiendo cada valor en los períodos temporales de cada una de estas).
	  Las observaciones ausentes se ignoran al calcular las medias.
	</para>
	<para context="tex">
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie que contiene cada una de las medias temporales
	  de la variable <argname>y</argname> en cada unidad de corte transversal,
	  es decir, \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\]
	  donde $T_i$ representa el número de observaciones válidas de la unidad
	  $i$.
	</para>
	<para>
	  Cuando indicas el segundo argumento (opcional), se van a ignorar aquellas
	  observaciones en las que el valor de <argname>máscara</argname> sea igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie que contiene cada uno de los valores mínimos
	  de la variable <argname>y</argname> en cada unidad de corte transversal
	  (repitiendo cada valor en los períodos temporales de cada una de estas).
	</para>
	<para>
	  Cuando indicas el segundo argumento (opcional), se van a ignorar aquellas
	  observaciones en las que el valor de <argname>máscara</argname> sea igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie que contiene el número de observaciones
	  válidas de la variable <argname>y</argname> en cada unidad de corte
	  transversal (repitiéndolo en los períodos temporales de cada una de estas).
	</para>
	<para>
	  Cuando indicas el segundo argumento (opcional), se van a ignorar aquellas
	  observaciones en las que el valor de <argname>máscara</argname> sea igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="math" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve las raíces de un polinomio. Si el polinomio es de grado
	  <math>p</math>, el vector <argname>a</argname> debe contener
	  <math>p</math> + 1 coeficientes en orden ascendente; es decir,
	  comenzando con la constante y finalizando con el coeficiente de
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  El valor que se devuelve es un vector columna complejo con
	  longitud igual a <math>p</math>.
	</para>
      </description>
    </function>

    <function name="polyfit" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie, ajustando una tendencia polinómica de orden
	  <argname>q</argname> a la serie del argumento <argname>y</argname>,
	  utilizando el método de polinomios ortogonales. La serie que se genera
	  contiene los valores ajustados.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">matrizcov</fnarg>
      </fnargs>
      <description>
	<para>
	  Sea <argname>X</argname> una matriz de orden <by r="T" c="k"/>,
	  que contiene <math>T</math> observaciones sobre <math>k</math>
	  variables. El argumento <argname>p</argname> debe ser un número
	  entero positivo menor que o igual a <math>k</math>. Esta función
	  devuelve una matriz <math>P</math>, de orden <by r="T" c="p"/>,
	  que contiene las <math>p</math> primeras componentes principales de
	  <argname>X</argname>.
	</para>
	<para>
	  El tercer argumento (opcional) opera como un conmutador booleano:
	  si no es cero, las componentes principales se calculan en base a la matriz
	  de varianzas-covarianzas de las columnas de <argname>X</argname>
	  (por defecto se utiliza la matriz de correlaciones).
	</para>
	<para context="notex">
	  Los elementos de la matriz <math>P</math> que se devuelve, se calculan
	  como la suma desde <math>i</math> hasta <math>k</math> de
	  <math>Z</math><sub>ti</sub> veces <math>v</math><sub>ji</sub>,
	  donde <math>Z</math><sub>ti</sub> representa el valor
	  estandarizado (o simplemente el valor centrado, si utilizas la matriz
	  de covarianzas) de la variable <math>i</math> en la observación
	  <math>t</math>, y <math>v</math><sub>ji</sub> representa el
	  <math>j</math>-ésimo autovector de la matriz de correlaciones (o la
	  matriz de covarianzas) entre las <math>X</math><sub>i</sub>s, con los
	  autovectores ordenados de acuerdo con los valores decrecientes de los
	  autovalores correspondientes.
	</para>
	<para context="tex">
	  Los elementos de la matriz $P$ que se devuelve, se calculan como
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \]
	  donde $Z_{ti}$ representa el valor estandarizado (o simplemente
	  el valor centrado, si utilizas la matriz de covarianzas) de la variable $i$
	  en la observación $t$, $Z_{ti} = (X_{ti} - \bar{X}_i) / \hat{\sigma}_i$,
	  y $v^{(j)_i}$ representa el $j$-ésimo autovector de la matriz de
	  correlaciones (o de covarianzas) de los $X_i$s, con los autovectores
	  ordenados de acuerdo con los valores decrecientes de los autovalores
	  correspondientes.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila con los productos de los elementos de cada
	  columna de la matriz <argname>X</argname>. Si indicas un valor no nulo
	  para el segundo argumento (opcional), se ignoran los valores ausentes;
	  de otra forma, el resultado es <lit>NA</lit> para cada columna que
	  tenga valores ausentes. Observa que indicar <argname>obviar_na</argname>
	  es equivalente a tratar los valores como si fuesen 1s.
	</para>
	<para>
	  <seelist>
            <fncref targ="prodr"/>
            <fncref targ="meanc"/>
            <fncref targ="sdc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna con los productos de los elementos de cada
	  fila de la matriz <argname>X</argname>. Si indicas un valor no nulo
	  para el segundo argumento (opcional), se ignoran los valores ausentes;
	  de otra forma, el resultado es <lit>NA</lit> para cada fila que contenga
	  valores ausentes. Observa que indicar <argname>obviar_na</argname>
	  es equivalente a tratar los valores como si fuesen 1s.
	</para>
	<para>
	  <seelist>
            <fncref targ="prodc"/>
            <fncref targ="meanr"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie que contiene la desviación típica (muestral)
	  de la variable <math>y</math>, en cada unidad de corte transversal
	  (repitiendo cada valor en los períodos temporales de cada una de estas).
	  El denominador que se utiliza es el tamaño de la muestra en cada unidad
	  menos 1, excepto que solo haya 1 única observación válida para una
	  unidad dada (pues en este caso se devuelve 0) o que no haya ninguna
	  (en este caso se devuelve <lit>NA</lit>).
	</para>
	<para context="tex">
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie que contiene la desviación típica (muestral)
	  de la variable <math>y</math> en cada unidad de corte transversal, es decir,
	  \[ \sigma_i = \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} -
	  \bar{y}_i)^2 } \]. Esta fórmula se aplica cuando $T_i \ge 2$, donde
	  $T_i$ representa el número de observaciones válidas para la unidad
	  $i$; si $T_i = 0$ se devuelve <lit>NA</lit>, y si $T_i = 1$
	  se devuelve 0.
	</para>
	<para>
	  Cuando indicas el segundo argumento (opcional), se van a ignorar aquellas
	  observaciones en las que el valor de <argname>máscara</argname> sea igual a
	  cero.
  </para>
	<para>
	  Nota: Esta función permite comprobar si una variable cualquiera
	  (por ejemplo, <lit>X</lit>) es invariante a lo largo del tiempo,
	  por medio de la condición <lit>max(psd(X)) == 0</lit>.
	</para>
	<para>
		<seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="bool" optional="true">probapsd</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve la matriz cuadrada que resulta de aplicarle a la matriz simétrica
	  <argname>A</argname> del argumento, una variante generalizada de la
	  descomposición de Cholesky. La matriz del argumento debe ser
	  semidefinida positiva (aunque puede ser singular) pero, si no es
	  cuadrada, se muestra un mensaje de fallo. La simetría se asume y no se
	  comprueba; solo se lee el triángulo inferior de <argname>A</argname>.
	  El resultado es una matriz triangular inferior, <math>L</math>, que
	  cumple <equation status="inline" ascii="A = LL'" tex="$A = LL'$"/>.
	  Los elementos indeterminados de la solución se establecen como iguales a cero.
	</para>
	<para>
	  Para forzar la comprobación de que <argname>A</argname> es semidefinida
	  positiva, indica un valor no nulo para el segundo argumento (opcional).
	  En ese caso, se muestra un fallo si el máximo valor absoluto de
	  <equation status="inline" ascii="A &minus; LL'" tex="$A - LL'$"/>
	  es mayor que 1.0e-8. Este tipo de comprobación también puedes hacerla
	  manualmente:
	</para>
	<code>
	  L = psdroot(A)
	  chk = maxc(maxr(abs(A - L*L')))
	</code>
	<para>
	  Para el caso en el que la matriz <argname>A</argname> es definida positiva,
	  consulta <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="panel" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve un vector que contiene cada una de las primeras
	  observaciones válidas de la serie <argname>y</argname> en cada unidad
	  de corte transversal del panel, a lo largo del rango de la muestra vigente.
	  Si la serie tiene alguna unidad sin observaciones válidas, esa
	  unidad se ignora.
	</para>
	<para>
	  Esta función te proporciona un modo de compactar las series que
	  te van a devolver algunas funciones tales como <fncref targ="pmax"/>
	  y <fncref targ="pmean"/>, en las que se repite un mismo valor en los
	  diferentes períodos de tiempo de una misma unidad de corte
	  transversal.
	</para>
	<para>
	  Consulta <fncref targ="pexpand"/> para la operación inversa.
	</para>
      </description>
    </function>

    <function name="psum" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie en la que cada valor es la suma de la variable
	  <argname>y</argname> en los distintos períodos temporales de cada unidad
	  de corte transversal. En cada una de estas, la suma así calculada se
	  repite para cada período temporal. Las observaciones ausentes se ignoran
	  en el cálculo de las sumas.
	</para>
	<para context="tex">
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie en la que cada valor es la suma de la variable
	  <argname>y</argname> en los distintos períodos temporales de cada unidad
	  de corte transversal, es decir, \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\]
	  donde $T_i$ indica el número de observaciones válidas de la unidad $i$.
	</para>
	<para>
	  Cuando indicas el segundo argumento (opcional), se van a ignorar aquellas
	  observaciones en las que el valor de <argname>máscara</argname> sea igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  Calcula valores <math>P</math> de probabilidad, y devuelve un
	  resultado (del mismo tipo que el argumento) con la probabilidad
	  <equation status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>, donde
	  la distribución de probabilidad de <math>X</math> se indica con la letra
	  <argname>c</argname>. Entre los argumentos <argname>d</argname> y
	  <argname>p</argname>, puedes necesitar algún argumento adicional
	  escalar para especificar los parámetros de la distribución de que se
	  trate. Para más detalles, consulta <fncref targ="cdf"/>. Las
	  distribuciones soportadas por la función <lit>pvalue</lit> son:
	  Normal estándar, <math>t</math>, Chi-cuadrado, <math>F</math>, Gamma,
	  Binomial, Poisson, Exponencial, Weibull, Laplace y Error Generalizado.
	</para>
	<para>
	  <seelist>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="urcpval"/>
            <fncref targ="imhof"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxnobs" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura de
	  panel, y devuelve una serie que contiene el número de observaciones
	  válidas de <argname>y</argname> en cada período de tiempo (el valor
	  calculado se repite en cada una de las unidades de corte transversal).
	</para>
	<para>
	  Cuando indicas el segundo argumento (opcional), se van a ignorar aquellas
	  observaciones en las que el valor de <argname>máscara</argname> sea igual a
	  cero.
	</para>
	<para>
	  Ten en cuenta que esta función opera en la otra dimensión del panel,
	  diferente a la de la función <fncref targ="pnobs"/>.
	</para>
      </description>
    </function>

    <function name="pxsum" section="panel" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Se aplica tan solo si el conjunto vigente de datos tiene estructura de panel,
	  y devuelve una serie en la que cada valor es la suma de <argname>y</argname>
	  en las distintas unidades de corte transversal de cada período temporal.
	  Las sumas así calculadas se repiten en cada unidad de corte transversal.
	</para>
	<para context="tex">
	  Se aplica tan solo si el conjunto vigente de datos tiene estructura de panel,
	  y devuelve una serie en la que cada valor es la suma de <argname>y</argname>
	  en las distintas unidades de corte transversal de cada período temporal,
	  es decir, \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] donde $N$ es el número
	  de unidades de corte transversal.
	</para>
	<para>
	  Cuando indicas el segundo argumento (opcional), se van a ignorar aquellas
	  observaciones en las que el valor de <argname>máscara</argname> sea igual a
	  cero.
	</para>
	<para>
	  Ten en cuenta que esta función opera en la otra dimensión del panel,
	  diferente a la de la función <fncref targ="psum"/>.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve una matriz con el resultado de calcular la forma cuadrática
	  <equation status="inline" ascii="Y = xAx'" tex="$Y = x A x'$"/>.
	  Si la matriz simétrica <argname>A</argname> del argumento es de tipo
	  genérico, cuando utilizas esta función en lugar de la típica multiplicación
	  de matrices, garantizas una mayor rapidez y mejor precisión. Sin embargo,
	  en el caso especial de que <argname>A</argname> sea una matriz
	  identidad, la simple expresión <lit>x'x</lit> resulta mucho mejor ca
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Devuelve una matriz con el resultado de calcular la forma cuadrática
	  <equation status="inline" ascii="Y = xAx'" tex="$Y = x A x'$"/>.
	  Si la matriz simétrica <argname>A</argname> del argumento es de tipo
	  genérico, cuando utilizas esta función en vez de la típica multiplicación
	  de matrices, garantizas una mayor rapidez y mejor precisión. Sin embargo,
	  en el caso especial <equation status="inline" ascii="A = I" tex="$A = I$"/>,
	  la simple expresión <lit>x'x</lit> resulta mucho mejor que
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	  En el caso especial de que <argname>A</argname> sea una matriz
	  diagonal, puedes indicar el segundo argumento como un vector del
	  tamaño apropiado, en el que se entiende que está contenida la diagonal
	  principal de <argname>A</argname>. En ese caso, se utiliza un
	  algoritmo más eficiente.
	</para>
	<para>
	  Si <argname>x</argname> y <argname>A</argname> no son matrices
	  conformables, o si <argname>A</argname> no es simétrica, la función
	  devuelve un fallo.
	</para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">gl</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con la probabilidad asociada (<math>P</math>) al valor
	  del estadístico para hacer el contraste LR de Quandt (o sup-Wald) de cambio
	  estructural en un punto desconocido (consulta <cmdref targ="qlrtest"/>),
	  según <cite key="hansen97">Bruce Hansen (1997)</cite>.
	</para>
	<para>
	  El primer argumento, <argname>X2</argname>, indica el valor del
	  estadístico de contraste de Wald máximo (en formato chi-cuadrado), y el
	  segundo, <argname>gl</argname>, indica sus grados de libertad.
	  El tercer y el cuarto argumentos, representan los puntos de inicio y
	  de fin del rango central de observaciones sobre el que se van a calcular
	  los sucesivos estadísticos de Wald de los contrastes, y debes expresarlos como
	  fracciones decimales en relación al rango total de estimación. Por
	  ejemplo, si quieres adoptar el enfoque estándar de recorte del 15 por
	  ciento, debes establecer <argname>p1</argname> igual a 0.15 y
	  <argname>p2</argname> igual a 0.85.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con los cuantiles de una
	  Normal estándar que se corresponden con cada valor del argumento. Si
	  <argname>x</argname> no está entre 0 y 1, se devuelve <lit>NA</lit>.
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
	<fnarg type="matrixref" optional="true">&amp;P</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz con el cálculo de una <quote>tenue</quote>
	  descomposición QR de una matriz <argname>X</argname> de orden
	  <by r="m" c="n"/> siendo <math>m</math> &ge; <math>n</math>,
	  de forma que <math>X = QR</math> donde <math>Q</math> es una
	  matriz <by r="m" c="n"/> ortogonal, y <math>R</math> es una
	  matriz <by r="n" c="n"/> triangular superior. La matriz <math>Q</math>
	  se devuelve directamente, mientras que puedes obtener <math>R</math>
	  mediante el segundo argumento (opcional).
	</para>
	<para>
	  Si indicas el tercer argumento (opcional), la descomposición
	  utiliza el pivotado de columnas y, cuando se completa con éxito,
	  <argname>P</argname> contiene la ordenación final de las columnas
	  en forma de un vector fila. Si las columnas no están realmente
	  reordenadas, <argname>P</argname> se va a equipar a
	  <fncref targ="seq"/><lit>(1, n)</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">tipo</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz <by r="n" c="2"/> para utilizar con la cuadratura
	  Gaussiana (en integración numérica). La primera columna contiene los
	  nodos o abscisas, y la segunda las ponderaciones.
	</para>
	<para>
	  El primer argumento especifica el número de puntos (filas) que se
	  van a calcular. El segundo argumento codifica el tipo de cuadratura:
	  utiliza 1 para la Gauss&ndash;Hermite (la establecida por defecto);
	  2 para la Gauss&ndash;Legendre; o 3 para la Gauss&ndash;Laguerre.
	  El sentido de los parámetros <argname>a</argname> y <argname>b</argname>
	  (opcionales) depende del <argname>tipo</argname> seleccionado,
	  como se explica a continuación.
	</para>
	<para context="notex">
	  La cuadratura Gaussiana es un método para aproximar numéricamente la
	  integral definida de alguna función que te interese. Supongamos que la
	  función se representa mediante el producto <math>f(x)W(x)</math>.
	  Los distintos tipos de cuadratura difieren en la especificación de la
	  componente <math>W(x)</math>: en el caso de la Hermite esto es igual a
	  exp(&minus;<math>x</math><sup>2</sup>); en el caso de la Laguerre es
	  igual a exp(&minus;<math>x</math>); y en el caso de la Legendre simplemente
	  es <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  La cuadratura Gaussiana es un método para aproximar numéricamente la
	  integral definida de alguna función que te interese. Supongamos que la
	  función se representa mediante el producto $f(x)W(x)$. Los distintos
	  tipos de cuadratura difieren en la especificación de la componente $W(x)$:
	  en el caso de la Hermite tenemos $W(x) = \exp(-x^2)$; en el caso de la Laguerre,
	  $W(x) = \exp(-x)$; y en el caso de la Legendre tenemos simplemente
	  $W(x) = 1$.
	</para>
	<para context="notex">
	  Para cada especificación de <math>W</math>, puede calcularse un
	  conjunto de nodos (<math>x</math><sub>i</sub>) y un conjunto de
	  ponderaciones (<math>w</math><sub>i</sub>), de tal modo que la suma
	  desde <math>i</math>=1 hasta <math>n</math> de
	  <math>w</math><sub>i</sub>
	  <math>f</math>(<math>x</math><sub>i</sub>) se va a aproximar a la
	  integral deseada. Para esto se va a utilizar el método de
	  <cite key="golub69">Golub y Welsch (1969)</cite>.
	</para>
	<para context="tex">
	  Para cada especificación de $W(x)$, puede calcularse un conjunto de
	  nodos ($x_i$) y un conjunto de ponderaciones ($w_i$), de tal modo que
	  $\sum_{i=1}^n f(x_i) w_i$ se va a aproximar a la integral deseada. Se va a
	  usar el método de <cite key="golub69">Golub y Welsch (1969)</cite>.
	</para>
	<para context="notex">
	  Cuando se selecciona el tipo de Gauss&ndash;Legendre, puedes utilizar
	  los argumentos opcionales <argname>a</argname> y <argname>b</argname>
	  para controlar los límites inferior y superior de la integración, siendo
	  en este caso los valores por defecto &minus;1 y 1. (En la cuadratura
	  de Hermite, los límites están fijados en menos y más infinito;
	  mientras que en el caso de la cuadratura de Laguerre, están fijados en 0
	  e infinito.)
	</para>
	<para context="tex">
	  Cuando se selecciona el tipo de Gauss&ndash;Legendre, puedes utilizar
	  los argumentos opcionales <argname>a</argname> y <argname>b</argname>
	  para controlar los límites inferior y superior de la integración, siendo
	  en este caso los valores por defecto $-1$ y 1. (En la cuadratura
	  de Hermite, los límites están fijados en $-\infty$ y $+\infty$;
	  mientras que en el caso de Laguerre, están fijados en 0 y $\infty$.)
	</para>
	<para context="notex">
	  En el caso de Hermite, <argname>a</argname> y <argname>b</argname>
	  juegan papeles diferentes: pueden utilizarse para substituir la forma
	  por defecto de <math>W</math>(<math>x</math>) por la distribución
	  Normal de probabilidad con media <argname>a</argname> y desviación
	  típica <argname>b</argname> (con la que está estrechamente emparentada).
	  Por ejemplo, si indicas los valores 0 y 1 para estos parámetros,
	  respectivamente, vas a provocar que <math>W</math>(<math>x</math>)
	  sea la función de densidad de probabilidad Normal estándar; lo
	  que es equivalente a multiplicar los nodos por defecto por la raíz
	  cuadrada de dos, y dividir las ponderaciones por la raíz cuadrada de
	  &pi;.
	</para>
	<para context="tex">
	  En el caso de Hermite, <argname>a</argname> y <argname>b</argname>
	  juegan papeles diferentes: pueden utilizarse para substituir la forma
	  por defecto de $W(x)$ por la distribución Normal de probabilidad con
	  media <argname>a</argname> y desviación típica <argname>b</argname>
	  (con la que está estrechamente emparentada). Por ejemplo, si indicas
	  los valores 0 y 1 para estos parámetros, respectivamente, vas a
	  provocar que $W(x)$ sea la función de densidad de probabilidad
	  Normal estándar; lo que es equivalente a multiplicar los valores
	  $x_i$ por defecto por $\sqrt{2}$, y dividir las ponderaciones por defecto
	  $w_i$ por $\sqrt{\pi}$.
	</para>
      </description>
    </function>

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="pscalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>y</argname> es una serie, devuelve un escalar que
	  representa el cuantil <argname>p</argname> de la misma. Por ejemplo,
	  cuando <math>p</math> = 0.5, se devuelve la mediana.
	</para>
	<para>
	  Si <argname>y</argname> es una matriz, devuelve un vector fila que
	  contiene los <argname>p</argname> cuantiles de las diferentes columnas
	  de <argname>y</argname>; es decir, cada una de sus columnas
	  se trata como una serie.
	</para>
	<para>
	  Además, para una matriz <argname>y</argname> se admite una forma
	  alternativa del segundo argumento: puedes indicar <argname>p</argname>
	  como un vector. En ese caso, el valor que se te devuelve es una matriz
	  de orden <by r="m" c="n"/>, en la que <repl>m</repl> indica el número de
	  elementos de <argname>p</argname> y <repl>n</repl> indica el número
	  de columnas de <argname>y</argname>.
	</para>
	<para>
	  <cite key="hyndman96">Hyndman y Fan (1996)</cite> describen nueve
	  métodos distintos para calcular los cuantiles muestrales. En GRETL, por
	  defecto, el método es el que ellos denominan <math>Q</math><sub>6</sub>
	  (que también lo es en Python, por defecto). En cambio, puedes seleccionar
	  los métodos <math>Q</math><sub>7</sub> (que es el usado por defecto
	  en R) o <math>Q</math><sub>8</sub> (que es el recomendado por
	  Hyndman y Fan) por medio de la instrucción <cmdref targ="set"/>,
	  como en
	</para>
	<code>
	  set quantile_type Q7 # o Q8
	</code>
	<para context="tex">
	  El cuantil $p$ ($Q_p$) de una serie $y$ que tiene longitud igual
	  a $n$ se define como:
	  \[Q_p = y_{[k]} + (h - k) (y_{[k+1]} - y_{[k]})\]
	  donde $k$ representa la parte entera de $h$, un término que difiere
	  dependiendo del método
	  ---$h=(n+1)p$ para $Q_6$, $(n-1)p+1$ para $Q_7$ y $(n+1/3)p + 1/3$ para $Q_8$---
	  donde $y_{[i]}$ representa el $i$-ésimo elemento de la serie cuando
	  se ordena de menor a mayor.
	</para>
	<para>
	Por ejemplo, el código
	</para>
	<code>
	  set verbose off
	  matrix x = seq(1,7)'
	  set quantile_type Q6
	  printf "Q6: %g\n", quantile(x, 0.45)
	  set quantile_type Q7
	  printf "Q7: %g\n", quantile(x, 0.45)
	  set quantile_type Q8
	  printf "Q8: %g\n", quantile(x, 0.45)
	</code>
	<para>
	produce el siguiente resultado:
	</para>
	<code>
	  Q6: 3.6
	  Q7: 3.7
	  Q8: 3.63333
	</code>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-series">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  Devuelve una serie calculada con un generador universal de números
	  aleatorios. El argumento <argname>d</argname> es una cadena de texto
	  (que generalmente está formada por un solo carácter) que permite
	  especificar el tipo de distribución de probabilidad de la que se extraen
	  los números pseudoaleatorios. Los argumentos de <argname>p1</argname>
	  a <argname>p3</argname> especifican los parámetros de la distribución
	  escogida, y el número de estos parámetros depende de esa distribución.
	  Para otras distribuciones diferentes a la Beta-Binomial, los parámetros
	  <argname>p1</argname> y (caso de ser aplicable) <argname>p2</argname>
	  puedes indicarlos en formato de escalar o de serie. Cuando los utilizas
	  en formato escalar, la serie que resulta procede de distribuciones
	  idénticamente distribuidas. Cuando utilizas series para los argumentos
	  <argname>p1</argname> o <argname>p2</argname>, la serie resultante
	  procede de distribuciones condicionadas al valor de los parámetros en
	  cada observación. En el caso de la Beta-Binomial, todos los parámetros
	  deben ser escalares.
	</para>
	<para>
	  A continuación se indican detalles más específicos: el código de
	  texto para cada tipo de distribución se muestra entre paréntesis,
	  seguido de la interpretación del argumento <argname>p1</argname> y,
	  cuando es aplicable, de la interpretación de <argname>p2</argname> y
	  <argname>p3</argname>.
	</para>

	<ilist context="notex">
	  <li>
            <para>
              Uniforme (continua) (u o U): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Uniforme (discreta) (i): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Normal (z, n o N): media, desviación típica
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): grados de libertad
            </para>
	  </li>
	  <li>
            <para>
              Chi-cuadrado (c, x o X): grados de libertad
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f o F): grados de libertad (num.), grados de libertad (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g o G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b o B): probabilidad, cantidad de ensayos
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p o P): media
            </para>
	  </li>
	  <li>
            <para>
              Exponencial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Logística (lgt o s): posición, escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w o W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l o L): media, escala
            </para>
	  </li>
	  <li>
            <para>
              Error Generalizado (E): forma
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): forma1, forma2
            </para>
	  </li>
	  <li>
            <para>
              Beta-Binomial (bb): ensayos, forma1, forma2
            </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textbf{Distribución} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniforme (continua) &amp; \texttt{u} o \texttt{U} &amp; mínimo &amp; máximo &amp; --\\
	  Uniforme (discreta) &amp; \texttt{i} &amp; mínimo &amp; máximo &amp; --\\
	  Normal &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp; media &amp; desviación típica &amp; --\\
	  $t$ de Student &amp; \texttt{t} &amp; grados de libertad &amp; -- &amp; --\\
	  Chi-cuadrado &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp; grados de libertad &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} o \texttt{F} &amp; gl (num.) &amp; gl (den.) &amp; --\\
	  Gamma &amp; \texttt{g} o \texttt{G} &amp; forma &amp; escala  &amp; --\\
	  Binomial &amp; \texttt{b} o \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} o \texttt{P} &amp; media &amp; --  &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp; escala &amp; -- &amp; --\\
	  Logística &amp; \texttt{s} &amp; posición &amp; escala &amp; --\\
	  Weibull &amp; \texttt{w} o \texttt{W} &amp; forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} o \texttt{L} &amp; media &amp; escala &amp; --\\
	  Error Generalizado &amp; \texttt{E} &amp; forma &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; forma1 &amp; forma2 &amp; --\\
	  Beta-Binomial &amp; \texttt{bb} &amp; $n$ &amp; forma1 &amp; forma2
	</tabular>
	<para>
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="uniform"/>
            <fncref targ="mrandgen"/>
            <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Funciona del mismo modo que <fncref targ="randgen"/> excepto por el
	  hecho de que devuelve un escalar en lugar de una serie.
	</para>
	<para>
	  El primer ejemplo de arriba devuelve un valor extraído de la distribución
	  Normal estándar, mientras que el segundo devuelve un valor extraído de la
	  distribución Gamma con un parámetro de forma igual a 3 y de escala a 2.5.
	</para>
	<para>
	  <seelist>
            <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un entero pseudoaleatorio en el intervalo cerrado
	  [<argname>min</argname>, <argname>max</argname>].
	  <seelist>
	    <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randperm" section="probdist" output="vector">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Si solo indicas el primer argumento, devuelve un vector fila que
	  contiene una permutación aleatoria de los números enteros desde 1
	  hasta ese valor <argname>n</argname>, sin repetición de elementos.
	  Cuando indiques el segundo argumento, deberá ser un número entero
	  positivo dentro del rango de 1 a <argname>n</argname>; en ese caso
	  la función devuelve un vector fila que contiene <argname>k</argname>
	  número enteros seleccionados aleatoriamente desde 1 hasta
	  <argname>n</argname>, sin reemplazamiento.
	</para>
	<para>
	  Si quieres extraer una muestra de <math>k</math> filas de una matriz
	  <lit>X</lit> que tiene <math>n</math> filas (y sin reemplazamiento),
	  puedes conseguir eso tal como se muestra debajo:
	</para>
	<code>
	  matrix S = X[randperm(n, k),]
	</code>
	<para>
	  Y si deseas mantener el orden original de las filas en la
	  muestra:
	</para>
	<code>
	  matrix S = X[sort(randperm(n, k)),]
	</code>
	<para>
	  Consulta también la función <fncref targ="resample"/> para
	  remuestrear con reemplazamiento.
	</para>
      </description>
    </function>

    <function name="randstr" section="strings" output="string">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una cadena de texto aleatoria de <argname>n</argname> bytes
	  de ancho. En la cadena se van a incluir con la misma probabilidad los
	  números que van de <lit>0</lit> a <lit>9</lit>, y las letras minúsculas
	  que van de <lit>a</lit> hasta <lit>f</lit>; y se interpreta como un
	  entero hexadecimal. Su uso previsto es como un identificador único.
	  Por ejemplo, con <argname>n</argname> = 16, se genera una cadena
	  de entre cerca de 10<sup>19</sup> posibilidades, por lo que será
	  única con una probabilidad próxima a 1.
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">tol</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un entero con el rango de la matriz <argname>X</argname> de orden
	  <by r="r" c="c"/>, calculado numéricamente mediante la descomposición
	  en valores singulares.
	</para>
	<para>
	  El resultado de esta operación es el número de valores singulares
	  de la matriz <argname>X</argname> que numéricamente se consideran
	  mayores que 0. El parámetro opcional <argname>tol</argname> puedes
	  usarlo para retocar este aspecto. Se va a considerar que los valores
	  singulares no son nulos cuando resultan ser mayores que
	  <math>m &times; tol &times; s</math>, donde <math>m</math> es el
	  mayor valor de entre <math>r</math> y <math>c</math>, siendo
	  <math>s</math> lo que expresa el valor singular más grande. Cuando
	  omites el segundo argumento, se establece que <argname>tol</argname>
	  sea igual al épsilon de la máquina (consulta <fncref targ="$macheps"/>).
	  En algunos casos, puedes querer establecer que <argname>tol</argname>
	  sea un valor más grande (p.e. 1.0e-9) con el fin de evitar que
	  se sobrestime el rango de la matriz <argname>X</argname> (lo que
	  podría dar lugar a resultados numéricamente
	  inestables).
	</para>
	<para>
	  <seelist>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie o vector con las posiciones jerárquicas de los valores
	  de <math>y</math>. La observación <math>i</math> tiene una posición
	  en la jerarquía que viene determinada por el número de elementos que son
	  menores que <math>y</math><sub>i</sub>, más la mitad del número
	  de elementos que son iguales a <math>y</math><sub>i</sub>.
	  (Intuitivamente, puedes imaginarlo como la jerarquía en un torneo de
	  ajedrez, en el que cada vitoria supone conceder un punto al ganador, y
	  cada empate supone conceder medio punto). Se añade un 1 de forma
	  que el número más pequeño para una posición es 1, y no 0.
	</para>
	<para context="tex">
	  Formalmente,
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \]
	  donde $I$ denota la función índice.
	</para>
	<para>
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el número de condición recíproco de la matriz cuadrada
	  <argname>A</argname> respecto a la norma 1. En muchos casos, este
	  mide de forma más adecuada que el determinante, la sensibilidad de
	  <argname>A</argname> a las operaciones numéricas tales como la inversión.
	</para>
	<para context="notex">
	  El valor se calcula como el inverso (o recíproco) del resultado de
	  multiplicar la norma 1 de la matriz cuadrada <argname>A</argname>, por la
	  norma 1 de la matriz inversa de <argname>A</argname>.
	</para>
	<para context="tex">
	  Dada una matriz cuadrada <math>A</math> no singular, se puede definir
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\]
	  La función devuelve $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="ldet"/>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="Re" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz real con la misma dimensión que
	  <argname>C</argname>, y que contiene la parte real de la
	  matriz de ese argumento. Consulta también <fncref targ="Im"/>.
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">nombrearchivo</fnarg>
	<fnarg type="string" optional="true">código</fnarg>
      </fnargs>
      <description>
	<para>
	  Si existe (y puede leerse) un archivo con el nombre del argumento
	  <argname>nombrearchivo</argname>, la función devuelve una cadena de
	  texto que incluye el contenido de ese archivo; en caso contrario,
	  indica un fallo. Si <argname>nombrearchivo</argname> no indica una
	  especificación de la ruta completa al archivo, se va a buscar en varias
	  localizaciones <quote>probables</quote>, comenzando por el directorio
	  vigente en ese momento, <cmdref targ="workdir"/>. Si el archivo en
	  cuestión está comprimido con gzip, se maneja del modo evidente.
	</para>
	<para>
	  Si <argname>nombrearchivo</argname> comienza con un identificador de un protocolo
	  de internet que sea admisible (<lit>http://</lit>, <lit>ftp://</lit>
	  o <lit>https://</lit>), se activa una orden a 'libcurl' para que
	  descargue el recurso. Para otras operaciones de descarga más
	  complicadas, consulta también <fncref targ="curl"/>.
	</para>
	<para>
	  Cuando el texto que se quiere leer no está codificado en UTF-8, GRETL va a
	  tratar de volver a codificarlo desde el tipo vigente de codificación
	  local (si este no es UTF-8), o desde ISO-8859-15 en otro caso. Si este
	  sencillo funcionamiento por defecto no cumple con tus necesidades,
	  puedes usar el segundo argumento (opcional) para especificar un tipo de
	  codificación. Por ejemplo, si quieres leer texto que está en el tipo de
	  página de código Microsoft 1251, y este no es tu tipo de código
	  local, deberás indicar <lit>"cp1251"</lit> como segundo argumento.
	</para>
    <para>
        Ejemplos:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        print web_page

        string current_settings = readfile("@dotdir/.gretl2rc")
        print current_settings
    </code>
	<para>
	  Consulta también las funciones <fncref targ="sscanf"/> y
	  <fncref targ="getline"/>.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string">hallada</fnarg>
	<fnarg type="string">substit</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>s</argname> é una cadena única, devuelve una cadena de
	  texto con una copia de <argname>s</argname> en la que todos los casos en
	  los que ocurre el patrón <argname>hallada</argname>, se substituyen por
	  <argname>substit</argname>. Los dos argumentos <argname>hallada</argname>
	  y <argname>substit</argname> se interpretan como expresiones regulares
	  de estilo Perl. Si <argname>s</argname> es un 'array' de cadenas
	  de texto o una serie que contiene cadenas de valores, esta operación
	  se realiza con cada una de las cadenas del 'array' o de la
	  serie.
	</para>
	<para>
	  Consulta también la función <fncref targ="strsub"/> para la substitución
	  simple de cadenas de texto.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nombrearchivo</fnarg>
      </fnargs>
      <description>
	<para>
	  Si el archivo del argumento <argname>nombrearchivo</argname>
	  existe y si el usuario puede modificarlo, esta función lo elimina
	  y devuelve un 0. Si no existe el archivo, o no puede eliminarse
	  por alguna razón, la función devuelve un código no nulo indicando
	  un fallo.
	</para>
	<para>
	  Cuando <argname>nombrearchivo</argname> no especifica la ruta
	  completa, entonces se asume que el archivo al que se refiere, está
	  en el directorio vigente de trabajo (<cmdref targ="workdir"/>).
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">hallar</fnarg>
	<fnarg type="scalar-or-vec">substit</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo de) <argname>x</argname> cambiando
	  sus elementos que sean iguales al elemento <math>i</math>-ésimo de
	  <argname>hallar</argname> por el concordante de <argname>substit</argname>.
	</para>
	<para>
	  Cuando el segundo argumento (<argname>hallar</argname>) es un escalar, el
	  tercer argumento (<argname>substit</argname>) también debe ser un
	  escalar. Cuando ambos son vectores, deben tener el mismo número de
	  elementos. Pero cuando <argname>hallar</argname> es un vector y
	  <argname>substit</argname> es un escalar, entonces todas las coincidencias de
	  aquel se substituyen en <argname>x</argname> por <argname>substit</argname>.
	</para>
	<para>
	  Ejemplo:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  halla = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, halla, subst)
	  print a b
	</code>
	<para>
	  produce...
	</para>
	<code>
          a (2 x 3)

          1   2   3
          3   4   5

          b (2 x 3)

          -1    2   -8
          -8    0    5
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">tamañobloque</fnarg>
	<fnarg optional="true" type="int">extracciones</fnarg>
      </fnargs>
      <description>
	<para>
	  La descripción inicial de esta función se refiere a los casos con
	  datos de corte transversal o con series temporales; mira más abajo
	  para los casos con datos de panel.
	</para>
	<para>
	  Devuelve el resultado (del tipo del argumento) que se obtiene haciendo
	  un remuestreo de <argname>x</argname> con reemplazamiento. Si el
	  argumento es una serie, cada valor <math>y</math><sub>t</sub> de
	  la serie que se devuelve, se obtiene de entre todos los valores de
	  <math>x</math><sub>t</sub> que tienen la misma probabilidad. Cuando
	  el argumento es una matriz, cada fila de la matriz que se devuelve,
	  se obtiene de las filas de <argname>x</argname> que tienen la misma
	  probabilidad. Consulta también <fncref targ="randperm"/> para
	  extraer una muestra de filas de una matriz sin reemplazamiento.
	</para>
	<para>
	  El argumento <argname>tamañobloque</argname> (opcional) representa el
	  tamaño del bloque para hacer el remuestreo moviendo bloques. Cuando
	  se indique este argumento, deberá ser un entero positivo mayor o
	  igual a 2. Como consecuencia, el resultado se va a componer por
	  selección aleatoria con reemplazamiento, de entre todas las posibles
	  secuencias contiguas de longitud <argname>tamañobloque</argname>
	  del argumento. (En caso de que el argumento sea una matriz, esto
	  significa filas contiguas.) Si la longitud de los datos no es un
	  número entero que sea múltiplo del tamaño del bloque, el último
	  bloque seleccionado se trunca para que se ajuste.
	</para>
	<subhead>Número de extracciones</subhead>
	<para>
	  Por defecto, el número de observaciones que se vuelven a extraer
	  para obtener el resultado es igual al del argumento indicado
	  &mdash;si <argname>x</argname> fuese una serie, sería la longitud del
	  rango muestral vigente; si <argname>x</argname> fuese una matriz, sería
	  el número de sus filas. En el caso matricial, <emphasis>solo</emphasis>
	  puedes ajustar esto mediante el tercer argumento (opcional), que
	  habrá de ser un número entero positivo. Ten en cuenta que si el
	  argumento <argname>tamañobloque</argname> es mayor que 1, el
	  argumento <argname>extracciones</argname> se refiere al número de
	  observaciones individuales, no al número de bloques.
	</para>
	<subhead>Datos de panel</subhead>
	<para>
	  Cuando el argumento <argname>x</argname> es una serie, y el conjunto
	  de datos tiene formato de panel, no se admite hacer el muestreo por
	  repetición moviendo bloques. La forma básica de hacer este tipo de
	  muestreo está admitida, pero tiene su propia interpretación: se hace
	  el muestreo por repetición de los datos <quote>por individuo</quote>.
	  Supón que tienes un panel en el que se observan 100 individuos a lo largo
	  de 5 períodos. Entonces, la serie que se devuelve también va a estar compuesta
	  por 100 bloques de 5 observaciones: cada bloque va a obtenerse con igual
	  probabilidad de las 100 series temporales individuales, conservándose
	  el orden de las series temporales.
	</para>
      </description>
    </function>

    <function name="rgbmix" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="string">color1</fnarg>
	<fnarg type="string">color2</fnarg>
	<fnarg type="matrix">f</fnarg>
	<fnarg type="bool" optional="true">grafico</fnarg>
      </fnargs>
      <description>
	<para>
	  Dados dos colores y un vector <argname>f</argname> de longitud
	  <math>n</math> que contenga valores en [0,1], esta función devuelve
	  un 'array' de <math>n</math> cadenas de texto, en el que su elemento
	  <math>i</math> contiene el código RGB hexadecimal para una mixtura
	  de tipo (1-<math>f</math><sub>i</sub>) &times; <lit>color1</lit>
	  + <math>f</math><sub>i</sub> &times; <lit>color2</lit>. La media
	  ponderada se toma sobre los canales de Rojo, Verde y Azul de los
	  colores de entrada.
	</para>
	<para>
	  Puedes especificar los argumentos de color con nombres reconocidos por
	  <cmdref targ="gnuplot"/>, o como valores hexadecimales con el formato
	  <lit>0xrrggbb</lit> o <lit>#rrggbb</lit>. En el primero de estos
	  formatos, se pueden indicar numéricamente los valores hex; de otro modo,
	  son necesarias las cadenas de texto. Si indicas un valor no nulo para
	  el argumento <argname>grafico</argname>, se produce un gráfico que
	  muestra las mezclas de colores.
	</para>
	<para>
	  Esta función ofrece un medio de generar un conjunto de colores
	  relacionados con un propósito de representación gráfica, siendo su uso
	  principal la especificación de múltiples franjas en un gráfico (por
	  ejemplo, para indicar intervalos de confianza con más de un nivel). A
	  continuación hay tres ejemplos: el primero genera sucesivos aclarados
	  de un azul inicial; el segundo genera progresivos oscurecimientos de
	  un tono rosa; y el tercero, una transición del rojo al amarillo.
	</para>
	<code>
	  f = {0, 0.5, 0.75, 0.875, 0.9375}
	  mezclas = rgbmix(0x1b43dc, "white", f, 1)
	  print mezclas
	  f = {0, 0.1, 0.2, 0.3, 0.4}
	  rgbmix(0xefd0d3, "black", f, 1)
	  f = {0, 0.2, 0.4, 0.6, 0.8, 1}
	  rgbmix("red", "yellow", f, 1)
	</code>
	<para>
	  El resultado de la instrucción <lit>print</lit> para el primer ejemplo
	  será
	</para>
	<code>
	  [1] "0x1b43dc"
	  [2] "0x8da1ee"
	  [3] "0xc6d0f6"
	  [4] "0xe2e8fb"
	  [5] "0xf1f3fd"
	</code>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado, del tipo del argumento, que lo redondea al
	  entero más próximo. Ten en cuenta que si <math>x</math> está justo
	  entre dos enteros, el redondeo se hace "alejándose de cero" de
	  modo que, por ejemplo, 2.5 se redondea a 3, pero <lit>round(-3.5)</lit>
	  devuelve &minus;4. Esta convención es común en software de hojas de
	  cálculo, pero otro tipo de software puede generar resultados diferentes.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Si indicas el argumento <argname>r</argname>, devuelve una
	  cadena con el nombre de la fila <argname>r</argname> de la matriz
	  <argname>M</argname>. Si las filas de <argname>M</argname>
	  no tienen nombre, entonces se devuelve una cadena vacía; y si
	  <argname>r</argname> está fuera de los límites del número de filas
	  de esta matriz, se muestra un fallo.
	</para>
	<para>
	  Si no indicas el segundo argumento, devuelve un 'array' de cadenas
	  de texto que contiene los nombres de las filas de <argname>M</argname>,
	  o un 'array' vacío si la matriz no tiene asignados nombres para sus
	  filas.
	</para>
	<para>
	  Ejemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  rnameset(A, "Primera Segunda")
	  string name = rnameget(A, 2)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="rnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameset" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite añadir nombres a las filas de una matriz <argname>M</argname>
	  de orden <by r="m" c="n"/>. Cuando el argumento <argname>S</argname>
	  se refiere a una lista, los nombres se toman de las series de la lista
	  (que deberá tener <math>m</math> elementos). Cuando <argname>S</argname>
	  es un 'array' de cadenas de texto, deberá tener <math>m</math>
	  elementos. Se admite también que indiques una única cadena de texto
	  como segundo argumento; en este caso esta deberá tener <math>m</math>
	  subcadenas de texto separadas por espacios.
	</para>
	<para>
	  Se devuelve el valor nominal 0 cuando las filas se nombran con éxito;
	  en caso de fracaso, se muestra un fallo. Consulta también
	  <fncref targ="cnameset"/>.
	</para>
	<para>
	  Ejemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(3)
	  S[1] = "Fila1"
	  S[2] = "Fila2"
	  S[3] = "Fila3"
	  rnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="rows" section="matrix" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un entero con el número de filas de la matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="schur" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;Z</fnarg>
	<fnarg type="matrixref" optional="true">&amp;w</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza la descomposición de Schur de la matriz compleja
	  <argname>A</argname> del argumento, devolviendo una matriz
	  triangular superior compleja <math>T</math>. Cuando indicas un
	  segundo argumento que non sea <lit>null</lit> (nulo), recoge
	  una matriz compleja <math>Z</math> que contiene los vectores de
	  Schur asociados a <math>A</math> y <math>T</math>, tales que
	  <math>A</math> = <math>ZTZ</math><sup>H</sup>. Cuando indicas el
	  tercer argumento, recoge los autovalores de la matriz <math>A</math>
	  en un vector columna complejo.
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>x</argname> es una serie, la función devuelve un escalar
	  con su desviación típica muestral, descartando las observaciones ausentes.
	</para>
	<para>
	  Si <argname>x</argname> es una lista, la función devuelve una
	  serie <math>y</math> tal que <math>y</math><sub>t</sub>
	  representa la desviación típica muestral de los valores de las
	  series de la lista, en la observación <math>t</math>. Por
	  defecto, la desviación típica se registra como <lit>NA</lit>,
	  si hay algún valor ausente en <math>t</math>; pero si le das
	  un valor no nulo a <argname>parcial</argname>, cualquier valor
	  no ausente se usará para crear el estadístico.
	</para>
	<para>
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">gl</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila con las desviaciones típicas de las columnas
	  de la matriz <argname>X</argname>. Si <argname>gl</argname> es
	  positivo, se utiliza como divisor para las varianzas de las columnas;
	  en otro caso, el divisor es igual al número de filas que tiene
	  <argname>X</argname> (es decir, en ese caso no se aplica la
	  corrección por los grados de libertad). Si indicas un valor no
	  nulo para el tercer argumento (opcional), se ignoran los valores
	  ausentes; de otra forma, el resultado es <lit>NA</lit> para cada
	  columna que contenga valores ausentes.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado con el cálculo de las diferencias estacionales:
	  <equation status="inline" ascii="y(t) - y(t-k)"  tex="$y_t - y_{t-k}$"/>,
	  donde <math>k</math> indica la periodicidad del conjunto vigente de
	  datos (consulta <fncref targ="$pd"/> o <fncref targ="$panelpd"/>).
	  Los valores iniciales se definen como <lit>NA</lit>.
	</para>
	<para>
	  Cuando se devuelve una lista, cada variable individual de esta se nombra de
	  forma automática siguiendo el patrón <lit>sd_</lit><repl>nombrevar</repl>,
	  en el que <repl>nombrevar</repl> indica el nombre de la serie original. La parte
	  original del nombre va a truncarse cuando así resulte necesario, e incluso
	  podrá ajustarse para garantizar que sea único dentro del conjunto de
	  nombres que así se vayan a construir.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="ldiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">base</fnarg>
	<fnarg optional="true" type="bool">centro</fnarg>
      </fnargs>
      <description>
	<para>
	  Se aplica tan solo si el conjunto vigente de datos tiene una estructura
	  de series temporales con periodicidad mayor que 1. Devuelve una lista con
	  variables ficticias que representan cada período o estación, y que se
	  nombran como <lit>S1</lit>, <lit>S2</lit>, etc.
	</para>
	<para>
	  Utiliza el argumento <argname>base</argname> (opcional) para
	  excluir de la lista a la variable ficticia que representa uno de los períodos.
	  Por ejemplo, si le asignas un valor igual a 1 teniendo un conjunto de
	  datos trimestrales, obtienes una lista que solo tiene las variables ficticias
	  de los trimestres 2, 3 y 4. Si omites este argumento o es igual a 0,
	  se generan variables ficticias para todos los períodos; y si no es cero,
	  deberá ser un entero comprendido entre 1 y la periodicidad de los datos.
	</para>
	<para>
	  El argumento <argname>centro</argname>, si no es nulo, indica que
	  las variables ficticias van a centrarse; es decir, sus valores van a
	  calcularse restándole las medias en la población. Por ejemplo, con
	  datos trimestrales, las variables ficticias estacionales centradas van a
	  tener valores iguales a &minus;0.25 y 0.75 en vez de 0 y 1.
	</para>
	<para>
	  Con datos de frecuencia semanal, el resultado concreto depende
	  de si los datos tienen fecha o no. Si tienen fecha, se crean hasta
	  53 series estacionales, basadas en el número de semana ISO 8601
	  (consulta <fncref targ="isoweek"/>); si no la tienen, el número
	  máximo de series es 52 (y durante un período prolongado las series
	  <quote>estacionales</quote> se van a desfasar con el año del calendario).
	  En caso de disponer de datos semanales, si deseas generar series
	  estacionales mensuales puedes hacerlo del siguiente modo:
	</para>
	<code>
	  series month = $obsminor
	  list months = dummify(month)
	</code>
	<para>
	  Para obtener más detalles, consulta <fncref targ="dummify"/>.
	</para>
      </description>
    </function>

    <function name="selifc" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz tras seleccionar solo aquellas columnas de
	  <argname>A</argname> en las que el elemento correspondiente de
	  <argname>b</argname> no es nulo. El <argname>b</argname> debe ser un
	  vector fila con el mismo número de columnas que <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz tras seleccionar solo aquellas filas de
	  <argname>A</argname> en las que el elemento correspondiente de
	  <argname>b</argname> no es nulo. El <argname>b</argname> debe ser un
	  vector columna con el mismo número de filas que <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifc"/>
            <fncref targ="trimr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matrix" output="rvec">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg optional="true" type="scalar">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Con solo dos argumentos, devuelve un vector fila con la secuencia creciente
	  (sumando 1) desde <argname>a</argname> hasta <argname>b</argname>, si el
	  primer argumento es menor que el segundo; o con la secuencia decreciente
	  (restando 1) si el primer argumento es mayor que el segundo.
	</para>
	<para>
	  Si indicas el tercer argumento <argname>k</argname> (opcional),
	  la función va a devolver un vector fila con la secuencia iniciada en
	  <argname>a</argname>, y ampliada (o disminuida en el caso inverso de
	  que <argname>a</argname> sea mayor que <argname>b</argname>) en
	  <argname>k</argname> unidades a cada paso. La secuencia finaliza en el
	  mayor valor posible que sea menor o igual a <argname>b</argname>
	  (o en el menor valor posible que sea mayor o igual a <argname>b</argname>,
	  en el caso inverso). El argumento <argname>k </argname> debe ser
	  positivo.
	</para>
	<para>
	  <seelist>
            <fncref targ="ones"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">clave</fnarg>
	<fnarg type="string">nota</fnarg>
      </fnargs>
      <description>
	<para>
	  Inserta una nota descriptiva para un objeto que se identifica por la
	  <argname>clave</argname>, dentro de un 'bundle' <argname>b</argname>.
	  Se va a mostrar esa nota cuando se utilice la instrucción <lit>print</lit>
	  con el 'bundle'. Esta función devuelve un entero igual a 0 en caso de
	  ejecutarse con éxito, y un valor no nulo en caso de fallo (por
	  ejemplo, si no existe ningún objeto <argname>clave</argname> en el
	  'bundle' <argname>b</argname>).
	</para>
      </description>
    </function>

    <function name="sgn" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve la función signo de <argname>x</argname>; es decir,
	  0 si <argname>x</argname> es cero, 1 si <argname>x</argname> es
	  positivo, &minus;1 si <argname>x</argname> es negativo, o
	  <lit>NA</lit> si <argname>x</argname> es No Numérico.
	</para>
      </description>
    </function>

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Pone en práctica el templado simulado, que puede ser útil para
	  mejorar la determinación del punto de partida de un problema de
	  optimización numérica.
	</para>
	<para>
	  Indicando el primer argumento, se establece el valor inicial de un
	  vector de parámetros; e indicando el segundo argumento, se especifica
	  una llamada a una función que devuelve el valor escalar de la
	  función objetivo a maximizar. El tercer argumento (opcional)
	  especifica el número máximo de iteraciones (que por defecto es de 1024).
	  Cuando se completa con éxito, la función <lit>simann</lit> devuelve un
	  escalar con el valor final de la función objetivo a maximizar, y
	  <argname>b</argname> contiene el vector de parámetros asociado.
	</para>
	<para>
	  Para obtener más detalles y un ejemplo, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el seno de <argname>x</argname>.
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con el seno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="asinh"/>
            <fncref targ="cosh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el valor del coeficiente de asimetría de la serie
	  <argname>x</argname>, descartando cualquier observación ausente.
	</para>
      </description>
    </function>

    <function name="sleep" section="programming" output="scalar">
      <fnargs>
	<fnarg type="scalar">ns</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función no tiene ningún uso directo en Econometría, pero puede
	  ser de utilidad para comprobar métodos de computación en paralelo.
	  Simplemente provoca que se <quote>duerma</quote> la línea de cómputo
	  vigente (es decir, que se pare) durante <argname>ns</argname>
	  segundos. El argumento debe ser un escalar no negativo. Al
	  <quote>despertar</quote>, la función devuelve el escalar 0.
	</para>
      </description>
    </function>

    <function name="smplspan" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">obsinicio</fnarg>
	<fnarg type="string">obsfin</fnarg>
	<fnarg type="int">pd</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el número de observaciones que hay contando desde
	  <argname>obsinicio</argname> hasta <argname>obsfin</argname>
	  (ambas incluidas), para datos de series temporales que tienen
	  una frecuencia <argname>pd</argname>.
	</para>
	<para>
	  Deberías indicar los dos primeros argumentos en el formato
	  que prefiere GRETL para datos de tipo anual, trimestral o
	  mensual (por ejemplo, <lit>1970</lit>, <lit>1970:1</lit>
	  o <lit>1970:01</lit> para cada una de esas frecuencias,
	  respectivamente) o como fechas en el formato ISO 8601,
	  <lit>YYYY-MM-DD</lit>.
	</para>
	<para>
	  El argumento <argname>pd</argname> debe ser bien 1, 4
	  o 12 (datos anuales, trimestrales o mensuales), bien una
	  de las frecuencias diarias (5, 6, 7), o bien 52 (semanal).
	  Si <argname>pd</argname> es igual a 1, 4 o 12, entonces las
	  fechas ISO 8601 se aceptan para los dos primeros argumentos,
	  si indican el inicio del período en cuestión. Por ejemplo,
	  <lit>2015-04-01</lit> se admite en lugar de <lit>2015:2</lit>
	  para representar el segundo trimestre de 2015.
	</para>
	<para>
	  Si ya tienes un conjunto de datos con frecuencia <argname>pd</argname>
	  preparado, y con un rango suficiente de observaciones, entonces puedes
	  imitar fácilmente el comportamiento de esta función utilizando
	  la función <fncref targ="obsnum"/>. La ventaja de <lit>smplspan</lit>
	  consiste en que puedes calcular el número de observaciones sin
	  necesidad de tener preparado un conjunto apropiado de datos
	  (ni ningún conjunto de datos). A continuación, un ejemplo:
	</para>
	<code>
	  scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  nulldata T
	  setobs 5 2010-01-01
	</code>
	<para>
	  Esto genera
	</para>
	<code>
	  ? scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  Se ha generado el escalar T = 1565
	  ? nulldata T
	  Periodicidad: 1, máx. obs: 1565
	  Rango de observaciones: 1 a 1565
	  ? setobs 5 2010-01-01
	  Rango completo de datos: 2010-01-01 - 2015-12-31 (n = 1565)
	</code>
	<para>
	  Después de lo anterior, puedes tener confianza en que la última
	  observación del conjunto de datos que se va a generar por medio
	  de <cmdref targ="nulldata"/> va a ser <lit>2015-12-31</lit>.
	  Ten en cuenta que el número 1565 sería más bien complicado
	  calcularlo de otro modo.
	</para>
      </description>
    </function>

    <function name="sort" section="matrix" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado del tipo de <argname>x</argname> con los valores ordenados
	  de forma ascendente. Las observaciones con valores ausentes se descartan cuando
	  <math>x</math> es una serie, pero se ordenan al final si <math>x</math> es un vector.
	  <seelist>
            <fncref targ="dsort"/>
            <fncref targ="values"/>
	  </seelist>
	  Para matrices, en especial, consulta <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie que contiene los elementos de <argname>y2</argname>
	  ordenados de acuerdo con los valores crecientes del primer argumento
	  <argname>y1</argname>.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sphericorr" section="stats" output="matrix">
      <fnargs>
       <fnarg type="matrix">X</fnarg>
       <fnarg type="int">modo</fnarg>
       <fnarg type="matrixref" optional="true">&amp;J</fnarg>
      </fnargs>
      <description>
       <para>
	 Permite hacer la representación en coordenadas esféricas de una
	 matriz de correlaciones, o la operación inversa, dependiendo del
	 valor del parámetro <argname>modo</argname>.
       </para>
       <para>
	 Cuando se omite <argname>modo</argname>, o es igual a 0, se asume
	 que <argname>X</argname> es una matriz de correlaciones de orden
	 <by r="n" c="n"/>. El valor que se devuelve es un vector que tiene
	 <math>n(n-1)/2</math> elementos entre 0 y &pi;. En este modo, se ignora
	 la referencia a <argname>J</argname>.
       </para>
       <para>
	 Cuando <argname>modo</argname> es igual a 1 o a 2, se realiza la
	 transformación inversa, por lo que <argname>X</argname> debe ser un
	 vector que tenga <math>n(n-1)/2</math> elementos entre 0 y &pi;.
	 El valor que se devuelve ahora es la matriz <math>R</math> de
	 correlaciones cuando la opción <argname>modo</argname> es igual a 1;
	 o su factor <math>K</math> de Cholesky cuando <argname>modo</argname>
	 es igual a 2. En estos casos, cuando se indica, el puntero opcional
	 a la matriz <argname>J</argname> permite recuperar el Jacobiano de
	 vech(<math>R</math>) o de vech(<math>K</math>) con respecto a
	 <math>X</math>.
       </para>
       <para>
	 Ten en cuenta que la representación en coordenadas esféricas
	 hace muy sencillo el cálculo del log-determinante de la matriz
	 de correlaciones <math>R</math>:
	</para>
       <code>
	 omega = sphericorr(X)
	 log_det = 2 * sum(log(sin(omega)))
	</code>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">formato</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Devuelve una cadena de texto (<quote>string</quote>) que se construye
	  representando los valores de los argumentos (indicados por los puntos de
	  arriba) que acompañan a la instrucción, bajo el control del argumento
	  <argname>formato</argname>. Tiene la intención de darte gran flexibilidad
	  para crear cadenas de texto. Utiliza <argname>formato</argname> para
	  indicar el modo preciso en el que quieres que se presenten los argumentos.
	</para>
	<para>
	  En general, el argumento <argname>formato</argname> debe ser una
	  expresión que se corresponda con una cadena de texto, pero en la mayoría
	  de los casos solo va a ser una cadena de texto literal (una secuencia
	  alfanumérica entrecomillada). Algunas secuencias de
	  caracteres de formato tienen un significado especial: aquellas que
	  comienzan con el símbolo (%) se interpretan como <quote>comodines</quote>
	  para los elementos que contiene la lista de argumentos. Además, caracteres
	  especiales (por ejemplo, el de nueva línea) se representan por medio de una
	  combinación de símbolos que comienza con una barra diagonal inversa.
	</para>
	<para>
	  Por ejemplo, el código de abajo...
	</para>
	<code>
	  scalar x = sqrt(5)
	  string claim = sprintf("sqrt(%d) es (aproximadamente) %6.4f.\n", 5, x)
	  print claim
	</code>
	<para>
	  va a producir...
	</para>
	<code>
	  sqrt(5) es (aproximadamente) 2.2361.
	</code>
	<para>
	  La expresión <lit>%d</lit> en la cadena de formato, indica que se quiere un
	  número entero en ese preciso lugar de la salida que se va a presentar, y dado
	  que esa es la expresión con el símbolo <quote>por ciento</quote> que está
	  más a la izquierda, se empareja con el primer argumento, es decir 5.
	  La segunda secuencia especial es <lit>%6.4f</lit>, y representa un
	  valor con 6 dígitos de ancho como mínimo, y con 4 dígitos después del
	  separador decimal. El número de esas secuencias debe coincidir con la
	  cantidad de argumentos que acompañan a la cadena de texto para el formato.
	</para>
	<para>
	  Consulta la página de ayuda de la instrucción <cmdref targ="printf"/>
	  para obtener más detalles en relación con la sintaxis que puedes utilizar
	  en las cadenas de texto para el formato.
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado, del mismo tipo que <argname>x</argname>, con la raíz
	  cuadrada positiva de este. Genera <lit>NA</lit> para valores negativos de este.
	</para>
	<para>
	  Observa que, si el argumento es una matriz, se realiza la operación
	  para cada elemento. Para la <quote>raíz cuadrada matricial</quote>
	  consulta <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">productos-cruz</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una lista que contiene los cuadrados de las variables de la lista
	  <argname>L</argname>, con sus elementos nombrados de acuerdo con el
	  siguiente patrón :<lit>sq_</lit><repl>nombrevariable</repl>. Cuando indicas
	  el segundo argumento (opcional) y tiene un valor no nulo, la lista
	  también va a incluir los productos cruzados de los elementos de la lista
	  <argname>L</argname>, que se nombrarán de acuerdo con el formato del
	  patrón <repl>var1</repl><lit>_</lit><repl>var2</repl>. De ser
	  necesario, el nombre de las series de los argumentos va a truncarse e incluso
	  ajustarse el nombre del resultado final, para evitar la duplicación de
	  nombres en la lista que se devuelve.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string-or-strings">origen</fnarg>
	<fnarg type="string">formato</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Lee valores indicados por el argumento <argname>origen</argname> bajo
	  el control del argumento <argname>formato</argname>, y asigna estos
	  valores a uno o más de los argumentos siguientes, indicados por los
	  puntos de arriba. Devuelve un entero con el número de valores que se
	  asignan. Esta función es una versión simplificada de la función
	  <lit>sscanf</lit> del lenguaje C de programación, con una extensión
	  para escanear una matriz entera, y que se describe más abajo bajo el
	  título <quote>Escaneando una matriz</quote>. Ten en cuenta que indicar
	  una formación de cadenas de texto como <argname>origen</argname>
	  solo se acepta en caso de que escanees una matriz.
	</para>
	<para>
	  Como argumento <repl>origen</repl> puedes usar una cadena de texto literal
	  entrecomillada, o bien el nombre de una cadena de texto que hayas
	  definido previamente. El argumento <repl>formato</repl> se indica de
	  modo similar a la cadena del argumento <quote>formato</quote> en
	  <cmdref targ="printf"/> (mira más abajo); en esta última función,
	  <repl>elementos</repl> debe ser una lista de variables definidas antes,
	  separadas por comas y que son los objetivos de la conversión de
	  <repl>origen</repl>. (Para los acostumbrados a C: podéis fijar previamente los
	  nombres de las variables numéricas con <lit>&amp;</lit>, pero no es necesario.)
	</para>
	<para>
	  El texto literal en el argumento <repl>formato</repl> se compara con
	  <repl>origen</repl>. Los elementos que especifican la conversión empiezan
	  con el carácter <lit>%</lit>, y las conversiones que están admitidas
	  incluyen: <lit>%f</lit>, <lit>%g</lit> o <lit>%lf</lit> para números
	  de punto flotante; <lit>%d</lit> para números enteros; y <lit>%s</lit>
	  para cadenas de texto. Puedes insertar un entero positivo después del
	  símbolo de porcentaje, que establece el número máximo de caracteres
	  que se van a leer para la conversión indicada. Como forma alternativa,
	  puedes insertar un carácter literal de asterisco, <lit>*</lit>, después
	  del símbolo de porcentaje para eliminar la conversión (saltándose así
	  cualquier carácter que, de otro modo, podría haberse convertido al
	  tipo indicado). Por ejemplo, la expresión <lit>%3d</lit> convierte
	  los siguientes 3 caracteres de <repl>origen</repl> en un entero, en
	  caso de que sea posible; y la expresión <lit>%*g</lit> permite saltarse
	  tantos caracteres de <repl>origen</repl> como los que podrían
	  convertirse en un número de punto flotante simple.
	</para>
	<para>
	  Además de la conversión <lit>%s</lit> para cadenas de texto, también
	  está disponible una versión simplificada del formato C
	  <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit>.
	  En este formato, <repl>N</repl> representa el número máximo de
	  caracteres que se van a leer, y <repl>chars</repl> expresa un conjunto de
	  caracteres que sean admisibles, expresados entre corchetes:
	  el proceso de lectura finaliza cuando se alcanza <repl>N</repl>, o cuando
	  se encuentra un carácter que no está en <repl>chars</repl>. Puedes
	  cambiar el funcionamiento de <repl>chars</repl>indicando el circunflejo
	  <lit>^</lit> como primer carácter; en ese caso, el proceso de lectura
	  finaliza cuando se encuentra un carácter que está indicado en el conjunto.
	  (A diferencia de lo que sucede en C, el guion no juega ningún papel
	  especial en el conjunto <repl>chars</repl>.)
	</para>
	<para>
	  Si la cadena de texto del origen no coincide (exactamente) con el formato,
	  el número de conversiones puede quedarse corta respecto al número
	  de argumentos indicados. Esto no es por si mismo un fallo en lo que
	  atañe a GRETL. Así y todo, podrías querer comprobar el número de
	  conversiones que se completaron; esto se indica en el valor que se
	  devuelve  Some simple examples follow:
	</para>
	<code>
	  # Escaneando valores escalares
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)
	  # Escaneando valores de cadena de texto
	  string s = "uno dos"
	  string s1
	  string s2
	  sscanf(s, "%s %s", s1, s2)
	  print s1 s2
	</code>
	<subhead>Escaneando una matriz</subhead>
	<para>
	  El escaneado de matrices debe señalarse mediante la especificación
	  especial de conversión, <quote><lit>%m</lit></quote>. Puedes indicar
	  el número máximo de filas a leer, insertando un número entero entre el
	  signo <quote><lit>%</lit></quote> y la <quote><lit>m</lit></quote>
	  indicativa de matriz. Se permiten dos variantes: que
	  <argname>origen</argname> indique una cadena de texto única que
	  represente una matriz, y que <argname>origen</argname> indique una
	  formación de cadenas de texto. Estas opciones se describen por turno.
	</para>
	<para>
	  Si <argname>origen</argname> es un argumento de cadena de texto única,
	  el escáner lee una línea de la entrada y cuenta el número de campos
	  numéricos (separados por espacios o por tabuladores). Esto define el
	  número de columnas de la matriz. Por defecto, el proceso de lectura
	  continúa con todas las líneas (filas) que contengan el mismo número de
	  columnas numéricas, pero el número máximo de filas puede limitarse
	  mediante el valor entero opcional mencionado antes.
	</para>
	<para>
	  Si <argname>origen</argname> es una formación de cadenas de texto,
	  el resultado va a ser forzosamente un vector columna, del que cada
	  elemento va a ser la conversión numérica de la cadena correspondiente,
	  o <lit>NA</lit> si la cadena de texto no representa un número.
	  A continuación, tienes varios ejemplos:
	</para>
	<code>
	  # Escaneando una única cadena de texto
	  string s = sprintf("1 2 3 4\n5 6 7 8")
	  print s
	  matrix m
	  sscanf(s, "%m", m)
	  print m
	  # Escaneando una formación de cadenas de texto
	  strings S = defarray("1.1", "2.2", "3.3", "4.4", "5.5")
	  sscanf(S, "%4m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con la suma de los cuadrados de las desviaciones
	  respecto a la media (SCT), de las observaciones no ausentes de la
	  serie o vector <argname>y</argname>.
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="stack" section="panel" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">desplazamiento</fnarg>
      </fnargs>
      <description>
	<para>
	  Diseñado para el manejo de datos con formato de series de tiempo
	  apiladas, que necesita GRETL para datos de panel. El valor que se
	  devuelve es una serie que se consigue apilando de forma
	  <quote>vertical</quote>, grupos de <argname>n</argname>
	  observaciones de cada serie de la lista <argname>L</argname>. Por
	  defecto, se usan las primeras <argname>n</argname> observaciones
	  (ello se corresponde con <argname>desplazamiento</argname> = 0),
	  pero puedes trasladar el punto de inicio indicando un valor positivo
	  para <argname>desplazamiento</argname>. Si la serie resultante
	  fuese más larga que el conjunto de datos vigente, se añaden tantas
	  observaciones como sean necesarias.
	</para>
	<para>
	  Con esta función puedes manejar el caso de un archivo de datos que tiene
	  series de tiempo colocadas unas al lado de otras, para un grupo de
	  unidades de sección cruzada. Y también cuando se considera el tiempo
	  en sentido horizontal, y cada fila representa una unidad atemporal.
	</para>
	<para>
	  Consulta la sección titulada <quote>Panel data specifics</quote>
	  en <guideref targ="chap:datafiles"/> para obtener detalles y ejemplos
	  de su utilización.
	</para>
      </description>
    </function>

    <function name="stdize" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-list-or-mat">X</fnarg>
	<fnarg type="int" optional="true">v</fnarg>
	<fnarg type="bool" optional="true">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Por defecto, devuelve un resultado del mismo tipo que el argumento, con
	  la versión tipificada de esa serie, lista o matriz: el argumento se
	  centra y se divide por su desviación típica muestral (con corrección
	  de 1, en los grados de libertad). En caso de que el argumento sea una
	  matriz, los resultados se calculan por columnas.
	</para>
	<para>
	  Puedes usar el segundo argumento (opcional) para modular el resultado.
	  Un valor no negativo de ese <argname>v</argname> permite configurar
	  la corrección en los grados de libertad que se utilizan para la
	  desviación típica; así <argname>v</argname> = 0 solicita utilizar
	  el estimador máximo-verosímil. Como caso especial, si estableces
	  que <argname>v</argname> sea igual a &minus;1, únicamente se va
	  a centrar el primer argumento.
	</para>
	<para>
	  Por defecto, los valores ausentes se obvian en el caso de una entrada
	  de tipo serie o lista, pero no en el caso de una entrada de tipo matriz.
	  Para que se ignoren los valores ausentes en el caso matricial, indica
	  un valor no nulo para <argname>obviar_na</argname>.
	</para>
      </description>
    </function>

    <function name="strfday" section="calendar" output="depends">
      <fnargs>
	<fnarg type="anyfloat">dia_epoca</fnarg>
	<fnarg type="string" optional="true">formato</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función opera como <fncref targ="strftime"/>, convirtiendo un valor
	  numérico en una cadena de texto regida por <argname>formato</argname>,
	  excepto cuando la entrada sea un <quote>día de época</quote> (para cuya
	  definición puedes consultar la función <fncref targ="epochday"/>).
	  Dado que la resolución es de tipo diario, solo se manejan formatos
	  relacionados con fechas; los formatos relacionados con tiempo
	  proporcionan resultados indefinidos.
	</para>
	<para>
	  Si omites el segundo argumento, el formato por defecto se establece
	  en ISO 8601 extendido, <lit>YYYY-MM-DD</lit>.
	</para>
      </description>
    </function>

    <function name="strftime" section="calendar" output="depends">
      <fnargs>
	<fnarg type="anyfloat">tm</fnarg>
	<fnarg optional="true" type="string">formato</fnarg>
	<fnarg optional="true" type="scalar">desplazamiento</fnarg>
      </fnargs>
      <description>
	<para>
	  El argumento <argname>tm</argname> se utiliza para proporcionar
	  el <quote>tiempo Unix</quote>, es decir el número de segundos
	  desde el comienzo del año 1970, de acuerdo con el UTC. El valor
	  que se devuelve es una cadena de texto que proporciona la fecha
	  y/u hora correspondiente, bien en un formato especificado mediante
	  el segundo argumento (opcional) o bien, por defecto, mediante la
	  <quote>representación preferida de fecha y hora en el entorno local vigente</quote>
	  tal como determinaría la biblioteca del sistema C. Mira más abajo para
	  más detalles sobre la especificación del formato.
	</para>
	<para>
	  Puedes usar el argumento <argname>desplazamiento</argname> (opcional)
	  para especificar un desplazamiento en segundos en relación a UTC,
	  seleccionando así una zona horaria diferente a la predeterminada (que
	  es siempre la hora local). Por ejemplo, un desplazamiento de 3600
	  selecciona la Hora Central Europea, mientras que 0 selecciona la GMT.
	  El valor absoluto de <argname>desplazamiento</argname> no debe
	  exceder de 86400 (24 horas).
	</para>
	<para>
	  El tipo concreto que se devuelve, depende del tipo de <argname>tm</argname>:
	  cuando <argname>tm</argname> es un escalar, un vector o una serie,
	  el resultado es una única cadena de texto, un 'array' de cadenas o una
	  serie con cadenas de valores, respectivamente.
	</para>
	<para>
	  Puedes obtener valores apropiados de <argname>tm</argname> para
	  utilizar con esta función mediante el accesor <fncref targ="$now"/>
	  o la función <fncref targ="strptime"/>.
	</para>
	<para>
	  Ten en cuenta que mientras que <argname>tm</argname> se considera
	  en relación al UTC, el resultado predeterminado de esta función es
	  <quote>local</quote> (en relación con la zona horaria establecida en el
	  ordenador servidor). Por eso, un mismo <argname>tm</argname> va a
	  mostrar un tiempo distinto (y quizás una distinta fecha) en zonas
	  horarias diferentes. Pero si quieres una cadena de texto que represente
	  el UTC en lugar del tiempo local, GRETL puede hacerlo; mira más
	  abajo.
	</para>
	<subhead>Opciones de formato</subhead>
	<para>
	  Puedes encontrar las opciones típicas de formato consultando la
	  página sobre <lit>strftime</lit> del manual, en los sistemas que
	  tengan esas páginas; o por medio de uno de los muchos sitios web
	  que presentan información relevante, como por ejemplo
	  <url>https://devhints.io/strftime</url>. Además de los formatos
	  típicos, GRETL reconoce una opción especial : si
	  <argname>formato</argname> es <quote><lit>8601</lit></quote>
	  simplemente, la fecha y el tiempo se presentan en el formato
	  ISO 8601.
  </para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciona un modo de definir valores de cadena de texto para la
	  serie <argname>y</argname>. Para que esto funcione, deben
	  cumplirse dos condiciones: la serie objetivo no debe tener otra
	  cosa que no sean valores enteros positivos (ninguno de ellos menor
	  que 1); y el 'array' <argname>S</argname> debe tener por lo menos
    <math>n</math> elementos, siendo <math>n</math> el mayor valor de
	  <argname>y</argname>. Además, cada elemento de <argname>S</argname>
	  debe tener un formato UTF-8 válido. Si no se cumple alguna de estas
	  condiciones, se presenta un fallo. El valor nominal que devuelve
	  esta función es cero, al completarse con éxito.
	</para>
	<para>
	  Una alternativa a <lit>stringify</lit> que puede ser de utilidad en
	  algunos contextos es la asignación directa de un 'array' de cadenas
	  de texto a una serie: esto genera una serie cuyos valores se toman
	  de la serie de forma secuencial; el número de elementos del 'array'
	  debe ser igual a la longitud total del conjunto de datos o a la
	  longitud del rango de la muestra vigente, y los valores se pueden
	  repetir como sea necesario.
	</para>
	<para>
	  <seelist>
      <fncref targ="strvals"/>
	    <fncref targ="strvsort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string-or-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando <argname>s</argname> es una cadena de texto simple, devuelve
	  el número de caracteres UTF-8 que contiene. Ten en cuenta que esto
	  no es igual al número de bytes, si algunos caracteres están fuera
	  del intervalo de impresión ASCII. Cuando desees obtener el número
	  de bytes, puedes usar la función <fncref targ="nelem"/>. Por ejemplo:
	</para>
	<code>
	  string s = "¡Olé!"
	  printf "strlen(s) = %d, nelem(s) = %d\n", strlen(s), nelem(s)
	</code>
	<para>
	  debería devolver
	</para>
	<code>
	  strlen(s) = 5, nelem(s) = 7
	</code>
	<para>
	  Si el argumento es un 'array' de cadenas de texto, el valor que se devuelve
	  es un vector columna que contiene el número de caracteres de cada cadena.
	  También se acepta que uses como argumento una serie con cadenas de
	  valores; en ese caso, el valor que se devuelve es una serie que contiene el
	  largo de las cadenas de valores a lo largo del rango muestral vigente.
	</para>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Compara las dos cadenas de texto de los argumentos, y devuelve un entero
	  que es menor, igual o mayor que 0 cuando <argname>s1</argname> es
	  (respectivamente) menor, igual o mayor que <argname>s2</argname>,
	  hasta los <argname>n</argname> primeros caracteres. Cuando se omite
	  <argname>n</argname>, la comparación continúa hasta donde resulte
	  posible.
	</para>
	<para>
	  Ten en cuenta que, si solo quieres comprobar si dos cadenas de texto
	  son iguales, puedes hacerlo sin necesidad de utilizar esta función, como
	  con la indicación <lit>if (s1 == s2)...</lit>.
	</para>
      </description>
    </function>

    <function name="strpday" section="calendar" output="depends">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string" optional="true">formato</fnarg>
      </fnargs>
      <description>
	<para>
	 Esta función se comporta similarmente a la función <fncref targ="strptime"/>,
	 excepto en que el valor que se devuelve es de tipo <quote>día de época</quote>
	 (para cuya definición puedes consultar <fncref targ="epochday"/>).
	 Dado que la solución es de tipo diario, se ignora cualquier información
	 que haya en <argname>s</argname>, sobre el momento del día.
	</para>
      </description>
    </function>

    <function name="strptime" section="calendar" output="depends">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string" optional="true">formato</fnarg>
      </fnargs>
      <description>
	<para>
	 Esta función es la recíproca de <fncref targ="strftime"/>. Analiza una
	 o más cadenas de texto que expresan tiempo o fecha, utilizando el
	 <argname>formato</argname> especificado; y devuelve el número de
	 segundos transcurridos desde el inicio de 1970 según el Tiempo Universal
	 Coordinado (UTC). El tipo concreto de valor que se devuelve depende del
	 de <argname>s</argname>: si <argname>s</argname> es una cadena de texto,
	 un 'array' de cadenas o una serie con cadenas de valores, el resultado es
	 un escalar, un vector columna o una serie numérica, respectivamente.
	</para>
	<para>
	  Si omites la opción <argname>formato</argname>, este se establece por
	  defecto en ISO 8601 <quote>extendido</quote>, <lit>YYYY-MM-DD</lit>
	  (lo que se traduce a <quote><lit>%Y-%m-%d</lit></quote> como formato
	  de strptime).
	</para>
	<para>
	  Como caso especial, puedes indicar el primer argumento
	  como un entero de 8 dígitos, conforme al formato de fechas
	  <quote>básico</quote> de ISO 8601, <lit>YYYYMMDD</lit> (o un
	  vector o serie que contenga esos valores). En ese caso, deberás
	  omitir la opción <argname>formato</argname>.
	</para>
	<para>
	  Ten en cuenta que el primer argumento de esta función se considera
	  en relación con la zona horaria que está establecida en el ordenador
	  servidor. Entonces, por ejemplo, la llamada
	</para>
	<code>
	  strptime("13/02/2009 23:31.30", "%d/%m/%Y %H:%M.%S")
	</code>
	<para>
	  va a devolver como resultado 1234567890, si el tiempo de tu sistema
	  está establecido en UTC; pero si lo está en la zona horaria de Europa
	  Central (UTC+01:00), el resultado será 1234564290.
	</para>
	<para>
	  Puedes encontrar las opciones de <argname>formato</argname> si
	  consultas la página sobre <lit>strptime</lit> del manual, en sistemas
	  que dispongan de las mismas; o por medio de uno de los muchos sitios
	  web que presentan información relevante, como por ejemplo
	  <url>http://man7.org/linux/man-pages/man3/strptime.3.html</url>.
	</para>
	<para>
	  El ejemplo de abajo muestra como puedes convertir información
	  de fechas de uno a otro formato.
	</para>
	<code>
	  scalar tm = strptime("Sunday 17/02/19", "%A %d/%m/%y")
	  eval strftime(tm) # Resultado por defecto
	  eval strftime(tm, "%A, %d de %B de %Y")
	</code>
	<para>
	  En el entorno local de España, el resultado es
	</para>
	<code>
	  07/02/2019 0:00:00
	  febrero 07, 2019
	</code>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg optional="true" type="string">sep</fnarg>
	<fnarg optional="true" type="int">i</fnarg>
      </fnargs>
      <description>
	<para>
	  En su funcionamiento básico, con un único argumento, devuelve el 'array' de
	  cadenas de texto que resulta al separar el contenido de <argname>s</argname>
	  conforme a los espacios vacíos que tiene (es decir, conforme a cualquier
	  combinación de los caracteres de espacio, tabulación y/o línea nueva).
	</para>
	<para>
	  Puedes utilizar el segundo argumento (opcional) para especificar
	  el separador que se usa para separar <argname>s</argname>.
	  Por ejemplo...
	</para>
	<code>
	  string Cesta = "Plátano,Manzana,Yaca,Naranja"
	  strings S = strsplit(Cesta,",")
	</code>
	<para>
	  va a separar el primer argumento de la función en un 'array' de cuatro
	  cadenas de texto, usando la coma como elemento separador.
	</para>
	<para>
	  Las secuencias de barra diagonal izquierda para escapar, indicadas
	  mediante <quote><lit>\n</lit></quote>, <quote><lit>\r</lit></quote>
	  y <quote><lit>\t</lit></quote>, se considera que representan una
	  línea nueva, un salto de línea y una tabulación cuando se indican
	  en el argumento opcional <argname>sep</argname>. Si quieres incluir
	  una barra diagonal izquierda literal como carácter separador, debes
	  duplicarla como en <quote><lit>\\</lit></quote>. Ejemplo:
	</para>
	<code>
	  string s = "c:\fiddle\sticks"
	  strings S = strsplit(s, "\\")
	</code>
	<para>
	  Independientemente del separador, a los elementos del 'array' que se
	  devuelve, se les recorta cualquier espacio en blanco al principio o
	  al final. En consecuencia, si <argname>sep</argname> contiene
	  caracteres que no son espacios en blanco, entonces se le quita
	  cualquier espacio al principio o al final.
	</para>
	<para>
	  Cuando indicas un valor entero mayor que cero como tercer argumento,
	  el valor que se devuelve es una única cadena de texto; concretamente, el
	  elemento <argname>i</argname> (en base 1) del 'array' que se generaría
	  de otro modo sin ese tercer argumento. Cuando <argname>i</argname>
	  sea menor que 1, se produce un fallo; pero cuando <argname>i</argname>
	  excede el número de elementos implicados, se devuelve una cadena de
	  texto vacía.
	</para>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="bool">ign_mayus</fnarg>
      </fnargs>
      <description>
	<para>
	  Busca en <argname>s1</argname> la cadena <argname>s2</argname>.
	  En caso de encontrar la cadena de texto, devuelve otra cadena con una copia de la
	  parte de <argname>s1</argname> que comienza con <argname>s2</argname>;
	  en caso contrario, devuelve una cadena de texto vacía.
	</para>
  <para>
          Ejemplo:
  </para>
  <code>
          string s1 = "GRETL es un programa de Econometría"
          string s2 = strstr(s1, "un")
          print s2
  </code>
	<para>
	  Si el argumento opcional <argname>ign_mayus</argname> no es cero,
	  la búsqueda no distinguirá mayúsculas de minúsculas. Por ejemplo:
	</para>
	<code>
	  strstr("Bilbao", "b")
	</code>
	<para>
	  devolve <quote>bao</quote>, pero
	</para>
	<code>
	  strstr("Bilbao", "b", 1)
	</code>
	<para>
	  devolve <quote>Bilbao</quote>.
	</para>
	<para>
	  Si únicamente quieres descubrir si <argname>s1</argname>
	  contiene a <argname>s2</argname> (prueba booleana), consulta
	  <fncref targ="instring"/>.
	</para>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una cadena de texto con una copia de <argname>s</argname>
	  en la que se eliminaron los espacios en blanco del inicio y del final.
	</para>
  <para>
          Ejemplo:
  </para>
  <code>
          string s1 = "    Mucho espacio en blanco.  "
          string s2 = strstrip(s1)
          print s1 s2
  </code>
      </description>
    </function>

    <function name="strsub" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="string">hallada</fnarg>
	<fnarg type="string">substit</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>s</argname> es una cadena única, devuelve una cadena de
	  texto con una copia de <argname>s</argname> en la que se substituyó toda
	  la cadena <argname>hallada</argname> por <argname>substit</argname>.
	  Si <argname>s</argname> es un 'array' de cadenas de texto o una
	  serie que contiene cadenas de valores, esta operación se realiza
	  con cada una de las cadenas del 'array' o de la serie. Consulta
	  también <fncref targ="regsub"/> para otras substituciones más
	  complejas mediante expresiones regulares.
	</para>
  <para>
          Ejemplo:
  </para>
  <code>
          string s1 = "Hola, GRETL!"
          string s2 = strsub(s1, "GRETL", "HANSL")
          print s2
  </code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg optional="true" type="bool">submuestra</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando la serie <argname>y</argname> se compone de cadenas de texto
	  que expresan valores, esta función devuelve por defecto un 'array' que
	  contiene todos esos valores (con independencia del rango muestral que
	  esté vigente), ordenados numéricamente comenzando por el 1. Si está
	  vigente una submuestra del conjunto de datos, puedes proporcionar
	  un valor no nulo para el segundo argumento (opcional) y obtener así
	  un 'array' que contenga solo las cadenas de texto presentes en la
	  submuestra.
	</para>
	<para>
	  Cuando <argname>y</argname> no se compone de cadenas de texto que
	  expresan valores, se devuelve un 'array' de cadenas de texto vacías.
	  <seelist>
            <fncref targ="stringify"/>
	  </seelist>
	</para>
	<para>
	  Una alternativa a <lit>strvals</lit> que puede ser de utilidad en
	  algunos contextos es la asignación directa de una serie con valores
	  de cadenas de texto a un 'array' de cadenas de texto: esto no solo
	  proporciona los valores que sean diferentes, sino todos los valores
	  de la serie en el rango de la muestra vigente.
	</para>
      </description>
    </function>

    <function name="strvsort" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg optional="true" type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Lleva a cabo uno de los dos tipos de reordenación de la serie
	  <argname>y</argname>, que debe constar de valores en cadenas de
	  texto. El valor nominal que se devuelve es 0, cuando se completa con
	  éxito.
	</para>
	<para>
	  Método 1: Si no indicas el segundo argumento, el efecto que se
	  produce es la ordenación de <argname>y</argname> en este sentido: los
	  valores de cadena diferentes se alfabetizan y la serie se recodifica
	  entonces de modo que se asigna el 1 a la primera cadena ordenada, el 2
	  a la segunda, etcétera. Esto puede ser útil, entre otras razones, para
	  asegurar una codificación uniforme para múltiples series que compartan
	  el mismo conjunto de valores en cadenas.
	</para>
	<para>
	  Método 2: Si indicas el segundo argumento, este debe ser un 'array'
	  que contenga exactamente los diferentes valores de <argname>y</argname>
	  en cadenas (y que pueden conseguirse mediante <fncref targ="strvals"/>),
	  pero colocados en un orden preferido. El efecto entonces consiste en
	  una recodificación de la serie de modo que el valor 1 se asigna a la
	  primera cadena de texto de <argname>S</argname>, el valor 2 a la segunda,
	  etcétera. Esto puede ser útil para asegurar que los códigos numéricos
	  <quote>tengan sentido</quote> cuando los valores en cadenas de texto
	  puedan concebirse como naturalmente ordenados.
	</para>
	<para>
	  El principal uso de estos métodos es en el manejo de series con valores
	  en cadenas de texto importadas de fuentes de terceros, como son los
	  archivos con información separada por comas. Para esos datos, GRETL
	  asigna códigos numéricos basados simplemente en el orden en que están
	  las cadenas de texto a lo largo de las filas del archivo. Así, en una
	  serie con valores <lit>bajo</lit>, <lit>medio</lit> y <lit>alto</lit>,
	  se va a asignar a <lit>alto</lit> el código 1 si sucede primero, en
	  lugar de 3 (lo que sería claramente más <quote>natural</quote>).
	  Esto se puede fijar utilizando el Método 2. Además, si dos o más
	  series comparten los mismos valores en cadenas de texto, se van a
	  codificar de modo distinto excepto que suceda que sus valores
	  diferentes aparezcan en el mismo orden en el archivo de datos. Esto
	  se puede fijar mediante cualquiera de los métodos.
	</para>
	<para>
	  <seelist>
	    <fncref targ="stringify"/>
	    <fncref targ="strvals"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
	<fnarg type="int">inicio</fnarg>
	<fnarg type="int">fin</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>s</argname> es una cadena única, devuelve la subcadena
	  del argumento <argname>s</argname>, empezando en el carácter indicado
	  por el entero positivo de <argname>inicio</argname>, y finalizando en
	  el indicado por el de <argname>fin</argname>, ambos incluidos; o desde
	  <argname>inicio</argname> hasta el término de <argname>s</argname> si
	  <argname>fin</argname> es igual a &minus;1. Si el argumento es un 'array'
	  de cadenas de texto o una serie que contiene cadenas de valores, esta
	  operación se realiza con cada una de las cadenas del 'array' o de la serie.
	</para>
  <para>
          Por ejemplo, el código de abajo
  </para>
  <code>
          string s1 = "Hola, GRETL!"
          string s2 = substr(s1, 7, 11)
          print s2
  </code>
  <para>
          proporciona:
  </para>
  <code>
    ? print s2
    GRETL
  </code>
  <para>
          Debes darte cuenta de que, en algunos casos, podrías estar
          deseando intercambiar claridad por concisión, y utilizar operadores
          de reducción e incremento, como en
  </para>
  <code>
          string s1 = "Hola, GRETL!"
          string s2 = s1[7:11]
          string s3 = s1 + 6
          print s2
          print s3
  </code>
  <para>
    lo que te proporcionaría
  </para>
  <code>
    ? print s2
    GRETL
    ? print s3
    GRETL!
  </code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando <argname>x</argname> es una serie, devuelve un escalar con el
	  resultado de sumar las observaciones no ausentes del argumento
	  <argname>x</argname>. Consulta también <fncref targ="sumall"/>.
	</para>
	<para>
	  Cuando <argname>x</argname> es una matriz, devuelve un escalar con el
	  resultado de sumar los elementos de la matriz.
	</para>
	<para>
	  Cuando <argname>x</argname> es una lista de variables, la
	  función devuelve una serie <math>y</math>, en la que cada valor
	  <math>y</math><sub>t</sub> indica la suma de los valores de
	  las variables de la lista en la observación <math>t</math>. Por
	  defecto, la suma se registra como <lit>NA</lit>, si hay algún 
	  valor ausente en <math>t</math>; pero si le das un valor no
	  nulo a <argname>parcial</argname>, cualquier valor no ausente
	  se usará para crear la suma.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el resultado de sumar las observaciones de la serie
	  <argname>x</argname> en la muestra seleccionada, o <lit>NA</lit> si
	  existe algún valor ausente. Utiliza <fncref targ="sum"/> si quieres
	  obtener la suma descartando los valores ausentes.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector fila con las sumas de cada columna de la matriz
	  <argname>X</argname>. Si indicas un valor no nulo para el segundo
	  argumento (opcional), se ignoran los valores ausentes; de otro modo, el
	  resultado es <lit>NA</lit> para cada columna que contenga valores ausentes.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="bool">obviar_na</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna con las sumas de cada fila de la matriz
	  <argname>X</argname>. Si indicas un valor no nulo para el segundo
	  argumento (opcional), se ignoran los valores ausentes; de otro modo, el
	  resultado es <lit>NA</lit> para cada fila que contenga valores ausentes.
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve un vector fila con el resultado de descomponer la matriz
	  <argname>X</argname> en valores singulares.
	</para>
	<para context="tex">
	  Devuelve un vector fila con el resultado de descomponer la matriz $X$
	  de orden $r \times c$, en valores singulares:
	  \[ X = U \left[
	  \begin{array}{cccc}
	  \sigma_1 \\
	  &amp; \sigma_2 \\
	  &amp; &amp; \ddots \\
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \]
	  donde $n = \min(r,c)$. $U$ es $r \times n$ y $V$ es $n \times c$,
	  con $U'U = I$ y $VV' = I$.
	</para>
	<para>
	  Los valores singulares se devuelven en un vector fila. Puedes obtener el
	  vector singular izquierdo <math>U</math> y/o el derecho <math>V</math>
	  indicando valores no nulos en los argumentos 2 y 3, respectivamente.
	  Para cualquier matriz <lit>A</lit>, el código...
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V)
	  B = (U .* s) * V
	</code>
	<para>
	  ... debiera de proporcionar una matriz <lit>B</lit> idéntica a
	  <lit>A</lit> (excepto pequeñas diferencias debida a la precisión de cálculo).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svm" section="nonparam" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="bundle">bparms</fnarg>
	<fnarg type="bundleref" optional="true">bmod</fnarg>
	<fnarg type="bundleref" optional="true">bprob</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función te permite el entrenamiento (y la predicción basada en ella)
	  de una MSV (Máquina de Soporte Vectorial o SVM), utilizando la librería
	  LIBSVM como soporte. El argumento de tipo lista <argname>L</argname>
	  deberá incluir la variable dependiente seguida de las variables
	  independientes; y el 'bundle' <argname>bparms</argname> se utiliza
	  para pasarle opciones al mecanismo de la MSV. El valor que se
	  devuelve es una serie que contiene las predicciones de la MSV.
	  Puedes utilizar los dos argumentos opcionales puntero-bundle para
	  recuperar información adicional después del entrenamiento y/o predicción.
	</para>
	<para>
	  Para obtener más detalles, consulta la documentación PDF para
	  <mnu targ="gretlSVM">gretl + SVM</mnu>.
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con la tangente de <argname>x</argname>.
	  <seelist>
            <fncref targ="atan"/>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) con la tangente hiperbólica de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="atanh"/>
            <fncref targ="cosh"/>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tdisagg" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="series-or-mat">Y</fnarg>
	<fnarg optional="true" type="series-list-or-mat">X</fnarg>
	<fnarg type="scalar">s</fnarg>
	<fnarg optional="true" type="bundle">opciones</fnarg>
	<fnarg optional="true" type="bundle">resultados</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza la desagregación temporal (conversión a una frecuencia mayor)
	  de los datos de tipo serie temporal que haya en <argname>Y</argname>.
	  El argumento <argname>s</argname> proporciona el factor de expansión
	  (por ejemplo, 3 para pasar de trimestrales a mensuales). El argumento
	  <argname>X</argname> puede contener una o más covariantes (que tengan
	  la frecuencia mayor) para ayudar en el proceso de desagregación. Puedes
	  asumir diversas opciones en el argumento <argname>opciones</argname>,
	  y puedes recoger los detalles de la desagregación por medio de
	  <argname> resultados</argname>.
	</para>
	<para>
	  Consulta <guideref targ="chap:tdisagg"/> para obtener más detalles.
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
	<fnarg optional="true" type="scalarref">&amp;det</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna con la solución de un sistema Toeplitz
	  de ecuaciones lineales, es decir <math>Tx = b</math>
	  donde <math>T</math> es una matriz cuadrada cuyo elemento
	  <math>T</math><sub>i,j</sub> es
	  igual a <math>c</math><sub>i-j</sub>
	  cuando <equation status="inline" ascii="i&gt;=j" tex="$i\ge j$"/>, e
	  igual a <math>r</math><sub>j-i</sub>
	  cuando <equation status="inline" ascii="i&lt;=j" tex="$i\le j$"/>.
	  Ten en cuenta que los primeros elementos de los dos vectores
	  <math>c</math> y <math>r</math> deben ser iguales, pues
	  en caso contrario se devuelve un fallo. Cuando se completa con éxito,
	  la ejecución de esta función permite obtener el vector
	  <math>x</math>.
	</para>
	<para>
	  El algoritmo que se utiliza aquí aprovecha la especial estructura de la
	  matriz <math>T</math>, lo que lo hace mucho más eficiente que otros
	  algoritmos no especializados, particularmente para problemas muy
	  largos. Advertencia: En algunos casos, la función podría sugerir
	  falsamente un fallo en la singularidad de la matriz <math>T</math> cuando
	  realmente no es singular; de cualquier modo, este problema no
	  podrá surgir cuando la matriz <math>T</math> sea definida
	  positiva.
	</para>
	<para>
	  Cuando se indica el argumento opcional <argname>det</argname> (en
	  forma de puntero), al finalizar, este va a contener el determinante de
	  <math>T</math>. Por ejemplo, el código:
	</para>
	<code>
	  A = unvech({3;2;1;3;2;3})    # Configura una matriz 3x3 de Toeplitz
	  x = ones(3,1)                # y un vector 3x1
	  print A x
	  eval A\x                     # Soluciona mediante la inversión general
	  eval det(A)                  # Presenta el determinante
	  a = A[1,]
	  d = 0
	  eval toepsolv(a, a, x, &amp;d)   # Utiliza la función específica
	  print d
	</code>
	<para>
	  produce
	</para>
	<code>
A (3 x 3)

  3   2   1
  2   3   2
  1   2   3

x (3 x 1)

  1 
  1 
  1 

     0,25000
 -3,3307e-17
     0,25000

8
     0,25000
  2,7756e-17
     0,25000


d =  8,0000000
	</code>
      </description>
    </function>

    <function name="tolower" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>s</argname> es una cadena única, devuelve una copia de
	  <argname>s</argname>, en la que todas las letras en mayúsculas se
	  convirtieron en minúsculas. Si <argname>s</argname> es un 'array' de
	  cadenas de texto o una serie que contiene cadenas de valores, esta
	  operación se realiza con cada una de las cadenas del 'array' o de la serie.
	</para>
	<para>
          Ejemplo:
	</para>
	<code>
          string s1 = "Hola, GRETL!"
          string s2 = tolower(s1)
          print s2
	</code>
      </description>
    </function>

    <function name="toupper" section="strings" output="asinput">
      <fnargs>
	<fnarg type="all-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Si <argname>s</argname> es una cadena única, devuelve una copia de
	  <argname>s</argname>, en la que todas las letras en minúsculas se
	  convirtieron en mayúsculas. Si <argname>s</argname> es un 'array' de
	  cadenas de texto o una serie que contiene cadenas de valores, esta
	  operación se realiza con cada una de las cadenas del 'array' o de la serie.
	</para>
	<para>
          Ejemplo:
	</para>
	<code>
          string s1 = "Hola, GRETL!"
          string s2 = toupper(s1)
          print s2
	</code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con la traza de la matriz cuadrada <argname>A</argname>,
	  es decir, la suma de los elementos de su diagonal.
	  <seelist>
            <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz que es la traspuesta de <argname>X</argname>. Aviso:
	  Esta función se utiliza raramente. Para trasponer una matriz, en general
	  puedes usar simplemente el operador para trasposición: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trigamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve un resultado del mismo tipo que el argumento con la función trigamma de
	  <argname>x</argname>; es decir, la segunda derivada del logaritmo de la función Gamma.
	</para>
	<para context="tex">
	  Devuelve un resultado del mismo tipo que el argumento con la función trigamma
	  de $x$; es decir, $\frac {\mathrm{d}^2} {\mathrm{d} x^2}\, \log \Gamma(x)$.
	</para>
	<para>
	  <seelist>
            <fncref targ="lngamma"/>
            <fncref targ="digamma"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="trimr" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">tsup</fnarg>
	<fnarg type="int">tinf</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz que es una copia de la matriz <argname>X</argname>
	  en la que se eliminaron las <argname>tsup</argname> filas superiores
	  y las <argname>tinf</argname> filas inferiores. Los dos últimos
	  argumentos no deben ser negativos, y su suma debe ser menor
	  que el total de filas de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typename" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  Una función de conveniencia que combina las funciones
	  <fncref targ="typeof"/> y <fncref targ="typestr"/>, con un pequeño
	  valor añadido. Básicamente, los dos siguientes enunciados serían
	  equivalentes ...
	</para>
	<code>
	  eval typestr(typeof(x))
	  eval typename(x)
	</code>
	<para>
	  ... excepto en que cuando <argname>expr</argname> denomina un
	  'array', <lit>typename</lit> devuelve el tipo específico de 'array', como
	  en
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  eval typestr(typeof(S))  # presenta "array"
	  eval typename(S)         # presenta "strings"
	</code>
      </description>
    </function>

    <function name="typeof" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un código numérico indicando el tipo de <argname>expr</argname>
	  cuando denomina una variable vigente ya definida, especifica un objeto
	  secundario como un elemento de un 'bundle' o un elemento de un 'array',
	  o es una expresión correcta que se pueda colocar en el lado derecho
	  de una operación de asignación. Los códigos son: 1 para un escalar,
	  2 para una serie, 3 para una matriz, 4 para una cadena de texto,
	  5 para un 'bundle', 6 para un 'array' y 7 para una lista. Al devolverse
	  un  valor igual a 0, se indica que <argname>expr</argname> denomina
	  un objeto que no existe o, más generalmente, que fallaría una
	  asignación con <argname>expr</argname> en el lado derecho.
	</para>
	<para>
	  A continuación, algunos ejemplos:
	</para>
	<code>
	  strings S = defarray("foo", "bar")
	  eval typeof(S)            # presenta 6 (array)
	  eval typeof(S[1])         # presenta 4 (cadena de texto)
	  eval typeof(S[7])         # presenta 0 (fuera de límites)
	  eval typeof(S[x])         # presenta 0 (índice incorrecto)
	  eval typeof(1+1)          # presenta 1 (escalar)
	  eval typeof(sqrt("foo"))  # presenta 0 (incorrecto)
	</code>
	<para>
	  Se puede utilizar la función <fncref targ="typestr"/> para conseguir
	  la cadena de texto que se corresponde con el valor que se devuelve con
	  <lit>typeof</lit>; aunque si únicamente quieres el resultado de la
	  cadena, <fncref targ="typename"/> puede ser una alternativa más
	  conveniente.
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">codigotipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado un código de tipo del GRETL (por ejemplo, obtenido mediante
	  <fncref targ="typeof"/> o <fncref targ="inbundle"/>), devuelve una
	  cadena de texto que indica el nombre de ese tipo. La asignación de
	  códigos a cadenas de texto es: 1 = <quote>scalar</quote> (escalar),
	  2 =  <quote>series</quote> (serie), 3 = <quote>matrix</quote> (matriz),
	  4 = <quote>string</quote> (cadena de texto), 5 = <quote>bundle</quote>,
	  6 = <quote>array</quote>, 7 = <quote>list</quote> (lista), y
	  0 = <quote>null</quote> (nulo).
	</para>
	<para>
	  Consulta también <fncref targ="typename"/> como alternativa.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie que se genera con una variable pseudoaleatoria
	  Uniforme que toma valores dentro del intervalo (<argname> a</argname>,
	  <argname>b</argname>) o, si no indicas esos argumentos, en el
	  intervalo (0,1). El algoritmo que se utiliza por defecto es el
	  <quote>SIMD-oriented Fast Mersenne Twister</quote> desarrollado por 
	  <cite key="saito_matsumoto08">Saito y Matsumoto (2008)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="normal"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector que contiene los distintos elementos no ausentes
	  del argumento <argname>x</argname> sin ningún orden especial, sino en
	  el que están en <argname>x</argname>. Consulta <fncref targ="values"/>
	  para la variante de esta función que devuelve los valores ordenados.
	</para>
      </description>
    </function>

    <function name="unvech" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Si omites el segundo argumento, devuelve la matriz simétrica de orden
	  <by r="n" c="n"/> que se obtiene reordenando los elementos del vector
	  <math>v</math> en forma de matriz triangular inferior, y copiando los
	  de las posiciones simétricas. El número de elementos de <math>v</math>
	  debe ser un entero triangular, o sea, un número <math>k</math> tal que
	  exista un entero <math>n</math> que cumpla la siguiente propiedad:
	  <equation status="inline" ascii="k = n(n+1)/2" tex="$k = n(n+1)/2$"/>.
	  Esta función es la inversa de <fncref targ="vech"/>.
	</para>
	<para>
	  Si indicas el argumento <argname>d</argname>, la función devuelve
	  una matriz <by r="(n+1)" c="(n+1)"/>, con las posiciones fuera de la
	  diagonal principal ocupadas con los elementos de <math>v</math>, como
	  en el caso anterior. Por el contrario, todos los elementos de la diagonal
	  principal se establece que sean iguales a <argname>d</argname>.
	</para>
	<para>
        Ejemplo:
	</para>
    <code>
        v = {1;2;3}
        matrix uno = unvech(v)
        matrix dos = unvech(v, 99)
        print uno dos
    </code>
    <para>
      devuelve
    </para>
    <code>
      uno (2 x 2)

      1   2
      2   3

      dos (3 x 3)

      99     1     2
       1    99     3
       2     3    99
    </code>
	<para>
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matrix" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devuelve una matriz triangular superior de orden <by r="n" c="n"/>. Los
	  elementos de la diagonal y los de arriba de esta, son iguales a los elementos que
	  se corresponden en <argname>A</argname>; los demás son iguales a cero.
	</para>
	<para context="tex">
	  Devuelve una matriz triangular superior <math>B</math> de orden
	  $n\times n$ donde $B_{ij} = A_{ij}$ si $i \le j$, y 0 en otro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con la probabilidad asociada (<math>P</math>) al
	  valor del estadístico para hacer el contraste de raíces unitarias de
	  Dickey-Fuller o el contraste de cointegración de Engle&ndash;Granger,
	  de acuerdo con <cite key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  Los argumentos se expresan de este modo: <argname>tau</argname> indica
	  el valor del estadístico de contraste que corresponda; <argname>n</argname>
	  señala el número de observaciones (o 0 si lo que quieres es un resultado
	  asintótico);<argname>niv</argname> denota el número de variables
	  potencialmente cointegradas, si compruebas la cointegración (o 1 si haces
	  un contraste univariante de raíces unitarias); e <argname>itv</argname>
	  es un código que especifica el tipo modelo (1 = sin constante, 2 = con
	  constante, 3 = con constante más tendencia lineal, 4 = con constante más
	  tendencia cuadrada).
	</para>
	<para>
	  Ten en cuenta que debes darle un valor de 0 a <argname>n</argname>
	  para obtener un resultado asintótico, si la regresión auxiliar para el
	  contraste es <quote>aumentada</quote> con retardos de la variable dependiente.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="qlrpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector que contiene los distintos elementos del argumento
	  <argname>x</argname> ordenados de forma ascendente, ignorando
	  cualquiera de los valores ausente. Si quieres descartar la parte
	  decimal antes de aplicar esta función, utiliza la expresión
	  <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="uniq"/>
            <fncref targ="dsort"/>
            <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando <argname>x</argname> es una serie, devuelve un escalar con
	  su varianza muestral, descartando cualquier observación ausente.
	</para>
	<para>
	  Cuando <argname>x</argname> es una lista, devuelve una serie
	  <math>y</math> en la que cada valor <math>y</math><sub>t</sub>
	  indica la varianza muestral de los valores de las variables
	  de la lista en la observación <math>t</math>. Por defecto, la
	  varianza se registra como <lit>NA</lit>, si hay algún valor
	  ausente en <math>t</math>; pero si le das un valor no nulo
	  a <argname>parcial</argname>, cualquier valor no ausente se
	  usará para crear el estadístico.
	</para>
	<para>
	  En cada uno de esos casos, la suma de los cuadrados de las desviaciones con
	  respecto a la media se divide por (<math>n</math> &minus; 1) cuando
	  <math>n</math> &gt; 1. En otro caso, se indica que la varianza es igual
	  a cero si <math>n</math> = 1, o es igual a <lit>NA</lit> si
	  <math>n</math> = 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Cuando se indica un número entero como argumento, la función devuelve
	  una cadena de texto con el nombre de la variable que tiene un número ID igual a
	  <argname>v</argname>, o genera un fallo si esa variable no existe.
	</para>
	<para>
	  Cuando se indica una lista como argumento, devuelve una cadena de
	  texto que contiene los nombres de las variables de la lista, separados por
	  comas. Si indicas una lista que está vacía, se devuelve una cadena
	  de texto vacía. En su lugar, puedes utilizar <fncref targ="varnames"/>
	  para obtener un 'array' de cadenas de texto .
	</para>
    <para>
        Ejemplo:
    </para>
    <code>
        open broiler.gdt
        string s = varname(7)
        print s
    </code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un 'array' de cadenas de texto que contiene los nombres de las
	  variables de la lista <argname>L</argname>. Si la lista que indicas
	  está vacía, se devuelve un 'array' vacío.
	</para>
    <para>
        Ejemplo:
    </para>
    <code>
        open keane.gdt
        list L = year wage status
        strings S = varnames(L)
        eval S[1]
        eval S[2]
        eval S[3]
    </code>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nombrevar</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un número entero con el código ID de la variable que tiene el nombre
	  del argumento <argname>nombrevar</argname>, o NA si esa variable
	  no existe.
	</para>
      </description>
    </function>

    <function name="varsimul" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz al simular un VAR de orden <math>p</math> y
	  <math>n</math> variables, es decir
	  <equation status="inline"
		    ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)."
		    tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
	  La matriz <argname>A</argname> de coeficientes se forma agrupando
	  horizontalmente las matrices <math>A</math><sub>i</sub>; y es de
	  orden <by r="n" c="np"/>, con una fila por cada ecuación. Esta
	  se corresponde con las primeras <math>n</math> filas de la matriz
	  <lit>$compan</lit> que proporcionan las instrucciones <lit>var</lit> y
	  <lit>vecm</lit>.
	</para>
	<para>
	  Los vectores <math>u_t</math> están incluidos (como filas) en la matriz
	  <argname>U</argname> (<by r="T" c="n"/>). Los valores iniciales están
	  en <argname>y0</argname> (<by r="p" c="n"/>).
	</para>
	<para>
	  Cuando el VAR contiene algún término determinista y/o regresores
	  exógenos, puedes manejarlos incorporándolos a la matriz
	  <argname>U</argname>: en este caso cada fila de <argname>U</argname>
	  pasa a ser entonces
	  <equation status="inline"
		    ascii="u(t) = B'x(t) + e(t)."
		    tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  La matriz que resulta tiene <math>T</math> + <math>p</math> filas y
	  <math>n</math> columnas; contiene los <math>p</math> valores iniciales
	  de las variables endógenas, además de <math>T</math> valores
	  simulados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$compan"/>
            <cmdref targ="var"/>
            <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matrix" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un vector columna, apilando las columnas de <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matrix" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg optional="true" type="bool">omitir-diag</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función vuelve a ordenar en un vector columna, los elementos de la
	  matriz <argname>A</argname> que están en la diagonal principal y por
	  encima de ella, excepto que le asignes un valor no nulo a la opción
	  <argname>omitir-diag</argname>, en cuyo caso solo se tienen en cuenta
	  las posiciones por encima.
  </para>
	<para>
	  Normalmente esta función se utiliza con matrices simétricas, en
	  cuyo caso, esa operación puede revertirse mediante la función
	  <fncref targ="unvech"/>. Si la matriz de entrada no es simétrica y su
	  triángulo inferior contiene los valores <quote>correctos</quote>,
	  puedes obtener el resultado deseado por medio de <lit>vech(A')</lit>
	  (aunque sus elementos puede que necesiten volver a ordenarse
	  de nuevo).
	  <seelist>
            <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vma" section="timeseries" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix" optional="true">K</fnarg>
	<fnarg type="int" optional="true">horizonte</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función genera una matriz con la representación VMA de un sistema
	  VAR. Si <math>u</math><sub>t</sub> son los residuos de las predicciones
	  adelantadas un paso y
	  <equation status="inline" ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)"
	  tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$"/>,
	  la correspondiente representación VMA es
	  <equation status="inline" ascii="y(t) = C0 e(t) + C1 e(t-1) + ..."
	  tex="$y_t = C_0 e_t + C_1 e_{t-1} + \ldots$."/>.
	  La relación entre <math>u</math><sub>t</sub> (residuos de
	  predicciones) y <math>e</math><sub>t</sub> (impactos estructurales) será
	  <equation status="inline" ascii="u(t) = K e(t)" tex="$u_t = K e_t$"/>.
	  (Observa que <math>C</math><sub>0</sub> =
	  <math>K</math>.)
	</para>
	<para>
	  La matriz <argname>A</argname> de coeficientes del primer argumento,
	  se forma apilando las matrices <math>A</math><sub>i</sub> de forma
	  horizontal; tendrá rango <by r="n" c="np"/>, con una fila por cada
	  ecuación. Esto se corresponde con las primeras <math>n</math> filas
	  de la matriz <lit>$compan</lit> que proporcionan las instrucciones
	  <lit>var</lit> y <lit>vecm</lit> de GRETL. La matriz <argname>K</argname>
	  es opcional, indicando por defecto la matriz identidad.
	</para>
	<para>
	  La matriz que devuelve esta función tiene un número de filas igual a
	  <argname>horizonte</argname>, y <math>n</math><sup>2</sup> columnas:
	  cada <math>i</math>-ésima fila contiene <math>C</math><sub>i-1</sub>
	  en formato vectorial. El valor de <argname>horizonte</argname> se
	  establece por defecto igual a 24, cuando no se indique.
	</para>
	<para>
	  <seelist>
            <fncref targ="irf"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">año</fnarg>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">día</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve el día de la semana (de Domingo = 0 hasta Sábado=6) de la fecha
	  especificada por los tres argumentos, o <lit>NA</lit> si la fecha
	  no es correcta. Ten en cuenta que los tres argumentos deben ser
	  del mismo tipo; o sea, deben ser todos de tipo escalar (entero)
	  o todos de tipo serie.
	</para>
	<para>
	  También se admite una solicitud alternativa: cuando se indica un
	  único argumento, se considera que es una fecha (o una serie de
	  fechas) en formato numérico <quote>básico</quote> ISO 8601,
	  <lit>YYYYMMDD</lit>. De este modo, las siguientes dos solicitudes
	  generan el mismo resultado, concretamente 2 (martes).
	</para>
	<code>
	  eval weekday(1990, 5, 1)
	  eval weekday(19900501)
	</code>
	<para>
	  Una alternativa habitual de numeración de los días de la semana va
	  desde Lunes = 1 hasta Domingo = 7. Si tienes una serie denominada
	  <lit>wd</lit> obtenida mediante la función <lit>weekday</lit>, y
	  quieres convertirla a la alternativa, puedes hacer
	</para>
	<code>
	  altwd = wd == 0 ? 7 : wd
	</code>
	<para>
	  Ten en cuenta que si únicamente añades 1 a <lit>wd</lit>, obtienes
	  una numeración que es válida pero no estándar; concretamente
	  de Domingo = 1 a Sábado = 7.
	</para>
      </description>
    </function>

    <function name="wmean" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica la media ponderada de los
	  valores (en la observación <math>t</math>) de las variables presentes en la
	  lista <argname>Y</argname>, con las respectivas ponderaciones señaladas
	  por los valores de las variables que forman la lista <argname>W</argname>
	  en cada <math>t</math>. Las ponderaciones pueden así variar con el tiempo.
	  Las listas <argname>Y</argname> y <argname>W</argname> de variables
	  deben tener el mismo tamaño, y las ponderaciones deben ser no
	  negativas.
	</para>
	<para>
	  Por defecto, el resultado es <lit>NA</lit>, si hay algún valor
	  ausente en la observación <math>t</math>; pero si le das un
	  valor no nulo a <argname>parcial</argname>, se utilizará
	  cualquier valor no ausente.
	</para>
	<para>
	  <seelist>
            <fncref targ="wsd"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wsd" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica la desviación típica ponderada
	  muestral, de los valores (en la observación <math>t</math>) de las variables
	  presentes en la lista <argname>Y</argname>, con las respectivas ponderaciones
	  señaladas por los valores de las variables de la lista <argname>W</argname>
	  en cada <math>t</math>. Las ponderaciones pueden así variar con el tiempo.
	  Las listas <argname>Y</argname> y <argname>W</argname> de variables
	  deben tener el mismo tamaño, y las ponderaciones deben ser no
	  negativas.
	</para>
	<para>
	  Por defecto, el resultado es <lit>NA</lit>, si hay algún valor
	  ausente en la observación <math>t</math>; pero si le das un
	  valor no nulo a <argname>parcial</argname>, se utilizará
	  cualquier valor no ausente.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wvar" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
	<fnarg type="bool" optional="true">parcial</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica la varianza ponderada muestral,
	  de los valores (en la observación <math>t</math>) de las variables presentes en la
	  lista <argname>Y</argname>, con las respectivas ponderaciones señaladas
	  por los valores de las variables que forman la lista <argname>W</argname>
	  en cada <math>t</math>. Las ponderaciones pueden así variar con el tiempo.
	  Las listas <argname>Y</argname> y <argname>W</argname> de variables
	  deben tener el mismo tamaño, y las ponderaciones deben ser no
	  negativas.
	</para>
	<para>
	  Por defecto, el resultado es <lit>NA</lit>, si hay algún valor
	  ausente en la observación <math>t</math>; pero si le das un
	  valor no nulo a <argname>parcial</argname>, se utilizará
	  cualquier valor no ausente.
	</para>
	<para context="tex">
	  La varianza ponderada muestral se calcula mediante
	  \[ s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} \]
	  donde $n'$ indica el número de ponderaciones no nulas y $\bar{x}_w$
	  indica la media ponderada.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wsd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmax" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el mayor valor que resulta de comparar
	  <argname>x</argname> e <argname>y</argname>. Si alguno de los
	  valores está ausente, se devuelve <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmin"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmin" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un escalar con el menor valor que resulta de comparar
	  <argname>x</argname> e <argname>y</argname>. Si alguno de los
	  valores está ausente, se devuelve <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmax"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmlget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string-or-strings">ruta</fnarg>
	<fnarg optional="true" type="scalarref">&amp;coincidencias</fnarg>
      </fnargs>
      <description>
	<para>
	  El argumento <argname>buf</argname> debe ser un buffer
	  XML, tal como puede recuperarse de un lugar web adecuado
	  mediante la función <fncref targ="curl"/> (o leerse de un
	  archivo mediante la función <fncref targ="readfile"/>);
	  y el argumento <argname>ruta</argname> debe ser una
	  especificación XPath sencilla o un 'array' de ellas.
	</para>
	<para>
	  Esta función devuelve una cadena de texto que representa los datos
	  encontrados en el buffer XML en la ruta especificada. Si hay múltiples nodos
	  que coincidan con la expresión de la ruta, las unidades de datos se
	  presentan una por cada línea de la cadena que se devuelve. Cuando indicas
	  un 'array' de rutas como segundo argumento, la cadena que se devuelve
	  tiene la forma de un buffer separado con comas, cuya columna <math>i</math>
	  contiene las coincidencias de la ruta <math>i</math>. En este caso, si una
	  cadena obtenida del buffer XML contiene algún espacio o coma, se
	  entrecomilla.
	</para>
	<para>
	  Por defecto, se muestra un fallo si <argname>ruta</argname> no
	  coincide en el buffer XML; pero este comportamiento se modifica
	  si indicas el tercer argumento (opcional) pues, en este
	  caso, el argumento recupera un recuento de las coincidencias, devolviéndose
	  una cadena vacía si no hay ninguna. Llamada de ejemplo:
	</para>
	<code>
	  ngot = 0
	  ret = xmlget(xbuf, "//some/thing", &amp;ngot)
	</code>
	<para>
	  Ahora bien, todavía se va a mostrar un fallo en caso de hacer una solicitud
	  mal configurada.
	</para>	
	<para>
	  Puedes encontrar una buena introducción al uso y a la sintaxis de
	  XPath en
	  <url>https://www.w3schools.com/xml/xml_xpath.asp</url>.
	  El programa de soporte (back-end) para <lit>xmlget</lit>
	  lo proporciona el módulo xpath de libxml2, que admite
	  XPath 1.0 pero no XPath 2.0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="jsonget"/>
	    <fncref targ="readfile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeromiss" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve un resultado (del tipo del argumento) cambiando los ceros por
	  <lit>NA</lit>s. Si <argname>x</argname> es una serie o una matriz,
	  la conversión se hace elemento a elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matrix" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devuelve una matriz nula con <math>r</math> filas y <math>c</math>
	  columnas. Si lo omites, el número de columnas se establece en 1
	  (vector columna), por defecto.
      <seelist>
        <fncref targ="ones"/>
        <fncref targ="seq"/>
      </seelist>
    </para>
      </description>
    </function>

  </funclist>
</funcref>
