\chapter{Operazioni con le matrici}
\label{chap-matrices}

\section{Introduzione}
\label{matrix-intro}

A partire dalla versione 1.5.1, gretl offre la possibilità di creare e
manipolare matrici definite dall'utente. La versione 1.6.1 contiene alcune
modifiche a questa funzionalità.

\section{Creazione di matrici}
\label{matrix-create}

È possibile creare una matrice usando uno dei quattro metodi seguenti:

\begin{enumerate}
\item Specificando direttamente i valori scalari che compongono la matrice,
  in forma numerica o per riferimento a variabili scalari preesistenti, o in un
  modo misto;
\item fornendo una lista di serie di dati;
\item fornendo una \textit{lista personalizzata} di serie;
\item usando una formula simile a quelle usate con il comando
  \texttt{genr}, in cui una nuova matrice viene definita in termini di matrici
  e/o scalari esistenti, oppure attraverso funzioni speciali.
\end{enumerate}

Per specificare una matrice \textit{direttamente in termini di scalari}, la
sintassi è la seguente:

\begin{code}
matrix A = { 1, 2, 3 ; 4, 5, 6 }
\end{code}

La matrice viene definita per righe successive; gli elementi di ogni riga sono
separati da virgole e le righe sono separate da punti e virgola. L'intera
espressione va racchiusa tra parentesi graffe. Gli spazi tra le parentesi non
sono significativi. L'espressione vista sopra definisce una matrice $2\times3$.
Ogni elemento deve essere un valore numerico, il nome di una variabile scalare
preesistente, o un'espressione che, valutata, produce uno scalare.
Per ottenere la matrice trasposta, basta aggiungere un apostrofo
(\texttt{'}) direttamente dopo la parentesi graffa che chiude l'espressione.

Per specificare una matrice \textit{in termini di serie di dati} la sintassi è
la seguente:
%
\begin{code}
matrix A = { x1, x2, x3 }
\end{code}
%
dove i nomi delle variabili sono separati da virgole. Oltre ai nomi di variabili
esistenti, è possibile usare espressioni che producono una serie una volta
valutate. Ad esempio, data una serie \texttt{x}, si può scrivere
%
\begin{code}
matrix A = { x, x^2 }
\end{code}
%

Per impostazione predefinita, ogni variabile rappresenta una colonna (e può
esserci solo una variabile per ogni colonna). L'intervallo dei valori dei dati
inclusi nella matrice dipende dall'impostazione corrente dell'intervallo del
campione.

Si noti che mentre le funzioni statistiche di gretl sono in grado di gestire
valori mancanti, ciò non vale per le funzioni che trattano le matrici:
\emph{quando si costruisce una matrice partendo da serie che contengono valori
mancanti, le osservazioni per cui almeno una delle serie contiene valori
mancanti sono saltate}.

Invece di fornire una lista esplicita di variabili, è possibile fornire il
\textit{nome di una lista personalizzata} (si veda il capitolo~\ref{persist}),
come nell'esempio seguente:
%
\begin{code}
list xlist = x1 x2 x3
matrix A = { xlist }
\end{code}
%
Se si usa il nome di una lista, le serie che la costituiscono vengono usate per
comporre le colonne, come risulta naturale in un contesto econometrico; se si
vuole che vengano usate come righe, basta usare il simbolo di trasposizione.

Un caso speciale di costruzione di una matrice usando una lista di variabili
è il seguente:
%
\begin{code}
matrix A = { dataset }
\end{code}
%
In questo modo, si costruisce una matrice usando tutte le serie del dataset
corrente, salvo la costante (variabile 0).

È possibile creare nuove matrici, o sostituire matrici esistenti, usando varie
trasformazioni, come per gli scalari e le serie di dati. I prossimi paragrafi
spiegano nel dettaglio questi meccanismi.

\tip{I nomi delle matrici devono soddisfare gli stessi requisiti dei nomi delle
variabili in gretl: il nome non può essere più lungo di 15 caratteri, deve
iniziare per una lettera e deve essere composto da lettere, numeri e il
carattere trattino basso.}

\section{Operatori matriciali}
\label{matrix-op}

Per le matrici sono disponibili i seguenti operatori binari:

\begin{center}
\begin{tabular}{ll}
\texttt{+} & addizione \\
\texttt{-} & sottrazione \\
\texttt{*} & moltiplicazione matriciale \\
\texttt{/} & ``divisione'' matriciale (si veda oltre) \\
\texttt{.*} & moltiplicazione per elementi \\
\texttt{'} & moltiplicazione per la trasposta \\
\texttt{./} & divisione per elementi \\
\verb+.^+ & elevazione a potenza per elementi \\
\verb+~+ & concatenazione per colonne \\
\texttt{**} & prodotto di Kronecker \\
\texttt{=} & test per l'uguaglianza 
\end{tabular}
\end{center}

Ecco qualche spiegazione per i casi meno ovvi.

Per l'addizione e la sottrazione matriciale, in generale le due matrici
devono avere le stesse dimensioni, salvo il caso in cui uno dei termini
è una matrice $1\times 1$ o uno scalare. In questo caso, lo scalare viene
implicitamente trasformato in una matrice con le corrette dimensioni, i cui
elementi sono tutti pari al valore dello scalare. Ad esempio, se
$A$ è una matrice $m \times n$ e $k$ è uno scalare, i comandi
%
\begin{code}
matrix C = A + k
matrix D = A - k
\end{code}
%
producono entrambi delle matrici $m \times n$, con elementi $c_{ij} = 
+a_{ij} + k$ e $d_{ij} = a_{ij} - k$ rispettivamente.
 
Per ``moltiplicazione per la trasposta'' si intende, ad esempio, che
%
\begin{code}
matrix C = X'Y
\end{code}
%
ha come risultato il prodotto fra $X$-trasposta e $Y$.  In effetti, 
l'espressione \texttt{X'Y} ha lo stesso significato di \texttt{X'*Y}
(che pure è un comando valido).

La ``divisione'' tra matrici, $A/B$ è algebricamente equivalente a $B^{-1}A$
(pre-moltiplicazione per mezzo dell'inversa del ``divisore''). Quindi in linea
di principio le due espressioni seguenti sono equivalenti:
%
\begin{code}
matrix C = A / B
matrix C = inv(B) * A
\end{code}
%
dove \texttt{inv()} è la funzione di inversione tra matrici (si veda oltre).
Però la prima forma può essere più accurata della seconda, perché la soluzione è
ottenuta tramite la scomposizione LU, senza calcolare esplicitamente la matrice
inversa.

Nella moltiplicazione per elementi, scrivendo
%
\begin{code}
matrix C = A .* B
\end{code}
% 
il risultato dipende dalle dimensioni di $A$ e $B$. Se $A$ è una matrice
$m \times n$ e $B$ è una matrice $p \times q$.  
%
\begin{itemize}
\item Se $m=p$ e $n=q$, $C$ sarà una matrice $m\times n$ con $c_{ij} = a_{ij}
  \times b_{ij}$. Questo tipo di prodotto è tecnicamente noto come
  \emph{prodotto di Hadamard}.
\item Se $m=1$ e $n=q$, oppure $n=1$ e $m=p$, $C$ sarà una matrice
  $p\times q$ con $c_{ij} = a_k \times b_{ij}$, dove $k=j$ se $m=1$,
  altrimenti $k=i$.
\item Se $p=1$ e $n=q$, oppure $q=1$ e $m=p$, $C$ sarà una matrice
  $m\times n$ con $c_{ij} = a_{ij} \times b_k$, dove $k=j$ se $p=1$,
  altrimenti $k=i$.
\item Se non è soddisfatta alcuna delle condizioni precedenti, il prodotto non è
  definito e viene segnalato un errore.
\end{itemize}
 
Per una variante della moltiplicazione per elementi che può essere utile in
alcuni contesti, si veda anche la funzione \texttt{colmult()} descritta in
seguito (pagina~\pageref{matrix-two}).

La divisione per elementi funziona in modo simile alla moltiplicazione per elementi,
sostituendo $\times$ con $\div$ nella spiegazione precedente.

L'elevamento a potenza per elementi, come in
%
\begin{code}
matrix C = A .^ k
\end{code}
% 
produce $c_{ij} = a_{ij}^k$. La variabile $k$ deve essere uno scalare o una
matrice $1\times 1$.

Nella concatenazione tra una matrice $A$ $m\times n$ e una matrice $B$ $m\times
p$, il risultato è una matrice $m\times (n+p)$. Ossia,
%
\begin{code}
C = A ~ B
\end{code}
% 
produce $C = \left[ \begin{array}{cc} A & B \end{array} \right]$.

\section{Funzioni matriciali}
\label{matrix-func}

Sono disponibili le seguenti funzioni per \textit{la trasformazione
elemento per elemento} delle matrici: \texttt{log}, \texttt{exp},
\texttt{sin}, \texttt{cos}, \texttt{tan}, \texttt{atan}, \texttt{int},
\texttt{abs}, \texttt{sqrt}, \texttt{dnorm}, \texttt{cnorm},
\texttt{qnorm}, \texttt{gamma} e \texttt{lngamma}. Queste funzioni operano in
modo analogo a quando sono usate nel contesto del comando \texttt{genr}.  Ad
esempio, se una matrice \texttt{A} è già stata definita,
%
\begin{code}
matrix B = sqrt(A)
\end{code}
%
genera una matrice tale che $b_{ij} = \sqrt{a_{ij}}$.  Tutte queste
funzioni richiedono una sola matrice come argomento, o un'espressione
che si risolve in una singola matrice.

Le funzioni \texttt{sort()} e \texttt{dsort()} utilizzabili con le serie di
dati, possono essere usate anche con le matrici. In questo caso,
l'argomento di queste funzioni deve essere un vettore ($p \times 1$ o
$1\times p$).  Il valore restituito è un vettore che contiene gli elementi del
vettore originale riordinati in ordine di grandezza crescente (\texttt{sort})
o decrescente (\texttt{dsort}).

Infine, ci sono funzioni dedicate in modo specifico alle matrici, che è
possibile suddividere in quattro categorie:
%
\begin{enumerate}
\item Quelle che richiedono come argomento una sola matrice e producono uno scalare.
\item Quelle che richiedono come argomento una sola matrice (e in alcuni casi un parametro aggiuntivo) e producono una matrice.
\item Quelle che richiedono come argomento uno o due valori e producono una matrice.
\item Quelle che richiedono come argomento due matrici e producono una matrice.
\item Quelle che richiedono come argomento una o due matrici e producono una o due matrici.
\end{enumerate}
%
Questi gruppi di funzioni vengono presentati nell'ordine.

\subsection{Funzioni da matrice a scalare}
\label{matrix-to-scalar}

Le funzioni che richiedono come argomento una sola matrice e producono uno
scalare sono:

\begin{center}
\begin{tabular}{ll}
\texttt{det()} & determinante \\
\texttt{ldet()} & log-determinante \\
\texttt{tr()} & traccia \\
\texttt{onenorm()} & norma-1 \\
\texttt{rcond()} & reciproco del numero di condizione \\
\texttt{rows()} & numero di righe \\
\texttt{cols()} & numero di colonne 
\end{tabular}
\end{center}

L'argomento di queste funzioni può essere il nome di una matrice esistente o
un'espressione che si risolve in una matrice. Si noti che le funzioni
\texttt{det}, \texttt{ldet} e \texttt{tr} richiedono una matrice quadrata.

La funzione \texttt{onenorm} restituisce la norma-1 di una matrice, ossia
il massimo tra le colonne della matrice della somma dei valori assoluti degli
elementi della colonna. La funzione \texttt{rcond} restituisce il reciproco del
numero di condizione per una matrice simmetrica definita positiva.

\subsection{Funzioni da matrice a matrice}
\label{matrix-to-matrix}

Le funzioni che richiedono come argomento una sola matrice e producono una
matrice sono:

\begin{center}
\begin{tabular}{ll}
\texttt{sumc()} & somma per colonna \\
\texttt{sumr()} & somma per riga \\
\texttt{meanc()} & media per colonna \\
\texttt{meanr()} & media per riga \\
\texttt{mcov()} & matrice di covarianza per colonne \\
\texttt{mcorr()} & matrice di correlazione per colonne \\
\texttt{inv()} & inversa \\
\texttt{cholesky()} & scomposizione di Cholesky \\
\texttt{diag()} & diagonale principale \\
\texttt{transp()} & trasposta \\
\texttt{cdemean()} & sottrazione della media delle colonne \\
\texttt{vec()} & organizza gli elementi come vettore colonna \\
\texttt{vech()} & organizza gli elementi del triangolo inferiore come vettore colonna \\
\texttt{unvech()} & annulla l'operazione \texttt{vech} \\
\texttt{mlag()} & ritardo o anticipo per le matrici
\end{tabular}
\end{center}

Come per il gruppo precedente di funzioni, l'argomento deve essere il nome di
una matrice esistente o un'espressione che si risolve in una matrice.

Per una matrice $A$ con $m$ righe e $n$ colonne, \texttt{sumc(A)}
produce un vettore riga con le $n$ somme per colonna, mentre \texttt{sumr(A)}
produce un vettore colonna con le $m$ somme per riga. \texttt{meanc(A)}
produce un vettore riga con le $n$ medie per colonna e \texttt{meanr(A)}
un vettore colonna con le $m$ medie per riga.

Per una matrice $A$ con $T$ righe e $k$ colonne, \texttt{mcov(A)} e
\texttt{mcorr(A)} producono entrambe delle matrici simmetriche $k \times k$,
nel primo caso contenenti le varianze (sulla diagonale) e le covarianze delle
variabili nelle colonne di $A$, e nel secondo caso, le correlazioni delle
variabili.

La funzione \texttt{cholesky} calcola la scomposizione di Cholesky
$L$ di una matrice simmetrica definita positiva $A$: $A = LL'$; $L$ è
triangolare inferiore (contiene zeri al di sopra della diagonale).

La funzione \texttt{diag} restituisce la diagonale principale di una matrice
$n\times n$ $A$ come vettore colonna, ossia come vettore $n$-dimensionale $v$
tale che $v_i = a_{ii}$.

La funzione \texttt{cdemean} applicata a una matrice $A$ $m \times n$
restituisce una matrice $B$ $m \times n$ tale che $b_{ij} = a_{ij} -
\bar{A}_j$, dove $\bar{A}_j$ indica la media della colonna $j$ di $A$.  

La funzione \texttt{vec} applicata a una matrice $A$ $m \times n$
restituisce un vettore colonna di lunghezza $mn$ formato impilando le
colonne di $A$.

La funzione \texttt{vech} applicata a una matrice $A$ $n \times n$
restituisce un vettore colonna di lunghezza $n(n+1)/2$ formato impilando
gli elementi del triangolo inferiore di $A$, colonna per colonna.
Si noti che $A$ deve essere quadrata e, perché l'operazione abbia senso,
simmetrica. La funzione \texttt{unvech} esegue l'operazione inversa, producendo
una matrice simmetrica.
 
La funzione \texttt{mlag} richiede due argomenti: una matrice e uno scalare che
indica un ordine di ritardo, $m$. Applicata a una matrice $A$ $T \times k$, questa
funzione produce una matrice $B$ $T \times k$ tale che
%
\[
  b_{ij} = \left\{ 
    \begin{array}{ll} 
      a_{i-m,j} & 1 \leq i - m \leq T \\ 
      0 & \mbox{otherwise}
    \end{array}
    \right.
\]
%
Ossia, le colonne di $B$ sono versioni ritardate delle colonne di $A$, in cui i
valori mancanti vengono sostituiti da zeri. L'ordine $m$ può essere negativo, e
in questo caso invece di ritardi verranno generati anticipi delle variabili.

\subsection{Funzioni da scalare a matrice}
\label{matrix-fill}

Le funzioni che richiedono come argomento uno o due valori e producono una
matrice sono:

\begin{center}
\begin{tabular}{ll}
\texttt{I(}\textsl{n}\texttt{)} & matrice identità $n\times n$ \\
\texttt{zeros(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} & 
   matrice nulla $m\times n$ \\
\texttt{ones(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con tutti gli elementi pari a 1 \\
\texttt{muniform(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con elementi casuali uniformi \\
\texttt{mnormal(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con elementi casuali normali \\
\end{tabular}
\end{center}

Le dimensioni \textsl{m} e \textsl{n} possono essere indicate numericamente,
per riferimento a variabili scalari pre-esistenti, o con espressioni che,
valutate, producono scalari.
%
\begin{code}
scalar m = 4
scalar n = 5
matrix A = mnormal(m,n)
\end{code}
%
Le funzioni matriciali \texttt{muniform()} e \texttt{mnormal()} riempiono la
matrice con valori estratti dalla distribuzione uniforme (0--1) e dalla
distribuzione normale standard.

\subsection{Funzioni da coppie di matrici a matrici}
\label{matrix-two}

La funzione \texttt{qform()} costruisce una forma quadratica in una matrice
$A$ e una matrice simmetrica $X$ conformabile. Il comando
%
\begin{code}
B = qform(A, X)
\end{code}
%
calcola $B = A X A^{\prime}$.  Questo risultato viene calcolato in modo più
efficiente rispetto al comando alternativo \texttt{B = A*X*A'}. Inoltre, il
risultato è simmetrico per costruzione.

La funzione \texttt{colmult()} esegue la moltiplicazione per colonne di due
matrici, se esse sono conformabili. La sintassi è la seguente:
%
\begin{code}
C = colmult(A, B)
\end{code}
%  
Se $A$ è una matrice $m \times n$ e $B$ è $m \times k$, la moltiplicazione per
colonne è definita nel modo seguente: se $n = 1$, $c_{ij} = a_i
\times b_{ij}$; altrimenti se $k = 1$, then $c_{ij} = a_{ij} \times b_{i}$;
altrimenti se $k = n$, $c_{ij} = a_{ij} \times b_{ij}$; altrimenti il risultato
è indefinito e viene segnalato un errore.

\subsection{Funzioni da matrici a matrici}
\label{matrix-multiples}

Le funzioni che richiedono come argomento una o due matrici e producono una
o due matrici sono:

\begin{center}
\begin{tabular}{ll}
\texttt{qrdecomp()} & scomposizione QR \\
\texttt{eigensym()} & auto-analisi di una matrice simmetrica \\
\texttt{eigengen()} & auto-analisi di una matrice generica
\end{tabular}
\end{center}

La sintassi per queste funzioni segue la forma
%
\begin{textcode}
matrix B = func(\textsl{A}, \&\textsl{C})
\end{textcode}
%
Il primo argomento, \ttsl{A}, rappresenta i dati in ingresso, ossia la matrice
di cui è richiesta la scomposizione o l'analisi. Questo deve essere specificato
sotto forma di nome di una matrice esistente; in questo caso non è accettata
un'espressione che si risolve in una matrice.

Il secondo argomento, deve essere il nome di una matrice esistente, preceduto da
\verb+&+ (per indicare l'``indirizzo'' della matrice in questione), nel qual
caso un risultato ausiliario viene scritto in quella matrice, oppure la parola
chiave \texttt{null}, nel qual caso il risultato non è mostrato o è scartato.

Nel caso in cui il secondo argomento venga indicato, la matrice specificata sarà
sovrascritta con il risultato della funzione (non è richiesto che la matrice
preesistente abbia le dimensioni corrette per ricevere il risultato della
funzione).

La funzione \texttt{qrdecomp} calcola la scomposizione QR di una matrice $m
\times n$ $A$: $A = QR$, dove $Q$ è una matrice ortogonale $m \times n$
e $R$ è una matrice $n \times n$ triangolare superiore.
La matrice $Q$ è prodotta direttamente, mentre $R$ può essere recuperata
attraverso il secondo argomento. Ecco due esempi:
%
\begin{code}
matrix R
matrix Q = qrdecomp(M, &R)
matrix Q = qrdecomp(M, null)
\end{code}
%
Nel primo esempio, la matrice triangolare $R$ è salvata come \texttt{R};
nel secondo, $R$ è scartata. La prima delle righe nell'esempio precedente
mostra una ``dichiarazione semplice'' di una matrice: \texttt{R} viene
dichiarata come matrice, ma non gli viene assegnato alcun valore esplicito. In
questo caso, la variabile è inizializzata a una matrice $1\times 1$ il cui
unico elemento vale zero.

La funzione \texttt{eigensym} calcola gli autovalori, e opzionalmente gli
autovettori destri, di una matrice simmetrica $n \times n$.
Gli autovalori sono restituiti direttamente in un vettore colonna di lunghezza
$n$; se vengono richiesti gli autovettori, sono restituiti in una matrice $n
\times n$. Ad esempio:
%
\begin{code}
matrix V
matrix E = eigensym(M, &V)
matrix E = eigensym(M, null)
\end{code}
%
Nel primo caso \texttt{E} contiene gli autovalori di \texttt{M} e
\texttt{V} contiene gli autovettori. Nel secondo, \texttt{E} contiene gli
autovalori, ma gli autovettori non vengono calcolati.

La funzione \texttt{eigengen} calcola gli autovalori, e opzionalmente gli
autovettori, di una matrice generica $n \times n$. Gli autovalori vengono
restituiti direttamente in un vettore colonna di lunghezza $2n$: i primi
$n$ elementi sono le componenti reali, mentre i restanti $n$ sono le componenti
immaginarie. Se vengono richiesti gli autovettori (ossia il secondo argomento di
\texttt{eigengen} non è \texttt{null}), essi vengono restituiti in una matrice
$n \times n$.

\section{Matrici accessorie}
\label{matrix-accessors}

Oltre alle funzioni matriciali viste sopra, esistono vari ``accessori'' che
permettono di salvare una copia di alcune matrici che vengono generate
automaticamente dal programma quando viene stimato un modello:

\begin{center}
\begin{tabular}{ll}
\texttt{\$coeff} & vettore dei coefficienti stimati \\
\texttt{\$stderr} & vettore degli errori standard stimati \\
\texttt{\$uhat} & vettore dei residui \\
\texttt{\$yhat} & vettore dei valori stimati \\
\texttt{\$vcv} & matrice di covarianza (si veda oltre) \\
\texttt{\$rho} & coefficienti di autoregressione per il processo di errore \\
\texttt{\$jalpha} & matrice $\alpha$ (loading) della procedura di Johansen \\
\texttt{\$jbeta} & matrice $\beta$ (vettori di cointegrazione) della procedura di Johansen \\
\texttt{\$jvbeta} & matrice di covarianza per gli elementi non vincolati di $\beta$ della procedura di Johansen

\end{tabular}
\end{center}

Quando questi accessori sono utilizzati senza farli precedere da alcun prefisso,
producono i risultati dell'ultimo modello stimato, se esiste. Altrimenti,
se sono prefissati dal nome di un modello salvato in precedenza, separato
da un punto (\texttt{.}), producono i risultati dal modello specificato. Ecco
alcuni esempi:
%
\begin{textcode}
matrix u = \$uhat\\
matrix b = m1.\$coeff\\
matrix v2 = m1.\$vcv[1:2,1:2]
\end{textcode}
%
Il primo comando produce i residui dell'ultimo modello; il secondo produce il
vettore dei coefficienti del modello \texttt{m1}, mentre il terzo (che usa il
meccanismo della selezione di sotto-matrici descritto nel prossimo paragrafo)
produce una porzione della matrice di covarianza del modello
\texttt{m1}.

Se il ``modello'' in questione è in realtà un sistema (un VAR, un VECM, o un
sistema di equazioni simultanee), \texttt{\$uhat} produce la matrice dei
residui (una colonna per equazione) e \texttt{\$vcv} produce la matrice di
covarianza tra le equazioni. Al momento non sono disponibili altri accessori
per i sistemi di equazioni.

Dopo aver stimato un modello vettoriale a correzione d'errore con la procedura
di Johansen, sono disponibili anche le matrici \texttt{\$jalpha} e \texttt{\$jbeta}.
Esse hanno un numero di colonne pari al rango di cointegrazione scelto, quindi
il prodotto
\begin{code}
  matrix Pi = $jalpha * $jbeta'
\end{code}
produce la stima a rango ridotto di $A(1)$. Poiché $\beta$ è identificato
automaticamente attraverso la normalizzazione di Phillips (si veda la sezione
\ref{sec:johansen-ident}), i suoi elementi non vincolati possiedono una
matrice di covarianza che può essere recuperata attraverso l'accessorio
\texttt{\$jvbeta}.



\section{Selezione di sotto-matrici}
\label{matrix-sub}

È possibile selezionare delle sotto-matrici a partire da una matrice usando la
sintassi:

\texttt{A[}\textsl{righe},\textsl{colonne}\texttt{]}

dove \textsl{righe} può avere una delle seguenti quattro forme:

\begin{center}
\begin{tabular}{ll}
Vuoto & seleziona tutte le righe \\
Un valore intero & seleziona la riga identificata dal numero \\
Due interi separati dal carattere due punti & seleziona un intervallo di righe \\
Il nome di una matrice & seleziona le righe specificate dai valori della matrice \\
\end{tabular}
\end{center}

Rispetto alla seconda opzione, il valore intero può essere indicato
numericamente, attraverso il nome di una variabile scalare esistente, o
con un'espressione che, valutata, produce uno scalare.
Con l'ultima opzione, la matrice indicata nel campo \textsl{righe} deve
avere dimensioni $p\times 1$ o $1\times p$ e deve contenere valori interi
nell'intervallo da 1 a $n$, dove $n$ è il numero di righe da selezionare
dalla matrice principale.

L'uso del parametro \textsl{colonne} è simile, \textit{mutatis
  mutandis}.  Ecco alcuni esempi.
%
\begin{code}
matrix B = A[1,]
matrix B = A[2:3,3:5]
matrix B = A[2,2]
matrix idx = { 1, 2, 6 }
matrix B = A[idx,]
\end{code}
%
Il primo esempio seleziona la prima riga dalla matrice \texttt{A}; il secondo
seleziona una sotto-matrice $2\times 3$; il terzo seleziona uno scalare, mentre
il quarto seleziona le righe 1, 2 e 6 dalla matrice \texttt{A}.

In aggiunta, c'è una ``matrice indice'' predefinita, \texttt{diag}, che
seleziona la diagonale principale di una matrice quadrata, come in
\texttt{B[diag]}, dove \texttt{B} è quadrata.

È possibile usare la selezione di sotto-matrici sia a destra sia a sinistra in
una formula che genera una matrice. Ecco un esempio di uso della selezione nella
parte destra, per estrarre una sotto-matrice $2\times 2$ $B$ da una matrice
$3\times 3$ $A$:
%
\begin{code}
matrix A = { 1, 2, 3; 4, 5, 6; 7, 8, 9 }
matrix B = A[1:2,2:3]
\end{code}
%
Ed ecco un esempio di selezione sulla sinistra. La seconda riga nell'esempio
scrive una matrice identità $2\times 2$ nell'angolo inferiore destro della matrice
$3\times 3$ $A$. La quarta riga rimpiazza la diagonale di $A$ con valori 1.
%
\begin{code}
matrix A = { 1, 2, 3; 4, 5, 6; 7, 8, 9 }
matrix A[2:3,2:3] = I(2)
matrix d = { 1, 1, 1 }
matrix A[diag] = d
\end{code}

\section{Conflitti tra nomi}
\label{matrix-namespace}

Le matrici condividono lo spazio dei nomi consentiti con le serie di dati e le
variabili scalari. In altre parole, non possono esistere due oggetti di questo
tipo con lo stesso nome. È un errore tentare di cambiare il tipo di una
variabile esistente; ad esempio:
%
\begin{code}
scalar x = 3
matrix x = ones(2,2) # Errore!
\end{code}
%

È comunque possibile cancellare o rinominare una variabile esistente, e quindi
riutilizzare il nome per una variabile di diverso tipo:
\begin{code}
scalar x = 3
delete x
matrix x = ones(2,2) # Corretto!
\end{code}

\section{Creazione di una serie di dati da una matrice}
\label{matrix-create-series}

Il capitolo~\ref{matrix-create} descrive come creare una matrice da una o più
serie di dati. In alcuni casi può essere necessario dover fare l'operazione
inversa, ossia copiare valori da una matrice a una serie. La sintassi da usare è
%
\begin{textcode}
series \textsl{serie} = \textsl{matrice}
\end{textcode}
%
dove \ttsl{serie} è il nome della serie da creare e \ttsl{matrice} è il nome della
matrice da cui copiare i valori (che può essere seguita da un'espressione di
selezione). Ecco alcuni esempi:
%
\begin{code}
series s = x
series u1 = U[,1]
\end{code}
%
Si assume che \texttt{x} e \texttt{U} siano matrici preesistenti. Nel secondo
esempio, la serie \texttt{u1} è formata dalla prima colonna della matrice
\texttt{U}.

Affinché questa operazione funzioni, la matrice (o il risultato dell'operazione
di selezione matriciale) deve essere un vettore con lunghezza pari alla
lunghezza del dataset attuale, $n$, oppure alla lunghezza dell'intervallo del
campione attuale, $n^{\prime}$. Se $n^{\prime} < n$, verranno estratti dalla
matrice solo $n^{\prime}$ elementi; se la matrice comprende $n$ elementi,
vengono usati i $n^{\prime}$ valori a partire dall'elemento $t_1$, dove $t_1$
rappresenta l'osservazione iniziale dell'intervallo del campione. Ad ogni valore
della serie che non proviene dalla matrice viene assegnato il codice di
valore mancante.
 
\section{Eliminazione di matrici}
\label{matrix-delete}

Per eliminare una matrice, basta scrivere
%
\begin{code}
delete M
\end{code}
%
dove \texttt{M} è il nome della matrice da eliminare.

\section{Stampa di matrici}

Per stampare una matrice, basta indicare solo il suo nome su una riga:
\begin{code}
matrix M = mnormal(100,2)
M
\end{code}

\section{Esempio: OLS usando le matrici}
\label{matrix-example}

L'esempio \ref{examp-matrix} mostra come usare i metodi matriciali per replicare
la funzionalità OLS di gretl.

\begin{script}[htbp]
  \caption{OLS usando le matrici}
  \label{examp-matrix}
\begin{code}
  open data4-1
  matrix X = { const, sqft }
  matrix y = { price }
  matrix b = inv(X'X) * X'y
  printf "vettore dei coefficienti stimati\n"
  b
  matrix uh = y - X*b
  scalar SSR = uh'uh
  scalar s2 = SSR / (rows(X) - rows(b))
  matrix V = s2 * inv(X'X)
  V
  matrix se = sqrt(diag(V))
  printf "errori standard stimati\n"
  se
  # Confronto con la funzione OLS di gretl
  ols price const sqft --vcv
\end{code}
\end{script}



















