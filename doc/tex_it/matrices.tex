\chapter{Operazioni con le matrici}
\label{chap:matrices}

\section{Introduzione}
\label{matrix-intro}

A partire dalla versione 1.5.1, gretl offre la possibilità di creare e
manipolare matrici definite dall'utente. La versione 1.6.1 contiene alcune
modifiche a questa funzionalità.

\section{Creazione di matrici}
\label{matrix-create}

È possibile creare una matrice usando uno dei metodi seguenti:

\begin{enumerate}
\item Specificando direttamente i valori scalari che compongono la matrice,
  in forma numerica, per riferimento a variabili scalari preesistenti, o usando
  valori calcolati;
\item fornendo una lista di serie di dati;
\item fornendo una \textit{lista personalizzata} di serie;
\item usando una formula simile a quelle usate con il comando
  \texttt{genr}, in cui una nuova matrice viene definita in termini di matrici
  e/o scalari esistenti, oppure attraverso funzioni speciali.
\end{enumerate}

Per specificare una matrice \textit{direttamente in termini di scalari}, la
sintassi è la seguente:

\begin{code}
matrix A = { 1, 2, 3 ; 4, 5, 6 }
\end{code}

La matrice viene definita per righe successive; gli elementi di ogni riga sono
separati da virgole e le righe sono separate da punti e virgola. L'intera
espressione va racchiusa tra parentesi graffe. Gli spazi tra le parentesi non
sono significativi. L'espressione vista sopra definisce una matrice $2\times 3$.
Ogni elemento deve essere un valore numerico, il nome di una variabile scalare
preesistente, o un'espressione che, valutata, produce uno scalare.
Per ottenere la matrice trasposta, basta aggiungere un apostrofo
(\texttt{'}) direttamente dopo la parentesi graffa che chiude l'espressione.

Per specificare una matrice \textit{in termini di serie di dati} la sintassi è
la seguente:
%
\begin{code}
matrix A = { x1, x2, x3 }
\end{code}
%
dove i nomi delle variabili sono separati da virgole. Oltre ai nomi di variabili
esistenti, è possibile usare espressioni che producono una serie una volta
valutate. Ad esempio, data una serie \texttt{x}, si può scrivere
%
\begin{code}
matrix A = { x, x^2 }
\end{code}
%

Ogni variabile rappresenta una colonna (e può esserci solo una variabile per
ogni colonna). Non è possibile usare il carattere di punto e virgola come
separatore di riga in questo caso: se si vuole che le serie siano disposte per
righe, occorre usare il simbolo di trasposizione.  L'intervallo dei valori dei
dati inclusi nella matrice dipende dall'impostazione corrente dell'intervallo
del campione.

Si noti che mentre le funzioni statistiche di gretl sono in grado di gestire
valori mancanti, ciò non vale per le funzioni che trattano le matrici:
\emph{quando si costruisce una matrice partendo da serie che contengono valori
mancanti, le osservazioni per cui almeno una delle serie contiene valori
mancanti sono saltate}.

Invece di fornire una lista esplicita di variabili, è possibile fornire il
\textit{nome di una lista personalizzata} (si veda il capitolo~\ref{chap-persist}),
come nell'esempio seguente:
%
\begin{code}
list xlist = x1 x2 x3
matrix A = { xlist }
\end{code}
%
Se si usa il nome di una lista, le serie che la costituiscono vengono usate per
comporre le colonne, come risulta naturale in un contesto econometrico; se si
vuole che vengano usate come righe, basta usare il simbolo di trasposizione.

Un caso speciale di costruzione di una matrice usando una lista di variabili
è il seguente:
%
\begin{code}
matrix A = { dataset }
\end{code}
%
In questo modo, si costruisce una matrice usando tutte le serie del dataset
corrente, salvo la costante (variabile 0). Quando si usa questa lista speciale,
essa deve essere il solo elemento nella definizione della matrice \texttt{\{...\}}.
È tuttavia possibile creare una matrice che includa la costante, oltre alle
altre variabili, usando la concatenazione per colonne (si veda oltre), come
in questo esempio:
%
\begin{code}
matrix A = {const}~{dataset}
\end{code}
%

È possibile creare nuove matrici, o sostituire matrici esistenti, usando varie
trasformazioni, come per gli scalari e le serie di dati. I prossimi paragrafi
spiegano nel dettaglio questi meccanismi.

\tip{I nomi delle matrici devono soddisfare gli stessi requisiti dei nomi delle
variabili in gretl: il nome non può essere più lungo di 15 caratteri, deve
iniziare per una lettera e deve essere composto da lettere, numeri e il
carattere trattino basso.}

\section{Selezione di sotto-matrici}
\label{matrix-sub}

È possibile selezionare delle sotto-matrici a partire da una matrice usando la
sintassi:

\texttt{A[}\textsl{righe},\textsl{colonne}\texttt{]}

dove \textsl{righe} può avere una delle seguenti forme:

\begin{center}
\begin{tabular}{ll}
Vuoto & seleziona tutte le righe \\
Un valore intero & seleziona la riga identificata dal numero \\
Due interi separati dal carattere due punti & seleziona un intervallo di righe \\
Il nome di una matrice & seleziona le righe specificate dai valori della matrice \\
\end{tabular}
\end{center}

Rispetto alla seconda opzione, il valore intero può essere indicato
numericamente, attraverso il nome di una variabile scalare esistente, o
con un'espressione che, valutata, produce uno scalare.
Con l'ultima opzione, la matrice indicata nel campo \textsl{righe} deve
avere dimensioni $p\times 1$ o $1\times p$ e deve contenere valori interi
nell'intervallo da 1 a $n$, dove $n$ è il numero di righe da selezionare
dalla matrice principale.

L'uso del parametro \textsl{colonne} è simile, \textit{mutatis
  mutandis}.  Ecco alcuni esempi.
%
\begin{code}
matrix B = A[1,]
matrix B = A[2:3,3:5]
matrix B = A[2,2]
matrix idx = { 1, 2, 6 }
matrix B = A[idx,]
\end{code}
%
Il primo esempio seleziona la prima riga dalla matrice \texttt{A}; il secondo
seleziona una sotto-matrice $2\times 3$; il terzo seleziona uno scalare, mentre
il quarto seleziona le righe 1, 2 e 6 dalla matrice \texttt{A}.

In aggiunta, c'è una specificazione di indice predefinita, \texttt{diag},
seleziona la diagonale principale di una matrice quadrata, come in
\texttt{B[diag]}, dove \texttt{B} è quadrata.

È possibile usare la selezione di sotto-matrici sia a destra sia a sinistra in
una formula che genera una matrice. Ecco un esempio di uso della selezione nella
parte destra, per estrarre una sotto-matrice $2\times 2$ $B$ da una matrice
$3\times 3$ $A$:
%
\begin{code}
matrix A = { 1, 2, 3; 4, 5, 6; 7, 8, 9 }
matrix B = A[1:2,2:3]
\end{code}
%
Ed ecco un esempio di selezione sulla sinistra. La seconda riga nell'esempio
scrive una matrice identità $2\times 2$ nell'angolo inferiore destro della matrice
$3\times 3$ $A$. La quarta riga rimpiazza la diagonale di $A$ con valori 1.
%
\begin{code}
matrix A = { 1, 2, 3; 4, 5, 6; 7, 8, 9 }
matrix A[2:3,2:3] = I(2)
matrix d = { 1, 1, 1 }
matrix A[diag] = d
\end{code}

\section{Operatori matriciali}
\label{matrix-op}

Per le matrici sono disponibili i seguenti operatori binari:

\begin{center}
\begin{tabular}{ll}
\texttt{+} & addizione \\
\texttt{-} & sottrazione \\
\texttt{*} & moltiplicazione matriciale \\
\texttt{'} & premoltiplicazione per la trasposta \\
\texttt{/} & ``divisione'' matriciale (si veda oltre) \\
\verb+~+ & concatenazione per colonne \\
\verb+|+ & concatenazione per righe \\
\texttt{**} & prodotto di Kronecker \\
\texttt{=} & test per l'uguaglianza 
\end{tabular}
\end{center}

Inoltre, i seguenti operatori (operatori ``punto'') funzionano elemento per
elemento:

\begin{center}
\begin{tabular}{cccccc}
\texttt{.*}  &  \texttt{./}  &  \verb+.^+  &
\texttt{.=}  &  \texttt{.>}  &  \texttt{.<} 
\end{tabular}
\end{center}

Ecco qualche spiegazione per i casi meno ovvi.

Per l'addizione e la sottrazione matriciale, in generale le due matrici
devono avere le stesse dimensioni, salvo il caso in cui uno dei termini
è una matrice $1\times 1$ o uno scalare. In questo caso, lo scalare viene
implicitamente trasformato in una matrice con le corrette dimensioni, i cui
elementi sono tutti pari al valore dello scalare. Ad esempio, se
$A$ è una matrice $m \times n$ e $k$ è uno scalare, i comandi
%
\begin{code}
matrix C = A + k
matrix D = A - k
\end{code}
%
producono entrambi delle matrici $m \times n$, con elementi $c_{ij} = 
+a_{ij} + k$ e $d_{ij} = a_{ij} - k$ rispettivamente.
 
Per ``moltiplicazione per la trasposta'' si intende, ad esempio, che
%
\begin{code}
matrix C = X'Y
\end{code}
%
ha come risultato il prodotto fra $X$-trasposta e $Y$.  In effetti, 
l'espressione \texttt{X'Y} ha lo stesso significato di \texttt{X'*Y}
(che pure è un comando valido).

La ``divisione'' tra matrici, $A/B$ è algebricamente equivalente a $B^{-1}A$
(pre-moltiplicazione per mezzo dell'inversa del ``divisore''). Quindi in linea
di principio le due espressioni seguenti sono equivalenti:
%
\begin{code}
matrix C = A / B
matrix C = inv(B) * A
\end{code}
%
dove \texttt{inv} è la funzione di inversione tra matrici (si veda oltre).
Però la prima forma può essere più accurata della seconda, perché la soluzione è
ottenuta tramite la scomposizione LU, senza calcolare esplicitamente la matrice
inversa.

Nella \textit{moltiplicazione per elementi}, scrivendo
%
\begin{code}
matrix C = A .* B
\end{code}
% 
il risultato dipende dalle dimensioni di $A$ e $B$. Se $A$ è una matrice
$m \times n$ e $B$ è una matrice $p \times q$.  
%
\begin{itemize}
\item Se $m=p$ e $n=q$, $C$ sarà una matrice $m\times n$ con $c_{ij} = a_{ij}
  \times b_{ij}$. Questo tipo di prodotto è tecnicamente noto come
  \emph{prodotto di Hadamard}.
\item Se $m=1$ e $n=q$, oppure $n=1$ e $m=p$, $C$ sarà una matrice
  $p\times q$ con $c_{ij} = a_k \times b_{ij}$, dove $k=j$ se $m=1$,
  altrimenti $k=i$.
\item Se $p=1$ e $n=q$, oppure $q=1$ e $m=p$, $C$ sarà una matrice
  $m\times n$ con $c_{ij} = a_{ij} \times b_k$, dove $k=j$ se $p=1$,
  altrimenti $k=i$.
\item Se non è soddisfatta alcuna delle condizioni precedenti, il prodotto non è
  definito e viene segnalato un errore.
\end{itemize}
Ad esempio, se $A$ è un vettore riga con lo stesso numero di colonne di
$B$, le colonne di $C$ sono le colonne di $B$ moltiplicate per i corrispondenti
elementi di $A$. Si noti che questa convenzione rende superfluo, nella maggior
parte dei casi, usare matrici diagonali per eseguire trasformazioni usando la
moltiplicazione ordinaria tra matrici: se $Y = XV$, dove $V$ è diagonale, è
molto più comodo dal punto di vista computazionale ottenere $Y$ usando
l'istruzione
%
\begin{code}
matrix Y = X .* v
\end{code}
%
dove \texttt{v} è un vettore riga che contiene la diagonale di $V$.
 
La divisione per elementi e l'elevamento a potenza per elementi funzionano in
modo analogo alla moltiplicazione per elementi, sostituendo $\times$ con $\div$,
o con l'operazione di elevamento a potenza, nella spiegazione precedente.

Nella \textit{concatenazione per colonne} di una matrice $A$ $m\times n$ e di una
matrice $B$ $m\times p$, il risultato è una matrice $m\times (n+p)$. Ossia:
%
\begin{code}
matrix C = A ~ k
\end{code}
% 
produce $C = \left[ \begin{array}{cc} A & B \end{array} \right]$.

La \textit{concatenazione per righe} di una matrice $A$ $m\times n$ e di una matrice $B$
$p\times n$ produce una matrice $(m+p) \times n$.
%
\begin{code}
C = A | B
\end{code}
% 
produce $C = \left[ \begin{array}{cc} A \\ B \end{array} \right]$.

\section{Operatori matrice-scalare}
\label{matrix-scalar-op}

Per una matrice $A$ e uno scalare $k$, sono disponibili gli operatori mostrati nella
Tabella~\ref{tab:matrix-scalar-ops} (addizione e sottrazione sono state
presentate nella sezione~\ref{matrix-op} ma sono incluse nella tabella per
completezza). Inoltre, per una matrice quadrata $A$ e un intero $k \geq 0$,
\verb|B = A^k| produce una matrice $B$ che è $A$ elevata alla potenza $k$.
Si noti che l'operatore \texttt{**} non può essere usato al posto di \verb|^|
a questo scopo, perché in un contesto matriciale esso è riservato per il prodotto
di Kronecker.

\begin{table}[htbp]
\centering
\begin{tabular}{ll}
\textit{Espressione} & \textit{Risultato} \\[4pt]
\texttt{matrix B = A * k} & $b_{ij} = k a_{ij}$ \\
\texttt{matrix B = A / k} & $b_{ij} = a_{ij} / k$ \\
\texttt{matrix B = k / A} & $b_{ij} = k / a_{ij}$ \\
\texttt{matrix B = A + k} & $b_{ij} = a_{ij} + k$ \\
\texttt{matrix B = A - k} & $b_{ij} = a_{ij} - k$ \\
\texttt{matrix B = k - A} & $b_{ij} = k - a_{ij}$ \\
\texttt{matrix B = A \% k} & $b_{ij} = a_{ij} \mbox{ modulo } k$ \\
\end{tabular}
\caption{Operatori matrice--scalare}
\label{tab:matrix-scalar-ops}
\end{table}

\section{Funzioni matriciali}
\label{matrix-func}

\newlength{\cwid}
\setlength{\cwid}{0.1\textwidth}

\begin{table}[htbp]
\centering
\textbf{Creazione}
\hrulefill

\begin{tabular}{p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}}
\texttt{I}         &
\texttt{mnormal}   &
\texttt{muniform}  &
\texttt{ones}      &
\texttt{seq}       &
\texttt{zeros}     
\end{tabular}      

\textbf{Forma/dimensione}
\hrulefill

\begin{tabular}{p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}}
\texttt{cols}      &
\texttt{diag}      &
\texttt{dsort}     &
\texttt{mlag}      &
\texttt{mshape}    &
\texttt{rows}      \\
\texttt{sort}      &
\texttt{transp}    &
\texttt{unvech}    &
\texttt{vec}       &
\texttt{vech}      
\end{tabular}      

\textbf{Elemento per elemento}
\hrulefill

\begin{tabular}{p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}}
\texttt{abs}       &
\texttt{atan}      &
\texttt{cnorm}     &
\texttt{cos}       &
\texttt{dnorm}     &
\texttt{exp}       \\
\texttt{gamma}     &
\texttt{int}       &
\texttt{lngamma}   &
\texttt{log}       &
\texttt{qnorm}     &
\texttt{sin}       \\
\texttt{sqrt}      &
\texttt{tan}       
\end{tabular}      

\textbf{Algebra matriciale}
\hrulefill

\begin{tabular}{p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}}
\texttt{cholesky}  &
\texttt{det}       &
\texttt{eigengen}  &
\texttt{eigensym}  &
\texttt{fft}       &
\texttt{ffti}      \\
\texttt{infnorm}   &
\texttt{inv}       &
\texttt{ginv}      &
\texttt{ldet}      &
\texttt{mexp}      &
\texttt{nullspace} \\
\texttt{onenorm}   &
\texttt{qform}     &
\texttt{qrdecomp}  &
\texttt{rank}      &
\texttt{rcond}     &
\texttt{svd}       \\
\texttt{tr}        &
\texttt{cmult}      
\end{tabular}      

\textbf{Statistica}
\hrulefill

\begin{tabular}{p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}p{\cwid}}
\texttt{cdemean}   &
\texttt{imaxc}     &
\texttt{imaxr}     &
\texttt{iminc}     &
\texttt{iminr}     &
\texttt{mcorr}     \\
\texttt{mcov}      &
\texttt{maxc}      &   
\texttt{maxr}      &
\texttt{meanc}     &
\texttt{meanr}     &
\texttt{minc}      \\   
\texttt{minr}      &
\texttt{mols}      &
\texttt{mxtab}     &
\texttt{princomp}  &
\texttt{sumc}      &
\texttt{sumr}      \\
\texttt{sd}        &
\texttt{values}
\end{tabular}      
\caption{Funzioni matriciali suddivise per categoria}
\label{tab:matrix_funcs_cat}
\end{table}

La tabella \ref{tab:matrix_funcs_cat} elenca le funzioni matriciali fornite da
\app{gretl} (una versione ordinata in ordine alfabetico della tabella è fornita
alla fine di questo capitolo, si veda la Tabella~\ref{tab:matrix_funcs}).
Per \textit{la trasformazione elemento per elemento} delle matrici sono
disponibili le seguenti funzioni: \texttt{log}, \texttt{exp},
\texttt{sin}, \texttt{cos}, \texttt{tan}, \texttt{atan}, \texttt{int},
\texttt{abs}, \texttt{sqrt}, \texttt{dnorm}, \texttt{cnorm},
\texttt{qnorm}, \texttt{gamma} e \texttt{lngamma}. Queste funzioni operano in
modo analogo a quando sono usate nel contesto del comando \texttt{genr}.  Ad
esempio, se una matrice \texttt{A} è già stata definita,
%
\begin{code}
matrix B = sqrt(A)
\end{code}
%
genera una matrice tale che $b_{ij} = \sqrt{a_{ij}}$.  Tutte queste
funzioni richiedono una sola matrice come argomento, o un'espressione
che si risolve in una singola matrice.

Si noti che per calcolare la ``radice quadrata di una matrice'' occorre la
funzione \texttt{cholesky} (si veda oltre); inoltre, la funzione
\texttt{exp} calcola l'esponenziale elemento per elemento, quindi \emph{non}
produce l'esponenziale della matrice, a meno che la matrice non sia diagonale;
per calcolare l'esponenziale della matrice, si usi \texttt{mexp}.

Le funzioni \texttt{sort}, \texttt{dsort} e \texttt{values}, utilizzabili
con le serie di dati, possono essere usate anche con le matrici.  In questo
caso, l'argomento di queste funzioni deve essere un vettore ($p \times 1$ o
$1\times p$). Per \texttt{sort} e \texttt{dsort}, il valore restituito è un
vettore che contiene gli elementi del vettore originale riordinati in ordine di
grandezza crescente (\texttt{sort}) o decrescente (\texttt{dsort}). Per
\texttt{values} il risultato è un vettore che contiene i valori distinti del
vettore originale, riordinati in ordine crescente.

Infine, ci sono funzioni dedicate in modo specifico alle matrici, che è
possibile suddividere in cinque categorie:
%
\begin{enumerate}
\item Quelle che richiedono come argomento una sola matrice e producono uno scalare.
\item Quelle che richiedono come argomento una sola matrice (e in alcuni casi un parametro aggiuntivo) e producono una matrice.
\item Quelle che richiedono come argomento uno o due valori e producono una matrice.
\item Quelle che richiedono come argomento due matrici e producono una matrice.
\item Quelle che richiedono come argomento una o più matrici e producono una o più matrici.
\end{enumerate}
%
Questi gruppi di funzioni vengono presentati nell'ordine.

\subsection{Funzioni da matrice a scalare}
\label{matrix-to-scalar}

Le funzioni che richiedono come argomento una sola matrice e producono uno
scalare sono:

\begin{center}
\begin{tabular}{ll}
\texttt{rows} & numero di righe \\
\texttt{cols} & numero di colonne \\
\texttt{rank} & rango \\
\texttt{det} & determinante \\
\texttt{ldet} & log-determinante \\
\texttt{tr} & traccia \\
\texttt{onenorm} & norma-1 \\
\texttt{infnorm} & norma infinita \\
\texttt{rcond} & reciproco del numero di condizione
\end{tabular}
\end{center}

L'argomento di queste funzioni può essere il nome di una matrice esistente o
un'espressione che si risolve in una matrice. Si noti che le funzioni
\texttt{det}, \texttt{ldet} e \texttt{tr} richiedono una matrice quadrata.
La funzione \texttt{rank} è calcolata usando la decomposizione QR.

Le funzioni \texttt{onenorm} e \texttt{infnorm} restituiscono rispettivamente la
norma-1 e la norma infinita di una matrice. La prima è il massimo, tra le
colonne della matrice, della somma dei valori assoluti degli elementi della
colonna; la seconda è il massimo, tra le righe, della somma dei valori assoluti
degli elementi della riga. La funzione \texttt{rcond} restituisce il reciproco
del numero di condizione per una matrice simmetrica definita positiva.

\subsection{Funzioni da matrice a matrice}
\label{matrix-to-matrix}

Le funzioni che richiedono come argomento una sola matrice e producono una
matrice sono:

\begin{center}
{\small
\begin{tabular}{lp{.32\textwidth}clp{.32\textwidth}}
\texttt{sumc}      & somma per colonna & &
\texttt{sumr}      & somma per riga \\
\texttt{meanc}     & media per colonna & &
\texttt{meanr}     & media per riga \\
\texttt{sd}        & scarto quadratico medio per colonna \\
\texttt{mcov}      & matrice di covarianza & &
\texttt{mcorr}     & matrice di correlazione \\
\texttt{cholesky}  & scomposizione di Cholesky & &
\texttt{mexp}      & esponenziale matriciale \\
\texttt{inv}       & inversa & &
\texttt{ginv}      & inversa generalizzata \\
\texttt{diag}      & diagonale principale & &
\texttt{transp}    & trasposta \\
\texttt{cdemean}   & sottrazione della media delle colonne & &
\texttt{vec}       & elementi come vettore colonna \\
\texttt{vech}      & elementi del triangolo inferiore come vettore colonna & &
\texttt{unvech}    & annulla l'operazione \texttt{vech} \\
\texttt{mlag}      & ritardo o anticipo per le matrici & &
\texttt{nullspace} & spazio nullo destro \\
\texttt{princomp}  & componenti principali \\
\texttt{maxc}      & massimi delle colonne (valori) & &
\texttt{maxr}      & massimi delle righe (valori) \\
\texttt{imaxc}     & massimi delle colonne (indici) & &
\texttt{imaxr}     & massimi delle righe (indici) \\
\texttt{minc}      & minimi delle colonne (valori) & &
\texttt{minr}      & minimi delle righe (valori) \\
\texttt{iminc}     & minimi delle colonne (indici) & &
\texttt{iminr}     & minimi delle righe (indici) \\
\texttt{fft}       & trasformata discreta di Fourier & &
\texttt{ffti}      & trasformata discreta inversa di Fourier
\end{tabular}
}
\end{center}

Come per il gruppo precedente di funzioni, l'argomento deve essere il nome di
una matrice esistente o un'espressione che si risolve in una matrice.

Per una matrice $A$ $m \times n$, \texttt{sumc(A)} produce un vettore riga con
le $n$ somme per colonna, mentre \texttt{sumr(A)} produce un vettore colonna con
le $m$ somme per riga. \texttt{meanc(A)} produce un vettore riga con le $n$
medie per colonna e \texttt{meanr(A)} un vettore colonna con le $m$ medie per
riga. \texttt{sd(A)} produce un vettore riga che contiene gli scarti quadratici
medi delle $n$ colonne (senza la correzione per i gradi di libertà).

Inoltre, per una matrice $A$ $m \times n$, la famiglia di funzioni
\texttt{max} e \texttt{min} può produrre una matrice $m \times 1$ (le varianti
\texttt{r}, che selezionano il valore estremo di ogni riga), o una matrice
$1 \times n$ (le varianti \texttt{c}, che selezionano il valore estremo di ogni
colonna). I vettori \texttt{max} contengono i valori massimi di ogni riga o
colonna, mentre quelli \texttt{min} contengono i valori minimi. Le varianti
delle funzioni prefissate con \texttt{i} (ad es. \texttt{imaxc}) producono non i
valori ma gli indici (a partire da 1) degli elementi di valore massimo o minimo.

Per una matrice $A$ $T \times k$, \texttt{mcov(A)} e
\texttt{mcorr(A)} producono entrambe delle matrici simmetriche $k \times k$,
nel primo caso contenenti le varianze (sulla diagonale) e le covarianze delle
variabili nelle colonne di $A$, e nel secondo caso, le correlazioni delle
variabili.

Per una matrice $A$ $n \times n$, la funzione \texttt{mexp(A)} produce una matrice
$n \times n$ che contiene l'esponenziale matriciale
\[
e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!} = \frac{I}{0!} + \frac{A}{1!}
 + \frac{A^2}{2!} + \frac{A^3}{3!} + \cdots
\]
(questa serie converge sicuramente).

La funzione \texttt{cholesky} calcola la scomposizione di Cholesky
$L$ di una matrice simmetrica definita positiva $A$: $A = LL'$; $L$ è
triangolare inferiore (contiene zeri al di sopra della diagonale).

La funzione \texttt{diag} restituisce la diagonale principale di una matrice
$n\times n$ $A$ come vettore colonna, ossia come vettore $n$-dimensionale $v$
tale che $v_i = a_{ii}$.

La funzione \texttt{cdemean} applicata a una matrice $A$ $m \times n$
restituisce una matrice $B$ $m \times n$ tale che $b_{ij} = a_{ij} -
\bar{A}_j$, dove $\bar{A}_j$ indica la media della colonna $j$ di $A$.  

La funzione \texttt{vec} applicata a una matrice $A$ $m \times n$
restituisce un vettore colonna di lunghezza $mn$ formato impilando le
colonne di $A$.

La funzione \texttt{vech} applicata a una matrice $A$ $n \times n$
restituisce un vettore colonna di lunghezza $n(n+1)/2$ formato impilando
gli elementi del triangolo inferiore di $A$, colonna per colonna.
Si noti che $A$ deve essere quadrata e, perché l'operazione abbia senso,
simmetrica. La funzione \texttt{unvech} esegue l'operazione inversa, producendo
una matrice simmetrica.
 
La funzione \texttt{mlag} richiede due argomenti: una matrice e uno scalare che
indica un ordine di ritardo, $m$. Applicata a una matrice $A$ $T \times k$, questa
funzione produce una matrice $B$ $T \times k$ tale che
%
\[
  b_{ij} = \left\{ 
    \begin{array}{ll} 
      a_{i-m,j} & 1 \leq i - m \leq T \\ 
      0 & \mbox{otherwise}
    \end{array}
    \right.
\]
%
Ossia, le colonne di $B$ sono versioni ritardate delle colonne di $A$, in cui i
valori mancanti vengono sostituiti da zeri. L'ordine $m$ può essere negativo, e
in questo caso invece di ritardi verranno generati anticipi delle variabili.
 
La funzione \texttt{nullspace} produce $X$, lo spazio nullo destro di una
matrice $A$ (che si assume avere rango pieno): $X$ soddisfa la condizione
$A \cdot X = 0$.

La funzione \texttt{ginv} produce l'inversa generalizzata, o pseudoinversa
(chiamata anche inversa di Moore--Penrose) di una matrice rettangolare $A$.
Essa soddisfa le seguenti equazioni:
\begin{eqnarray*}
AA^+A &=& A \\
A^+AA^+	&=& A^+	 \\
(AA^+)' &=& AA^+ \\	
(A^+A)' &=& A^+A
\end{eqnarray*}

La funzione \texttt{princomp} richiede due argomenti: una matrice $X$ $T \times
k$ e uno scalare $p$, tale che $0 < p \leq k$.  Si assume che $X$ contenga $T$
osservazioni per ognuna delle $k$ variabili (serie). Il valore prodotto è una
matrice $P$ $T \times p$ che contiene le prime $p$ componenti principali di $X$.
Gli elementi di $P$ sono calcolati come
\[
P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i
\]
dove $Z_{ti}$ è il valore standardizzato della variabile $i$ nell'osservazione
$t$, $Z_{ti} = (X_{ti} - \bar{X}_i) / \hat{\sigma}_i$, e $v^{(j)}$ è
l'autovettore $j$-esimo della matrice di correlazione degli $X_i$, con gli
autovettori ordinati per valore decrescente dei corrispondenti autovalori.

Le funzioni \texttt{fft} e \texttt{ffti} producono la trasformata di Fourier
reale discreta e la sua inversa. Se \texttt{X} è una matrice $n \times k$,
\texttt{fft(X)} è una matrice $n \times 2k$ che contiene la parte reale della
trasformata nelle colonne dispari e la parte immaginaria in quelle pari. Al
contrario, \texttt{ffti} richiede un argomento $n \times 2k$ e produce un
risultato $n \times k$. Si veda la Sezione~\ref{sec:genr-fft} per alcuni esempi.

\subsection{Funzioni di riempimento delle matrici}
\label{matrix-fill}

Le funzioni che richiedono come argomento uno o due valori interi e producono una
matrice sono:

\begin{center}
\begin{tabular}{ll}
\texttt{I(}\textsl{n}\texttt{)} & matrice identità $n\times n$ \\
\texttt{zeros(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} & 
   matrice nulla $m\times n$ \\
\texttt{ones(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con tutti gli elementi pari a 1 \\
\texttt{muniform(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con elementi casuali uniformi \\
\texttt{mnormal(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con elementi casuali normali \\
\texttt{seq(}\textsl{a}\texttt{,}\textsl{b}\texttt{)} &
   vettore riga che contiene i numeri da $a$ a $b$
\end{tabular}
\end{center}

Le dimensioni $m$ e $n$, o nel caso di \texttt{seq} i valori estremi $a$ e
$b$, possono essere indicate numericamente, per riferimento a variabili scalari
pre-esistenti, o con espressioni che, valutate, producono scalari.

Le funzioni matriciali \texttt{muniform} e \texttt{mnormal} riempiono la
matrice con valori estratti dalla distribuzione uniforme (0--1) e dalla
distribuzione normale standard.
 
La funzione \texttt{seq} genera una sequenza di numeri interi da $a$ a $b$
inclusi, crescente se $a<b$ o decrescente se $a>b$.

\subsection{Funzioni di ristrutturazione delle matrici}
\label{matrix-mshape}

È possibile creare una matrice anche ri-strutturando gli elementi di una matrice
preesistente, usando la funzione \texttt{mshape}; essa richiede tre argomenti:
la matrice iniziale $A$ e le righe e colonne della matrice finale,
rispettivamente $r$ e $c$. Gli elementi di $A$ vengono letti per colonne e
scritti nella matrice finale con lo stesso metodo; se $A$ contiene meno elementi
di $n = r \times c$, essi sono ripetuti ciclicamente, se invece $A$ contiene più
elementi, sono usati solo i primi $n$.

Ad esempio:
\begin{code}
matrix a = mnormal(2,3)
a
matrix b = mshape(a,3,1)
b
matrix b = mshape(a,5,2)
b
\end{code}
produce
\begin{code}
?   a
a

      1.2323      0.99714     -0.39078
     0.54363      0.43928     -0.48467

?   matrix b = mshape(a,3,1)
Generata la matrice b
?   b
b

      1.2323
     0.54363
     0.99714

?   matrix b = mshape(a,5,2)
Sostituita la matrice b
?   b
b

      1.2323     -0.48467
     0.54363       1.2323
     0.99714      0.54363
     0.43928      0.99714
    -0.39078      0.43928
\end{code}


\subsection{Funzioni da coppie di matrici a matrici}
\label{matrix-two}

La funzione \texttt{qform} costruisce una forma quadratica in una matrice
$A$ e una matrice simmetrica $X$ conformabile. Il comando
%
\begin{code}
B = qform(A, X)
\end{code}
%
calcola $B = A X A^{\prime}$.  Questo risultato viene calcolato in modo più
efficiente rispetto al comando alternativo \texttt{B = A*X*A'}. Inoltre, il
risultato è simmetrico per costruzione.

La funzione \texttt{cmult} calcola il prodotto complesso di due matrici
$A$ e $B$ che rappresentano numeri complessi. Queste  matrici devono avere lo
stesso numero di righe, $n$, e una o due colonne. La prima colonna contiene la
parte reale, mentre la seconda (se presente) la parte immaginaria. Il valore
prodotto è una matrice $n \times 2$, o se il prodotto non ha parte immaginaria,
un vettore di dimensione $n$.

\subsection{Funzioni da matrici a matrici}
\label{matrix-multiples}

Le funzioni che richiedono come argomento una o più matrici e producono una
o più matrici sono:

\begin{center}
\begin{tabular}{ll}
\texttt{qrdecomp} & scomposizione QR \\
\texttt{eigensym} & auto-analisi di una matrice simmetrica \\
\texttt{eigengen} & auto-analisi di una matrice generica \\
\texttt{mols}     & OLS matriciale \\
\texttt{svd}      & decomposizione in valori singolari (SVD) 
\end{tabular}
\end{center}

La sintassi per le funzioni \texttt{qrdecomp}, \texttt{eigensym} e
\texttt{eigengen} segue la forma
%
\begin{code}
matrix B = func(A, &C)
\end{code}
%
Il primo argomento, \texttt{A}, rappresenta i dati in ingresso, ossia la matrice
di cui è richiesta la scomposizione o l'analisi.  Il secondo argomento deve
essere il nome di una matrice esistente, preceduto da \verb+&+ (per indicare
l'``indirizzo'' della matrice in questione), nel qual caso un risultato
ausiliario viene scritto in quella matrice, oppure la parola chiave
\texttt{null}, nel qual caso il risultato non è mostrato o è scartato.

Nel caso in cui il secondo argomento venga indicato, la matrice specificata sarà
sovrascritta con il risultato della funzione (non è richiesto che la matrice
preesistente abbia le dimensioni corrette per ricevere il risultato della
funzione).

La funzione \texttt{eigensym} calcola gli autovalori, e opzionalmente gli
autovettori destri, di una matrice simmetrica $n \times n$.
Gli autovalori sono restituiti direttamente in un vettore colonna di lunghezza
$n$; se vengono richiesti gli autovettori, sono restituiti in una matrice $n
\times n$. Ad esempio:
%
\begin{code}
matrix V
matrix E = eigensym(M, &V)
matrix E = eigensym(M, null)
\end{code}
%
Nel primo caso \texttt{E} contiene gli autovalori di \texttt{M} e
\texttt{V} contiene gli autovettori. Nel secondo, \texttt{E} contiene gli
autovalori, ma gli autovettori non vengono calcolati.

La funzione \texttt{eigengen} calcola gli autovalori, e opzionalmente gli
autovettori, di una matrice generica $n \times n$.  Gli autovalori vengono
restituiti direttamente in una matrice $n \times 2$, in cui la prima colonna
contiene le componenti reali e la seconda quelle immaginarie.

Se vengono richiesti gli autovettori (ossia il secondo argomento di
\texttt{eigengen} non è \texttt{null}), essi vengono restituiti in una matrice
$n \times n$. La disposizione delle colonne in questa matrice è particolare: gli
autovettori sono disposti nello stesso ordine degli autovalori, ma gli
autovettori reali occupano una colonna, mentre quelli complessi ne occupano due
(la parte reale nella prima colonna); il numero totale di colonne è sempre $n$,
visto che l'autovettore coniugato viene saltato. L'esempio \ref{cmplx-evecs}
dovrebbe chiarire la situazione.

\begin{script}[htbp]
  \caption{Autovalori e autovettori complessi}
  \label{cmplx-evecs}
\begin{scode}
set seed 34756

matrix v
A = mnormal(3,3)

/* Genera gli autovalori e autovettori */
l = eigengen(A,&v)
/* L'autovalore 1 è reale, 2 e 3 sono complessi coniugati */
print l
print v

/* 
  La colonna 1 contiene il primo autovettore (reale)
*/

B = A*v[,1]
c = l[1,1] * v[,1]
/* B dovrebbe essere pari a c */
print B
print c


/* 
  Le colonne 2:3 contengono le parti reale e immaginaria dell'autovettore 2
*/

B = A*v[,2:3]
c = cmult(ones(3,1)*(l[2,]),v[,2:3])
/* B dovrebbe essere pari a c */
print B
print c
\end{scode}
\end{script}
 
La funzione \texttt{qrdecomp} calcola la scomposizione QR di una matrice $m
\times n$ $A$: $A = QR$, dove $Q$ è una matrice ortogonale $m \times n$
e $R$ è una matrice $n \times n$ triangolare superiore.
La matrice $Q$ è prodotta direttamente, mentre $R$ può essere recuperata
attraverso il secondo argomento. Ecco due esempi:
%
\begin{code}
matrix R
matrix Q = qrdecomp(M, &R)
matrix Q = qrdecomp(M, null)
\end{code}
%
Nel primo esempio, la matrice triangolare $R$ è salvata come \texttt{R};
nel secondo, $R$ è scartata. La prima delle righe nell'esempio precedente
mostra una ``dichiarazione semplice'' di una matrice: \texttt{R} viene
dichiarata come matrice, ma non gli viene assegnato alcun valore esplicito. In
questo caso, la variabile è inizializzata a una matrice $1\times 1$ il cui
unico elemento vale zero.

La sintassi per \texttt{svd} è
%
\begin{code}
matrix B = func(A, &C, &D)
\end{code}
%

La funzione \texttt{svd} calcola la decomposizione in valori singolari (totale o
parziale) della matrice reale $A$ $m \times n$. La decomposizione è
\[
A = U \Sigma V'
\]
dove $\Sigma$ è una matrice $m \times n$ che contiene zeri tranne che per i suoi
$k = \mbox{min}(m, n)$ diagonali, $U$ è una matrice ortogonale $m \times m$ e
$V$ è una matrice ortogonale $n \times n$. Gli elementi diagonali di
$\Sigma$ sono i valori singolari di $A$, sono reali e non negativi, e sono
prodotti in ordine decrescente. Le prime $\mbox{min}(m, n)$ colonne di $U$ e
$V$ sono i vettori singolari destro e sinistro di $A$.

La funzione \texttt{svd} produce i valori singolari in un vettore di ordine $k$.
I vettori singolari sinistri e/o destri si possono ottenere indicando valori non
nulli per il secondo e/o terzo argomento della funzione. Ad esempio:
%
\begin{code}
matrix s = svd(A, &U, &V)
matrix s = svd(A, null, null)
matrix s = svd(A, null, &V)
\end{code}
%
Nel primo caso si otterranno entrambi gli insiemi di vettori singolari; nel
secondo caso si otterranno solo i valori singolari, nel terzo si ottengono i
vettori singolari destri ma non viene calcolata $U$.
\emph{Nota bene}: quando il terzo argomento è non nullo, in realtà viene
prodotto $V'$.
 
Infine, la sintassi per \texttt{mols} è
%
\begin{code}
matrix b = func(y, X, &u)
\end{code}
%
La funzione produce la statistica OLS ottenuta regredendo la matrice $T
\times n$ sulla matrice $T \times k$, ossia una matrice $k \times n$
che contiene $(X'X)^{-1} X'Y$. Viene usata la decomposizione di Cholesky.
La matrice u, se non nulla, è usata per salvare i residui.

\section{Matrici accessorie}
\label{matrix-accessors}

Oltre alle funzioni matriciali viste sopra, esistono vari ``accessori'' che
permettono di salvare una copia di alcune matrici che vengono generate
automaticamente dal programma quando viene stimato un modello:

\begin{center}
\begin{tabular}{ll}
\texttt{\$coeff}  & vettore dei coefficienti stimati \\
\texttt{\$stderr} & vettore degli errori standard stimati \\
\texttt{\$uhat}   & vettore dei residui \\
\texttt{\$yhat}   & vettore dei valori stimati \\
\texttt{\$vcv}    & matrice di covarianza (si veda oltre) \\
\texttt{\$rho}    & coefficienti di autoregressione per il processo di errore \\
\texttt{\$jalpha} & matrice $\alpha$ (loading) della procedura di Johansen \\
\texttt{\$jbeta}  & matrice $\beta$ (vettori di cointegrazione) della procedura di Johansen \\
\texttt{\$jvbeta} & matrice di covarianza per gli elementi non vincolati di $\beta$ della procedura di Johansen

\end{tabular}
\end{center}

Quando questi accessori sono utilizzati senza farli precedere da alcun prefisso,
producono i risultati dell'ultimo modello stimato, se esiste. Altrimenti,
se sono prefissati dal nome di un modello salvato in precedenza, separato
da un punto (\texttt{.}), producono i risultati dal modello specificato. Ecco
alcuni esempi:
%
\begin{code}
matrix u = $uhat
matrix b = m1.$coeff
matrix v2 = m1.$vcv[1:2,1:2]
\end{code}
%$
Il primo comando produce i residui dell'ultimo modello; il secondo produce il
vettore dei coefficienti del modello \texttt{m1}, mentre il terzo (che usa il
meccanismo della selezione di sotto-matrici descritto in precedenza)
produce una porzione della matrice di covarianza del modello
\texttt{m1}.

Se il ``modello'' in questione è in realtà un sistema (un VAR, un VECM, o un
sistema di equazioni simultanee), \verb|$uhat| produce la matrice dei
residui (una colonna per equazione) e \verb|\$vcv| produce la matrice di
covarianza tra le equazioni. Nel caso speciale di un VAR o un VECM,
\verb|$coeff| produce la matrice dei coefficienti (una colonna per
equazione) e \verb|$compan| la matrice associata. Al momento gli altri
accessori non sono disponibili per i sistemi di equazioni.

Dopo aver stimato un modello vettoriale a correzione d'errore con la procedura
di Johansen, sono disponibili anche le matrici \verb|jalpha| e \verb|$jbeta|.
Esse hanno un numero di colonne pari al rango di cointegrazione scelto, quindi
il prodotto
\begin{code}
matrix Pi = $jalpha * $jbeta'
\end{code}
produce la stima a rango ridotto di $A(1)$. Poiché $\beta$ è identificato
automaticamente attraverso la normalizzazione di Phillips (si veda la sezione
\ref{sec:johansen-ident}), i suoi elementi non vincolati possiedono una
matrice di covarianza che può essere recuperata attraverso l'accessorio
\verb|$jvbeta|.

\section{Conflitti tra nomi}
\label{matrix-namespace}

Le matrici condividono lo spazio dei nomi consentiti con le serie di dati e le
variabili scalari. In altre parole, non possono esistere due oggetti di questo
tipo con lo stesso nome. È un errore tentare di cambiare il tipo di una
variabile esistente; ad esempio:
%
\begin{code}
scalar x = 3
matrix x = ones(2,2) # Errore!
\end{code}
%

È comunque possibile cancellare o rinominare una variabile esistente, e quindi
riutilizzare il nome per una variabile di diverso tipo:
\begin{code}
scalar x = 3
delete x
matrix x = ones(2,2) # Corretto!
\end{code}

\section{Creazione di una serie di dati da una matrice}
\label{matrix-create-series}

Il capitolo~\ref{matrix-create} descrive come creare una matrice da una o più
serie di dati. In alcuni casi può essere necessario dover fare l'operazione
inversa, ossia copiare valori da una matrice a una serie. La sintassi da usare è
%
\begin{textcode}
series \textsl{serie} = \textsl{matrice}
\end{textcode}
%
dove \ttsl{serie} è il nome della serie da creare e \ttsl{matrice} è il nome della
matrice da cui copiare i valori (che può essere seguita da un'espressione di
selezione). Ecco alcuni esempi:
%
\begin{code}
series s = x
series u1 = U[,1]
\end{code}
%
Si assume che \texttt{x} e \texttt{U} siano matrici preesistenti. Nel secondo
esempio, la serie \texttt{u1} è formata dalla prima colonna della matrice
\texttt{U}.

Affinché questa operazione funzioni, la matrice (o il risultato dell'operazione
di selezione matriciale) deve essere un vettore con lunghezza pari alla
lunghezza del dataset attuale, $n$, oppure alla lunghezza dell'intervallo del
campione attuale, $n^{\prime}$. Se $n^{\prime} < n$, verranno estratti dalla
matrice solo $n^{\prime}$ elementi; se la matrice comprende $n$ elementi,
vengono usati i $n^{\prime}$ valori a partire dall'elemento $t_1$, dove $t_1$
rappresenta l'osservazione iniziale dell'intervallo del campione. Ad ogni valore
della serie che non proviene dalla matrice viene assegnato il codice di
valore mancante.
 
\section{Matrici e liste}
\label{matrix-and-list}

Per facilitare la manipolazione di liste di variabili (si veda il
capitolo~\ref{chap-persist}), è possibile convertire liste in matrici e
viceversa. Nella sezione precedente \ref{matrix-create} è stato presentato
il modo di creare una matrice a partire da una lista di variabili, come in
%
\begin{code}
matrix M = { listname }
\end{code}
%
Questa formulazione, con il nome della lista tra parentesi graffe, crea una
matrice le cui colonne contengono le variabili indicate nella lista.
Di seguito viene presentato un altra operazione: dicendo
%
\begin{code}
matrix M = listname
\end{code}
%
(senza le parentesi graffe) si ottiene un vettore riga i cui elementi sono
i numeri identificativi delle variabili della lista. Questo caso speciale di
generazione di matrici non può essere utilizzato all'interno di altre
espressioni: la sintassi deve essere quella appena vista, ossia la semplice
assegnazione di una lista a una matrice.

Per lavorare nella direzione opposta, è possibile includere una matrice nella
parte destra di un'espressione che definisce una lista, come in
%
\begin{code}
list Xl = M
\end{code}
%
dove \texttt{M} è una matrice che deve avere le dimensioni adatte per la
conversione, ossia, deve essere un vettore riga o colonna che contenga valori
interi e non negativi, nessuno dei quali ecceda il massimo numero identificativo
di una variabile (serie o scalare) nel dataset attuale.

L'esempio~\ref{normalize-list} illustra l'uso di questo tipo di conversione per
``normalizzare'' una lista, spostando la costante (variabile 0) al primo posto.

\begin{script}[htbp]
  \caption{Manipolazione di una lista}
  \label{normalize-list}
\begin{scode}
function normalize_list (matrix *x)
  # Se la matrice (che rappresenta una lista) contiene la variabile 0
  # ma non nella prima posizione, questa viene spostata nella prima posizione

  if (x[1] != 0)
     scalar k = cols(x)
     loop for (i=2; i<=k; i++) --quiet
        if (x[i] = 0)
            x[i] = x[1]
            x[1] = 0
            break
         endif
     end loop
  end if
end function

open data9-7
list Xl = 2 3 0 4
matrix x = Xl
normalize_list(&x)
list Xl = x
\end{scode}
\end{script}

\section{Eliminazione di matrici}
\label{matrix-delete}

Per eliminare una matrice, basta scrivere
%
\begin{code}
delete M
\end{code}
%
dove \texttt{M} è il nome della matrice da eliminare.

\section{Stampa di matrici}

Per stampare una matrice, basta indicare solo il suo nome su una riga, oppure
usare il comando \cmd{print}:
%
\begin{code}
matrix M = mnormal(100,2)
M
print M
\end{code}

\section{Esempio: OLS usando le matrici}
\label{matrix-example}

L'esempio \ref{matrixOLS} mostra come usare i metodi matriciali per replicare
la funzionalità OLS di gretl.

\begin{script}[htbp]
  \caption{OLS usando le matrici}
  \label{matrixOLS}
\begin{scode}
open data4-1
matrix X = { const, sqft }
matrix y = { price }
matrix b = inv(X'X) * X'y
printf "vettore dei coefficienti stimati\n"
b
matrix u = y - X*b
scalar SSR = u'u
scalar s2 = SSR / (rows(X) - rows(b))
matrix V = s2 * inv(X'X)
V
matrix se = sqrt(diag(V))
printf "errori standard stimati\n"
se
# Confronto con la funzione OLS di gretl
ols price const sqft --vcv
\end{scode}
\end{script}
%
\clearpage

\begin{table}[p]
\centering
\begin{tabular}{llllll}
\texttt{abs}       &
\texttt{atan}      &
\texttt{cdemean}   &
\texttt{cholesky}  &
\texttt{cmult}     &
\texttt{cnorm}     \\
\texttt{cols}      &
\texttt{cos}       &
\texttt{det}       &
\texttt{diag}      &
\texttt{dnorm}     &
\texttt{dsort}     \\
\texttt{eigengen}  &
\texttt{eigensym}  &
\texttt{exp}       &
\texttt{fft}       &
\texttt{ffti}      &
\texttt{gamma}     \\
\texttt{ginv}      &
\texttt{I}         &
\texttt{imaxc}     &
\texttt{imaxr}     &
\texttt{iminc}     &
\texttt{iminr}     \\
\texttt{infnorm}   &
\texttt{int}       &
\texttt{inv}       &
\texttt{ldet}      &
\texttt{lngamma}   &
\texttt{log}       \\
\texttt{mcorr}     &
\texttt{mcov}      &
\texttt{maxc}      &   
\texttt{maxr}      &
\texttt{meanc}     &
\texttt{meanr}     \\
\texttt{mexp}      &
\texttt{minc}      &  
\texttt{minr}      &
\texttt{mlag}      &
\texttt{mnormal}   &
\texttt{mols}      \\
\texttt{mshape}    &
\texttt{muniform}  &
\texttt{mxtab}     &
\texttt{nullspace} &
\texttt{onenorm}   &
\texttt{ones}      \\
\texttt{princomp}  &
\texttt{qform}     &
\texttt{qnorm}     &
\texttt{qrdecomp}  &
\texttt{rank}      &
\texttt{rcond}     \\
\texttt{rows}      &
\texttt{seq}       &
\texttt{sin}       &
\texttt{sort}      &
\texttt{sqrt}      &
\texttt{sumc}      \\
\texttt{sumr}      &
\texttt{svd}       &
\texttt{tan}       &
\texttt{tr}        &
\texttt{transp}    &
\texttt{unvech}    \\
\texttt{values}    &
\texttt{vec}       &
\texttt{vech}      &
\texttt{zeros}
\end{tabular}      
\caption{Elenco alfabetico delle funzioni matriciali}
\label{tab:matrix_funcs}
\end{table}

